
#    This software is Copyright by the Board of Trustees of Michigan
#    State University (c) Copyright 2005.
#
#    You may use this software under the terms of the GNU public license
#    (GPL).  The terms of this license are described at:
#
#     http://www.gnu.org/licenses/gpl.txt
#
#     Author:
#             Ron Fox
#            NSCL
#            Michigan State University
#            East Lansing, MI 48824-1321
#

package provide browser 1.0
package require BLT
package require snit


#   browser provides a snit megawidget called "browser" which allows
#   the user to browse SpecTcl objects in a hierarchical manner
#   currently implemented as a blt treeview with a scrollbar.  The object types that can
#   be browsed include:
#     Spectra
#     Parameters (tree and otherwise)
#     TreeVariables
#     Gates
#
#  Options:
#
#        The following allow the attachment
#        of scripts to the right click of top level folders.
#
#     -spectrumfoldercommand  script
#     -parameterfoldercommand script
#     -variablefoldercommand  script
#     -gatefoldercommand      script
#
#       The following allow the attachment of scripts
#       to double-clicks of spectra, parameters, variablesand gates:
#
#     -spectrumscript        script
#     -parameterscript       script
#     -variablescript        script
#     -gatescript            script
#
#       The following allow the attachment of scripts to right clicks
#       of spectra, parameters, variables and gates:
#
#     -spectrumrightclick    script
#     -parameterrightclick   script
#     -variablerightclick    script
#     -gaterightclick       script
#
#      The following control what is visible in the browser:
#
#      -restrict   {list of toplevel folders to view} (at present this is not dynamic!!).
#      -detail     bool
#      -showcolumns {list of columns to show}         (at presnt this is not dynamic!!).
#      -filtergates script     Run gate defs through script and only display those for which script is true
#      -filterparameters script As for -filtergates but with parameters.
#      -filterspectra script  as for -filtergates but with specrtra.
#\
#     Geometric aspects:
#      -width     - Width of the browser window               (at present not dynamic)
#      -treewidth - Width of the tree column of the browser.  (at present not dynamic)
#
#  Each of these categories is represented as a folder whose contents contain the
#  objects of that type.  By convention in SpecTcl/Treeparameter, .'s are path
#  separators.  The tree hierarchy will generate, as needed, subfolders to reflect
#  the pathing hierarchy generated by the user.
#

#   Locate ourself and read in the icons we require:
#

namespace eval browser {
    variable here [file dirname [info script]]
}

image create photo ::browser::spectrumicon -format gif \
                                           -file [file join $::browser::here icons  spectrumicon.gif]
image create photo ::browser::gateicon     -format gif \
                                           -file [file join $::browser::here icons  gateicon.gif]
image create photo ::browser::paramicon    -format gif \
                                           -file [file join $::browser::here icons  treeparicon.gif]
image create photo ::browser::varicon      -format gif \
                                           -file [file join $::browser::here icons  treevaricon.gif]
image create photo ::browser::axisicon     -format gif \
                                           -file [file join $::browser::here icons  axisicon.gif]
image create photo ::browser::pointicon    -format gif \
                                           -file [file join $::browser::here icons  pointicon.gif]
image create photo ::browser::pseudoicon   -format gif \
                                           -file [file join $::browser::here icons  pseudoicon.gif]



::snit::widget browser {
    option -spectrumfoldercommand  {}
    option -parameterfoldercommand {}
    option -variablefoldercommand  {}
    option -gatefoldercommand      {}


    option -spectrumscript         {}
    option -parameterscript        {}
    option -variablescript         {}
    option -gatescript             {}


    option -spectrumrightclick     {}
    option -parameterrightclick    {}
    option -variablerightclick     {}
    option -gaterightclick        {}

    option -restrict   {spectra parameters gates variables}
    option -detail     1
    option -showcolumns {type gate low high bins value units}
    option -filtergates {}
    option -filterparameters {}
    option -filterspectra    {}

    option -width 8in
    option -treewidth 2.5in

    delegate option * to tree
    delegate method * to tree

    constructor {args} {
        $self configurelist $args


        # Create the tree and the initial top level folders:



        install tree using ::blt::treeview $win.tree
        $win.tree configure -autocreate 1 -hideroot 1 -separator . -width $options(-width)tree
        $win.tree sort auto 1

        if {[lsearch -exact $options(-restrict) spectra] != -1} {
            set folderid [$win.tree insert end Spectra]
            $win.tree entry configure $folderid -bindtags [list Spectra all]
            $win.tree bind Spectra    <Button-3> \
                    [mymethod FolderContextDispatch -spectrumfoldercommand %X %Y]
        }

        if {[lsearch -exact $options(-restrict) parameters] != -1} {
            set folderid [$win.tree insert end Parameters]
            $win.tree entry configure  $folderid -bindtags [list Parameters all]
            $win.tree bind Parameters <Button-3>  \
                    [mymethod FolderContextDispatch -parameterfoldercommand %X %Y]
        }

        if {[lsearch -exact $options(-restrict) gates] != -1} {
            set folderid [$win.tree insert end Gates]
            $win.tree entry configure $folderid -bindtags [list Gates all]
            $win.tree bind Gates      <Button-3>  \
                    [mymethod FolderContextDispatch -gatefoldercommand %X %Y]
        }
        if {[lsearch -exact $options(-restrict) variables] != -1} {
            set folderid [$win.tree insert end Variables]
            $win.tree entry configure  $folderid -bindtags [list Variables all]
            $win.tree bind Variables  <Button-3>  \
                    [mymethod FolderContextDispatch -variablefoldercommand %X %Y]
        }
        scrollbar $win.scroll -orient vertical -command "$win.tree yview"
        $win.tree configure -yscrollcommand "$win.scroll set"

        scrollbar $win.scrollx -orient horizontal -command "$win.tree xview"
        $win.tree configure -xscrollcommand "$win.scrollx set"


        # Layout the tree and its scrollbar (packer is still best for this simple stuff).

       grid $win.tree $win.scroll -sticky news
       grid $win.scrollx          -sticky news
       grid rowconfigure    $win 0   -weight 1
       grid columnconfigure $win 0   -weight 1


        # Add the data columns... in hopefully a reasonable order.
        #

        $win.tree column insert end Type  -edit 0 -borderwidth 3 -relief ridge
        if {[lsearch -exact $options(-showcolumns) type] == -1} {
            $win.tree column configure Type -hide 1
        }
        $win.tree column insert end Gate  -edit 0 -borderwidth 3 -relief ridge
        if {[lsearch -exact $options(-showcolumns) gate] == -1} {
            $win.tree column configure Gate -hide 1
        }
        $win.tree column insert end Low   -edit 0 -borderwidth 3 -relief ridge
        if {[lsearch -exact $options(-showcolumns) low] == -1} {
            $win.tree column configure Low -hide 1
        }
        $win.tree column insert end High  -edit 0 -borderwidth 3 -relief ridge
        if {[lsearch -exact $options(-showcolumns) high] == -1} {
            $win.tree column configure High -hide 1
        }
        $win.tree column insert end Bins  -edit 0 -borderwidth 3 -relief ridge
        if {[lsearch -exact $options(-showcolumns) bins] == -1} {
            $win.tree column configure Bins -hide 1
        }
        $win.tree column insert end Value -edit 0 -borderwidth 3 -relief ridge
        if {[lsearch -exact $options(-showcolumns) value] == -1} {
            $win.tree column configure Value -hide 1
        }
        $win.tree column insert end Units -edit 0 -borderwidth 3 -relief ridge
        if {[lsearch -exact $options(-showcolumns) units] == -1} {
            $win.tree column configure Units -hide 1
        }


        # Set the tree column width:

        $win.tree column configure [lindex [$win.tree column names] 0] \
                                    -width $options(-treewidth)

        # Fill the subfolders (we're hog wild assuming this is SpecTcl

        $self fillAllFolders
        $self fillAllFolders;     # Second time shakes the unparented guys after the folders.

        #  Event bindings for elements:

        $win.tree bind gate <Button-1> +[mymethod selectElement %x %y]
        $win.tree bind gate <Double-1> +[mymethod onElementDoubleClick -gatescript %x %y]
        $win.tree bind gate <Button-3> +[mymethod onElementContext -gaterightclick %x %y %X %Y]

        $win.tree bind spectrum <Button-1> +[mymethod selectElement %x %y]
        $win.tree bind spectrum <Double-1> +[mymethod onElementDoubleClick -spectrumscript %x %y]
        $win.tree bind spectrum <Button-3> +[mymethod onElementContext -spectrumrightclick %x %y %X %Y]

        $win.tree bind parameter <Button-1> +[mymethod selectElement %x %y]
        $win.tree bind parameter <Double-1> +[mymethod onElementDoubleClick -parameterscript %x %y]
        $win.tree bind parameter <Button-3> +[mymethod onElementContext -parameterrightclick %x %y %X %Y]

        $win.tree bind variable <Button-1>  +[mymethod selectElement %x %y]
        $win.tree bind variable <Double-1>  +[mymethod onElementDoubleClick -variablescript %x %y]
        $win.tree bind variable <Button-3>  +[mymethod onElementContext -variablerightclick %x %y %X %Y]



    }
    # fillAllFolders
    #    Destructively restock all folders;
    #
    method fillAllFolders {} {
        if {[lsearch -exact $options(-restrict) spectra] != -1} {
            $self fillSpectrumFolder
        }
        if {[lsearch -exact $options(-restrict) parameters] != -1} {
             $self fillParameterFolder
        }
        if {[lsearch -exact $options(-restrict) variables] != -1} {
            $self fillVariableFolder
        }
        if {[lsearch -exact $options(-restrict) gates] != -1} {
            $self fillGateFolder
        }
    }

    # fillSpectrumFolder
    #      Fills in the Spectrum folder with spectrum definitions.  At the top level,
    #      We just fill in the name and type.  Then we need to dispatch to type dependent
    #      methods to figure out how to fill in the rest of spectrum information.
    #      As with all the fill*Folder functions, the existing spectra are first removed from
    #      the folder.  See insertSpectrum for information about how to add a single spectrum.
    #
    method fillSpectrumFolder {} {
        catch {$win.tree delete spectrum}
        foreach application [apply -list] {
            set name [lindex $application 0]
            set gate [lindex [lindex $application 1] 0]
            set gating($name) $gate
        }
        foreach spectrum [spectrum -list] {
            if {$options(-filterspectra) != ""} {
                if {![eval $options(-filterspectra) [list $spectrum]]} {
                    continue
                }
            }
            set name       [lindex $spectrum 1]
            set type       [lindex $spectrum 2]
            set parameters [lindex $spectrum 3]
            set axes       [lindex $spectrum 4]
            set dtype      [lindex $spectrum 5]
            set gate       $gating($name)
            if {$gate == "-TRUE-"} {
                set gate "";              # Not intersted in ungated.
            }
            set treename [nameToPath Spectra $name]

	    set parentPath [split $treename .]
	    set parentPath [lrange $parentPath 0 end-1]
	    set parentPath [join $parentPath .]
	    if {[catch {set parentPaths($parentPath)}] } {
		$self makeParents $treename
	    }
            set id [$win.tree insert end $treename]
            set treetype "$type $dtype"
            $win.tree entry configure $id -icons {::browser::spectrumicon ::browser::spectrumicon} \
                                          -activeicons {::browser::spectrumicon ::browser::spectrumicon} \
                                          -data [list Type $treetype Gate $gate]
            $win.tree tag add spectrum $id
            $win.tree entry configure $id -bindtags [list spectrum all]
            if {$options(-detail)} {
                $self setSpectrumSubInfo $id $type $parameters $axes
            }
        }
    }
    # fillParameterFolder
    #      Fills the parameter folder with the set of parameters that are now defined.
    #      Previously existing parameters in the folder are first destroyed.
    #      this is suitable for a wholesale refresh of the gui.. it is not
    #      so useful for adding a single parameter.  See the addParameter method for that.
    #
    method fillParameterFolder {} {
        catch {$win.tree delete parameter}
        foreach parameter [parameter -list] {
            if {$options(-filterparameters) != ""} {
                if {![eval $options(-filterparameters) [list $parameter]]} {
                    continue
                }
            }
            set rawname [lindex $parameter 0]
            set name [nameToPath Parameters $rawname]

	    set parentPath [split $name .]
	    set parentPath [lrange $parentPath 0 end-1]
	    set parentPath [join $parentPath .]
	    if {[catch {set parentPaths($parentPath)}] } {
		$self makeParents $name
	    }

            set id [$win.tree insert end $name]
            $win.tree entry configure $id -icons {::browser::paramicon ::browser::paramicon} \
                                          -activeicons {::browser::paramicon ::browser::paramicon}
            $win.tree tag add parameter $id
            $win.tree entry configure $id -bindtags [list parameter all]
            set info [treeparameter -list $rawname]
            if {$info != ""} {
                set info  [lindex $info 0]
                set bins  [lindex $info 1]
                set low   [lindex $info 2]
                set hi    [lindex $info 3]
                set units [lindex $info 5]
                $win.tree entry configure $id -data [list Low $low High $hi Bins $bins Units $units]
            }
            if {$options(-detail)} {
                set pseudoInfo [pseudo -list $rawname]
                if {$pseudoInfo != ""} {
                    $win.tree entry configure $id -icons {::browser::pseudoicon ::browser::pseudoicon} \
                                    -activeicons {::browser::pseudoicon ::browser::pseudoicon}
                    set pseudoInfo [lindex $pseudoInfo 0]
                    set dependencies [lindex $pseudoInfo 1]
		    set pseudonum 0
                    foreach dependentParam $dependencies {
			$self addEntryParameter $id $pseudonum $dependentParam
			incr pseudonum
                    }
                }
            }
        }
    }
    # fillVariableFolder
    #      Fills the variable folder with the set of treevariables that are now defined.
    #      note that only treevariables are put in the folder, not ordinary Tcl vars.
    #      as that could be a strain on the user. Prior to filling, the existing
    #      variables are wiped out.  This function is best used to do a full refresh.
    #
    #
    method fillVariableFolder {} {
        catch {$win.tree delete variable}
	set vars [treevariable -list]
	set varCount [llength $vars]
	set varNum   0
        foreach variable $vars {
	    incr varNum
            set rawname [lindex $variable 0]
            set value   [lindex $variable 1]
            set units   [lindex $variable 2]
            set name [nameToPath Variables $rawname]

	    set parentPath [split $name .]
	    set parentPath [lrange $parentPath 0 end-1]
	    set parentPath [join $parentPath .]
	    if {[catch {set parentPaths($parentPath)}] } {
		$self makeParents $name
	    }

            set id [$win.tree insert end $name]
            $win.tree tag add variable $id
            $win.tree entry configure $id -data [list Value $value Units $units] \
                     -icons {::browser::varicon ::browser::varicon}      \
                     -activeicons {::browser::varicon ::browser::varicon}  \
                     -bindtags [list variable all]
	    if {($varNum % 100) == 0} {
	    }

        }
    }
    # fillGateFolder
    #    Fills the gate folder with the set of gates that are now defined.
    #    The type column is filled with the gate type and gate type specific
    #    subnodes are created for each gate.
    #
    method fillGateFolder {} {
        catch {$win.tree delete gate}
        foreach gate        [gate -list] {
            $self addGateByDescription $gate
        }

    }
    #  update
    #      Updates the browser to catch any items that were recently added.
    #
    method update {} {
        $self fillAllFolders;          #Same thing really.
    }
    # getSelection
    #       Returns a list consisting of:
    #       The full names of all the selected entities in the browser tree.
    #       Note that the item type prefix (e.g. Gates or Spectrum) is still
    #       present.
    #       If there are no elements selected, an empty list is returned.
    # Returns:
    #     A list of names in the selection. 
    #     The elements of this list are translated back  to names 
    #     (the _BLTFOLDER is removed from intermediate path entries.
    #
    method getSelection {} {
        set selected [$win.tree curselection];         # These are ID's.
        set names [list]
        foreach id $selected {
            lappend names [pathToName [$win.tree get -full $id]]
        }
        return $names
    }
    # remove path
    #      Removes an entry from the browser tree given its name.
    #      note that if the path is not a terminal node all subordinate
    #      entries will also be deleted.
    # Parameters:
    #    name   - the name of the node.  This will not have any folder decoration.
    #
    method remove name {
	set path [nameToPath [getPrefix $name] $name]
        set id [$win.tree find -full $path]
        if {[llength $id] != 0} {
            foreach i $id {
                $win.tree delete $i
            }
        }
    }
    # find name
    #      Locate the id of a name in the browser tree.
    # Parameters:
    #  name:  - Name of the item to locate.  This name will not have any
    #           folder decorations.
    #
    method find name {
	set nameList [split $name .]
        return [$win.tree find -full [nameToPath [getPrefix $name] $name]]
    }
    # addGate name
    #    Adds a gate to the browser tree.
    #    if -detail is true, then subnodes are built too.
    # Parameters:
    #   name  - Name of the gate (without the Gates. in front of it.
    #
    method addGate name {
        set gate [gate -list $name]
        if {$gate != ""} {
            set gate [lindex $gate 0]
            $self addGateByDescription $gate
        }
    }
    # addGateByDescription
    #    Adds a gate to the browser tree given its description.
    # Parameters:
    #   gate  - the gate description
    method addGateByDescription gate {
        if {$options(-filtergates) != ""} {
            if {![eval $options(-filtergates) [list $gate]]} {
                return
            }
        }
        set name        [lindex $gate 0]
        set type        [lindex $gate 2]
        set description [lindex $gate 3]
        set entryname [nameToPath Gates $name]

	set parentPath [split $entryname .]
	set parentPath [lrange $parentPath 0 end-1]
	set parentPath [join $parentPath .]
	if {[catch {set parentPaths($parentPath)}] } {
	    $self makeParents $entryname
	}

        set id [$win.tree insert end $entryname]
        $win.tree tag add gate $id
        $win.tree entry configure $id -data [list Type $type]   \
            -icons {::browser::gateicon ::browser::gateicon}    \
            -activeicons {::browser::gateicon ::browser::gateicon} \
            -bindtags [list gate all]

        if {$options(-detail)} {
            $self setGateSubInfo $id $type $description
        }

    }
    ###########################################################################
    #
    #   Methods below this line should be considered private.
    #

    # addPoint id number prefix point
    #     Adds a point subnode to the indicated id.
    #     A point subnode is labelled as "prefix (x,y)"
    #     A point is labelled with the pointicon.
    # Parameters:
    #    id      - Id of node to which this point is getting added.
    #    number  - Index of the point
    #    prefix  - Prefix string for the point label
    #    point   - The point coordinates.
    #
    #
    method addPoint {id number prefix point} {
        set label [format "$prefix (%.2f,%.2f)" [lindex $point 0] [lindex $point 1]]
        set pid [$win.tree insert -at $id end $number]
        $win.tree entry configure $pid -label $label                          \
                    -icons {::browser::pointicon ::browser::pointicon}        \
                    -activeicons {::browser::pointicon ::browser::pointicon}
    }
    # setSliceSubInfo id description
    #    Sets the subinfo for a slice gate.
    #    This consists of:
    #    - A parameter subnode containing the name of the parameter
    #      the gate is tested on.
    #    - A Point subnode labelled "limits : (low,hi)
    #      showing the extent of the gate on the parameter.
    #
    # parameters:
    #    id          - The id in the treeview of the gate on which
    #                  these subnodes will be created.
    #    description - The gate dependent description which is a list
    #                  of the form {parameter-name {low high}}
    method setSliceSubInfo {id description} {
        # Parse the description:

        set parameter [lindex $description 0]
        set limits    [lindex $description 1]
        $self addEntryParameter $id 0 $parameter
        $self addPoint $id 1 "limits : " $limits
    }
    # set2DGateSubInfo id description
    #    Sets the appropriate subordinate information for a 2d gate
    #    (band or contour).
    #    - We create a parameter subentry for each of the parameters in the gate.
    #      These will be labelled X : parametername
    #    - We create a subfolder named 'points' and an entry in it for each
    #      point labelled (x,y).
    # Parameters:
    #   id           - The treeview id of the entity we are creating these subnodes under.
    #   description  - The gate descrption which consists of an n element list.  The
    #                  First element is a 2 element sublist containing the x/y parameter names
    #                  The subsequent elements are the x/y points as {x y} sublists.
    #
    method set2DGateSubInfo {id description} {
        set parameters [lindex $description 0]
        set points     [lrange  $description 1 end]

        $self addEntryParameter $id 0 "X : [lindex $parameters 0]"
        $self addEntryParameter $id 1 "Y : [lindex $parameters 1]"

        set pno 0
        foreach point $points {
            $self addPoint $id Points.$pno "" $point
            incr pno
        }

    }
    # setCompoundGateSubinfo id description
    #    Sets appropriate subordinate information for compound gate.
    #    Compound gates consist of/depend on other gates.
    #    For each gate we produce a simple gate subentry
    #    simple gate subentries look like gates but don't show any subordinate
    #    detail other than the gate type.
    # Parameters:
    #   id           - The id of the gate we are creating subordinate information for.
    #   description  - The gate description, which in this case is,
    #                  the list of names of subordinate gates.
    #
    method setCompoundGateSubinfo {id description} {
        foreach gate $description {
            set gid [$win.tree insert -at $id end $gate]
            set type [lindex [lindex [gate -list $gate] 0] 2]
            $win.tree entry configure $gid -data [list Type $type] \
                -icons {::browser::gateicon ::browser::gateicon} \
                -activeicons {::browser::gateicon ::browser::gateicon}
        }
    }
    # setGammaSliceSubinfo id description
    #    Sets the appropriate subordinate information for a gamma slice.
    #    This consists of a single point and a list of parameters and Parameters folder.
    #    The point is labelled "Limits : (hi,low)"
    # Parameters:
    #   id          - The treeview id of the gate to which we are adding
    #                 the subordinates.
    #   description - The description of the gate.
    #
    method setGammaSliceSubinfo {id description} {
        set point      [lindex $description 0]
        set parameters [lindex $description 1]

        set parno 0
        foreach parameter $parameters {
            $self addEntryParameter $id Parameters.$parno $parameter
            incr parno
        }
        $self addPoint $id $parno "Limits : " $point

    }
    # setGamma2DGateSubinfo id description
    #    Set the appropriate subordinate information for a 2d gamma gate
    #    (gc, gb). This consists of a list of parameters in a parameter folder
    #    and a list of points in a Points folder.
    #
    # Parameters:
    #   id          : Id of the gate we are filling in (in the treeview)
    #   description : Gate description which consists of a list of points and
    #                 a list of parameters.
    #
    method setGamma2DGateSubinfo {id description} {
        set points     [lindex $description 0]
        set parameters [lindex $description 1]

        set parno 0
        foreach parameter $parameters {
            $self addEntryParameter $id Parameters.$parno $parameter
            incr parno
        }

        set pnum 0
        foreach point $points {
            $self addPoint $id Points.$pnum "" $point
            incr pnum
        }
    }
    # setMaskGateSubinfo id description
    #    Sets appropriate subordinate informatino for a bitmask
    #    gate (type em, am, nm).  We list the parameter
    #    and the mask.  The mask is listed as a 'point'
    #    however the label is just mask = (hex of mask).
    #    Since the 'point' is not really a point, we must manually
    #    create the point.
    # Parameters:
    #   id           - Id of the gate for which  we are making subordinate data.
    #   description  - The gate description which consists of a parameter and mask.
    #
    method setMaskGateSubinfo {id description} {
        set parameter [lindex $description 0]
        set mask      [lindex $description 1]
        set masklabel [format "mask = 0x%x" $mask]

        $self addEntryParameter $id 0 $parameter
        set mid [$win.tree insert -at $id end 1 ]
        $win.tree entry configure $mid -label $masklabel            \
                -icons {::browser::pointicon  ::browser::pointicon} \
                -activeicons {::browser::pointicon ::browser::pointicon}
    }
    #
    # setGateSubInfo id type description
    #    Sets appropriate subordinate information for a gate.
    #    This is done by independent gate type handlers that know
    #    the format of the gate description field (which varies from gate type to
    #    gate type).
    # Parameters:
    #    id           - treeview id of the gate we are elaborating.
    #    type         - Gate type (from SpecTcl gate description.
    #    description  - Gate dependent description information.
    #
    method setGateSubInfo {id gateType description} {
        switch -exact -- $gateType {
            s {
                $self setSliceSubInfo $id $description
            }
            b -
            c {
                $self set2DGateSubInfo $id $description
            }
            * -
            + -
            "-" {
                $self setCompoundGateSubinfo $id $description
            }
            gs {
                $self setGammaSliceSubinfo $id $description
            }
            gb -
            gc {
                $self setGamma2DGateSubinfo $id $description
            }
            em -
            am -
            nm {
                $self setMaskGateSubinfo $id $description
            }
            default {
            }
        }
    }
    # setFold id
    #     Adds a fold node to id if there is a fold applied to the
    #     spectrum.  A fold is represented as a gate node labelled:
    #     "Folded on : gatename
    #
    method setFold id {
        #  The spectrum name is the part of the node name after Spectra.

        set name [$win.tree get -full $id] ;    #Spectrum name.
        set namelist [split $name .]
        set namelist [lrange $namelist 1 end]
        set name [join $namelist .]

        set fold [fold -list $name]
        if {$fold != ""} {
            set fold [lindex $fold 0]
            set foldname "Folded on : [lindex $fold 1]"
            set foldid [$win.tree insert -at $id end fold]
            $win.tree entry configure $foldid -label $foldname \
                -icons {::browser::gateicon ::browser::gateicon} \
                -activeicons {::browser::gateicon ::browser::gateicon}
        }
    }
    # addAxisInfo id specification parameter
    #     Adds axis specification information to the indicated node.
    #     this consists of low, high, bins, and if the parameter is
    #     a treeparam, units.
    # Parameters:
    #    id             - Id of the node to add this info to.
    #    specification  - SpecTcl axis specification string.
    #    parameter      - Parameter name.
    #
    method addAxisInfo {id specification parameter} {
        set data [$win.tree entry cget $id -data];     # We append to existing data if any.
        set low   [format %.2f [lindex $specification 0]]
        set high  [format %.2f [lindex $specification 1]]
        set bins  [lindex $specification 2]
        set units ""
        set info [treeparameter -list $parameter]
        if {$info != ""} {
            set info [lindex $info 0]
            set units [lindex $info 5]
        }
        lappend data Low $low High $high Bins $bins Units $units
        $win.tree entry configure $id -data $data
    }
    # addAxis id name parameter specification
    #     Adds an axis subnode to the node id (presumably a spectrum).
    #     - The axis limits are taken from the specification
    #     - The label of the axis is "$name : parametername"
    #     - The units of the axis are taken from the treeparameter units
    #       if the parameter is a tree parameter.
    # Parameters:
    #  id            - ID of spectrum node to which the axis is being added.
    #  name          - axis name (usually X or Y).
    #  parameter     - Name of parameter from which to draw the parameter informatino.
    #  specification - Axis limit specification
    # Returns:
    #    The new node id.
    method addAxis {id name parameter specification} {
        set axisid [$win.tree insert -at $id end $name]
        $win.tree entry configure $axisid -label "$name : $parameter" \
                -icons {::browser::axisicon ::browser::axisicon}      \
                -activeicons {::browser::axisicon ::browser::axisicon}
        $self addAxisInfo $axisid $specification $parameter
        return $axisid
    }
    # addEntryParameter id number name
    #      Adds a parameter subnode to a treeview entry The parameter node just shows the
    #      paramter name with a parameter icon.
    # Parameters:
    #    id      - Id of the treeview node to which this is being added.
    #    number  - A parameter index number used to name the node.
    #    name    - A parameter name used to label the node.
    # Returns:
    #     The new node id.
    #
    method addEntryParameter {id number name} {
        set pid [$win.tree insert -at $id end $number]
        $win.tree entry configure $pid -label $name                            \
                -icons {::browser::paramicon ::browser::paramicon}             \
                -activeicons {::browser::paramicon ::browser::paramicon}
        return $pid
    }
    # set1dSubInfo id parameters axes
    #      Sets the subnode information for a 1-d spectrum:
    #      The info for the single axis is loaded into the
    #      the primary node's data. If the parameters is a
    #      treeparameter, units are also loaded.
    #      The parameter is loaded as a subnode, if a tree parameter its info
    #      is loaded as well.
    # Parameters:
    #  id         - The spectrum node's id in the treeview.
    #  parameters - A single parameter name.
    #  axes       - A list containing a single axis definition list.
    #
    method set1dSubInfo {id parameters axes} {
        set axis  [lindex $axes 0]
        $self addAxisInfo              $id $axis $parameters
        $self addEntryParameter     $id 0 $parameters

    }
    # set2dSubInfo id parameters axes
    #     Fils in the subnode information for a 2-d spectrum.
    #     This consists of two subnodes, one for the x axis and one for the y axis.
    #     The x axis is labelled with X : xparametername
    #     The y axis is labelled with Y : yparametername
    #     For both axes, the low, high, bins are taken from the axis definitions
    #
    method set2dSubInfo {id parameters axes} {
        foreach parameter $parameters axis $axes name {X Y} {
            $self addAxis $id $name $parameter $axis
        }
    }
    # setg1SubInfo id parameters axes
    #      Fills in subnodes for a g1 spectrum:
    #      The axis information is placed on the spectrum line, and we create one
    #      parameter subnode for each parameter in the spectrum.  The icon for each parameter
    #      is the treeparameter icon, to distinguish it from being an axis specification.
    #      No data is supplied with each parameter.   There is no axis subnode.
    #      If the first parameter in the parameter list is a treeparamter, its units are
    #      used as the axis units. under the assumption that all paramters will have the same
    #      units.
    # Parameters:
    #    id          - The id of the parent node.
    #    parameters  - List of parameters for the spectrum.
    #    axes        - The single axis specification for the spectrum.
    #
    method setg1SubInfo {id parameters axes} {

        # Extract the axis information and add it to the existing data for id.

        set axis [lindex $axes 0]
        $self addAxisInfo $id $axis [lindex $parameters 0]


        $self setFold $id

        #  Now a parameter subnode for each parameter in the gamma spectrum:

        set paramnumber 0
        foreach parameter $parameters {
            $self addEntryParameter $id $paramnumber $parameter
            incr paramnumber
        }

    }

    # setg2SubInfo id parameters axes
    #      Fills in any required child nodes for a g2 spectrum.  These
    #      consist of:
    #      - A fold subnode if the spectrum has a fold applied.
    #      - An x and a y axis subnode.  The limits/bins on the axis are taken
    #        from the axis specification.  If the first parameter in the spectrum
    #        is a tree parameter, the units for both axes are taken from it on the
    #        assumption that a gamma spectrum with mixed units has no reason to live.
    #      - A parameter axis for each parameter in the list.
    #
    method setg2SubInfo {id parameters axes} {
        set axisid [$self addAxis $id X [lindex $parameters 0] [lindex $axes 0]]
        $win.tree entry configure $axisid -label X
        set axisid [$self addAxis $id Y [lindex $parameters 0] [lindex $axes 1]]
        $win.tree entry configure $axisid -label Y

        $self setFold $id

        set paramno 0
        foreach param $parameters {
            $self addEntryParameter $id $paramno $param
            incr paramno
        }

    }
    # setSummarySubInfo id parameters axes
    #     Fills in any required child nodes for a summaryy spectrum.
    #     The summary spectrum has the following subnodes:
    #     - X axis which is labeled X : parameters
    #       for which the low is 0, the high is nparams -1 and the bins are nparams.
    #       and for which there are no units.
    #     - Y axis which is labelled Y and has info from the first of the parameters.
    #     - A parameter entry for each parameter in the spectrum
    #     The spectrum itself is given the y axis info.
    # Parameters:
    #  id         - Id of the node we are adding children to.
    #  parameters - List of parameter names involved in the spectra.
    #  axes       - Axis specifications.
    #
    method setSummarySubInfo {id parameters axes} {
        $self addAxis $id X parameters "0 [expr [llength $parameters]-1] [llength $parameters]"
        set xid [$self addAxis $id Y [lindex $parameters 0] [lindex $axes 0]]
        $win.tree entry configure $xid -label Y
        $self addAxisInfo $id [lindex $axes 0] [lindex $parameters 0]

        set pno 0
        foreach parameter $parameters {
            $self addEntryParameter $id $pno $parameter
            incr pno
        }
    }
    # setBitmaskSubInfo id parameters axes
    #      Fills in any required child nodes etc. for a bitmask spectrum.
    #      The top level gets the axis limit information, units are not relevant.
    #      A parameter subnode is created for the parameter from which the mask is being
    #      computed.
    # Parameters:
    #   id          - Id of the spectrum node we are filling in
    #   parameters  - list of parameters that make the spectrum (one really)
    #   axes        - list of axis specifications (one really).
    #
    method setBitmaskSubInfo {id parameters axes} {
        set axis [lindex $axes 0]
        $self addAxisInfo $id $axis $parameters
        $self addEntryParameter $id 0 $parameters
    }
    # setStripchartSubInfo id parameters axes
    #     Fills in required child nodes for a stripchart spectrum from the time parameter
    #     This consists of an axis specification in the spectrum itself.
    #     and a pair of parameters with labels that look like:
    #     Time  : parametername
    #     Value : parametername
    # Parameters:
    #   id         : The id of the spectrum node.
    #   parameters : The time and value parameter for the spectrum.
    #   axes       : The single axis specification.
    #
    method setStripchartSubInfo {id parameters axes} {
        set axis [lindex $axes 0]
        set timep [lindex $parameters 0]
        set valuep [lindex $parameters 1]

        $self addAxisInfo $id $axis $timep
        $self addEntryParameter $id 0 "Time  : $timep"
        $self addEntryParameter $id 1 "Value : $valuep"

    }

    # set2dMultipleSubInfo id parameters axes
    #     Fills in the required sub info for a 2d multiply incremented
    #     spectrum.  We add 2 axes named arbitrarily X and Y
    #     and list all the parameters and their information as well.
    #
    # Parameters:
    #    id         : Id of the spectrum node.
    #    parameters : list of parameter names.
    #    axes       : 2 axis specifications.
    #
    method set2dMultipleSubInfo {id parameters axes} {
        set axisid [$self addAxis $id X "" [lindex $axes 0]]
        $win.tree entry configure $axisid -label X
        set axisid [$self addAxis $id Y "" [lindex $axes 1]]
        $win.tree entry configure $axisid -label Y


	set i 0
	foreach parameter $parameters {
	    $self addEntryParameter $id $i $parameter
	    incr i
	}
    }
    #
    #  setgdSubInfo id parameters axes
    #    Set the sub information for a gamma 2d deluxe spectrum.
    #    Note that the parameters parameter is a 2 element list of
    #    the x and y parameters.
    #
    method setgdSubInfo {id parameters axes} {
	set xparams [lindex $parameters 0]
	set yparams [lindex $parameters 1]


	set axisid [$self addAxis $id X "" [lindex $axes 0]]
	$win.tree entry configure $axisid -label X

	set axisid [$self addAxis $id Y "" [lindex $axes 1]]
	$win.tree entry configure $axisid -label Y

	set i 0

	foreach x $xparams {
	    $self addEntryParameter $id $i "X: $x"
	    incr i
	}
	foreach y $yparams {
	    $self addEntryParameter $id $i "Y $y"
	    incr i
	}
    }

    #
    #  setGammaSummarySubInfo id parameters axes
    #
    #  Set the sub information for a gamma summary spectrum.
    #  We'll have one axis, which is the Y axis, and that will
    #  display as on a 1-d spectrum.
    #  We'll have strip subfolders numbered for the x axis coordinate
    #  each strip subfolder will have entries for each parameter in that strip.
    #
    #
    method setGammaSummarySubInfo {id parameters axes} {
        
        #  Add the y axis as our axisi formation:
        
        set axis [lindex $axes 0]
	set c [lindex $parameters 0]

	puts "Column0: $c"

	set p [lindex $c 0]
	puts "parameter0: $p"

        $self addAxisInfo $id $axis $p
        
        set xChannel 0
        set param 0
        foreach channel $parameters {
            
            # Add a folder for a channels parameters.
            
            set name Channel$xChannel
            set channelId [$win.tree insert -at $id end $name]
            $win.tree entry configure $channelId -label $name
            
            
            foreach parameter $channel {
                # Add a parameter definition.
                
                $self addEntryParameter $channelId $param $parameter
                
                incr param
            }
            incr xChannel
        }
    }

    #
    # setSpectrumSubInfo id type parameters axes
    #      Fills in any required child nodes for a spectrum.  This is type dependent.
    #      Note that in the case of 1-d spectra (type 1, g1, b, and S),
    #      We fill in the x axis low/high/bins on the parent node just to make
    #      it a bit easier for the user.
    #      For 2-d type spectra, we'll have subsidiary nodes for each axis that
    #      will have this information.
    #      In any case we list the parameters and their information as well.
    # Parameters:
    #     id            - The treeview ident of the primary node.
    #     spectrumType  - The spectrum type.
    #     parameters    - The parameters used by the spectrum.
    #     axes          - The axis definitions used by the spectrum.
    #
    method setSpectrumSubInfo {id spectrumType parameters axes} {

        # Branch out depending on the type of spectrum:

        switch -exact -- $spectrumType {
	    1 {
		$self set1dSubInfo $id $parameters $axes
	    }
	    2 {
		$self set2dSubInfo $id $parameters $axes
	    }
	    g1 {
		$self setg1SubInfo $id $parameters $axes
	    }
	    g2 {
		$self setg2SubInfo $id $parameters $axes
	    }
	    gd {
		$self setgdSubInfo $id $parameters $axes
	    }
	    s {
		$self setSummarySubInfo $id $parameters $axes
	    }
	    b {
		$self setBitmaskSubInfo $id $parameters $axes
	    }
	    S {
		$self setStripchartSubInfo $id $parameters $axes
	    }
	    m2 {
		$self set2dMultipleSubInfo $id $parameters $axes
	    }
            gs {
                $self setGammaSummarySubInfo $id $parameters $axes
            }
	    default {}
        }
    }
    # [mymethod FolderContextDispatch Option %X %Y]
    #       Dispactches folder context menu requests.  These are typically
    #       requested via a right click over a top level folder.
    # Parameters:
    #     Option   - the name of the option array element that is holding
    #                the user supplied script to call or {} if there is none.
    #                the X/Y coordinates of the click are passed to the caller.
    #    %X %Y     - The coordinates of the click relative to the widget.
    #
    method FolderContextDispatch {OptionName x y} {
        set script $options($OptionName)
        if {$script != ""} {
            $script $x $y
        }
    }
    # onElementDoubleClick Option x y
    #      Dispatches user scripts on double clicks on SpecTcl elements.
    #      (e.g. Spectra, Gates, Parameters, Variables.
    # Parameters:
    #    Option   - Name of the option that should have the user script body.
    #    x,y      - Coordinates of the click.
    # NOTE:
    #    The user script is called:
    #        userscript path
    #    Where path is the path of the nearest element under the pointer when the doubleclick occured.
    #
    method onElementDoubleClick {Option x y} {

        set script $options($Option)
        if {$script != ""} {
            set id [$win.tree nearest $x $y]
            if {$id != ""} {
                set path [$win.tree get -full $id]
                eval $script [list [pathToName $path]]
            }
        }
    }
    # onElementContext Option x y X Y
    #     Invokes a context click (right button) for
    #     an element:
    # Parameters:
    #    Option   - Name of the option that should have the user script body.
    #    x,y      - Coordinates of the click.
    #    X,Y      - Absolute coordinates of the click.
    # Note:
    #     The user script is called:
    #        userscript path X Y
    #
    method onElementContext {Option x y X Y} {
        set script $options($Option)
        if {$script != ""} {
            set id [$win.tree nearest $x $y]
            if {$id != ""} {
                set path [$win.tree get -full $id]
                eval $script [pathToName [list $path]] $X $Y
            }
        }
    }
    # selectElement x y
    #     Sets the selEction to the element at x,y
    #
    method selectElement {x y} {
        set id [$win.tree nearest $x $y]
        if {$id != ""} {
            $win.tree selection clearall
            $win.tree selection set $id $id
        }
    }
    # nameToPath  prefix name
    #   Converts name to a browser path for the group prefix.
    #   This is done by appending _BLTFOLDER to all but the last
    #   path element in name and prepending prefix.
    #   This is done to ensure that items can have the same name as
    #   folders e.g. a spectrum named a and one named a.b
    #
    # parameters:
    #      prefix  - The path prefix e.g. Spectra
    #      name    - The SpecTcl name of the item.
    #
    proc nameToPath {prefix name} {
	set path $prefix
	set nameList [split $name .]
	foreach folder [lrange $nameList 0 end-1] {
	    append path  .  $folder _BLTFOLDER
	}
	append path . [lindex $nameList end]
	return $path
    }
    # pathToName path
    #    Returns the name associated with an element.
    #    This will include the prefix (e.g. Spectrum).
    #    We strip the _BLTFOLDER from the end of all intermediate nodes
    #    in the name.
    #
    proc pathToName path {
	set pathList [split $path .]
	set prefix [lindex $pathList 0]
	set terminal [lindex $pathList end]
	set name $prefix
	foreach node [lrange $pathList 1 end-1] {
	    append name . [regsub {_BLTFOLDER$} $node ""]
	}
	append name . $terminal
	return $name
    }
    proc getPrefix name {
	set nameList [split $name .]
	return [lindex $nameList 0]
    }
    # makeParents path
    #    Takes a tree path (with the _BLTFOLDER bits in the path)
    #    and creates any neede parts of the folder hierarchy above the
    #    terminal node.
    #      These folders are labelled so that the _BLTFOLDER is missing.
    #
    method makeParents path {
	set pathList [split $path .]
	# Short cut optimization:
	# Most of the time, users have more than one terminal in
	# a single folder, If the entire path prior to our terminal
	# exists, then we don't need to make anything.
	


	#
	#  The prefix is already made by definition.
	#
	set parentPath [lindex $pathList 0]
	foreach element [lrange $pathList 1 end-1] {
	    append parentPath . $element
	    #
	    #  If not found, need to make one
	    #
		set label [regsub {_BLTFOLDER$} $element ""]
	    catch {$win.tree insert end $parentPath -label $label}


	}

	
    }

}

