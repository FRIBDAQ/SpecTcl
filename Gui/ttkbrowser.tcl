#    This software is Copyright by the Board of Trustees of Michigan
#    State University (c) Copyright 2005.
#
#    You may use this software under the terms of the GNU public license
#    (GPL).  The terms of this license are described at:
#
#     http://www.gnu.org/licenses/gpl.txt
#
#     Author:
#             Ron Fox
#            NSCL
#            Michigan State University
#            East Lansing, MI 48824-1321
#

package provide browser 2.0
package require Tk
package require snit
package require img::png


#   browser provides a snit megawidget called "browser" which allows
#   the user to browse SpecTcl objects in a hierarchical manner
#   currently implemented as a ttk::treeview with scrollbars.  The object types that can
#   be browsed include:
#     Spectra
#     Parameters (tree and otherwise)
#     TreeVariables
#     Gates
#
#  Options:
#
#        The following allow the attachment
#        of scripts to the right click of top level folders.
#
#     -spectrumfoldercommand  script
#     -parameterfoldercommand script
#     -variablefoldercommand  script
#     -gatefoldercommand      script
#
#       The following allow the attachment of scripts
#       to double-clicks of spectra, parameters, variablesand gates:
#
#     -spectrumscript        script
#     -parameterscript       script
#     -variablescript        script
#     -gatescript            script
#
#       The following allow the attachment of scripts to right clicks
#       of spectra, parameters, variables and gates:
#
#     -spectrumrightclick    script
#     -parameterrightclick   script
#     -variablerightclick    script
#     -gaterightclick       script
#
#      The following control what is visible in the browser:
#
#      -restrict   {list of toplevel folders to view} (at present this is not dynamic!!).
#      -detail     bool
#      -showcolumns {list of columns to show}         (at presnt this is not dynamic!!).
#      -filtergates script     Run gate defs through script and only display those for which script is true
#      -filterparameters script As for -filtergates but with parameters.
#      -filterspectra script  as for -filtergates but with specrtra.
#
#     Geometric aspects:
#      -width     - Width of the browser window               (at present not dynamic)
#      -treewidth - Width of the tree column of the browser.  (at present not dynamic)
#
#  Each of these categories is represented as a folder whose contents contain the
#  objects of that type.  By convention in SpecTcl/Treeparameter, .'s are path
#  separators.  The tree hierarchy will generate, as needed, subfolders to reflect
#  the pathing hierarchy generated by the user.
#

#   Locate ourself and read in the icons we require:
#

namespace eval browser {
    variable here [file dirname [info script]]
}

image create photo ::browser::spectrumicon -format gif \
                                           -file [file join $::browser::here icons   spectrumicon.gif]
image create photo ::browser::gateicon     -format gif \
                                           -file [file join $::browser::here icons  gateicon.gif]
image create photo ::browser::paramicon    -format gif \
                                           -file [file join $::browser::here icons   treeparicon.gif]
image create photo ::browser::varicon      -format gif \
                                           -file [file join $::browser::here icons  treevaricon.gif]
image create photo ::browser::axisicon     -format gif \
                                           -file [file join $::browser::here icons  axisicon.gif]
image create photo ::browser::pointicon    -format gif \
                                           -file [file join $::browser::here  icons  pointicon.gif]
image create photo ::browser::pseudoicon   -format gif \
                                           -file [file join $::browser::here  icons  pseudoicon.gif]
image create photo ::browser::foldericon   -format png \
    -file [file join $::browser::here icons folder.png]

::snit::widget browser {

    # the subwidgets in this frame:

    component tree
    component xscroll
    component yscroll

    option -spectrumfoldercommand  {}
    option -parameterfoldercommand {}
    option -variablefoldercommand  {}
    option -gatefoldercommand      {}


    option -spectrumscript         {}
    option -parameterscript        {}
    option -variablescript         {}
    option -gatescript             {}


    option -spectrumrightclick     {}
    option -parameterrightclick    {}
    option -variablerightclick     {}
    option -gaterightclick        {}

    option -restrict   -default [list spectra parameters gates variables] \
	-configuremethod configRestrict
    option -detail     1
    option -showcolumns -default [list type gate low high bins value units] \
	-configuremethod configColumns

    option -filtergates {}
    option -filterparameters {}
    option -filterspectra    {}

    option -width 8in
    option -treewidth 2.5in

    delegate option * to tree
    delegate method * to tree

    #---
    
    variable topLevelIds [list]

    constructor {args} {
	# install and layout the widgets in the frame>

	install tree using ttk::treeview $win.tree \
	    -yscrollcommand [list $win.yscroll set] -xscrollcommand [list $win.xscroll set] \
	    -height 32
	install xscroll using scrollbar $win.xscroll -orient horizontal -command [list $win.tree xview]
	install yscroll using scrollbar $win.yscroll -orient vertical   -command [list $win.tree yview]
	grid $tree $yscroll -sticky nsew
	grid $xscroll       -sticky nsew

	#  Invariant tree configuration:
	
	set allcolumns [list type gate low high bins value units]
	$tree configure -columns $allcolumns
	foreach colname $allcolumns {
	    $tree heading $colname -text $colname
	    $tree column $colname -stretch 1 -anchor w -width 100
	}
	$tree heading #0 -text "Tree"

	
	# Force default configuration

	foreach option [array names options] {
	    $self configure $option $options($option)
	}

	$self configurelist $args; # overrides to defaults.

	# Populate the tree:

	$self fillAllFolders


    }
    #----------------------------------------------------------------------------------
    #  configuration management:

    ##
    #  -showcolumns - affects both the columns displayed as well as the
    #                 -show results for the tree:
    #
    method configColumns {option value} {
	set options($option) $value
	$tree configure -displaycolumns [concat $value]
	set showList tree
	if {[llength $value] > 0} {
	    set showList [concat $showList headings]
	}
	$tree configure -show $showList
    }
    ##
    # -restrict - This will just update the options(-restrict) variable and
    #             perform an update which repopulate the entire tree:
    #
    method configRestrict {option value} {
	set options($option) $value
	$self update
    }
    #------------------------------------------------------------------------------------
    # Public methods:

    

    ##
    # update
    #   Updates the contents of the browser:
    #
    method update {} {
	$self fillAllFolders
    }
    #-------------------------------------------------------------------------------------
    # Private methods.

    # fillAllFolders
    #    Destructively restock all folders;
    #
    method fillAllFolders {} {

	# Kill off the top level folders:

	foreach id $topLevelIds {
	    $tree delete $id
	}
	set topLevelIds [list]

	# Stock only those in the -restrict list:

        if {[lsearch -exact $options(-restrict) spectra] != -1} {
            $self fillSpectrumFolder
        }
        if {[lsearch -exact $options(-restrict) parameters] != -1} {
             $self fillParameterFolder
        }
        if {[lsearch -exact $options(-restrict) variables] != -1} {
            $self fillVariableFolder
        }
        if {[lsearch -exact $options(-restrict) gates] != -1} {
            $self fillGateFolder
        }

	#  Bindings for folders:

	$tree tag bind spectrumFolder <Button-3> \
	    [mymethod FolderContextDispatch -spectrumfoldercommand %X %Y]
	$tree tag bind parameterFolder <Button-3> \
	    [mymethod FolderContextDispatch -parameterfoldercommand %X %Y]
	$tree tag bind variableFolder <Button-3> \
	    [mymethod FolderContextDispatch -variablefoldercommand %X %Y]
	$tree tag bind gateFolder <Button-3> \
	    [mymethod FolderContextDispatch -gatefoldercommand %X %Y]


	# Bindings for the items in the folders:

	# gates:

	$tree tag bind gate <Button-1> [mymethod selectElement %x %y]
	$tree tag bind gate <Double-1> [mymethod onElementDoubleClick -gatescript %x %y]
	$tree tag bind gate <Button-3> [mymethod onElementContext -gaterightclick %x %y %X %Y]

	# Spectra:

	$tree tag bind spectrum <Button-1> [mymethod selectElement %x %y]
	$tree tag bind spectrum <Double-1> [mymethod onElementDoubleClick -spectrumscript %x %y]
	$tree tag bind spectrum <Button-3> [mymethod onElementContext -spectrumrightclick %x %y %X %Y]; # ]


	# Parameters:

	$tree tag bind parameter <Button-1> [mymethod selectElement %x %y]
	$tree tag bind parameter <Double-1> [mymethod onElementDoubleClick -parameterscript %x %y]
	$tree tag bind parameter <Button-3> [mymethod onElementContext -parameterrightclick %x %y %X %Y]

	# Variables:

	$tree tag bind variable <Button-1>  [mymethod selectElement %x %y]
	$tree tag bind variable <Double-1>  [mymethod onElementDoubleClick -variablescript %x %y]
	$tree tag bind variable <Button-3>  [mymethod onElementContext -variablerightclick %x %y %X %Y]


    }

    # fillSpectrumFolder
    #      Fills in the Spectrum folder with spectrum definitions.  At the top level,
    #      We just fill in the name and type.  Then we need to dispatch to type dependent
    #      methods to figure out how to fill in the rest of spectrum information.
    #      As with all the fill*Folder functions, the existing spectra are first removed from
    #      the folder.  See insertSpectrum for information about how to add a single spectrum.
    #
    method fillSpectrumFolder {} {
	
	# Create the top level folder for spectra:

	set spectrumFolder [$tree insert {} end -text Spectra \
				-open 0 -tags spectrumFolder -image ::browser::foldericon]
	lappend topLevelIds $spectrumFolder

	# Step 1: Create an array indexed by spectrum name whose value is the gate on that
	#         spectrum "-TRUE-" is filtered out to an empty string:
	# NOTE: All spectra have a gate applied to them even if it's a -TRUE- gate.
	#      this is how SpecTcl works.
	#
	foreach application [apply -list] {
	    set name [lindex $application 0]
	    set gate [lindex [lindex $application 1] 0]
	    if {$gate eq "-TRUE-"} {
		set gate ""
	    }
	    set applications($name) $gate
	}

	# Now we're ready to populate the subtree:
	# Step 2:  Create a list of spectra filtered by any -filterspectra script each element
	#          itself a list containing:
	#           name, type, gate, "" "" "" "" ""  definition.
	# 
	set spectrumList [list]
	foreach definition [spectrum -list] {
	    if {$options(-filterspectra) ne ""} {
		if {![uplevel #0 $options(-filterspectra) [list $definition]] } {
		    continue;	# Skip if filter script rejected.
		}
	    }
	    set name [lindex $definition 1]
	    lappend spectrumList [list \
				      $name                   \
				      "[lindex $definition 2] [lindex $definition 5]"  \
				      $applications($name)    \
				      "" "" "" "" ""          \
				      $definition]				  
	}

	# Fill in the spectrum tree:

	$self fillSpectrumSubtree $spectrumFolder $spectrumList

       

    }
    # fillParameterFolder
    #      Fills the parameter folder with the set of parameters that are now defined.
    #      Previously existing parameters in the folder are first destroyed.
    #      this is suitable for a wholesale refresh of the gui.. it is not
    #      so useful for adding a single parameter.  See the addParameter method for that.
    #
    method fillParameterFolder {} {
	# Create the top level folder for parameters

	set paramFolder [$tree insert {} end -text Parameters \
			     -open 0 -tags parameterFolder -image ::browser::foldericon]
	lappend topLevelIds $paramFolder

	# Stock with parameters:
	#  Make the list of parameters we are going to display in the tree:
	#  This is a 2 element list of parameter name, parameter definition:
	#

	set parameterList [list]
        foreach parameter [parameter -list] {
            if {$options(-filterparameters) != ""} {
                if {![eval $options(-filterparameters) [list $parameter]]} {
                    continue
                }
            }
	    lappend parameterList [list [lindex $parameter 0] $parameter]
	}


	# Recursively stock the parameter tree algorithm is pretty much the same as
	# for fillSpectrumSubtree

	$self fillParameterSubtree $paramFolder $parameterList


   
    }
    # fillVariableFolder
    #      Fills the variable folder with the set of treevariables that are now defined.
    #      note that only treevariables are put in the folder, not ordinary Tcl vars.
    #      as that could be a strain on the user. Prior to filling, the existing
    #      variables are wiped out.  This function is best used to do a full refresh.
    #
    #
    method fillVariableFolder {} {
	# Create the the variable folder:

	set varFolder [$tree insert {} end -text Variables \
			   -open 0 -tags variableFolder -image ::browser::foldericon]

	lappend topLevelIds $varFolder


	set vars [treevariable -list]
	set varCount [llength $vars]
	set varNum   0
	set treeVariables [list]
        foreach variable $vars {
	    incr varNum
            set rawname [lindex $variable 0]
            set value   [lindex $variable 1]
            set units   [lindex $variable 2]

	    lappend treeVariables [list $rawname $value $units]

        }
	$self fillVariableSubtree $varFolder $treeVariables

		      
    }
    # fillGateFolder
    #    Fills the gate folder with the set of gates that are now defined.
    #    The type column is filled with the gate type and gate type specific0
    #    subnodes are created for each gate.
    #
    method fillGateFolder {} {
	set gateFolder [$tree insert {} end -text Gates \
			    -open 0 -tags gateFolder -image ::browser::foldericon]
	lappend topLevelIds $gateFolder

	# Create the list of filtered gates:

	set gateList [list]
	set gates [gate -list]
	set filter $options(-filtergates)

	if {$filter ne ""} {
	    foreach gate $gates {
		if {[uplevel #0 $filter [list $gate]]} {
		    lappend gateList $gate
		}
	    }
	} else {
	    set gateList $gates
	}
	$self fillGateSubtree $gateFolder $gateList
    }

    ## fillSpectrumSubtree
    #    Recursively fills the spectrum tree.
    #    The spectrum list we've been given is considere to be sorted.
    #    We take each spectrum and split the remaining name into
    #    a list of path elements.
    #    - For each path list that has more than one element we create
    #      a folder and recurse for the remainder of the path.
    #    - For each path list that has only  one element we create a terminal
    #      spectrum node.
    #    Note that this automatically correctly handles the case where
    #    A name is both a path lead in as well as a terminal node e.g.:
    #    x and x.left, x.right for a PPAC position.
    #
    # @param id           - Id of parent fror all nodes that will be created.
    # @param spectrumList - List of spectrum definitions.
    #                       Note that the 0'th element of each of these is the
    #                       remaining path name.
    #
    method fillSpectrumSubtree {id spectrumList} {
	array set folders [list]; # Will hold folder nodes.
	array set terminals [list]; # Will hold terminal nodes.

	foreach spectrum $spectrumList {
	    set nameList [split [lindex $spectrum 0] .]
	    if {[llength $nameList] == 1} {
		set terminals($nameList) $spectrum; #  One path element means terminal node
	    } else {
		# Folder
		set spectrum [lreplace $spectrum 0 0 [join [lrange $nameList 1 end] .]]; # Remainder of path.
		lappend folders([lindex $nameList 0]) $spectrum; # list of stuff in the folder.
	    }
	}
	# Now create the folders and their subtrees...sort by index of the folders array:

	foreach folderName [lsort [array names folders]] {
	    set folderId [$tree insert $id end -text $folderName -image ::browser::foldericon]
	    $self fillSpectrumSubtree $folderId $folders($folderName)
	}
	# Finally add in the terminal nodes:

	foreach spectrum [lsort [array names terminals]] {
	    $self addSpectrum $id $terminals($spectrum)
	}

	
    }

    ##
    # addSpectrum
    #   Adds a spectrum at the end of the list below the given parent
    #
    # @param parent - Parent id.
    # @param item   - List element created by fillSpectrumFolder.
    #
    # @return id    - the tree id of the element created.
    #
    # @note if the spectrum definition is empty "" we are creating a subfolder for the given 
    #       name, otherwise we are creating a spectrum along with its elements for each parameter
    #       and axis definition.
    #
    method addSpectrum {parent item} {

	set spectrumDef [lindex $item 8]
	if {$spectrumDef eq ""} {
	    set icon ::browser::foldericon
	} else {
	    set icon ::browser::spectrumicon
	}

	# The only thing that differs at the top level is the icon used:

	set id [$tree insert $parent end -text [lindex $item 0] -image $icon \
		    -values [lrange $item 1 7] -tags spectrum]

	# If this is actually a spectrum we need to set its subinfo:

	if {$spectrumDef ne ""} {
	    set type       [lindex $spectrumDef 2]
	    set parameters [lindex $spectrumDef 3]
	    set axes       [lindex $spectrumDef 4]

	    $self setSpectrumSubInfo $id $type $parameters $axes
	}
	return $id
    }
    ##
    # setSpectrumSubInfo id type parameters axes
    #      Fills in any required child nodes for a spectrum.  This is type dependent.
    #      Note that in the case of 1-d spectra (type 1, g1, b, and S),
    #      We fill in the x axis low/high/bins on the parent node just to make
    #      it a bit easier for the user.
    #      For 2-d type spectra, we'll have subsidiary nodes for each axis that
    #      will have this information.
    #      In any case we list the parameters and their information as well.
    # 
    #   @param  id            - The treeview ident of the primary node.
    #   @param  spectrumType  - The spectrum type.
    #   @param  parameters    - The parameters used by the spectrum.
    #   @param  axes          - The axis definitions used by the spectrum.
    #
    method setSpectrumSubInfo {id spectrumType parameters axes} {

        # Branch out depending on the type of spectrum:

        switch -exact -- $spectrumType {
	    1 {
		$self set1dSubInfo $id $parameters $axes
	    }
	    2 {
		$self set2dSubInfo $id $parameters $axes
	    }
	    g1 {
		$self setg1SubInfo $id $parameters $axes
	    }
	    g2 {
		$self setg2SubInfo $id $parameters $axes
	    }
	    gd {
		$self setgdSubInfo $id $parameters $axes
	    }
	    s {
		$self setSummarySubInfo $id $parameters $axes
	    }
	    b {
		$self setBitmaskSubInfo $id $parameters $axes
	    }
	    S {
		$self setStripchartSubInfo $id $parameters $axes
	    }
	    m2 {
		$self set2dMultipleSubInfo $id $parameters $axes
	    }
            gs {
                $self setGammaSummarySubInfo $id $parameters $axes
            }
	    default {}
        }
    }
    ##
    # set1dSubInfo id parameters axes
    #      Sets the subnode information for a 1-d spectrum:
    #      The info for the single axis is loaded into the
    #      the primary node's data. If the parameters is a
    #      treeparameter, units are also loaded.
    #      The parameter is loaded as a subnode, if a tree parameter its info
    #      is loaded as well.
    # 
    # @param id         - The spectrum node's id in the treeview.
    # @param parameters - A single parameter name.
    # #param  axes       - A list containing a single axis definition list.
    #
    method set1dSubInfo {id parameters axes} {
        set axis  [lindex $axes 0]
        $self addAxisInfo           $id $axis $parameters
        $self addEntryParameter     $id 0 $parameters

    }
    ##
    # set2dSubInfo id parameters axes
    #     Fils in the subnode information for a 2-d spectrum.
    #     This consists of two subnodes, one for the x axis and one for the y axis.
    #     The x axis is labelled with X : xparametername
    #     The y axis is labelled with Y : yparametername
    #     For both axes, the low, high, bins are taken from the axis definitions
    #
    # @param id         - Id of the parent node.
    # @param parameters - list containing x, y parameters.
    # @param axes       - list containing the axis specifications.
    method set2dSubInfo {id parameters axes} {
        foreach parameter $parameters axis $axes name {X Y} {
            $self addAxis $id $name $parameter $axis
        }
    }
    ##
    # setg1SubInfo id parameters axes
    #      Fills in subnodes for a g1 spectrum:
    #      The axis information is placed on the spectrum line, and we create one
    #      parameter subnode for each parameter in the spectrum.  The icon for each parameter
    #      is the treeparameter icon, to distinguish it from being an axis specification.
    #      No data is supplied with each parameter.   There is no axis subnode.
    #      If the first parameter in the parameter list is a treeparamter, its units are
    #      used as the axis units. under the assumption that all paramters will have the same
    #      units.
    # 
    #   @param  id          - The id of the parent node.
    #   @param  parameters  - List of parameters for the spectrum.
    #   @param  axes        - The single axis specification for the spectrum.
    #
    method setg1SubInfo {id parameters axes} {

        # Extract the axis information and add it to the existing data for id.

        set axis [lindex $axes 0]
        $self addAxisInfo $id $axis [lindex $parameters 0]


        $self setFold $id

        #  Now a parameter subnode for each parameter in the gamma spectrum:

        set paramnumber 0
        foreach parameter $parameters {
            $self addEntryParameter $id $paramnumber $parameter
            incr paramnumber
        }

    }
    ##
    # setg2SubInfo id parameters axes
    #      Fills in any required child nodes for a g2 spectrum.  These
    #      consist of:
    #      - A fold subnode if the spectrum has a fold applied.
    #      - An x and a y axis subnode.  The limits/bins on the axis are taken
    #        from the axis specification.  If the first parameter in the spectrum
    #        is a tree parameter, the units for both axes are taken from it on the
    #        assumption that a gamma spectrum with mixed units has no reason to live.
    #      - A parameter axis for each parameter in the list.
    #
    # @param id         - The id of the parent node.
    # @param parameters - list of parameters in this spectrum.
    # @param axes       - list of axes.
    method setg2SubInfo {id parameters axes} {
        set axisid [$self addAxis $id X [lindex $parameters 0] [lindex $axes 0]]
	$tree item $axisid -text X

        set axisid [$self addAxis $id Y [lindex $parameters 0] [lindex $axes 1]]
	$tree item $axisid -text Y

        $self setFold $id

        set paramno 0
        foreach param $parameters {
            $self addEntryParameter $id $paramno $param
            incr paramno
        }

    }
    ##
    #  setgdSubInfo id parameters axes
    #    Set the sub information for a gamma 2d deluxe spectrum.
    #    Note that the parameters parameter is a 2 element list of
    #    the x and y parameters.
    #
    # @param id - Parent node id.
    # @param parameters - list of parameters in the spectrum.
    # @param list of axis definitions.
    #
    method setgdSubInfo {id parameters axes} {
	set xparams [lindex $parameters 0]
	set yparams [lindex $parameters 1]


	set axisid [$self addAxis $id X "" [lindex $axes 0]]
	$tree item $axisid -text X


	set axisid [$self addAxis $id Y "" [lindex $axes 1]]
	$tree item $axisid -text Y


	set i 0

	foreach x $xparams {
	    $self addEntryParameter $id $i "X: $x"
	    incr i
	}
	foreach y $yparams {
	    $self addEntryParameter $id $i "Y $y"
	    incr i
	}
    }
    ##
    # setSummarySubInfo id parameters axes
    #     Fills in any required child nodes for a summaryy spectrum.
    #     The summary spectrum has the following subnodes:
    #     - X axis which is labeled X : parameters
    #       for which the low is 0, the high is nparams -1 and the bins are nparams.
    #       and for which there are no units.
    #     - Y axis which is labelled Y and has info from the first of the parameters.
    #     - A parameter entry for each parameter in the spectrum
    #     The spectrum itself is given the y axis info.
    # 
    # @param  id         - Id of the node we are adding children to.
    # @param  parameters - List of parameter names involved in the spectra.
    # @param  axes       - Axis specifications.
    #
    method setSummarySubInfo {id parameters axes} {
        $self addAxis $id X parameters "0 [expr [llength $parameters]-1] [llength $parameters]"
        set xid [$self addAxis $id Y [lindex $parameters 0] [lindex $axes 0]]
	$tree item $xid -text Y

        $self addAxisInfo $id [lindex $axes 0] [lindex $parameters 0]

        set pno 0
        foreach parameter $parameters {
            $self addEntryParameter $id $pno $parameter
            incr pno
        }
    }
    ##
    # setBitmaskSubInfo id parameters axes
    #      Fills in any required child nodes etc. for a bitmask spectrum.
    #      The top level gets the axis limit information, units are not relevant.
    #      A parameter subnode is created for the parameter from which the mask is being
    #      computed.
    # 
    # @param  id          - Id of the spectrum node we are filling in
    # @param   parameters  - list of parameters that make the spectrum (one really)
    # @param   axes        - list of axis specifications (one really).
    #
    method setBitmaskSubInfo {id parameters axes} {
        set axis [lindex $axes 0]
        $self addAxisInfo $id $axis $parameters
        $self addEntryParameter $id 0 $parameters
    }
    ##
    # setStripchartSubInfo id parameters axes
    #     Fills in required child nodes for a stripchart spectrum from the time parameter
    #     This consists of an axis specification in the spectrum itself.
    #     and a pair of parameters with labels that look like:
    #     Time  : parametername
    #     Value : parametername
    # 
    # @param  id         : The id of the spectrum node.
    # @param  parameters : The time and value parameter for the spectrum.
    # @param  axes       : The single axis specification.
    #
    method setStripchartSubInfo {id parameters axes} {
        set axis [lindex $axes 0]
        set timep [lindex $parameters 0]
        set valuep [lindex $parameters 1]

        $self addAxisInfo $id $axis $timep
        $self addEntryParameter $id 0 "Time  : $timep"
        $self addEntryParameter $id 1 "Value : $valuep"

    }
    ##
    # set2dMultipleSubInfo id parameters axes
    #     Fills in the required sub info for a 2d multiply incremented
    #     spectrum.  We add 2 axes named arbitrarily X and Y
    #     and list all the parameters and their information as well.
    #
    #
    #  @param  id         : Id of the spectrum node.
    #  @param  parameters : list of parameter names.
    #  @param  axes       : 2 axis specifications.
    #
    method set2dMultipleSubInfo {id parameters axes} {
        set axisid [$self addAxis $id X "" [lindex $axes 0]]
	$tree item $axisid -text X

        set axisid [$self addAxis $id Y "" [lindex $axes 1]]
	$tree item $axisid -text Y


	set i 0
	foreach parameter $parameters {
	    $self addEntryParameter $id $i $parameter
	    incr i
	}
    }
    ##
    #  setGammaSummarySubInfo id parameters axes
    #
    #  Set the sub information for a gamma summary spectrum.
    #  We'll have one axis, which is the Y axis, and that will
    #  display as on a 1-d spectrum.
    #  We'll have strip subfolders numbered for the x axis coordinate
    #  each strip subfolder will have entries for each parameter in that strip.
    #
    # @param id - Id of parent tree node.
    # @param parameters - list of parameters involved.
    # @param axes       - list of axis specifications.
    #
    method setGammaSummarySubInfo {id parameters axes} {
        
        #  Add the y axis as our axis information:
        
        set axis [lindex $axes 0]
	set c    [lindex $parameters 0]


	set p [lindex $c 0]

        $self addAxisInfo $id $axis $p
        
        set xChannel 0
        set param 0
        foreach channel $parameters {
            
            # Add a folder for a channels parameters.
            
            set name Channel$xChannel
	    set channelId [$tree insert $id end -text $name -image ::browser::foldericon]

            
            
            foreach parameter $channel {
                # Add a parameter definition.
                
                $self addEntryParameter $channelId $param $parameter
                
                incr param
            }
            incr xChannel
        }
    }
 
    ##
    # addAxisInfo id specification parameter
    #     Adds axis specification information to the indicated node.
    #     this consists of low, high, bins, and if the parameter is
    #     a treeparam, units.
    # 
    #    @param id             - Id of the node to add this info to.
    #    @param specification  - SpecTcl axis specification string.
    #    @param parameter      - Parameter name.
    #
    method addAxisInfo {id specification parameter} {
	


        set data [$tree item $id -values]
        set low   [format %.2f [lindex $specification 0]]
        set high  [format %.2f [lindex $specification 1]]
        set bins  [lindex $specification 2]
        set units ""
        set info [treeparameter -list $parameter]
        if {$info != ""} {
            set info [lindex $info 0]
            set units [lindex $info 5]
        }
	#Replace the new information into the values data:

	set data [lreplace $data 2 6 $low $high $bins "" $units]
        $tree item $id -values $data
    }
    ##
    # addAxis id name parameter specification
    #     Adds an axis subnode to the node id (presumably a spectrum).
    #     - The axis limits are taken from the specification
    #     - The label of the axis is "$name : parametername"
    #     - The units of the axis are taken from the treeparameter units
    #       if the parameter is a tree parameter.
    # 
    # @param  id            - ID of spectrum node to which the axis is being added.
    # @param  name          - axis name (usually X or Y).
    # @param  parameter     - Name of parameter from which to draw the parameter informatino.
    # @param  specification - Axis limit specification
    # @return The new node id.
    method addAxis {id name parameter specification} {
	set axisid [$tree insert $id end -text "$name : $parameter" -image ::browser::axisicon \
			-values [list "" "" "" "" "" ""  ""]]
        $self addAxisInfo $axisid $specification $parameter
        return $axisid
    }
    ##
    # addEntryParameter id number name
    #      Adds a parameter subnode to a treeview entry The parameter node just shows the
    #      paramter name with a parameter icon.
    # 
    # @param   id      - Id of the treeview node to which this is being added.
    # @param   number  - A parameter index number used to name the node.
    # @param   name    - A parameter name used to label the node.
    #
    # @return    The new node id.
    #
    method addEntryParameter {id number name} {
	return [$tree insert $id end -text $name -image ::browser::paramicon]

    }
    ##
    # setFold id
    #     Adds a fold node to id if there is a fold applied to the
    #     spectrum.  A fold is represented as a gate node labelled:
    #     "Folded on : gatename
    #
    # @param id - the id of the node in which to apply the fold.
    #
    method setFold id {

	# Figure out the full spectrum name by crawling back up the path.
	# Note that the top level is Spectra and must not be used.
	#
	
	set nameList [list]
	set here $id
	while {[$tree parent $here] ne ""} {
	    lappend nameList [$tree item $here -text]; # bottom to top list.
	    set here [$tree parent $here]
	}
	set nameList [lreverse $nameList]; # Top to bottomlist. Spectra....


        set name [$self ItemName $id]


        set fold [fold -list $name]
        if {$fold != ""} {
            set fold [lindex $fold 0]
            set foldname "Folded on : [lindex $fold 1]"
	    $tree insert $id end -text $foldname -image ::browser::gateicon

        }
    }
    ## 
    #  ItemName id
    #
    #  Given the id of an item that is a spectrum, parameter, gate etc.
    #  Determines its full path name.  This is done by getting parent names
    #  up until and not including the top level folder, then joining them in 
    #  top to bottom path order with '.''s.
    #
    # @param id - The id of the item we're trying to get a name for.
    # 
    # @return - the full path name of the item.
    #
    method ItemName id {
	set nameList [list]
	set here $id
	while {[$tree parent $here] ne ""} {
	    lappend nameList [$tree item $here -text]; # bottom to top list.
	    set here [$tree parent $here]
	}
	set nameList [lreverse $nameList]; # Top to bottomlist. Spectra....


        return [join $nameList .]


    }
    ##
    # FullPath
    #    Just like ItemName above, however the folder name is also returned.
    #
    method FullPath id {
	set nameList [list]
	set here $id
	while {$here ne ""} {
	    lappend nameList [$tree item $here -text]
	    set here [$tree parent $here]
	}
	set nameList [lreverse $nameList]
	return [join $nameList .]
	
    }
    ##
    # fillParameterSubtree id parameters
    #   Fills a parameter subtree by
    #   - Creating folders for all non-terminal nodes in parameters.
    #   - Creating parameter nodes for all terminal nodes in parameters.
    #
    # @param id - The id of the parent node in which we are going to insert children.
    # @param parameters - List where each element contains in order the residual path string
    #                     and the parameter definition.
    #
    method fillParameterSubtree {id parameters} {
	array set folders [list]
	array set terminal [list]

	foreach element $parameters {
	    set pathList [split [lindex $element 0] .]
	    if {[llength $pathList] == 1} {
		# Terminal node
		
		set terminal($pathList) [lindex $element 1];	# elements contain parameter defs.
		
	    } else {
		set residualPath [join [lrange $pathList 1 end] .]
		set element [lreplace $element 0 0 $residualPath]
		lappend folders([lindex $pathList 0]) $element;	# List of children.
	    }
	}
	# Create the folders and recurse on them to create their children:

	foreach folder [lsort [array names folders]] {
	    set folderId [$tree insert $id end -text $folder -image ::browser::foldericon]
	    $self fillParameterSubtree $folderId $folders($folder)
	}

	# Create the parameter definitionsL

	foreach param [lsort [array names terminal]] {
	    $self addParameter $id $param $terminal($param)
	}
    }
    ##
    # addParameter id name definition
    #
    #  Adds a parameter definition to the list of parameters...this is a parameter terminal node.
    #
    # @param id   - Id of parent node.
    # @param name - Terminal part of path  name.
    # @param def  - Parameter definition.
    #
    method addParameter {id name def} {
	set fullName [lindex $def 0]; # full path name to parameter.

	set pid [$self addEntryParameter $id 0 $name]

	# Figure out the values we need to put..only there if tree parameter:

	set treeInfo [treeparameter -list $fullName]
	if {$treeInfo != ""} {
	    set info [lindex $treeInfo 0]; #  tree parameter has info.
	    set bins  [lindex $info 1]
	    set low   [lindex $info 2]
	    set hi    [lindex $info 3]
	    set units [lindex $info 5]
	} else {
	    set bins "";	# Non tree parameter has nothing.
	    set low  ""
	    set hi   ""
	    set units ""
	}
	$tree item $pid -tag Parameter -values [list "" "" $low $hi $bins "" $units] -tags parameter


	# If the parameter is a pseudo, we are going put the dependent parameters as subnodes:

	if {$options(-detail)} {
	    set pseudoInfo [pseudo -list $fullName]
	    if {$pseudoInfo != ""} {
		$tree item $pid -image ::browser::pseudoicon
		set pseudoInfo [lindex $pseudoInfo 0]
		set dependencies [lindex $pseudoInfo 1]
		set pseudonum 0
		foreach dependentParam $dependencies {
		    $self addEntryParameter $pid $pseudonum $dependentParam
		    incr pseudonum
		}
	    }
	}
    }
    ##
    # addEntryParameter id number name
    #      Adds a parameter subnode to a treeview entry The parameter node just shows the
    #      paramter name with a parameter icon.
    # Parameters:
    #    id      - Id of the treeview node to which this is being added.
    #    number  - A parameter index numer -- ignored there for compatibility with vsn 1.0 of the pkg.
    #    name    - A parameter name used to label the node.
    # Returns:
    #     The new node id.
    #
    method addEntryParameter {id number name} {
	set pid [$tree insert $id end -text $name -image ::browser::paramicon]

        return $pid
    }
    ##
    # fillVariableSubtree 
    #
    # Fills  variable subtree given a parent and a list of variables that may or
    # or may not be terminal.  This is recursive.
    # For each variable that is not yet in terminal form the first path element is stripped out
    # and turned into a fodler and that folder is filled.
    #
    # @param id - Parent id.
    # @param variables - List of variables where the first item is the residual path, followed by
    #                    the value and units currently held by the variable.
    #
    method fillVariableSubtree {id variables} {
	array set folders [list]
	array set terminal [list]

	# Build up the folders and terminal arrays.

	foreach variable $variables {
	    set name [lindex $variable 0]
	    set pathList [split $name .]
	    if {[llength $pathList] == 1} {
		set terminal($name) $variable
	    } else {
		set residualPath [join [lrange $pathList 1 end] .]
		set variable [lreplace $variable 0 0 $residualPath]
		lappend folders([lindex $pathList 0]) $variable
	    }
	}

	# Create folders and recurse:

	foreach folder [lsort [array names folders]] {
	    set folderId [$tree insert $id end -text $folder -image ::browser::foldericon]
	    $self fillVariableSubtree $folderId $folders($folder)
	}
	# Enter the terminal nodes:

	foreach variable [lsort [array names terminal]] {
	    set varInfo  $terminal($variable)
	    set valueList [list "" "" "" "" "" [lindex $varInfo 1] [lindex $varInfo 2]]
	    $tree insert $id end -text $variable -image ::browser::varicon \
		-values $valueList -tags variable
	}
    }
    ##
    # fillGateSubtree
    #
    #  Fills a gate subtree..  by now the pattern should be familiar,
    #  Gate names are divided into path elments gate are divided into terminal and folder nodes
    #  depending on whether they have only one or more than one path elements.
    #  folder nodes; create the folder, strip off the first path element and recurse.
    #  terminal nodes create the gate entry.
    #  Since filling in gate information can be comlex depending on the gate type,
    #  once the gate node is created, fillGateInformation is invoked to fill in the details
    #  (which could mean additional nodes for some gate types).
    #
    # @param id    - The node id of the parent of this subtree.
    # @param gates - List of gate descriptions that should populate this subtree.
    #
    method fillGateSubtree {id gates} {
	array set folders [list]
	array set terminals [list]

	foreach gate $gates {
	    # Only show non 'F' gates -- as those are deleted gates.
	    if {[lindex $gate 2] ne "F"} {
		set path [split [lindex $gate 0] .]
		if {[llength $path] == 1} {
		    set terminals($path) $gate
		} else {
		    set residual [join [lrange $path 1 end] .]
		    set gate [lreplace $gate 0 0 $residual]
		    lappend folders([lindex $path 0]) $gate
		}
	    }
	}
	# Create folders and curse and recurse.

	foreach folder [lsort [array names folders]] {
	    set folderId [$tree insert $id end -text $folder -image ::browser::foldericon]
	    $self fillGateSubtree $folderId $folders($folder)
	}

	# Create terminal nodes.

	foreach gate [lsort [array names terminals]] {
	    set description $terminals($gate)
	    set type [lindex $description 2]
	    set gateId [$tree insert $id end -text $gate -image ::browser::gateicon \
			    -values $type -tags gate]
	    $self setGateSubInfo $gateId $type [lindex $description 3]
	}
    }
    #
    # setGateSubInfo id type description
    #    Sets appropriate subordinate information for a gate.
    #    This is done by independent gate type handlers that know
    #    the format of the gate description field (which varies from gate type to
    #    gate type).
    # 
    # @param   id           - treeview id of the gate we are elaborating.
    # @param   type         - Gate type (from SpecTcl gate description.
    # @param   description  - Gate dependent description information.
    #
    method setGateSubInfo {id gateType description} {
        switch -exact -- $gateType {
            s {
                $self setSliceSubInfo $id $description
            }
            b -
            c {
                $self set2DGateSubInfo $id $description
            }
            * -
            + -
            "-" {
                $self setCompoundGateSubinfo $id $description
            }
            gs {
                $self setGammaSliceSubinfo $id $description
            }
            gb -
            gc {
                $self setGamma2DGateSubinfo $id $description
            }
            em -
            am -
            nm {
                $self setMaskGateSubinfo $id $description
            }
            default {
            }
        }
    }

    ##
    # setSliceSubInfo id description
    #    Sets the subinfo for a slice gate.
    #    This consists of:
    #    - A parameter subnode containing the name of the parameter
    #      the gate is tested on.
    #    - A Point subnode labelled "limits : (low,hi)
    #      showing the extent of the gate on the parameter.
    #
    # parameters:
    #  @param  id          - The id in the treeview of the gate on which
    #                  these subnodes will be created.
    #  @param  description - The gate dependent description which is a list
    #                  of the form {parameter-name {low high}}
    method setSliceSubInfo {id description} {
        # Parse the description:

        set parameter [lindex $description 0]
        set limits    [lindex $description 1]

        $self addEntryParameter $id 0 $parameter
        $self addPoint $id 1 "limits : " $limits
    }
    ##
    # addPoint id number prefix point
    #     Adds a point subnode to the indicated id.
    #     A point subnode is labelled as "prefix (x,y)"
    #     A point is labelled with the pointicon.
    # 
    #    @param id      - Id of node to which this point is getting added.
    #    @param number  - Index of the point
    #    @param prefix  - Prefix string for the point label
    #    @param point   - The point coordinates.
    #
    #
    method addPoint {id number prefix point} {
        set label [format "$prefix (%.2f,%.2f)" [lindex $point 0] [lindex $point 1]]
	$tree insert $id end  -text $label -image ::browser::pointicon

    }
    ##
    # set2DGateSubInfo id description
    #    Sets the appropriate subordinate information for a 2d gate
    #    (band or contour).
    #    - We create a parameter subentry for each of the parameters in the gate.
    #      These will be labelled X : parametername
    #    - We create a subfolder named 'points' and an entry in it for each
    #      point labelled (x,y).
    # 
    #   @param id           - The treeview id of the entity we are creating these subnodes under.
    #   @param description  - The gate descrption which consists of an n element list.  The
    #                  First element is a 2 element sublist containing the x/y parameter names
    #                  The subsequent elements are the x/y points as {x y} sublists.
    #
    method set2DGateSubInfo {id description} {
        set parameters [lindex $description 0]
        set points     [lrange  $description 1 end]

        $self addEntryParameter $id 0 "X : [lindex $parameters 0]"
        $self addEntryParameter $id 1 "Y : [lindex $parameters 1]"

        set pno 0
        foreach point $points {
            $self addPoint $id Points.$pno "" $point
            incr pno
        }

    }
    ##
    # setCompoundGateSubinfo id description
    #    Sets appropriate subordinate information for compound gate.
    #    Compound gates consist of/depend on other gates.
    #    For each gate we produce a simple gate subentry
    #    simple gate subentries look like gates but don't show any subordinate
    #    detail other than the gate type.
    # Parameters:
    #  @param  id           - The id of the gate we are creating subordinate information for.
    #  @param  description  - The gate description, which in this case is,
    #                  the list of names of subordinate gates.
    #
    method setCompoundGateSubinfo {id description} {
        foreach gate $description {
            set type [lindex [lindex [gate -list $gate] 0] 2]
	    $tree insert $id end -text $gate -image ::browser::gateicon \
		-values $type

        }
    }
    ##
    # setGammaSliceSubinfo id description
    #    Sets the appropriate subordinate information for a gamma slice.
    #    This consists of a single point and a list of parameters and Parameters folder.
    #    The point is labelled "Limits : (hi,low)"
    # 
    # @paream   id          - The treeview id of the gate to which we are adding
    #                         the subordinates.
    # @param   description - The description of the gate.
    #
    method setGammaSliceSubinfo {id description} {
        set point      [lindex $description 0]
        set parameters [lindex $description 1]

        set parno 0
        foreach parameter $parameters {
            $self addEntryParameter $id Parameters.$parno $parameter
            incr parno
        }
        $self addPoint $id $parno "Limits : " $point

    }
    ##
    # setGamma2DGateSubinfo id description
    #    Set the appropriate subordinate information for a 2d gamma gate
    #    (gc, gb). This consists of a list of parameters in a parameter folder
    #    and a list of points in a Points folder.
    #
    # 
    # @param  id          : Id of the gate we are filling in (in the treeview)
    # @param  description : Gate description which consists of a list of points and
    #                       a list of parameters.
    #
    method setGamma2DGateSubinfo {id description} {
        set points     [lindex $description 0]
        set parameters [lindex $description 1]

        set parno 0
        foreach parameter $parameters {
            $self addEntryParameter $id Parameters.$parno $parameter
            incr parno
        }

        set pnum 0
        foreach point $points {
            $self addPoint $id Points.$pnum "" $point
            incr pnum
        }
    }
    ##
    # setMaskGateSubinfo id description
    #    Sets appropriate subordinate informatino for a bitmask
    #    gate (type em, am, nm).  We list the parameter
    #    and the mask.  The mask is listed as a 'point'
    #    however the label is just mask = (hex of mask).
    #    Since the 'point' is not really a point, we must manually
    #    create the point.
    #
    # @param  id           - Id of the gate for which  we are making subordinate data.
    # @param  description  - The gate description which consists of a parameter and mask.
    #
    method setMaskGateSubinfo {id description} {
        set parameter [lindex $description 0]
        set mask      [lindex $description 1]
        set masklabel [format "mask = 0x%x" $mask]

        $self addEntryParameter $id 0 $parameter
	$tree insert $id end -text $masklabel -image ::browser::pointicon

    }
    ##
    # getSelection
    #       Returns a list consisting of:
    #       The full names of all the selected entities in the browser tree.
    #       Note that the item type prefix (e.g. Gates or Spectrum) is still
    #       present.
    #       If there are no elements selected, an empty list is returned.
    # Returns:
    #     A list of names in the selection. 
    #     The elements of this list are translated back  to names 
    #     (the _BLTFOLDER is removed from intermediate path entries.
    #
    method getSelection {} {
        set selected [$tree selection];         # These are ID's.
        set names [list]
        foreach id $selected {
            lappend names [$self FullPath $id]
        }
        return $names
    }
    #-------------------------------------------------------------------------
    #
    # Event dispatch and handling.

    ##
    # mymethod FolderContextDispatch Option %X %Y
    #       Dispactches folder context menu requests.  These are typically
    #       requested via a right click over a top level folder.
    # 
    # @param    OptionName   - the name of the option array element that is holding
    #                the user supplied script to call or {} if there is none.
    #                the X/Y coordinates of the click are passed to the caller.
    # @param x,y     - The coordinates of the click relative to the widget.
    #
    method FolderContextDispatch {OptionName x y} {
        set script $options($OptionName)
        if {$script != ""} {
            uplevel #0 $script $x $y
        }
    }
    ##
    # selectElement x y
    #     Sets the selEction to the element at x,y
    #
    method selectElement {x y} {
        set id [$tree identify row  $x $y]
        if {$id != ""} {
	    $tree selection set $id
        }
    }
    ##
    # onElementDoubleClick Option x y
    #      Dispatches user scripts on double clicks on SpecTcl elements.
    #      (e.g. Spectra, Gates, Parameters, Variables.
    # 
    #   @parameter Option   - Name of the option that should have the user script body.
    #   @parameter  x,y      - Coordinates of the click.
    # @note
    #    The user script is called:
    #        userscript path
    #    Where path is the path of the nearest element under the pointer when the doubleclick occured.
    #
    method onElementDoubleClick {Option x y} {

        set script $options($Option)
        if {$script != ""} {
            set id [$tree identify row  $x $y]
            if {$id != ""} {
                set path [$self FullPath $id]
                uplevel #0  $script  $path
            }
        }
    }
    ##
    # onElementContext Option x y X Y
    #     Invokes a context click (right button) for
    #     an element:
    # Parameters:
    #    Option   - Name of the option that should have the user script body.
    #    x,y      - Coordinates of the click.
    #    X,Y      - Absolute coordinates of the click.
    # Note:
    #     The user script is called:
    #        userscript path X Y
    #
    method onElementContext {Option x y X Y} {
	set script $options($Option)

	if {$script eq ""} return; # No callback.
	
	set id [$tree identify row $x $y]
	if {$id ne ""} {
	    set name [$self FullPath $id]

	    uplevel #0 $script $name $X $Y
	}
    }

    
}

