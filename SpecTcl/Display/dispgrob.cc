/*
		    GNU GENERAL PUBLIC LICENSE
		       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.
                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

			    Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
 (2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

		    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions of the General Public License from time to time.  Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions 
either of that version or of any later version published by the Free Software 
Foundation.  If the Program does not specify a version number of this License,
 you may choose any version ever published by the Free Software Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author to 
ask for permission.  For software which is copyrighted by the Free Software 
Foundation, write to the Free Software Foundation; we sometimes make 
exceptions for this.  Our decision will be guided by the two goals of 
preserving the free status of all derivatives of our free software and of 
promoting the sharing and reuse of software generally.

			    NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR
THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN 
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE 
THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, 
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND 
FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND 
PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, 
YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING 
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR 
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, 
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING 
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO 
LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR 
THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), 
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH 
DAMAGES.

		     END OF TERMS AND CONDITIONS
*/
static const char* Copyright = "(C) Copyright Michigan State University 1994, All rights reserved";

/*
** Facility:
**   Display program graphical object subsystem.
** Abstract:
**   dispgrob.cc   - This file contains code for the graphical object
**                   methods which are not in-line methods.
** Author:
**   Ron Fox
**   NSCL
**   Michigan State University
**   East Lansing, MI 48824-1321
** Version:
**    @(#)dispgrob.cc	2.1 12/22/93 
*/

/*
** Include files required:
*/
#include <stdio.h>
#include "dispgrob.h"
#include "XMWidget.h"
#include "XBatch.h"
#include "dispwind.h"
#include "dispshare.h"
#include "convert.h"
#include "sumregion.h"
#include "acceptgates.h"
#include "grobjdisplay.h" 
#include "marker.h"
#include "gcmgr.h"
#include "xaminegc.h"
#include "gc.h"
#include "chanplot.h"
/*
** Local storage:
**
*/
#if 0
static char dashes[2] = { 2,2 };
#endif
/*
** External references:
*/
extern volatile spec_shared *xamine_shared;

/*
** Functional Description:
**    Swap:
**      Template function to swap two arbitrarily typed items:
** Formal Parameters:
**    T   - Type of parameters.   Must have a copy constructor or an
**          assignment operator defined, null constructor must also be defined.
**
**    T& item1,item2:
**        The items to swap.
*/
template <class T>
static void Swap(T& item1, T& item2)
{
  T temp;
  temp  = item1;
  item1 = item2;
  item2 = temp;
}

/*
** Functional Description:
**    SetClipRegion:
**      Set the clipping region for drawing a graphical object... the
**      clip region is set to be the piece of the pane which contains
**      the drawn part of the spectrum.
** Formal Paramters:
**   XamineGrobjGC *gc:
**      Pointer to the graphical context object whose clip region will be set.
**   XMWidget *wid:
**      Widget which the gc is in.
**    win_attributed *attributes:
**       Attributes of the spectrum.
*/
static void SetClipRegion(XamineGrobjGC *gc, XMWidget *wid, 
			  win_attributed *attributes)
{
  gc->ClipToSpectrum(*wid, *attributes);
}

#if 0
/*
** Method Description:
**   getversion - Returns a pointer to the version string.
** 
*/
char *grobj_generic::getversion()
{
  return dispgrobversion;
}
#endif


/*
** Method Description:
**   addpt   - Adds a point to the end of the graphical object's point list.
**             Ensures that the point buffer does not overflow.
** Formal Parameters:
**   int x:
**      X coordinates of the point (defaults to zero).
**   int y:
**     Y coordinates of the point (defaults to zero).
** Returns:
**     0   - If failed.
**    npts - now in graphical object if success.
*/
int grobj_generic::addpt(int x, int y)
{
  if( (npts < GROBJ_MAXPTS) ) {
    pts[npts].set(x,y);
    npts++;
    return npts;
  }
  return 0;
}

/*
** Method Description:
**   delpt    -- Delete points from the point list of the graphical object.
**               This function has two instances, one with a location
**               and one without a location.  The function with a location
**               specifies which point is to be deleted (numbered from zero).
**               The function without a location deletes the last point.
**               The location less function is in-line.
** Formal Parameters:
**    int loc:
**       Optional parameter which specifies which point (numbered from zero)
**       should be deleted.
** Returns:
**   -1 if invalid point or nonexistent point.
**    0 If point deleted was the last one.
**  npts Number of points remaining.
*/
int grobj_generic::delpt(int loc)
{
  if(loc < npts) {
    npts--;
    for(int i = loc; i < npts ; i++)
      pts[i] = pts[i+1];	/* Slide pts down into hole if needed. */
    return npts;
  }
  return -1;
}

/*
** Method Description:
**   insertpt    - This function inserts a point into the middle of
**                 a graphical object's point list.  
** Formal Parameters:
**   int loc:
**     Point number (numbered from zero) at which to insert the point.
**     The point at that point number and all subsequent points are bumped
**     foreward one position.
**  int x,y:
**     The value of the point to add.
** Returns:
**    -1  - Location is not a valid location.
**     0  - Point list is already full.
**   npts - Number of points in list after insertion.
**/
int grobj_generic::insertpt(int loc,int x, int y)
{
  if(npts < GROBJ_MAXPTS) {
    if(loc < npts) {
      for(int i = npts; i > loc; i--)
	pts[i] = pts[i-1];	/* Slide everything up */
      pts[loc].set(x,y);	/* Insert the new point */
      npts++;
      return npts;
    }
    else
      return -1;
  }
  else
    return 0;
}

/*
** Method Description:
**   getpt     -  Returns the specified point from the point list.
** Formal Parameters:
**   int loc:
**     Specifies the point to get (numbered from zero).
** Returns:
**   A pointer to the selected point.
**   NULL if no such point.
*/
grobj_point *grobj_generic::getpt(int loc)
{
  if(loc < npts)
    return &pts[loc];
  return NULL;
}
/*
** Method description:
**  nextpt   - Retrieves the next point in a traversal context set up
**             by firstpt.
** Returns:
**   Pointer to the next point or NULL if there is no next point.
*/
grobj_point *grobj_generic::nextpt()
{
  where++;
  if(where < npts) {
    return &pts[where];
  }
  where--;
  return NULL;
}
/*
** Method Description:
**   *::type   - Returns the type of the graphical object.
**/
grobj_type grobj_generic::type() { return generic; }
grobj_type grobj_cut1d::type()   { return cut_1d;  }
grobj_type grobj_sum1d::type()   { return summing_region_1d; }
grobj_type grobj_mark1d::type()  { return marker_1d; }
grobj_type grobj_contour::type() { return contour_2d; }
grobj_type grobj_band::type()    { return band; }
grobj_type grobj_sum2d::type()   { return summing_region_2d; }
grobj_type grobj_mark2d::type()  { return marker_2d; }








/*
** The pages below provide drawing methods for all of the
** graphical object types.  Each method draws the object on a widget which
** is assumed to be a drawing area widget.
*/

/*
** Functional Description:
**   DrawPlusses:
**     This function draws a set of + marks at various points in a drawable.
** Formal Parameters:
**   Display *d:
**     Display Connection identifier.
**   Drawable win:
**     Id of the drawable, could be a window or a pixmap.
**   GC gc:
**     Handle to the graphical context to use for drawing.
**   Xamine_Converter *cvt:
**     Pointer to a coordinates convesion routine.
**   Boolean flipped:
**     True if the spectrum is displayed in an axis flipped representation.
**   grobj_generic: *o:
**     The object to draw.
*/
static void DrawPlusses(Display *d, Drawable win, GC gc,
		    Xamine_Converter *cvt, Boolean flipped, grobj_generic *o)
{
  XSegmentBatch crosses(d, win, gc); /* Instantiate a segment drawer. */

  grobj_point *pt = o->firstpt();

  while(pt != NULL) { 
    int sx,sy;			/* Spectrum points. */
    int x,y;			/* Screen points.   */

    sx = pt->getx(); sy = pt->gety();

    if(flipped) {
       int t;
       switch(o->type()) {
         case contour_2d:
	 case summing_region_2d:	/* If necessary flip the axes */
	 case marker_2d:
	 case pointlist_2d:
	    t = sx;
	    sx= sy;
	    sy= t;
            break;
	 default:
	    break;
       }
    }
    cvt->SpecToScreen(&x, &y, sx, sy);

    crosses.draw((short)(x - 4), (short)(y), 
		 (short)(x + 4), (short)(y));
    crosses.draw((short)(x), (short)(y + 4), 
		 (short)(x), (short)(y - 4));

    pt = o->nextpt();
  }
}
/*
** Functional Description:
**   DrawXes:
**     This is a local function which draws X-crosses at the vertices
**     of a graphical object.  It is used typically while drawing objects to 
**     show where the points are in high relief.
** Formal Parameters:
**   Display *d:
**      Pointer to the X11 display connection id.
**  Drawable win:
**     Drawable Id.  May be a window or a pixmap.
**  GC gc:
**     Graphical context which describes how the drawing should be done.
**  Xamine_Converter *cvt:
**     Pointer to the coordinate conversion for this window.
**  Boolean flipped:
**     True if the spectrum is displayed in axis flipped representation.
**  grobj_generic *o:
**     The graphical object to draw.
*/
static void DrawXes(Display *d, Drawable win, GC gc,
		    Xamine_Converter *cvt, Boolean flipped, grobj_generic *o)
{
  XSegmentBatch crosses(d, win, gc); /* Instantiate a segment drawer. */

  grobj_point *pt = o->firstpt();

  while(pt != NULL) { 
    int sx,sy;			/* Spectrum points. */
    int x,y;			/* Screen points.   */

    sx = pt->getx(); sy = pt->gety();
    if(flipped) {
       int t;
       switch(o->type()) {
       case contour_2d:
       case summing_region_2d:	/* If necessary flip the axes */
       case marker_2d:
       case pointlist_2d:
       case band:
	    t = sx;
	    sx= sy;
	    sy= t;
            break;
	 default:
	    break;
       }
    }

    cvt->SpecToScreen(&x, &y, sx, sy);

    crosses.draw((short)(x - 4), (short)(y - 4), 
		 (short)(x + 4), (short)(y + 4));
    crosses.draw((short)(x - 4), (short)(y + 4), 
		 (short)(x + 4), (short)(y - 4));

    pt = o->nextpt();
  }

  

}    

/*
** functional Description:
**   grobj_sum1d::draw:
**      This function draws a 1-d summing region on a given pane.
**      In final mode, the summing region uses a dashed line, while in
**      non-final mode a dotted line is used.  The pane is used
**      to derive everything else we need.
** Formal Parameters:
**   XMWidget *pane:
**     A drawing area widget into which to draw the pane.
**  win_attributed *at:
**    The attributes of the pane.
**  Boolean final:
**    True if the plot should be in final form... in which case we'll used
**    dashed lines, and non xor drawing.  Otherwise we'll use dotted lines
**    and Xor drawing.  If final is on, then labels can also be drawn.
*/
void grobj_sum1d::draw(XMWidget *pane, win_attributed *at, Boolean final)
{
  Display *d = XtDisplay(pane->getid());
  Window  win= XtWindow(pane->getid());
  Drawable pm= (Drawable)NULL;

  /* Determine if there's a backing store too.. we rely on the fact that
  ** the pane has encoded in it the widget index:
  */
  int index, row, col;
  pane->GetAttribute(XmNuserData, &index);
  col = index % WINDOW_MAXAXIS;
  row = index / WINDOW_MAXAXIS;
  pm  = Xamine_GetBackingStore(row, col);

  /* Next construct a converter for the drawing operation to convert
  ** channel coords into pixels. Since the object is a 1-d we're assured
  ** that we want a 1-d converter
  */
  Xamine_Convert1d cvt(pane, at, xamine_shared);
  
  /* Next figure out the remaining arguments for Xamine_DrawSumRegion
  ** These are flipped, labelit, and the graphical context.  labelit
  ** and the graphical context depend on the final argument
  */

  Boolean flipped = 
    at->isflipped();	/* Flipped however is just a spectrum attrib */

  Boolean labelit = False;
  if(final && at->showlbl()) 
    labelit = True;

  /* Finally construct the graphical context.  The line style depends on 
  ** the final argument... dashed if final otherwise solid
  ** as does function Set if final otherwise Xor
  */
  XamineGrobjGC *xgc = Xamine_GetGrobjGC(*pane);
  SetClipRegion(xgc, pane, at);
  xgc->Set1DColors(*pane);
  GC gc;
  if(final) {
    xgc->SetSumRegion();
  }
  else {
    xgc->SetProvisional();
  }
  gc = xgc->gc;

  /* Draw the lines.. n both the window and the pixmap (if present). */

  Xamine_DrawSumRegion(d, win, gc, pane, &cvt, flipped, labelit,
		       this);
  if(pm) {
    Xamine_DrawSumRegion(d, pm, gc, pane, &cvt, flipped, labelit,
			 this);
  }

}

/*
** Functional Description:
**   grobj_cut1d::draw:
**     Draws a 1-d cut on the current window pane.
** Formal Parameters:
**   XMWidget *pane:
**     The pane to draw on.
**   win_attriburted *at:
**     The attributes of the pane
**  Boolean Final:
**     True if the object should be drawn in final attributes.
*/
void grobj_cut1d::draw(XMWidget *pane, win_attributed *at, Boolean final)
{
  Display *d = XtDisplay(pane->getid());
  Window  win= XtWindow(pane->getid());
  Drawable pm= (Drawable)NULL;

  /* Determine if there's a backing store too.. we rely on the fact that
  ** the pane has encoded in it the widget index:
  */
  int index, row, col;
  pane->GetAttribute(XmNuserData, &index);
  col = index % WINDOW_MAXAXIS;
  row = index / WINDOW_MAXAXIS;
  pm  = Xamine_GetBackingStore(row, col);

  /* Next construct a converter for the drawing operation to convert
  ** channel coords into pixels. Since the object is a 1-d we're assured
  ** that we want a 1-d converter
  */
  Xamine_Convert1d cvt(pane, at, xamine_shared);
  
  /* Next figure out the remaining arguments for Xamine_DrawSumRegion
  ** These are flipped, labelit, and the graphical context.  labelit
  ** and the graphical context depend on the final argument
  */

  Boolean flipped = 
    at->isflipped();	/* Flipped however is just a spectrum attrib */

  Boolean labelit = False;
  if(final && at->showlbl()) 
    labelit = True;

  /* Finally construct the graphical context.  The line style depends on 
  ** the final argument... dashed if final otherwise solid
  ** as does function Set if final otherwise Xor
  */

  XamineGrobjGC *xgc = Xamine_GetGrobjGC(*pane);
  SetClipRegion(xgc, pane, at);
  xgc->Set1DColors(*pane);
  GC gc;
  if(final) {
    xgc->SetPermanent();
    
  }
  else {
    xgc->SetProvisional();
  }
  gc = xgc->gc;

  /* Draw the lines.. in both the window and the pixmap (if present). */

  Xamine_DisplayCut(d, win, gc, pane, &cvt, flipped, labelit, this);
  if(pm)
    Xamine_DisplayCut(d, pm, gc, pane, &cvt, flipped, labelit,this);
}


/*
** Functional Description:
**   grobj_mark1d:draw:
**     Method to draw a marker.  Final markers are drawn as filled
**     diamonds.  Tentative markers are drawn as dashed diamonds.
** Formal Parameters:
**   XMWidget *pane:
**     The pane to draw on.
**   win_attriburted *at:
**     The attributes of the pane
**  Boolean Final:
**     True if the object should be drawn in final attributes.
*/
void grobj_mark1d::draw(XMWidget *pane, win_attributed *at, Boolean final)
{
  Display *d = XtDisplay(pane->getid());
  Window  win= XtWindow(pane->getid());
  Drawable pm= (Drawable)NULL;

  /* Determine if there's a backing store too.. we rely on the fact that
  ** the pane has encoded in it the widget index:
  */
  int index, row, col;
  pane->GetAttribute(XmNuserData, &index);
  col = index % WINDOW_MAXAXIS;
  row = index / WINDOW_MAXAXIS;
  pm  = Xamine_GetBackingStore(row, col);

  /* Next construct a converter for the drawing operation to convert
  ** channel coords into pixels. Since the object is a 1-d we're assured
  ** that we want a 1-d converter
  */
  Xamine_Convert1d cvt(pane, at, xamine_shared);
  
  /* Next figure out the remaining arguments for Xamine_DrawSumRegion
  ** These are flipped, labelit, and the graphical context.  labelit
  ** and the graphical context depend on the final argument
  */

  Boolean labelit = False;
  if(final && at->showlbl()) 
    labelit = True;

  /* Finally construct the graphical context.  The line style depends on 
  ** the final argument... dashed if final otherwise solid
  ** as does function Set if final otherwise Xor
  */

  XamineGrobjGC *xgc = Xamine_GetGrobjGC(*pane);
  SetClipRegion(xgc, pane, at);
  xgc->Set1DColors(*pane);
  GC gc;
  if(final) {
    gc = xgc->gc;
    Xamine_PlotMarker(d, win, gc, pane, labelit, &cvt, this, at);
    if(pm)
      Xamine_PlotMarker(d,pm,gc, pane, labelit, &cvt, this, at);
  }
  else {
    grobj_point *pt = getpt(0);
    int x = pt->getx(),
        y = pt->gety();
    int sx,sy;
    
    cvt.SpecToScreen(&sx, &sy, x,y);
    xgc->SetProvisional();
    gc = xgc->gc;
    Xamine_DrawMarker(d, win, gc, sx, sy);
    if(pm)
      Xamine_DrawMarker(d, pm, gc, sx, sy);
  }
 
}

/*
** Functional Description:
**   grobj_contour::draw:
**     This method tells a contour to draw itself in either accepted or
**     tentative form.
** Formal Parameters:
**     XMWidget *pane:
**        Pane in which the contour should draw.
**     win_attributed *at:
**        Attributes of the pane.
**     Boolean final:
**        True if to draw in final form or not.
*/
void grobj_contour::draw(XMWidget *pane, win_attributed *at, Boolean final)
{
  Display *d = XtDisplay(pane->getid());
  Window  win= XtWindow(pane->getid());
  Drawable pm= (Drawable)NULL;

  /* Determine if there's a backing store too.. we rely on the fact that
  ** the pane has encoded in it the widget index:
  */
  int index, row, col;
  pane->GetAttribute(XmNuserData, &index);
  col = index % WINDOW_MAXAXIS;
  row = index / WINDOW_MAXAXIS;
  pm  = Xamine_GetBackingStore(row, col);

  /* Next construct a converter for the drawing operation to convert
  ** channel coords into pixels. Since the object is a 1-d we're assured
  ** that we want a 1-d converter
  */
  Xamine_Convert2d cvt(pane, at, xamine_shared);
  
  /* Next figure out the remaining arguments for Xamine_DrawSumRegion
  ** These are flipped, labelit, and the graphical context.  labelit
  ** and the graphical context depend on the final argument
  */

  Boolean flipped = 
    at->isflipped();	/* Flipped however is just a spectrum attrib */

  Boolean labelit = False;
  if(final && at->showlbl()) 
    labelit = True;

  /* Finally construct the graphical context.  The line style depends on 
  ** the final argument... dashed if final otherwise solid
  ** as does function Set if final otherwise Xor
  */

  XamineGrobjGC *xgc = Xamine_GetGrobjGC(*pane);
  SetClipRegion(xgc, pane, at);
  xgc->Set2DColors(*pane);
  GC gc = xgc->gc;
  if(final) {
    xgc->SetPermanent();
  }
  else {
    xgc->SetProvisional();

    /* Draw the x'es which mark the points */

    DrawXes(d,win,gc, &cvt, flipped,  this);
    if(pm)
      DrawXes(d,pm,gc, &cvt, flipped,  this);

  }
  Xamine_DisplayContour(d, win, gc, pane, &cvt,
			flipped, labelit, this);
  if(pm)
    Xamine_DisplayContour(d,pm,gc, pane, &cvt,
			  flipped, labelit, this);

}


/*
** Functional Description:
**     grobj_band::draw:
**        This function tells the object to draw itself.
**        The object can either be drawn tentatively (with XOR attributes and
**        dashed lines) or it can be drawn finally with solid lines and
**        XOR attributes.
** Formal Parameters:
**    XMWidget *pane:
**      The pane to draw in.
**    win_attributed *at:
**      Pane rendering attributes
**    Boolean final:
**      True if to be drawn in final form.
*/
void grobj_band::draw(XMWidget *pane, win_attributed *at, Boolean final)
{
  Display *d = XtDisplay(pane->getid());
  Window  win= XtWindow(pane->getid());
  Drawable pm= (Drawable)NULL;

  /* Determine if there's a backing store too.. we rely on the fact that
  ** the pane has encoded in it the widget index:
  */
  int index, row, col;
  pane->GetAttribute(XmNuserData, &index);
  col = index % WINDOW_MAXAXIS;
  row = index / WINDOW_MAXAXIS;
  pm  = Xamine_GetBackingStore(row, col);

  /* Next construct a converter for the drawing operation to convert
  ** channel coords into pixels. Since the object is a 1-d we're assured
  ** that we want a 1-d converter
  */
  Xamine_Convert2d cvt(pane, at, xamine_shared);
  
  /* Next figure out the remaining arguments for Xamine_DrawSumRegion
  ** These are flipped, labelit, and the graphical context.  labelit
  ** and the graphical context depend on the final argument
  */

  Boolean flipped = 
    at->isflipped();	/* Flipped however is just a spectrum attrib */

  Boolean labelit = False;
  if(final && at->showlbl()) 
    labelit = True;

  /* Finally construct the graphical context.  The line style depends on 
  ** the final argument... dashed if final otherwise solid
  ** as does function Set if final otherwise Xor
  */

  XamineGrobjGC *xgc = Xamine_GetGrobjGC(*pane);
  SetClipRegion(xgc, pane, at);
  xgc->Set2DColors(*pane);
  GC gc = xgc->gc;
  if(final) {
    xgc->SetPermanent();
  }
  else {
    xgc->SetProvisional();


    /* Draw the x'es which mark the points */

    DrawXes(d,win,gc, &cvt, flipped,  this);
    if(pm)
      DrawXes(d,pm,gc, &cvt, flipped,  this);

  }
  Xamine_DisplayBand(d, win, gc, pane, &cvt,
			flipped, labelit, this);
  if(pm)
    Xamine_DisplayBand(d,pm,gc, pane, &cvt,
			  flipped, labelit, this);

}

/*
** Functional Description:
**   grobj_sum2d:draw:
**     This method tells a summing region to draw itself into a pane.
** Formal Parameters:
**   XMWidget *pane:
**     The pane into which we should draw ourselves.
**   win_attributed *at:
**     The attributes of the pane.
**   Boolena final:
**     True if the object is being drawn in final form.
*/
void grobj_sum2d::draw(XMWidget *pane, win_attributed *at, Boolean final)
{
  Display *d = XtDisplay(pane->getid());
  Window  win= XtWindow(pane->getid());
  Drawable pm= (Drawable)NULL;

  /* Determine if there's a backing store too.. we rely on the fact that
  ** the pane has encoded in it the widget index:
  */
  int index, row, col;
  pane->GetAttribute(XmNuserData, &index);
  col = index % WINDOW_MAXAXIS;
  row = index / WINDOW_MAXAXIS;
  pm  = Xamine_GetBackingStore(row, col);

  /* Next construct a converter for the drawing operation to convert
  ** channel coords into pixels. Since the object is a 1-d we're assured
  ** that we want a 1-d converter
  */
  Xamine_Convert2d cvt(pane, at, xamine_shared);
  
  /* Next figure out the remaining arguments for Xamine_DrawSumRegion
  ** These are flipped, labelit, and the graphical context.  labelit
  ** and the graphical context depend on the final argument
  */

  Boolean flipped = 
    at->isflipped();	/* Flipped however is just a spectrum attrib */

  Boolean labelit = False;
  if(final && at->showlbl()) 
    labelit = True;

  /* Finally construct the graphical context.  The line style depends on 
  ** the final argument... dashed if final otherwise solid
  ** as does function Set if final otherwise Xor
  */

  XamineGrobjGC *xgc = Xamine_GetGrobjGC(*pane);
  SetClipRegion(xgc, pane, at);
  xgc->Set2DColors(*pane);
  GC gc = xgc->gc;
  if(final) {

    /* Need to set dashed lines: */

    xgc->SetSumRegion();
  }
  else {
    xgc->SetProvisional();


    /* Draw the x'es which mark the points */

    DrawXes(d,win,gc, &cvt, flipped,  this);
    if(pm)
      DrawXes(d,pm,gc, &cvt, flipped,  this);


  }
  Xamine_DrawSumRegion(d, win, gc, pane, &cvt,
			flipped, labelit, this);
  if(pm)
    Xamine_DrawSumRegion(d,pm,gc, pane, &cvt,
			 flipped, labelit, this);
}

/*
** Functional Description:
**   grobj_mark2d::draw:
**     Tells the marker to draw itself in a given pane.
**  Formal Parameters:
**     XMWidget *pane:
**       The pane into which the marker should be drawn.
**     win_attributed *at:
**       The pane drawing attributes.
**     Boolean final:
**       True if we're to draw the marker in final form.
*/
void grobj_mark2d::draw(XMWidget *pane, win_attributed *at, Boolean final)
{
  Display *d = XtDisplay(pane->getid());
  Window  win= XtWindow(pane->getid());
  Drawable pm= (Drawable)NULL;

  /* Determine if there's a backing store too.. we rely on the fact that
  ** the pane has encoded in it the widget index:
  */
  int index, row, col;
  pane->GetAttribute(XmNuserData, &index);
  col = index % WINDOW_MAXAXIS;
  row = index / WINDOW_MAXAXIS;
  pm  = Xamine_GetBackingStore(row, col);

  /* Next construct a converter for the drawing operation to convert
  ** channel coords into pixels. Since the object is a 1-d we're assured
  ** that we want a 1-d converter
  */
  Xamine_Convert2d cvt(pane, at, xamine_shared);
  
  /* Next figure out the remaining arguments for Xamine_DrawSumRegion
  ** These are flipped, labelit, and the graphical context.  labelit
  ** and the graphical context depend on the final argument
  */

  Boolean flipped = 
    at->isflipped();	/* Flipped however is just a spectrum attrib */

  Boolean labelit = False;
  if(final && at->showlbl()) 
    labelit = True;

  /* Finally construct the graphical context.  The line style depends on 
  ** the final argument... dashed if final otherwise solid
  ** as does function Set if final otherwise Xor
  */

  XamineGrobjGC *xgc = Xamine_GetGrobjGC(*pane);
  SetClipRegion(xgc, pane, at);
  xgc->Set2DColors(*pane);
  GC gc = xgc->gc;
  if(final) {
    xgc->SetPermanent();

    Xamine_PlotMarker(d, win, gc, pane, labelit, &cvt, this, at);
    if(pm)
      Xamine_PlotMarker(d,pm,gc, pane, labelit, &cvt, this, at);
  }
  else {
    xgc->SetProvisional();
    grobj_point *pt = getpt(0);
    int x = pt->getx(),
        y = pt->gety();
    if(flipped) {
      int t = x;
      x = y;
      y = t;
    }
    int sx,sy;
    
    cvt.SpecToScreen(&sx, &sy, x,y);
    Xamine_DrawMarker(d, win, gc, sx, sy);
    if(pm)
      Xamine_DrawMarker(d, pm, gc, sx, sy);
  }

}

/*
** Functions on the following pages are methods for the grobj_ptlist1 class.
** A grobj_ptlist1 is used to keep track of the points being accepted by a
** user point list.  It is convenient to use a grobj like object to do this
** since all of the plotting routines etc. are formulated with grobj in mind.
** User point lists are essentially temporary graphical objects anyway.
** grobj_ptlist1 is used for 1-d point lists.  See also grobj_ptlist2 used for
** 2-d point lists.
*/


/*
** Functional Description:
**   grobj_ptlist1::addpt:
**     adds a point to the end of a point list.
** Formal Parameters:
**   int x:
**     The x coordinate of the new point (channel number).
**     The y coordinate of the new point (counts if supplied).
** Returns:
**   0    - If failed (e.g. too many points) 
**  npts  - Number of points in the point list.
*/

int grobj_ptlist1::addpt(int x, int y)
{
  if(pointcount() >= maxpts)
    return 0;
  else
    return grobj_generic::addpt(x, y);
}   


/*
** Functional Description:
**   grobj_ptlist1::insertpt:
**     Insert a point at an arbitrary position of the point list.
** Formal Parameters:
**   int loc:
**     Location of inserted point.
**   int x,y:
**     Coordinates of the inserted point (channels, counts).
** Returns:
**   0  - If failed (e.g. too many points... or too few)
**  npts- Number of points in the new point list.
*/

int grobj_ptlist1::insertpt(int loc, int x, int y)
{
  if(pointcount() >= maxpts)
    return 0;
  else
    return grobj_generic::insertpt(loc, x, y);
}   


/*
** Functional Description:
**   grobj_ptlist1::clone:
**     Cones an instance of a point list for a 1-d spectrum.
** Returns:
**   pointer to the new point list which must be delete'd when no longer
**   needed.
*/

grobj_generic *grobj_ptlist1::clone()
{
  grobj_ptlist1 *pl = new grobj_ptlist1(maxpts);
  *pl       = *this;
  return (grobj_generic *)pl;

}   


/*
** Functional Description:
**   grobj_ptlist1::draw:
**     This function draws a point list on a widget which is assumed to be
**     a drawing area widget.  The points are drawn as little plus symbols to
**     distinguish them from Xamine's X points... although X points are not
**     used in 1-d grobj's.   We use +'s to preserve the height information
**     of the grobj points.
** Formal Parameters:
**   XMWidget *p:
**     The widget in which to draw.
**   win_attributed *at:
**     The window attributes list.
**   Boolean final:
**     True if drawing the final version... note there is no final version
**     for point lists, so this argument is ignored.
*/

void grobj_ptlist1::draw(XMWidget *p, win_attributed *at, Boolean final)
{
  Display   *d = XtDisplay(p->getid());
  Window   win = XtWindow(p->getid());
  Drawable  pm = (Drawable)NULL; // Possible backing pixmap.

  /*  If the pane has a backing pixmap, then we want to draw into that too
  **  so that if the window is contaiminated while accepting points, the 
  **  partial point set will be visible.
  */
  int index, row, col;
  p->GetAttribute(XmNuserData, &index); // This is the pane number.
  row = index % WINDOW_MAXAXIS;
  col = index / WINDOW_MAXAXIS;
  pm  = Xamine_GetBackingStore(row, col);

  /*
  ** Construct a coordinate converter.  It's a 1-d converter since
  ** we're drawing in a 1-d pane.
  */

  Xamine_Convert1d cvt(p, at, xamine_shared);
  
  /* Now we need to figure out the remaining argument for DrawPlusses:
  */

  Boolean flipped = at->isflipped();

  /* We always create tentative graphical contexts: */

  XamineGrobjGC *xgc = Xamine_GetGrobjGC(*p);
  SetClipRegion(xgc, p,at);
  xgc->Set1DColors(*p);
  xgc->SetProvisional();
  GC gc = xgc->gc;

  /* Draw the plusses which mark the point:  */

  DrawPlusses(d, win, gc, &cvt, flipped, this);
  if(pm)
    DrawPlusses(d, pm, gc, &cvt, flipped, this);

}   


/*
**  The pages which follow contain method functions for the grahpical
**  object grobj_ptlist2.  Thist type of grahpical object is used to 
**  store a point list that is being accumulated for a client button request
**  prompter in a 2-d spectrum pane.  See also grobj_ptlist2 above.
*/


/*
** Functional Description:
**   grobj_ptlist2::addpt:
**     adds a point to the end of a point list.
** Formal Parameters:
**   int x:
**     The x coordinate of the new point (channel number).
**     The y coordinate of the new point (counts if supplied).
** Returns:
**   0    - If failed (e.g. too many points) 
**  npts  - Number of points in the point list.
*/

int grobj_ptlist2::addpt(int x, int y)
{
  if(pointcount() >= maxpts)
    return 0;
  else
    return grobj_generic::addpt(x, y);
}   


/*
** Functional Description:
**   grobj_ptlist2::insertpt:
**     Insert a point at an arbitrary position of the point list.
** Formal Parameters:
**   int loc:
**     Location of inserted point.
**   int x,y:
**     Coordinates of the inserted point (channels, counts).
** Returns:
**   0  - If failed (e.g. too many points... or too few)
**  npts- Number of points in the new point list.
*/

int grobj_ptlist2::insertpt(int loc, int x, int y)
{
  if(pointcount() >= maxpts)
    return 0;
  else
    return grobj_generic::insertpt(loc, x, y);
}   


/*
** Functional Description:
**   grobj_ptlist2::clone:
**     Clones an instance of a point list for a 1-d spectrum.
** Returns:
**   pointer to the new point list which must be delete'd when no longer
**   needed.
*/

grobj_generic *grobj_ptlist2::clone()
{

  grobj_ptlist2 *pl = new grobj_ptlist2(maxpts);
  *pl = *this;
  return (grobj_generic *)pl;
}   


/*
** Functional Description:
**   grobj_ptlist2::draw:
**     This function draws a point list on a widget which is assumed to be
**     a drawing area widget.  The points are drawn as little plus symbols to
**     distinguish them from Xamine's X points... although X points are not
**     used in 1-d grobj's.   We use +'s to preserve the height information
**     of the grobj points.
** Formal Parameters:
**   XMWidget *p:
**     The widget in which to draw.
**   win_attributed *at:
**     The window attributes list.
**   Boolean final:
**     True if drawing the final version... note there is no final version
**     for point lists, so this argument is ignored.
*/

void grobj_ptlist2::draw(XMWidget *p, win_attributed *at, Boolean final)
{
  Display   *d = XtDisplay(p->getid());
  Window   win = XtWindow(p->getid());
  Drawable  pm = (Drawable)NULL; // Possible backing pixmap.

  /*  If the pane has a backing pixmap, then we want to draw into that too
  **  so that if the window is contaiminated while accepting points, the 
  **  partial point set will be visible.
  */
  int index, row, col;
  p->GetAttribute(XmNuserData, &index); // This is the pane number.
  row = index % WINDOW_MAXAXIS;
  col = index / WINDOW_MAXAXIS;
  pm  = Xamine_GetBackingStore(row, col);

  /*
  ** Construct a coordinate converter.  It's a 1-d converter since
  ** we're drawing in a 1-d pane.
  */

  Xamine_Convert2d cvt(p, at, xamine_shared);
  
  /* Now we need to figure out the remaining argument for DrawPlusses:
  */

  Boolean flipped = at->isflipped();

  /* We always create tentative graphical contexts: */

  XamineGrobjGC *xgc = Xamine_GetGrobjGC(*p);
  SetClipRegion(xgc, p, at);
  xgc->Set2DColors(*p);
  xgc->SetProvisional();
  GC gc = xgc->gc;

  /* Draw the plusses which mark the point:  */

  DrawPlusses(d, win, gc, &cvt, flipped, this);
  if(pm)
    DrawPlusses(d, pm, gc, &cvt, flipped, this);

}   

//////////////////////////////////////////////////////////////////////
// The methods below implement the grobj_Peak1d class.  That class is 
// responsible for maintaining and displaying 1-d peak objects on a
// spectrum.
//
// Functional Description:
//    grobj_Peak1d:
//          Constructs a 1d peak graphical object.
// Formal Parameters:
//    int nSpectrum:
//          Identifies the spectrum on which the object is applied.
//    int nId:
//          A unique Identifying number which the client can use to refer to
//          the object.  This is the number which is also displayed when the
//          labels are turned on.
//    grobj_name pszName:
//          Points to a name/comment string which is associated with the grobj.
//          The INFO button or menu entry will display this text as the comment
//          field for the object.
//    float fCentroid:
//          The centroid of the peak being identified.
//    float fWidth:
//          The width of the peak being identifies.
//  NOTE:
//      The point list is not used by this graphical object... yet another
//      reason to make it a dynamic (e.g. STL) list.
//
grobj_Peak1d::grobj_Peak1d(int nSpectrum,
			   int nId,
			   grobj_name pszName,
			   float fCentroid,
			   float fWidth) :
  grobj_generic(), 
  m_fFWHM(fWidth), 
  m_fPosition(fCentroid)
{
  setspectrum(nSpectrum);
  setid(nId);
  if(name != NULL) {
    setname(pszName);
  }
}
//
// Functional Description:
//   draw:
//     This member function draws the object on a window of the Xamine display.
// Formal Parameters:
//    XMWidget* pWindow:
//           Pointer to the widget containing the window in which the object
//           should be drawn.
//    win_attributed* pAttributes:
//           Pointer to the window attributes block which specifies display
//           attributes/modifications for the spectra.
//    Boolean fFinal:
//           True if the draw is for a final grobj, rather than a tentative
//           one.  There are no tentative peak markers, so this parameter is
//           ignored.
//
void grobj_Peak1d::draw(XMWidget* pWindow,
			win_attributed* pAttributes,
			Boolean fFinal)
{
  Display*  d = XtDisplay(pWindow->getid());
  Window  win = XtWindow(pWindow->getid());
  Drawable pm = (Drawable)NULL;

  // If there's a pixmap to accelerate refresh, then get it into pm.
  // we rely on the fact that the pane widget has the pane number in it's
  // user data field:

  int index, row, col;
  pWindow->GetAttribute(XmNuserData, &index);
  col = index % WINDOW_MAXAXIS;
  row = index / WINDOW_MAXAXIS;
  pm  = Xamine_GetBackingStore(row, col);

  // We need a converter to convert the spectrum coordinates of the centroid
  // and width as well as heights into pixels.  The underlying spectrum is
  // gaurenteed to be 1d:

  Xamine_Convert1d cvt(pWindow, pAttributes, xamine_shared);
  cvt.NoClip();

  // Extract the flip and label flag fromt the spectrum attributes:

  Boolean flipped = pAttributes->isflipped();
  Boolean labelit = pAttributes->showlbl();

  // Create a graphical context which will be used for the drawing.

  XamineGrobjGC *xgc = Xamine_GetGrobjGC(*pWindow);
  SetClipRegion(xgc, pWindow, pAttributes);
  xgc->Set1DColors(*pWindow);
  xgc->SetPermanent();
  GC gc = xgc->gc;

  // Now we draw the peak position.  Since this is a new grobj type and we
  // don't have to recycle old code. the draw is done here.  We do have some
  // helper functions.  The helpers determine in spectrum coordinates 
  // (floating) how high the horizontal line is, and where and how high the
  // vertical lines are to be drawn.  These are expressed in terms of 
  // channel value percentages, to ensure that the object will 'float' above
  // the peak.  This also allows the peak marked while spectra are still
  // incrementing.

  unsigned nBarHeight = ComputeHeight(m_fPosition); // Height of horizontal bar
  float fBarLeft   = m_fPosition  - m_fFWHM/2.0;   // left bound of peak.
  if(fBarLeft < 0.0) fBarLeft = 0;                  // For peaks close to edge.
  float fBarRight  = m_fPosition + m_fFWHM/2.0;   // right bound of peak.
  if(fBarRight >= (float)xamine_shared->getxdim(getspectrum()))
    fBarRight = (float)xamine_shared->getxdim(getspectrum())-1.0;
  unsigned nDropLeft  = ComputeBarHeight(fBarLeft);  // Where to drop left bar.
  unsigned nDropRight = ComputeBarHeight(fBarRight); // Where to drop right bar.
  unsigned nPeakDelta = ComputeDeltaHeight(m_fPosition); // Center spike height.
  
  //
  //  Convert the channel coordinates to pixels... including interpolation.
  //
  short npBarLeft;		// Pixel coordinates of left part of bar.
  short npBarLBottom;		// Pixel coords of bottom of Left bar.
  short npBarHeight;		// Pixel coords of top of bar.
  short npBarRight;		// Pixel coords of right of bar.
  short npBarRBottom;		// Pixel coords of bottom of right bar
  short npPeakHt;			// Pixel coords of peak spike.
  short npBarMid;			// Middle of the bar.
  short npUnused;

  // Figure out all the points we need to draw:
  //
  ComputeLocation(cvt, fBarLeft, nDropLeft, npBarLeft, npBarLBottom);
  if(flipped) Swap(npBarLeft, npBarLBottom);
  ComputeLocation(cvt, 0.0,      nBarHeight, npUnused, npBarHeight);
  if(flipped) npBarHeight = npUnused;
  ComputeLocation(cvt, fBarRight, nDropRight, npBarRight, npBarRBottom);
  if(flipped) Swap(npBarRight, npBarRBottom);
  ComputeLocation(cvt, m_fPosition, nPeakDelta,
		  npBarMid, npPeakHt);
  if(flipped) Swap(npBarMid, npPeakHt);

  XSegmentBatch XSPeak(d, win, gc);  // Polyline for drawing the peak.
  DrawMarker(XSPeak, flipped,
	     npBarLeft, npBarLBottom, npBarHeight, 
	     npBarRight, npBarRBottom,
	     npBarMid, npPeakHt);
  char label[10];
  sprintf(label, "P%d", getid());
  if(labelit) Xamine_LabelGrobj(d, win, gc, pWindow,
				label,
				flipped ? npBarHeight : npBarMid, 
				flipped ? npBarMid    : npBarHeight);

  // If there's a pixmap, we need to draw into it too:

  if(pm) {
    XSegmentBatch XSpmPeak(d, pm, gc);
    DrawMarker(XSpmPeak, flipped,
	       npBarLeft, npBarLBottom, npBarHeight, 
	       npBarRight, npBarRBottom,
	       npBarMid, npPeakHt);
    if(labelit) {
      Xamine_LabelGrobj(d, pm, gc, pWindow,
			label,
			flipped ? npBarHeight : npBarMid, 
			flipped ? npBarMid    : npBarHeight);

    }
  }

}

//
// Functional Description:
//    clone:
//      This function produces a copy of *this.  
//      The copy is dynamically allocated, so it's the
//      caller's responsibility to:
//      a. Delete when done.
//      b. Modify the id or spectrum number as appropriate.
//      c. Modify the comment if appropriate.
//  Returns:
//     Pointer to the clone of the grobj cast to grobj_generic*
//
grobj_generic*
grobj_Peak1d::clone()
{
  grobj_name    name;
  grobj_Peak1d* copy = new grobj_Peak1d(getspectrum(),
					getid(), 
					getname(name),
					m_fPosition,
					m_fFWHM);
  return (grobj_generic*)copy;
}
// Functional Description:
//    grobj_Peak1d::DrawMarker
//       Draws the peak marker and if necesary places a label on the marker.
//     The object is drawn to look like the picture below:
//
//                    |
//              +----[l]-----+
//              |           |
//              |           |
//              |           |
//
//     The vertical bars are m_fWidth channels apart, and extend down to
//     a bit above the height of the spectrum at that width.  The middle bar
//     is at the centroid and extends downward to just a bit above the peak.
//     The label, if enabled, is placed at the intersection of the middle bar
//     and the horizontal bar.
//
//     The lable will be placed at the intersection of the horizontal bar and
//     the vertical peak marker; [l] in the figure above..
//
// Formal Parameters:
//    XSegmentBatch &XSseg:
//       A reference to an X-11 polyline segment which will be used to draw
//       the marker.
//    Boolean flipped:
//        True if coordinate swap in force.
//    short npLeft, npLBottom:
//        Coordinates of the bottom right corner of the bar marker.
//    short npHeight:
//        Height of the horizontal bar.
//    short npRight, npRBottom:
//        Coordinates of the Lowr right corner of the bar marker.
//    short npMid:
//        X coordinate of the bar midpoint.
//    short npPeakht:
//        Y coordinate of the top of the peak center marker.
//
void
grobj_Peak1d::DrawMarker(XSegmentBatch &XSseg, Boolean flipped,
			 short npLeft, short npLBottom,
			 short npHeight, 
			 short npRight, short npRBottom,
			 short npMid, 
			 short npPeakht)
{
  if(flipped) {
    XSseg.draw(npLBottom, npLeft, npHeight, npLeft);   // Bottom horiz. bar.
    XSseg.draw(npHeight,  npLeft, npHeight, npRight);  // Vertical bar.
    XSseg.draw(npRBottom, npRight, npHeight, npRight); // Top horiz. bar.
    XSseg.draw(npHeight,  npMid,   npPeakht, npMid);   // Peak horiz bar.
    
  }
  else {
    XSseg.draw(npLeft, npLBottom, npLeft, npHeight);   // Left vertical bar.
    XSseg.draw(npLeft, npHeight, npRight, npHeight);   // Horizontal bar.
    XSseg.draw(npRight, npRBottom, npRight, npHeight); // Right vertical bar.
    XSseg.draw(npMid, npHeight, npMid, npPeakht);      // center vertical bar.
  }

}
//
//  Functional Description:
//     grobj_Peak1d::ComputeHeight
//       This function accepts a floating point channel number and determines
//       an appropriate height for a horizontal bar.
//       The bar is placed at a fixed percentage above the
//       spectrum.  In order to ensure that the bar is above the spectrum
//       regardless of the representation (remember connect the dots mode), we
//       use linear interpolation to figure out a 'virtual' spectrum height at
//       the position of the bar.
// Formal Parameters:
//     float fChan:
//       Floating point spectrum coordinates of the bar.
// Returns:
//       Integer height in counts describing where the bar should
//       go.
//
unsigned 
grobj_Peak1d::ComputeHeight(float fChan)
{
  // Need to get the height of the two channels above and below fChan They'll
  // be put into fLowh and fHih

  int nLow = (int) fChan;	// These are the limits of the interpolation.
  int nHi  = (int) (fChan + 1.0);
  int nSpec= getspectrum();     // Number of spectrum on which we're set.
  float fLowh= (float)xamine_shared->getchannel(nSpec, nLow);
  float fHih = (float)xamine_shared->getchannel(nSpec, nHi);

  // Now figure out the height at fChan via linear interpolation.
  
  float fFrac = (fChan - (float)nLow); // 1 channel span so this is easy.
  unsigned   nHt   = (unsigned)(fLowh + fFrac * (fHih - fLowh));

  // The proper height is GROBJ_MINDIST*nHt above nHt, but at least one count.

  int nDelta = (unsigned)((GROBJ_MINDIST)*(float)nHt);
  if(nDelta == 0) nDelta = 1;

  return( nHt + nDelta);

}
//
// Functional Description:
//   grobj_Peak1d::ComputeBarHeight:
//     This computes the clearance a vertical bar has.. For now, that's the 
//     same as ComputeHeight:
// Formal Parameters:
//    float fChan:
//      Where the bar is.
// Returns:
//   int height in counts at which bar bottom is:
//
unsigned 
grobj_Peak1d::ComputeBarHeight(float fChan)
{
  return ComputeHeight(fChan);
}
//
// Functional Description:
//   grobj_Peak1d::ComputeDeltaHeight:
//     Determines how tall the peak marker vertical bar should be.
//     We want it to be visible regardless of the height of the peak, or the
//     display scaling (log/linear). 100*peak ht. should be sufficient.
// Formal Parameters:
//    float fChan:
//      Channel at which we want the height.  We pass this in in case later
//      we want to try to be more clever about setting the height of this
//      bar.
// Returns:
//      The height of the top of the peak bar.
//
unsigned 
grobj_Peak1d::ComputeDeltaHeight(float fChan)
{
  return (unsigned)ComputeHeight(fChan)*100;
}
//
// Functional Description:
//   grobj_Peak1d::ComputeLocation:
//     This function computes the location in pixels of a point consisting of
//     a floating point channel number and an unsigned height.
// Formal Parameters:
//   Xamine_Convert1d &cvt:
//     Refers to the conversion block which determines the mapping of pixels to
//     spectrum coordinates.
//   float fchannel:
//     Floating point channel number.
//   unsigned height:
//     Number of counts of the point.
//   short &xpix, &ypix:
//     Output of the function... the pixel coords.
//
void 
grobj_Peak1d::ComputeLocation(Xamine_Convert1d& cvt,
			      float fChannel, unsigned nCounts,
			      short& xpix, short& ypix)
{
  //
  // The conversion procedes in two steps.  The first step gets the
  // pixel coordinates for (int)fChannel and (int)fChannel+1 
  // (nCounts is fine with the first one).
  // The second step does a linear interpolation betweent he two x-pixel values
  // to determine the closest pixel to fChannel.
  //
  int xpix1, xpix2, yp;
  cvt.SpecToScreen(&xpix1, &yp, (int)fChannel, nCounts);
  cvt.SpecToScreen(&xpix2, &yp, (int)(fChannel) + 1, nCounts);
  ypix = (short)yp;		// We're all set on the height...

  // Do the interpolation:

  xpix1 += (int)((fChannel - (float((int)fChannel))) * (float)(xpix2 - xpix1));
  xpix  = (short)xpix1;
}







