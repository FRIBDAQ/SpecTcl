<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">

<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<title>SpecTcl's handling of event data</title>
</head>

<body>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
    <tr>
        <th width="9%" nowrap><a href="http://www.nscl.msu.edu"><img
        src="../images/nscl_logo_small.gif"
        alt="nscl_logo_small.gif (2463 bytes)" width="63"
        height="52"></a></th>
        <td width="79%"><h1>SpecTcl's handling of Event Data</h1>
        </td>
        <td width="12%"><a href="../index.htm"><img
        src="../images/hh00706_.jpg"
        alt="HH00706_.wmf (6530 bytes)" width="192" height="84"></a></td>
    </tr>
</table>

<p><a href="../index.htm" name="Top">SpecTcl Home</a>&nbsp; <a
href="../general_information.htm">General Information</a> <a
href="../users_guide.htm">User Guide</a> <a
href="../programmers_guide.htm">Programmer's Guide</a> <a
href="../obtaining_and_installing.htm">Obtaining and Installing</a></p>

<p><a href="tailoring.htm">Tailoring SpecTcl</a></p>

<h1>Page Contents:</h1>

<ul>
    <li><a href="#Classes">Discussion of the relevant classes.</a></li>
    <li><a href="#Writing Event Processors">Writing event processors.</a></li>
    <li><a href="#Filling in the application class">Filling in the application
      class.</a></li>
</ul>

<h1><a name="Classes">The Classes:</a></h1>

<p>The figure below shows the set of classes which interact to
analyze data in SpecTcl.</p>

<p><img border="0" src="images/spectc1.jpg" width="583" height="667"></p>

<p>To build a tailored version of SpecTcl you will need to understand aspects of
the following classes:</p>

<table border="0" width="100%">
  <tr>
    <td width="17%"><a href="#CEvent">CEvent</a></td>
    <td width="83%">The unpacked event adjustable array</td>
  </tr>
  <tr>
    <td width="17%"><a href="#CMySpecTclApp">CMySpecTclApp</a></td>
    <td width="83%">Your derivation of the application base class</td>
  </tr>
  <tr>
    <td width="17%"><a href="#CEventProcessor">CEventProcessor</a></td>
    <td width="83%">Event processors you derive from and register on the
      analyzer.</td>
  </tr>
</table>

<h2><a name="CEvent"></a>The CEvent adjustable array</h2>

<p>The CEvent class represents an unpacked event.&nbsp; The histogramming kernel
of SpecTcl takes parameters from CEvent objects and histograms them according to
the parameters, histograms and gate applications defined by your Tcl
scripts.&nbsp; The job of analyzing the event stream consists of taking the incoming
event stream apart and filling in a CEvent array with the parameters relevant to
the event.</p>

<h2><a name="CMySpecTclApp"></a>The CMySpecTclApp application class/object</h2>

<p>There is one object in the system of type CMySpecTclApp.&nbsp; This object
uses its base class functionality to initialize SpecTcl and to set up the
linkages between the interacting objects which make up a&nbsp; SpecTcl.&nbsp;
CMySpecTclApp is is implemented in the MySpecTclApp.cpp file you receive in the
skeleton distribution.&nbsp; At a minimum, you must modify this class to
register event processors which understand the experimental data and what needs
to be done to it to create a filled in CEvent array.</p>

<h2><a name="CEventProcessor"></a>The CEventProcessor you derive event
processors from</h2>

<p>Event analysis in SpecTcl takes the form of an analysis pipeline.&nbsp;
Elements in the pipeline are instances of classes derived from CEventProcessor.&nbsp;
Event processors are registered into the analyzer by the CMySpecTclApp object
through calls to its RegisterEventProcessor member function.&nbsp; Event
processors are executed in the order in which they were registered.&nbsp;
Usually, the first event processor will unpack the raw event into CEvent, and
subsequent element in the pipeline will process this unpacked event performing
e.g. calibrations, validation and physics.&nbsp; The results of subsequent
stages in the pipeline are modifications to unpacked parameters or the creation
of additional 'compiled' pseudo parameters which represent the event at a higher
level of abstraction/meaning.</p>

<p>Event processors may also reject the event by calling the analyzers
AbortEvent() member function.&nbsp; If the event is accepted, its size must be
set by some combination of calls to the analyzer's SetEventSize() and
IncrementEventSize() members.&nbsp; This size allows SpecTcl's analyzer to know
where to find the next event in the buffer so it must be 100% accurate.</p>

<p>The Skeleton software includes a 2-step pipeline.&nbsp; The first step
unpacks a fixed length event.&nbsp; The second step computes a single pseudo
parameter.&nbsp;</p>

<p><a href="#Top">Top</a> <a href="tailoring.htm">Tailoring SpecTcl</a></p>

<h1><a name="Writing Event Processors"></a>Writing Event Processors</h1>

<p>Event processors are called in sequence when each event is located in a
physics data buffer.&nbsp; The CEventProcesor member functions are described
below:</p>

<table border="1" width="100%">
  <tr>
    <td width="12%"><b>Returns</b></td>
    <td width="17%"><b>Name</b></td>
    <td width="27%"><b>Parameters</b></td>
    <td width="44%"><b>Does</b></td>
  </tr>
  <tr>
    <td width="12%">  virtual   Bool_t</td>
    <td width="17%"> OnAttach</td>
    <td width="27%">CAnalyzer&amp; rAnalyzer</td>
    <td width="44%">Any necessary processing when the event processor is
      registered into the analyzer.&nbsp; Returns kfFALSE on failure.</td>
  </tr>
  <tr>
    <td width="12%">  virtual   Bool_t&nbsp;</td>
    <td width="17%"> OnBegin&nbsp;</td>
    <td width="27%">CAnalyzer&amp; rAnalyzer,<br>
      CBufferDecoder&amp; rDecoder</td>
    <td width="44%">Called for a begin run buffer.&nbsp; If kfFALSE is returned,
      then the remainder of the pipeline is aborted.</td>
  </tr>
  <tr>
    <td width="12%">   virtual   Bool_t&nbsp;</td>
    <td width="17%"> OnEnd</td>
    <td width="27%">CAnalyzer&amp; rAnalyzer,&nbsp;<br>
                           CBufferDecoder&amp; rBuffer</td>
    <td width="44%">Called for an end run buffer.&nbsp; If kfFALSE is returned,
      then the remainder of the pipeline is aborted.</td>
  </tr>
  <tr>
    <td width="12%">  virtual   Bool_t</td>
    <td width="17%">&nbsp;OnPause</td>
    <td width="27%">CAnalyzer&amp; rAnalyzer,&nbsp;<br>
                            CBufferDecoder&amp; rDecoder</td>
    <td width="44%">Called for a pause run buffer.&nbsp; If kfFALSE is returned,
      then the remainder of the pipeline is aborted.</td>
  </tr>
  <tr>
    <td width="12%">  virtual   Bool_t</td>
    <td width="17%"> OnResume</td>
    <td width="27%">CAnalyzer&amp; rAnalyzer,&nbsp;<br>
                             CBufferDecoder&amp; rDecoder</td>
    <td width="44%">Called for a resume run buffer.&nbsp; If kfFALSE is
      returned, then the remainder of the pipeline is aborted.</td>
  </tr>
  <tr>
    <td width="12%">  virtual   Bool_t</td>
    <td width="17%"> operator()</td>
    <td width="27%">const Address_t pEvent,&nbsp;<br>
                               CEvent&amp; rEvent,&nbsp;<br>
                               CAnalyzer&amp; rAnalyzer,&nbsp;<br>
                               CBufferDecoder&amp; rDecoder)&nbsp;</td>
    <td width="44%">Called for each event in a physics buffer.&nbsp; At least
      one element in the pipeline must set the event by calling a combination of
      rAnalyzer.SetEventSize(UInt_t n) and<br>
      rAnalyzer.IncrementeventSize(UInt_t n=1)</td>
  </tr>
</table>
<h2><br>
Sample Event processor.</h2>

<p>The event processor definition below is part of the sample provided in the
skeleton.&nbsp; It unpacks fixed length events which are preceded by a self
inclusive word count.</p>

<pre>class CFixedEventUnpacker : public  CEventProcessor
{
public:
  virtual Bool_t operator()(const Address_t pEvent,             // Only need to override the unpacking
                            CEvent&amp;         rEvent,             // behavior.  All other members have
                            CAnalyzer&amp;      rAnalyzer,          // adequate default behavior.
                            CBufferDecoder&amp; rDecoder);
};
Bool_t
CFixedEventUnpacker::operator()(const Address_t pEvent,
                                CEvent&amp;         rEvent,
                                CAnalyzer&amp;      rAnalyzer,
                                CBufferDecoder&amp; rDecoder)
{

  // This sample unpacker unpacks a fixed length event which is
  // preceded by a word count.
  //
  CTclAnalyzer&amp;      rAna((CTclAnalyzer&amp;)rAnalyzer);           // needed to call CTclAnalyzer::SetEventSize()
  UShort_t* p      = (UShort_t*)pEvent;                        // The event is made up of UShort_t's.
  UShort_t  nWords = *p++;                                     // The first word of the evetn is its size.
  Int_t     i      = 1;                                        // This is the index of the CEvent of the first
                                                               //  parameter we fill in.

  // At least one member of the pipeline must tell the analyzer how
  // many bytes were in the raw event so it knows where to find the
  // next event.

  rAna.SetEventSize(nWords*sizeof(UShort_t));                  // Set event size.  In Bytes!!!!

  nWords--;                                                    // The word count is self inclusive.

  while(nWords) {               
    rEvent[i] = *p++;                                          // Unpack into the event array.
    nWords--;
    i++;
  }
  return kfTRUE;                                               // kfFALSE would abort pipeline.
}

</pre>

<p><a href="#Top">Top</a> <a href="tailoring.htm">Tailoring SpecTcl</a></p>

<h1><a name="Filling in the application class"></a>Filling in the Application
Class</h1>

<p>The CTclApplicationClass must be filled in and instantiated to complete
SpecTcl initialization. At a minimum, one EventProcessor must be registered into
the event pipeline.&nbsp; This section will describe all of the member functions
in the CTclApplication class, when they are called,&nbsp; what they should do
and what the parent's class default behavior is.</p>

<p><a href="#Top">Top</a> <a href="tailoring.htm">Tailoring SpecTcl</a></p>

<p><b>virtual void CreateAnalysisPipeline(CAnalyzer&amp; rAnalyzer)</b></p>

<p>This function is the only one which absolutely has to be coded by you.&nbsp;
All of the others could, in simple cases be left to their default behavior. This
function is the next to the last action performed by the application
initialization.&nbsp; The last action is to source any action scripts that the
user requests (call to SourceFunctionalScripts).&nbsp; By this time essentially
all of SpecTcl is set up.</p>

<p>The programmer must register the event processors which make up the analysis
pipeline.&nbsp; For example:</p>

<pre>static CFixedEventUnpacker Stage1;
static CAddFirst2          Stage2;
...
void 
CMySpecTclApp::CreateAnalysisPipeline(CAnalyzer&amp; rAnalyzer)  
{ 
  RegisterEventProcessor(Stage1);
  RegisterEventProcessor(Stage2);
}  
</pre>

<p>The example above declares two event processors, <i>Stage1&nbsp;</i> and <i>Stage2</i>
and registers them in the analysis pipeline.</p>

<p><a href="#Top">Top</a> <a href="tailoring.htm">Tailoring SpecTcl</a></p>

<p><b>virtual void BindTCLVariables(CTCLInterpreter&amp; rInterp)</b></p>

<p>This function is called at the beginning of MySpecTclApp's initialization.
Any tcl variables the user needs can be bound at this time to CTCLVariable
objects.&nbsp; The default behavior is to call CTclGrammerApp::BindTCLVariables()
to bind the variables which SpecTcl uses to set limits on statically allocated
resources (such as DisplayMegabytes), or initial sizes of dynamically allocated
resources (such as ParameterCount).</p>

<p>You may <i>extend</i> the default functionality by adding your own
code..&nbsp; You <i>must not</i> remove the call to
CTclGrammerApp::BindTCLVariables() and expect SpecTcl to work.</p>

<p><a href="#Top">Top</a> <a href="tailoring.htm">Tailoring SpecTcl</a></p>

<p><b>virtual void SourceLimitScripts(CTCLInterpreter&amp; rInterpreter)</b></p>

<p>This function is called right after BindTCLVariables.&nbsp; It is intended to
source scripts which set variable values needed by SpecTcl or your
extensions.&nbsp; By default, this function calls
CTclGrammerApp::SourceLimitScripts() which executes SpecTclInit.tcl&nbsp;&nbsp;
first in the SpecTcl distribution area adn then in your home directory if it
exists.</p>

<p><a href="#Top">Top</a> <a href="tailoring.htm">Tailoring SpecTcl</a></p>

<p><b>void SetLimits()</b></p>

<p>Called after SourceLimitScripts.&nbsp; By now it is assumed that any tcl
variables involved in static limit setting will have been bound (BindTclVariables)
and initialized by user scripts (sourced by SourceLimitScripts).&nbsp; In this
function, if there are static limits which need be set, or other
configurable&nbsp; variables which must be initialized from Tcl variables, <i>extend</i>
this function.&nbsp; Do not delete the call to CTclGrammerApp::SetLimits() as
some critical SpecTcl limits are set by that call.</p>

<p><a href="#Top">Top</a> <a href="tailoring.htm">Tailoring SpecTcl</a></p>

<p><b>virtual   void CreateHistogrammer ()&nbsp;</b></p>

<p>Called immediately after SetLimits. This function is expected to set up a
data sink for the analyzer.&nbsp; The default call,
CTclGrammerApp::CreateHistogrammer() will set up a TclHistogrammer as the data
sink.&nbsp; If desired, this can be overridden and e.g. user specific data sinks
can be registered instead.</p>

<p><a href="#Top">Top</a> <a href="tailoring.htm">Tailoring SpecTcl</a></p>

<p><b>virtual   void SelectDisplayer (UInt_t nDisplaySize,&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
CHistogrammer&amp; rHistogrammer)</b></p>

<p>Called after CreateHistogrammer.&nbsp; The nDisplaySize parameter is, if
appropriate to the number of megabytes desired for display memory shared between
the SpecTcl and the displayer.&nbsp; The rHistogrammer parameter is the
histogrammer created in CreateHistogramer.&nbsp;</p>

<p>This function creates a displayer and hooks it to SpecTcl's histogrammer.&nbsp;
The displayer by default is Xamine (via the call to
CTclGrammerApp::SelectDisplayer).&nbsp; This can be overridden by removing that
call and substituting code to generate the user's own displayer.</p>

<p><a href="#Top">Top</a> <a href="tailoring.htm">Tailoring SpecTcl</a></p>

<p><b>virtual   void SetupTestDataSource ()</b></p>

<p>Called immediately after SelectDisplayer.&nbsp; The default action is to call
CTclGrammerApp::SetupTestDataSource which in turn sets up a data source to
produced 5 parameter fixed length events with gaussian distributions.&nbsp; If
you don't have your own test data source you can leave this alone.&nbsp; Sample
code for this is shown <a href="samplecode/sample_test_data_source.htm">here</a>.&nbsp;
Otherwise, remove the call to CTclGrammerApp::SetupTestDataSource and add code
to create your own test data source.</p>

<p><a href="#Top">Top</a> <a href="tailoring.htm">Tailoring SpecTcl</a></p>

<p><b>virtual   void CreateAnalyzer (CEventSink* pSink)</b></p>

<p>Called immediately after SetupTestDataSource. Creates the data analyzer
object.&nbsp; By default a CTclGrammerApp::CreateAnalyzer is called causeing
a&nbsp; CTclAnalyzer object to be created and the event sink created in
CreateHistogrammer linked to it.&nbsp; The CTclAnalyzer is the standard analyzer
used by SpecTcl, if you have your own analyzer derived from and extended from
the CAnalyzer class, you can create an instance of it instead and hook it into
the system.&nbsp; Do this by removing the call to CTclGrammerApp::CreateAnalyzer
and adding your own code.</p>

<p><a href="#Top">Top</a> <a href="tailoring.htm">Tailoring SpecTcl</a></p>

<p><b>virtual   void SelectDecoder (CAnalyzer&amp; rAnalyzer)</b></p>

<p>Called right after CreateAnalyzer. Selects which buffer decoder to use to
process incoming buffers, creates it and attaches it to SpecTcl.&nbsp; The
default code calls CTclGrammerApp::SelectDecoder() which in turn creates a
CNSCLBufferDecoder which is suitable for decoding NSCL data buffers.&nbsp; If
you have data from another data acquisition system, you will need to create your
own CBufferDecoder derived class, instantiate it here, and hook it into the
system.&nbsp; In order to help you do this, click for the code in <a href="samplecode/ctclgrammerapp.htm">CTclGrammerApp::SelectDecoder</a></p>

<p><a href="#Top">Top</a> <a href="tailoring.htm">Tailoring SpecTcl</a></p>

<p><b>virtual   void AddCommands (CTCLInterpreter&amp; rInterp)</b></p>

<p>Called immediately after SelectDecoder.&nbsp; Adds commands to the TCL
interpreter.&nbsp; The default action is to call CTclGrammerApp::AddCommands.&nbsp;
This call should not be removed as it registers the standard SpecTcl commands to
the Tk/Tcl interpreter.&nbsp; You may, however extend the interpreter with
commands and command packages of your own.&nbsp;&nbsp; <a href="commands.htm">See
here for information about how to extend the interpreter with user written
commands</a>.</p>

<p><a href="#Top">Top</a> <a href="tailoring.htm">Tailoring SpecTcl</a></p>

<p><b>virtual   void SetupRunControl ()</b></p>

<p>Called immediately after AddCommands.&nbsp; Sets up the run control system.
The run control system is manipulated by the SpecTcl <a href="../Commands/start.htm">start</a>
and <a href="../Commands/stop.htm">stop</a> commands.&nbsp; In most cases you
will not need to modify the default code.&nbsp; The default code calls
CTclGrammerApp::SetupRunControl which sets up a run control object suitable for
use in the Tc/Tk environment.</p>

<p><a href="#Top">Top</a> <a href="tailoring.htm">Tailoring SpecTcl</a></p>

<p><b>virtual   void SourceFunctionalScripts (CTCLInterpreter&amp; rInterp)</b></p>

<p>This function is called last.&nbsp; It provides an opportunity to source
experiment specific Tcl/Tk setup scripts.&nbsp; The default behavior is to call
CTclGrammerApp::SourceFunctionalScripts which in turn runs the SpecTclRC.tcl in
the user's home and&nbsp; current working directories if it exists there.&nbsp;
The attempts to run this file are enclosed in try blocks which silently catch
all exceptions.&nbsp; If you want to source additional functional scripts, then
you may add code to this function.&nbsp; <a href="samplecode/sourcefunctionalscripts.htm">To
see how to do this; see here for a listing of
CTclGrammerApp::SourceFunctionalScripts()</a></p>

<p><a href="#Top">Top</a> <a href="tailoring.htm">Tailoring SpecTcl</a></p>

<p><b>virtual   int operator() ()</b></p>

<p>This function is the &quot;Entry point&quot; for the object.&nbsp; It is
called at Tcl initialization.&nbsp; The default operation is to invoke
CTclGrammerApp::operator() which calls the functions described on this page in
the order listed.&nbsp; You may extend this functionality by adding code before
or after this call.&nbsp; It is not a good idea to remove the call to
CTclGrammerApp::operator() since so much of SpecTcl is set up through this
function.</p>

<p><a href="#Top">Top</a> <a href="tailoring.htm">Tailoring SpecTcl</a></p>

<p><a href="../index.htm">SpecTcl Home</a>&nbsp; <a
href="../general_information.htm">General Information</a> <a
href="../users_guide.htm">User Guide</a> <a
href="../programmers_guide.htm">Programmer's Guide</a> <a
href="../obtaining_and_installing.htm">Obtaining and Installing</a></p>

<hr>

<p>Last Modified: <!--webbot bot="Timestamp" s-type="EDITED"
s-format="%B %d, %Y" startspan -->October 28, 2003<!--webbot bot="Timestamp" endspan i-checksum="30351" --> by: <a
href="mailto:fox@nscl.msu.edu">fox@nscl.msu.edu</a><br>
<font size="2">© Copyright NSCL 1999, All rights reserved</font></p>
</body>
</html>
