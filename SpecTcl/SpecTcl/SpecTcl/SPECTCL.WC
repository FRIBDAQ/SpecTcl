With Class Chart Export File
I:\SPECTCL\SPECTCL\SpecTcl.omtUnified Method


General Info
Internal Version #, NextClassID, NextClassShapeID, NextRelationShapeID, NextStateID, NextStateShapeID, NextTransitionID, NextTransitionShapeID, NextObjectID, NextObjectShapeID, NextInteractionID, NextInteractionShapeID, NextOperationID, NextAttributeID
***BEGIN_TABLE***
4.728835819211111111339186
***END_TABLE***

Classes
ClassID, Name, Description, Multiplicity, Concurrency, Visibility, Persistence, FileName, Package, Import File, Author, LibraryBaseClass, Invariant, User1, User2, User3, Stereotype, 
***BEGIN_TABLE***
32
1CApplyCommandI:\spectcl\spectcl\ApplyCommand.cppGateCommandsCTCLPackagedCommand0000
2CAttachCommandI:\spectcl\spectcl\AttachCommand.cppDataSourceCommandsCTCLPackagedCommand0000
3CBindCommandI:\spectcl\spectcl\BindCommand.cppSpectrumPackageCTCLPackagedCommand0000
4ChannelCommandI:\spectcl\spectcl\ChanCommand.cppSpectrumPackageCTCLPackagedCommand0000
5CClearCommandI:\spectcl\spectcl\ClearCommand.cppSpectrumPackageCTCLPackagedCommand0000
6CDataSourcePackageI:\spectcl\spectcl\DataSourcePackage.cppDataSourceCommands0000
7GateFactoryTableI:\spectcl\spectcl\GateCommand.cppGateCommands0000
8CGateCommandI:\spectcl\spectcl\GateCommand.cppGateCommandsCTCLPackagedCommand0000
9CGateFactoryI:\spectcl\spectcl\GateFactory.cppGateCommands0000
10CGateFactoryExceptionI:\spectcl\spectcl\GateFactoryException.cppGateCommandsCException0000
11CGatePackageI:\spectcl\spectcl\GatePackage.cppGateCommands0000
12CParameterCommandI:\spectcl\spectcl\ParameterCommand.cppParameterCommandsCTCLPackagedCommand0000
13CParameterPackageI:\spectcl\spectcl\ParameterPackage.cppParameterCommands0000
14CPseudoCommandI:\spectcl\spectcl\PseudoCommand.cppParameterCommandsCTCLPackagedCommand0000
15CPseudoScriptI:\spectcl\spectcl\PseudoScript.cppCNamedItem0000
16StreamEntryI:\spectcl\spectcl\ReadCommand.cppSpectrumPackage0000
17CReadCommandI:\spectcl\spectcl\ReadCommand.cppSpectrumPackageCTCLPackagedCommand0000
18CRunControlPackageI:\spectcl\spectcl\RunControlPackage.cppRunControlCommands0000
19CSpectrumCommandI:\spectcl\spectcl\SpectrumCommand.cppSpectrumPackageCTCLPackagedCommand0000
20CSpectrumPackageI:\spectcl\spectcl\SpectrumPackage.cppSpectrumPackage0000
21CStartRunI:\spectcl\spectcl\StartRun.cppRunControlCommandsCTCLPackagedCommand0000
22CStopRunI:\spectcl\spectcl\StopRun.cppRunControlCommandsCTCLPackagedCommand0000
23CTapeCommandI:\spectcl\spectcl\TapeCommand.cppDataSourceCommandsCTCLPackagedCommand0000
24CTclAnalyzerI:\spectcl\spectcl\TCLAnalyzer.cppCAnalyzer0000
25CTCLHistogrammerI:\spectcl\spectcl\TCLHistogrammer.cppParameterCommands0000
26CUnbindCommandI:\spectcl\spectcl\UnbindCommand.cppSpectrumPackageCTCLPackagedCommand0000
27CUngateCommandI:\spectcl\spectcl\UngateCommand.cppGateCommandsCTCLPackagedCommand0000
28CWriteCommandI:\spectcl\spectcl\WriteCommand.cppSpectrumPackageCTCLPackagedCommand0000
29CXamineEventHandlerI:\spectcl\spectcl\XamineEventHandler.cppCTCLFileHandler0000
59CTclGrammerAppPerforms SpecTcl initialization.  The user extends this calss to add their own initialization.publicTclGrammerAppEventProcessingCTCLApplication1000
60CMySpecTclAppThe user creates this subclass and fills in the appropriate overrides for any 

additions they want to make.  The class is a self contained example which 

registers two event processors.  One which unpacks a simple fixed length

event and another which produces a pseudo parameter from the sum of 

the first two parameters in an event.1sequentialpublicTransitoryMySpecTclApp0010
61CEventProcessorThis is a base class for all elements in the analysis pipeline.  

Elements in the pipeline can do whatever they want with the raw

event and the unpacked event array.  They are registered into the

analyzer as a sequential set of processors which are called in registration

  The base class makes no assumption about which of the run events

is actually handled and is essentially a no-op for all member functions.

This allows a user to write e.g. an event processor which only cares about

things like the Begin Run event.



BUGBUGBUG - Need to extend this class at some point to have

   entries for Documentation buffers.

order for each event.publicEventProcessor0000
***END_TABLE***

Class Shape
ShapeID, PosX, PosY, TopText, MiddleText, BottomText, ClassDataID, ClassType, Abstract, Template, Interface, Final
***BEGIN_TABLE***
1042020CGateFactoryExceptionm_eReason:m_eGateType:m_svReasonTexts:m_svGateTypeStringsCGateFactoryException:~CGateFactoryException:CGateFactoryException$:operator=:operator==:getm_eReason:getGateType:getReasonTexts:setReason:setGateType:setReasonTexts:ReasonText:ReasonCode:ReasonCodeToText10000000
870640CGateCommandnArgs~GateFactoryTable:operator=:operator==:MatchSwitches:Usage:MatchGateType8000000
780840GateFactoryTablepGateType:eGateType:fGateList:nParameters7000000
1270830CApplyCommandrResultCApplyCommand:~CApplyCommand:CApplyCommand$:operator=:operator==:Usage1000000
11250240CGatePackagem_pHistogrammer:m_pGateCommand:m_pApplyCommand:m_pUngateCommand:m_nNextIdCGatePackage:~CGatePackage:CGatePackage$:operator=:operator==:getHistogrammer:getGateCommand:getApplyCommand:getUngateCommand:getNextId:setHistogrammer:setGateCommand:setApplyCommand:setUngateCommand:setNextId:AddGate:ListGates:ListGatesById:DeleteGates:DeleteGates$:ApplyGate:ListAppliedGate:Ungate:GateToString:AssignId:SortGateListById11000000
21940550CStartRunrResultCStartRun:~CStartRun:CStartRun$:operator=:operator==21000000
18111020CRunControlPackagem_pStartRun:m_pStopRun:m_pRunStateCRunControlPackage:~CRunControlPackage:CRunControlPackage$:operator=:operator==:InitializeRunState:StartRun:StopRun:isRunning18000000
221230420CStopRunrRestulCStopRun:~CStopRun:CStopRun$:operator=:operator==22000000
92010CGateFactorym_pHistogrammerCGateFactory:~CGateFactory:CGateFactory$:operator=:operator==:getHistogrammer:setHistogrammer:CreateGate:CreateGate$:CreateTrueGate:CreateFalseGate:CreateDeletedGate:CreateBand:CreateContour:CreateBandContour:CreateNotGate:CreateAndGate:CreateOrGate:CreateCut:ParameterToId:NameToGate:CreateGateList9000000
27460750CUngateCommandnArgsCUngateCommand:~CUngateCommand:CUngateCommand$:operator=:operator==:Usage27000000
191560220CSpectrumCommandnArgsCSpectrumCommand:~CSpectrumCommand:CSpectrumCommand$:operator=:operator==:Usage:MatchSwitch:SortSpectraById:SortSpectraByName:VectorToResult:ExtractId:ExtractName19000000
161600730StreamEntrypstreamloc:pos:device:inode16000000
281780680CWriteCommandnArgsCWriteCommand:~CWriteCommand:CWriteCommand$:operator=:operator==:IsFileId:GetFileId:GetFormatter:Usage28000000
32190480CBindCommandnArgsCBindCommand:~CBindCommand:CBindCommand$:operator=:operator==:BindAll:ListAll:MatchSwitch:Usage3000000
52080660CClearCommandnArgsCClearCommand:~CClearCommand:CClearCommand$:operator=:operator==:Usage:MatchSwitch5000000
171650430CReadCommandnArgsCReadCommand:~CReadCommand:CReadCommand$:operator=:operator==:Usage:NextSwitch:CheckIn:CheckOut:InMap:GetEntry17000000
261950800CUnbindCommandnArgsCUnbindCommand:~CUnbindCommand:CUnbindCommand$:operator=:operator==:Usage:MatchSwitch26000000
42160130ChannelCommandnArgsChannelCommand:~ChannelCommand:ChannelCommand$:EvalIndex:operator=:operator==:ParseSwitch:Usage4000000
13258040CParameterPackagem_pHistogrammer:m_pParameter:m_pPseudoCParameterPackage:~CParameterPackage:CParameterPackage$:operator=:operator==:getHistogrammer:setHistogrammer:AddParameter:CreateTclParameterList:DeleteParameter:DeleteParameter$:ListParameter:ListParameter$:getParameterInfoListString:AddPseudo:DescribePseudo:DeletePseudo:GetPseudoNames13000000
252440500CTCLHistogrammerm_pIntObject:m_PseudosCTCLHistogrammer:~CTCLHistogrammer:CTCLHistogrammer$:operator=:operator==:getInterpreter:getPseudoParameters:setInterpreter:setPseudoParameters:AddPseudo:RemovePseudo:FindPseudo:PseudoBegin:PseudoEnd:PseudoSize25000000
122620500CParameterCommandrResultCParameterCommand:~CParameterCommand:CParameterCommand$:operator=:operator==:Usage:ParseSwitch:ListParametersById12000000
142920480CPseudoCommandrResultCPseudoCommand:~CPseudoCommand:CPseudoCommand$:operator=:operator==:Create:List:Delete:Usage:ParseSwitch14000000
6348060CDataSourcePackagem_eSourceType:m_pTape:m_pAttachCDataSourcePackage:~CDataSourcePackage:CDataSourcePackage$:operator=:operator==:getSourceType:getTapeCommand:getAttachCommand:setSourceType:setTapeCommand:setAttachCommand:AttachFileSource:AttachTapeSource:AttachPipeSource:OpenSource:CloseSource:OpenNextTapeFile:RewindTape:isTape:isFile:isPipe:IsTest:isOpen6000000
233430510CTapeCommandnArgsCTapeCommand:~CTapeCommand:CTapeCommand$:operator=:operator==:Usage:ParseSwitch23000000
23570510CAttachCommandrResultCAttachCommand:~CAttachCommand:CAttachCommand$:operator=:operator==:Usage:ParseSwitch2000000
29418040CXamineEventHandlerm_pHistogrammerCXamineEventHandler:~CXamineEventHandler:CXamineEventHandler$:operator=:operator==:getHistogrammer:setHistogrammer:OnGate:OnButton29000000
154370200CPseudoScriptm_vParameterNames:m_vParameterIds:m_sRawScriptText:m_ScriptProc:m_CallStub:m_pInterpreter:m_fEnabledCPseudoScript:CPseudoScript$:~CPseudoScript:CPseudoScript$$:operator=:operator==:operator!=:getParameterNames:getParameterIds:getRawScriptText:getOutputParameter:getOutputId:getScriptObject:getCallStubObject:getInterpreter:isEnabled:setParameterNames:setParameterIds:setOutputParameter:setOutputId:setInterpreter:setEnabled:AddDependentParameter:AddDependentParameter$:setRawScriptText:ParNamesBegin:ParNamesSize:ParNamesEnd:ParIdsBegin:ParIdsSize:ParIdsEnd:RebuildState:BindOutputParameter15000000
664810450CMySpecTclAppBindTCLVariables:SourceLimitScripts:SetLimits:CreateHistogrammer:SelectDisplayer:SetupTestDataSource:CreateAnalyzer:SelectDecoder:CreateAnalysisPipeline:AddCommands:SetupRunControl:SourceFunctionalScripts:operator()60000100
675070410CEventProcessorOnAttach:OnBegin:OnEnd:OnPause:OnResume:operator()61000000
24507060CTclAnalyzerm_pBuffersAnalyzed:m_pLastSequence:m_pRunNumber:m_pRunTitle:m_pRunState:m_pStatisticsCTclAnalyzer:~CTclAnalyzer:CTclAnalyzer$:operator=:OnPhysics:OnStateChange:IncrementVariable:SetVariable:ClearVariable:OnBegin:OnEnd:OnPause:OnResume:AddEventProcessor:OnEventAccepted:OnEventRejected24000000
2019400CSpectrumPackagem_nNextId:m_pHistogrammer:m_pSpectrum:m_pClear:m_pBind:m_pUnbind:m_pChannel:m_pWrite:m_pReadCSpectrumPackage:~CSpectrumPackage:CSpectrumPackage$:operator=:operator==:getNextId:getHistogrammer:setHistogrammer:setNextId:AllocateId:CreateSpectrum:ListSpectra:ListSpectrum:ListSpectrum$:ClearAll:ClearSubset:ClearSubset$:BindAll:BindList:BindList$:UnbindList:UnbindList$:UnbindXidList:UnbindAll:DeleteList:DeleteList$:DeleteAll:ListBindings:ListBindings$:ListXidBindings:ListAllBindings:GetChannel:SetChannel:Write:Read:DescribeSpectrum:FindDisplayBinding:FindDisplayBinding$:FormatBinding:SpecTypeToText:DataTypeToText:SpectrumType:Datatype:ValidateIndices:UniquifyName:AllParamsExist20000000
65481040CTclGrammerAppm_pInterpreter:m_nDisplaySize:m_nParams:m_nListSize:m_pAnalyzer:m_pHistogrammer:m_pRunControl:m_pXamineEvents:m_pRunControlPackage:m_pParameterPackage:m_pSpectrumPackage:m_pDataSourcePackage:m_pGatePackage:m_RCFile:m_TclDisplaySize:m_TclParameterCount:m_TclEventListSizeRegisterEventProcessor:BindTCLVariables:SourceLimitScripts:SetLimits:CreateHistogrammer:SelectDisplayer:SetupTestDataSource:CreateAnalyzer:SelectDecoder:CreateAnalysisPipeline:AddCommands:SetupRunControl:SourceFunctionalScripts:operator()59100000
***END_TABLE***

Attributes
ClassID, ClassName, AttrID, Name, Type, Length, IsStatic, Description, Visibility, MaxVal, MinVal, InitVal, Stereotype, Constraint, IsConstant, IsIndexed, IsUnique, IsNotNull, IsPrimaryKey, IsForeignKey, User1, User2, User3, IsArray, IsFinal, IsWriteProperty, IsReadProperty
***BEGIN_TABLE***
1CApplyCommand1rResultCTCLResult&0public0000000000
2CAttachCommand2rResultCTCLResult&0public0000000000
3CBindCommand3nArgsint0public0000000000
4ChannelCommand4nArgsint0public0000000000
5CClearCommand5nArgsint0public0000000000
6CDataSourcePackage6m_eSourceTypeSourceType_t0private0000000000
6CDataSourcePackage7m_pTapeCTapeCommand*0private0000000000
6CDataSourcePackage8m_pAttachCAttachCommand*0private0000000000
7GateFactoryTable9pGateTypechar*0public0000000000
7GateFactoryTable10eGateTypeCGateFactory::GateType0public0000000000
7GateFactoryTable11fGateListBool_t0public0000000000
7GateFactoryTable12nParametersUInt_t0public0000000000
8CGateCommand13nArgsint0public0000000000
9CGateFactory14m_pHistogrammerCHistogrammer*0private0000000000
10CGateFactoryException15m_eReasonGateFactoryExceptionReason0private0000000000
10CGateFactoryException16m_eGateTypeCGateFactory::GateType0private0000000000
10CGateFactoryException17m_svReasonTextschar**1private0000000000
10CGateFactoryException18m_svGateTypeStringschar**1private0000000000
11CGatePackage19m_pHistogrammerCHistogrammer*0private0000000000
11CGatePackage20m_pGateCommandCGateCommand*0private0000000000
11CGatePackage21m_pApplyCommandCApplyCommand*0private0000000000
11CGatePackage22m_pUngateCommandCUngateCommand*0private0000000000
11CGatePackage23m_nNextIdUInt_t1private0000000000
12CParameterCommand24rResultCTCLResult&0public0000000000
13CParameterPackage25m_pHistogrammerCTCLHistogrammer*0private0000000000
13CParameterPackage26m_pParameterCParameterCommand*0private0000000000
13CParameterPackage27m_pPseudoCPseudoCommand*0private0000000000
14CPseudoCommand28rResultCTCLResult&0public0000000000
15CPseudoScript29m_vParameterNamesstring0private0000000000
15CPseudoScript30m_vParameterIdsUInt_t0private0000000000
15CPseudoScript31m_sRawScriptTextstring0private0000000000
15CPseudoScript32m_ScriptProcCTCLObject0private0000000000
15CPseudoScript33m_CallStubCTCLObject0private0000000000
15CPseudoScript34m_pInterpreterCTCLInterpreter*0private0000000000
15CPseudoScript35m_fEnabledBool_t0private0000000000
16StreamEntry37pstreamlocfstream*0private0000000000
16StreamEntry38posoff_t0private0000000000
16StreamEntry39devicedev_t0private0000000000
16StreamEntry40inodeino_t0private0000000000
17CReadCommand36nArgsint0public0000000000
18CRunControlPackage41m_pStartRunCStartRun*0private0000000000
18CRunControlPackage42m_pStopRunCStopRun*0private0000000000
18CRunControlPackage43m_pRunStateCTCLVariable*0private0000000000
19CSpectrumCommand44nArgsint0public0000000000
20CSpectrumPackage45m_nNextIdUInt_t1protected0000000000
20CSpectrumPackage46m_pHistogrammerCHistogrammer*0protected0000000000
20CSpectrumPackage47m_pSpectrumCSpectrumCommand*0protected0000000000
20CSpectrumPackage48m_pClearCClearCommand*0protected0000000000
20CSpectrumPackage49m_pBindCBindCommand*0protected0000000000
20CSpectrumPackage50m_pUnbindCUnbindCommand*0protected0000000000
20CSpectrumPackage51m_pChannelChannelCommand*0protected0000000000
20CSpectrumPackage52m_pWriteCWriteCommand*0protected0000000000
20CSpectrumPackage53m_pReadCReadCommand*0protected0000000000
21CStartRun54rResultCTCLResult&0public0000000000
22CStopRun55rRestulCTCLResult&0public0000000000
23CTapeCommand56nArgsint0public0000000000
24CTclAnalyzer57m_pBuffersAnalyzedCTCLVariable*0Buffers analyzed this run.private0000000000
24CTclAnalyzer58m_pLastSequenceCTCLVariable*0Sequence # of last buffer analyzed.private0000000000
24CTclAnalyzer65m_pRunNumberCTCLVariable*0Run number of current run.private00000000000
24CTclAnalyzer66m_pRunTitleCTCLVariable*0Title of current run.private00000000000
24CTclAnalyzer67m_pRunStateCTCLVariable*0State of runprivate00000000000
24CTclAnalyzer85m_pStatisticsCTCLVariable*0SpecTcl analysis statistics.private00000000000
25CTCLHistogrammer59m_pIntObjectCTCLInterpreter*0private0000000000
25CTCLHistogrammer60m_PseudosPseudoParameters0private0000000000
26CUnbindCommand61nArgsint0public0000000000
27CUngateCommand62nArgsint0public0000000000
28CWriteCommand63nArgsint0public0000000000
29CXamineEventHandler64m_pHistogrammerCHistogrammer*0private0000000000
59CTclGrammerApp80m_pInterpreterCTCLInterpreter*0Pointer to SpecTcl's (main) interpreter.private00000000000
59CTclGrammerApp68m_nDisplaySizeUInt_t0Number of megabytes in the display subsystem shared memory.private00000000000
59CTclGrammerApp69m_nParamsUInt_t0Initial size of the event array.private00000000000
59CTclGrammerApp70m_nListSizeUInt_t0Number of events in the batched event processing list.private00000000000
59CTclGrammerApp71m_pAnalyzerCAnalyzer*0Points to the analyzer we're attaching to SpecTcl to process the data.private00000000000
59CTclGrammerApp72m_pHistogrammerCTCLHistogrammer*0Points to the histogrammer we're going to attach to SpecTcl as the data sink.private00000000000
59CTclGrammerApp73m_pRunControlCTKRunControl*0Points to the run control object which is responsible for accepting data ready events.private00000000000
59CTclGrammerApp74m_pXamineEventsCXamineEventHandler*0Pointer to the event handler for displayer events.private00000000000
59CTclGrammerApp75m_pRunControlPackageCRunControlPackage*0Package of TCL extensions to control run analysis.private00000000000
59CTclGrammerApp76m_pParameterPackageCParameterPackage*0TCL Extension package to manipulate parameters.private00000000000
59CTclGrammerApp77m_pSpectrumPackageCSpectrumPackage*0TCL Extension package to manipulate spectra.private00000000000
59CTclGrammerApp78m_pDataSourcePackageCDataSourcePackage*0TCL Extension package to manipulate data sources.private00000000000
59CTclGrammerApp79m_pGatePackageCTCLGatePackage*0TCL Extension package to support gate commands.private00000000000
59CTclGrammerApp81m_RCFileCTCLVariable0Linked to "tcl_rcFileName" - initial TCL script.private00000000000
59CTclGrammerApp82m_TclDisplaySizeCTCLVariable0Linked to DisplayMegabytes tcl variable.private00000000000
59CTclGrammerApp83m_TclParameterCountCTCLVariable0Link to Tcl variable: "ParameterCount" initial event list size.private00000000000
59CTclGrammerApp84m_TclEventListSizeCTCLVariable0Linked to the TCLVariable "EventListSize": Number of events batched for analysis.private00000000000
***END_TABLE***

Operations
ClassID, ClassName, OperID, OperName, Return Type, Post Condition, PreCondition, Invariant, Stereotype, Classification, Exception, Transformation, Concurrency, Visibility,  Comment1, Comment2, Comment3, IsStatic, IsConstant, IsPureVirtual, IsVirtual, IsProcedure, IsInline, IsEvent, IsOverride, Message, IsFinal, IsSynchronized, IsNative, IsFriend
***BEGIN_TABLE***
1CApplyCommand3004CApplyCommandpublic000010000000
BEGIN_CODE
 
  
END_CODE
1CApplyCommand3005~CApplyCommandpublic000010000000
BEGIN_CODE
 
END_CODE
1CApplyCommand3006CApplyCommand$private000010000000
BEGIN_CODE

END_CODE
1CApplyCommand3007operator=CApplyCommand&private000010000000
BEGIN_CODE

END_CODE
1CApplyCommand3008operator==intpublic000010000000
BEGIN_CODE

    return CTCLPackagedCommand::operator==(aCApplyCommand);
  
END_CODE
1CApplyCommand3009Usagestringprotected100010000000
BEGIN_CODE

END_CODE
2CAttachCommand3010CAttachCommandpublic000010000000
BEGIN_CODE
}
END_CODE
2CAttachCommand3011~CAttachCommandpublic000110000000
BEGIN_CODE
 
END_CODE
2CAttachCommand3012CAttachCommand$private000010000000
BEGIN_CODE

END_CODE
2CAttachCommand3013operator=CAttachCommand&private000010000000
BEGIN_CODE

END_CODE
2CAttachCommand3014operator==intpublic000010000000
BEGIN_CODE
 
    return ((CTCLPackagedCommand::operator== (aCAttachCommand)) );
  
END_CODE
2CAttachCommand3015Usagevoidprotected100010000000
BEGIN_CODE

END_CODE
2CAttachCommand3016ParseSwitchSwitch_tprotected100010000000
BEGIN_CODE

END_CODE
3CBindCommand3017CBindCommandpublic000010000000
BEGIN_CODE
 
END_CODE
3CBindCommand3018~CBindCommandpublic000010000000
BEGIN_CODE
 
END_CODE
3CBindCommand3019CBindCommand$private000010000000
BEGIN_CODE

END_CODE
3CBindCommand3020operator=CBindCommand&private000010000000
BEGIN_CODE

END_CODE
3CBindCommand3021operator==intpublic000010000000
BEGIN_CODE
 
    return (
	    (CTCLPackagedCommand::operator== (aCBindCommand)) 

	    );
  
END_CODE
3CBindCommand3022BindAllInt_tpublic000010000000
BEGIN_CODE

END_CODE
3CBindCommand3023ListAllInt_tpublic000010000000
BEGIN_CODE

END_CODE
3CBindCommand3024MatchSwitcheSwitchesprotected100010000000
BEGIN_CODE

END_CODE
3CBindCommand3025Usagevoidprotected100010000000
BEGIN_CODE

END_CODE
4ChannelCommand3026ChannelCommandpublic000010000000
BEGIN_CODE
 
END_CODE
4ChannelCommand3027~ChannelCommandpublic000110000000
BEGIN_CODE
 
END_CODE
4ChannelCommand3028ChannelCommand$private000010000000
BEGIN_CODE

END_CODE
4ChannelCommand3029EvalIndexInt_tprivate000010000000
BEGIN_CODE

END_CODE
4ChannelCommand3030operator=ChannelCommand&private000010000000
BEGIN_CODE

END_CODE
4ChannelCommand3031operator==intpublic010010000000
BEGIN_CODE

    return CTCLPackagedCommand::operator==(aChannelCommand);
  
END_CODE
4ChannelCommand3032ParseSwitchSwitchesprotected000010000000
BEGIN_CODE

END_CODE
4ChannelCommand3033Usagevoidprotected000010000000
BEGIN_CODE

END_CODE
5CClearCommand3034CClearCommandpublic000010000000
BEGIN_CODE
 
END_CODE
5CClearCommand3035~CClearCommandpublic000110000000
BEGIN_CODE
 
END_CODE
5CClearCommand3036CClearCommand$private000010000000
BEGIN_CODE

END_CODE
5CClearCommand3037operator=CClearCommand&private000010000000
BEGIN_CODE

END_CODE
5CClearCommand3038operator==intpublic000010000000
BEGIN_CODE
 
    return ((CTCLPackagedCommand::operator== (aCClearCommand)) );
  
END_CODE
5CClearCommand3039Usagevoidprotected100010000000
BEGIN_CODE

END_CODE
5CClearCommand3040MatchSwitchSwitchprotected100010000000
BEGIN_CODE

END_CODE
6CDataSourcePackage3041CDataSourcePackagepublic000010000000
BEGIN_CODE

END_CODE
6CDataSourcePackage3042~CDataSourcePackagepublic000110000000
BEGIN_CODE
}
END_CODE
6CDataSourcePackage3043CDataSourcePackage$private000010000000
BEGIN_CODE

END_CODE
6CDataSourcePackage3044operator=CDataSourcePackage&private000010000000
BEGIN_CODE

END_CODE
6CDataSourcePackage3045operator==intpublic000010000000
BEGIN_CODE
 
    return (
	    (CTCLCommandPackage::operator== (aCDataSourcePackage)) &&
	    (m_eSourceType == aCDataSourcePackage.m_eSourceType) 
	    );
  
END_CODE
6CDataSourcePackage3046getSourceTypeSourceType_tpublic010010000000
BEGIN_CODE

    return m_eSourceType;
  
END_CODE
6CDataSourcePackage3047getTapeCommandCTapeCommand*public010010000000
BEGIN_CODE

    return m_pTape;
  
END_CODE
6CDataSourcePackage3048getAttachCommandCAttachCommand*public010010000000
BEGIN_CODE

    return m_pAttach;  
  
END_CODE
6CDataSourcePackage3049setSourceTypevoidprotected000010000000
BEGIN_CODE
 
    m_eSourceType = am_eSourceType;
  
END_CODE
6CDataSourcePackage3050setTapeCommandvoidprotected000010000000
BEGIN_CODE
 
    m_pTape= pTape;
  
END_CODE
6CDataSourcePackage3051setAttachCommandvoidprotected000010000000
BEGIN_CODE

    m_pAttach = pAttach;
  
END_CODE
6CDataSourcePackage3052AttachFileSourceintpublic000010000000
BEGIN_CODE

END_CODE
6CDataSourcePackage3053AttachTapeSourceintpublic000010000000
BEGIN_CODE

END_CODE
6CDataSourcePackage3054AttachPipeSourceintpublic000010000000
BEGIN_CODE

END_CODE
6CDataSourcePackage3055OpenSourceintpublic000010000000
BEGIN_CODE

END_CODE
6CDataSourcePackage3056CloseSourceintpublic000010000000
BEGIN_CODE

END_CODE
6CDataSourcePackage3057OpenNextTapeFileintpublic000010000000
BEGIN_CODE

END_CODE
6CDataSourcePackage3058RewindTapeintpublic000010000000
BEGIN_CODE

END_CODE
6CDataSourcePackage3059isTapeBool_tpublic000010000000
BEGIN_CODE
 return m_eSourceType == kTapeSource; 
END_CODE
6CDataSourcePackage3060isFileBool_tpublic000010000000
BEGIN_CODE
 return m_eSourceType == kFileSource; 
END_CODE
6CDataSourcePackage3061isPipeBool_tpublic000010000000
BEGIN_CODE
 return m_eSourceType == kPipeSource; 
END_CODE
6CDataSourcePackage3062IsTestBool_tpublic000010000000
BEGIN_CODE
 return m_eSourceType == kTestSource; 
END_CODE
6CDataSourcePackage3063isOpenBool_tpublic000010000000
BEGIN_CODE

END_CODE
8CGateCommand3064~GateFactoryTablepublic000010000000
BEGIN_CODE
 
END_CODE
8CGateCommand3065operator=CGateCommand&private000010000000
BEGIN_CODE

END_CODE
8CGateCommand3066operator==intpublic010010000000
BEGIN_CODE

    return CTCLPackagedCommand::operator==(aCGateCommand);
  
END_CODE
8CGateCommand3067MatchSwitchesSwitchesprotected100110000000
BEGIN_CODE

END_CODE
8CGateCommand3068Usagestringprotected100010000000
BEGIN_CODE

END_CODE
8CGateCommand3069MatchGateTypeGateFactoryTable*protected100010000000
BEGIN_CODE

END_CODE
9CGateFactory3070CGateFactorypublic000010000000
BEGIN_CODE
}
END_CODE
9CGateFactory3071~CGateFactorypublic000110000000
BEGIN_CODE
 
END_CODE
9CGateFactory3072CGateFactory$public000010000000
BEGIN_CODE

    m_pHistogrammer = aCGateFactory.m_pHistogrammer;  
  
END_CODE
9CGateFactory3073operator=CGateFactory&public000010000000
BEGIN_CODE

END_CODE
9CGateFactory3074operator==intpublic010010000000
BEGIN_CODE

END_CODE
9CGateFactory3075getHistogrammerCHistogrammer*public010010000000
BEGIN_CODE
 
    return m_pHistogrammer;
  
END_CODE
9CGateFactory3076setHistogrammervoidprotected000010000000
BEGIN_CODE
 
    m_pHistogrammer = am_pHistogrammer;
  
END_CODE
9CGateFactory3077CreateGateCGate*public000010000000
BEGIN_CODE

END_CODE
9CGateFactory3078CreateGate$CGate*public000010000000
BEGIN_CODE

END_CODE
9CGateFactory3079CreateTrueGateCTrueGate*public000010000000
BEGIN_CODE

END_CODE
9CGateFactory3080CreateFalseGateCFalseGate*public000010000000
BEGIN_CODE

END_CODE
9CGateFactory3081CreateDeletedGateCDeletedGate*public000010000000
BEGIN_CODE

END_CODE
9CGateFactory3082CreateBandCBand*public000010000000
BEGIN_CODE

END_CODE
9CGateFactory3083CreateContourCContour*public000010000000
BEGIN_CODE

END_CODE
9CGateFactory3084CreateBandContourC2Bands*public000010000000
BEGIN_CODE

END_CODE
9CGateFactory3085CreateNotGateCNot*public000010000000
BEGIN_CODE

END_CODE
9CGateFactory3086CreateAndGateCAndGate*public000010000000
BEGIN_CODE

END_CODE
9CGateFactory3087CreateOrGateCOrGate*public000010000000
BEGIN_CODE

END_CODE
9CGateFactory3088CreateCutCCut*public000010000000
BEGIN_CODE

END_CODE
9CGateFactory3089ParameterToIdUInt_tprotected010010000000
BEGIN_CODE

END_CODE
9CGateFactory3090NameToGateCGateContainer&protected010010000000
BEGIN_CODE

END_CODE
9CGateFactory3091CreateGateListvoidprotected010010000000
BEGIN_CODE

END_CODE
10CGateFactoryException3092CGateFactoryExceptionpublic000010000000
BEGIN_CODE
}
END_CODE
10CGateFactoryException3093~CGateFactoryExceptionpublic000110000000
BEGIN_CODE
 
END_CODE
10CGateFactoryException3094CGateFactoryException$public000010000000
BEGIN_CODE

       
    m_eReason = aCGateFactoryException.m_eReason;
    m_eGateType = aCGateFactoryException.m_eGateType;
     
  
END_CODE
10CGateFactoryException3095operator=CGateFactoryException&public000010000000
BEGIN_CODE

END_CODE
10CGateFactoryException3096operator==intpublic010010000000
BEGIN_CODE

END_CODE
10CGateFactoryException3097getm_eReasonGateFactoryExceptionReasonpublic010010000000
BEGIN_CODE
 return m_eReason;
  
END_CODE
10CGateFactoryException3098getGateTypeCGateFactory::GateTypepublic010010000000
BEGIN_CODE
 return m_eGateType;
  
END_CODE
10CGateFactoryException3099getReasonTextschar**public000010000000
BEGIN_CODE
 return m_svReasonTexts;
  
END_CODE
10CGateFactoryException3100setReasonvoidprotected000010000000
BEGIN_CODE
 m_eReason = am_eReason;
  
END_CODE
10CGateFactoryException3101setGateTypevoidprotected000010000000
BEGIN_CODE
 m_eGateType = am_eGateType;
  
END_CODE
10CGateFactoryException3102setReasonTextsvoidprotected100010000000
BEGIN_CODE
 m_svReasonTexts = am_svReasonTexts;
  
END_CODE
10CGateFactoryException3103ReasonTextstringpublic000110000000
BEGIN_CODE

END_CODE
10CGateFactoryException3104ReasonCodeInt_tpublic000110000000
BEGIN_CODE

END_CODE
10CGateFactoryException3105ReasonCodeToTextchar*public100010000000
BEGIN_CODE

END_CODE
11CGatePackage3106CGatePackagepublic000010000000
BEGIN_CODE

END_CODE
11CGatePackage3107~CGatePackagepublic000010000000
BEGIN_CODE

END_CODE
11CGatePackage3108CGatePackage$private000010000000
BEGIN_CODE

END_CODE
11CGatePackage3109operator=CGatePackage&private000010000000
BEGIN_CODE

END_CODE
11CGatePackage3110operator==intpublic000010000000
BEGIN_CODE

    return (CTCLCommandPackage::operator==(aCGatePackage)          &&
	    (m_pHistogrammer  == aCGatePackage.m_pHistogrammer)   &&
	    (m_pGateCommand   == aCGatePackage.m_pGateCommand)    &&
	    (m_pUngateCommand == aCGatePackage.m_pUngateCommand)  &&
	    (m_nNextId        == aCGatePackage.m_nNextId));
  
END_CODE
11CGatePackage3111getHistogrammerCHistogrammer*public000010000000
BEGIN_CODE
 
    return m_pHistogrammer;
  
END_CODE
11CGatePackage3112getGateCommandCGateCommand*public010010000000
BEGIN_CODE

    return m_pGateCommand;
  
END_CODE
11CGatePackage3113getApplyCommandCApplyCommand*public010010000000
BEGIN_CODE
 
    return m_pApplyCommand;
  
END_CODE
11CGatePackage3114getUngateCommandCUngateCommand*public010010000000
BEGIN_CODE
 
    return m_pUngateCommand;
  
END_CODE
11CGatePackage3115getNextIdUInt_tpublic010010000000
BEGIN_CODE

    return m_nNextId;
  
END_CODE
11CGatePackage3116setHistogrammervoidprotected000010000000
BEGIN_CODE
 
    m_pHistogrammer = am_pHistogrammer;
  
END_CODE
11CGatePackage3117setGateCommandvoidprotected000010000000
BEGIN_CODE

    m_pGateCommand = p;
  
END_CODE
11CGatePackage3118setApplyCommandvoidprotected000010000000
BEGIN_CODE

    m_pApplyCommand = p;
  
END_CODE
11CGatePackage3119setUngateCommandvoidprotected000010000000
BEGIN_CODE

    m_pUngateCommand = p;
  
END_CODE
11CGatePackage3120setNextIdvoidprotected000010000000
BEGIN_CODE

    m_nNextId = n;
  
END_CODE
11CGatePackage3121AddGateBool_tpublic000010000000
BEGIN_CODE

END_CODE
11CGatePackage3122ListGatesCTCLStringpublic000010000000
BEGIN_CODE

END_CODE
11CGatePackage3123ListGatesByIdCTCLStringpublic000010000000
BEGIN_CODE

END_CODE
11CGatePackage3124DeleteGatesBool_tpublic000010000000
BEGIN_CODE

END_CODE
11CGatePackage3125DeleteGates$Bool_tpublic000010000000
BEGIN_CODE

END_CODE
11CGatePackage3126ApplyGateBool_tpublic000010000000
BEGIN_CODE

END_CODE
11CGatePackage3127ListAppliedGateBool_tpublic000010000000
BEGIN_CODE

END_CODE
11CGatePackage3128UngateBool_tpublic000010000000
BEGIN_CODE

END_CODE
11CGatePackage3129GateToStringstd::stringpublic000010000000
BEGIN_CODE

END_CODE
11CGatePackage3130AssignIdUInt_tpublic100010000000
BEGIN_CODE

END_CODE
11CGatePackage3131SortGateListByIdvoidprotected100010000000
BEGIN_CODE

END_CODE
12CParameterCommand3132CParameterCommandpublic000010000000
BEGIN_CODE
 
END_CODE
12CParameterCommand3133~CParameterCommandpublic000110000000
BEGIN_CODE
 
END_CODE
12CParameterCommand3134CParameterCommand$private000010000000
BEGIN_CODE

END_CODE
12CParameterCommand3135operator=CParameterCommand&private000010000000
BEGIN_CODE

END_CODE
12CParameterCommand3136operator==intpublic000010000000
BEGIN_CODE
 
    return (
	    (CTCLPackagedCommand::operator== (aCParameterCommand)) );
  
END_CODE
12CParameterCommand3137Usagevoidprotected000010000000
BEGIN_CODE

END_CODE
12CParameterCommand3138ParseSwitchSwitchValue_tprotected000010000000
BEGIN_CODE

END_CODE
12CParameterCommand3139ListParametersByIdUInt_tprotected000010000000
BEGIN_CODE

END_CODE
13CParameterPackage3140CParameterPackagepublic000010000000
BEGIN_CODE

END_CODE
13CParameterPackage3141~CParameterPackagepublic000110000000
BEGIN_CODE

END_CODE
13CParameterPackage3142CParameterPackage$public000010000000
BEGIN_CODE

END_CODE
13CParameterPackage3143operator=CParameterPackage&public000010000000
BEGIN_CODE

END_CODE
13CParameterPackage3144operator==intpublic000010000000
BEGIN_CODE

END_CODE
13CParameterPackage3145getHistogrammerCTCLHistogrammer&public010010000000
BEGIN_CODE

    return *m_pHistogrammer;
  
END_CODE
13CParameterPackage3146setHistogrammervoidprotected000010000000
BEGIN_CODE

    m_pHistogrammer = &rHistogrammer;
  
END_CODE
13CParameterPackage3147AddParameterInt_tpublic000010000000
BEGIN_CODE

END_CODE
13CParameterPackage3148CreateTclParameterListCTCLListpublic000010000000
BEGIN_CODE

END_CODE
13CParameterPackage3149DeleteParameterInt_tpublic000010000000
BEGIN_CODE

END_CODE
13CParameterPackage3150DeleteParameter$Int_tpublic000010000000
BEGIN_CODE

END_CODE
13CParameterPackage3151ListParameterInt_tpublic000010000000
BEGIN_CODE

END_CODE
13CParameterPackage3152ListParameter$Int_tpublic000010000000
BEGIN_CODE

END_CODE
13CParameterPackage3153getParameterInfoListStringCTCLStringpublic000010000000
BEGIN_CODE

END_CODE
13CParameterPackage3154AddPseudoInt_tpublic000010000000
BEGIN_CODE

END_CODE
13CParameterPackage3155DescribePseudoInt_tpublic000010000000
BEGIN_CODE

END_CODE
13CParameterPackage3156DeletePseudoInt_tpublic000010000000
BEGIN_CODE

END_CODE
13CParameterPackage3157GetPseudoNamesvoidpublic000010000000
BEGIN_CODE

END_CODE
14CPseudoCommand3158CPseudoCommandpublic000010000000
BEGIN_CODE
 
  
END_CODE
14CPseudoCommand3159~CPseudoCommandpublic000110000000
BEGIN_CODE
 
END_CODE
14CPseudoCommand3160CPseudoCommand$private000010000000
BEGIN_CODE

END_CODE
14CPseudoCommand3161operator=CPseudoCommand&private000010000000
BEGIN_CODE

END_CODE
14CPseudoCommand3162operator==intpublic010010000000
BEGIN_CODE

    return CTCLPackagedCommand::operator==(aCPseudoCommand);
  
END_CODE
14CPseudoCommand3163CreateInt_tpublic000010000000
BEGIN_CODE

END_CODE
14CPseudoCommand3164ListUInt_tpublic000010000000
BEGIN_CODE

END_CODE
14CPseudoCommand3165DeleteUInt_tpublic000010000000
BEGIN_CODE

END_CODE
14CPseudoCommand3166Usagevoidprotected000010000000
BEGIN_CODE

END_CODE
14CPseudoCommand3167ParseSwitchSwitchValue_tprotected000010000000
BEGIN_CODE

END_CODE
15CPseudoScript3168CPseudoScriptpublic000010000000
BEGIN_CODE

END_CODE
15CPseudoScript3169CPseudoScript$public000010000000
BEGIN_CODE

END_CODE
15CPseudoScript3170~CPseudoScriptpublic000010000000
BEGIN_CODE
 
END_CODE
15CPseudoScript3171CPseudoScript$$public000010000000
BEGIN_CODE
 
    m_vParameterNames   = aCPseudoScript.m_vParameterNames;
    m_vParameterIds     = aCPseudoScript.m_vParameterIds;
    m_sRawScriptText    = aCPseudoScript.m_sRawScriptText;
    m_ScriptProc        = aCPseudoScript.m_ScriptProc;
    m_CallStub          = aCPseudoScript.m_CallStub;  
    m_pInterpreter      = aCPseudoScript.m_pInterpreter;
    m_fEnabled          = aCPseudoScript.m_fEnabled;
   
  
END_CODE
15CPseudoScript3172operator=CPseudoScript&public000010000000
BEGIN_CODE

    if(this != &aCPseudoScript) {
      CNamedItem::operator=(aCPseudoScript);
      m_vParameterNames   = aCPseudoScript.m_vParameterNames;
      m_vParameterIds     = aCPseudoScript.m_vParameterIds;
      m_sRawScriptText    = aCPseudoScript.m_sRawScriptText;
      m_ScriptProc        = aCPseudoScript.m_ScriptProc;
      m_CallStub          = aCPseudoScript.m_CallStub;  
      m_pInterpreter      = aCPseudoScript.m_pInterpreter;
      m_fEnabled          = aCPseudoScript.m_fEnabled;
    }
    return *this;
  
END_CODE
15CPseudoScript3173operator==intpublic010010000000
BEGIN_CODE

    return ( CNamedItem::operator==(aCPseudoScript)  &&
	     (m_vParameterNames   == aCPseudoScript.m_vParameterNames) &&
	     (m_vParameterIds     == aCPseudoScript.m_vParameterIds)   &&
	     (m_sRawScriptText    == aCPseudoScript.m_sRawScriptText)  &&
	     (m_ScriptProc        == aCPseudoScript.m_ScriptProc)      &&
	     (m_CallStub          == aCPseudoScript.m_CallStub)        &&
	     (m_pInterpreter      == aCPseudoScript.m_pInterpreter)    &&
	     (m_fEnabled          == aCPseudoScript.m_fEnabled) );
     
  
END_CODE
15CPseudoScript3174operator!=intpublic010010000000
BEGIN_CODE

    return !(operator==(aCPseudoScript));
  
END_CODE
15CPseudoScript3175getParameterNamesstringpublic010010000000
BEGIN_CODE
 return m_vParameterNames;
  
END_CODE
15CPseudoScript3176getParameterIdsUInt_tpublic010010000000
BEGIN_CODE
 return m_vParameterIds;
  
END_CODE
15CPseudoScript3177getRawScriptTextstringpublic010010000000
BEGIN_CODE
 return m_sRawScriptText;
  
END_CODE
15CPseudoScript3178getOutputParameterstringpublic010010000000
BEGIN_CODE
 return getName();;
  
END_CODE
15CPseudoScript3179getOutputIdUInt_tpublic010010000000
BEGIN_CODE
 return getNumber();
  
END_CODE
15CPseudoScript3180getScriptObjectCTCLObject&public000010000000
BEGIN_CODE
 return m_ScriptProc;
  
END_CODE
15CPseudoScript3181getCallStubObjectCTCLObject&public000010000000
BEGIN_CODE
 return m_CallStub;
  
END_CODE
15CPseudoScript3182getInterpreterCTCLInterpreter*public010010000000
BEGIN_CODE
 return m_pInterpreter;
  
END_CODE
15CPseudoScript3183isEnabledBool_tpublic010010000000
BEGIN_CODE

    return m_fEnabled;
  
END_CODE
15CPseudoScript3184setParameterNamesvoidprotected000010000000
BEGIN_CODE
 
    m_vParameterNames = am_vParameterNames;
    RebuildState();
  
END_CODE
15CPseudoScript3185setParameterIdsvoidprotected000010000000
BEGIN_CODE
 
    m_vParameterIds = am_vParameterIds;
    RebuildState();
  
END_CODE
15CPseudoScript3186setOutputParametervoidprotected000010000000
BEGIN_CODE
 
    setName(am_sOutputParameter);
  
END_CODE
15CPseudoScript3187setOutputIdvoidprotected000010000000
BEGIN_CODE
 
    setNumber(am_nOutputId);
  
END_CODE
15CPseudoScript3188setInterpretervoidprotected000010000000
BEGIN_CODE
 
    m_pInterpreter = am_pInterpreter;
  
END_CODE
15CPseudoScript3189setEnabledvoidprotected000010000000
BEGIN_CODE

    m_fEnabled = newvalue;
  
END_CODE
15CPseudoScript3190AddDependentParametervoidpublic000010000000
BEGIN_CODE

END_CODE
15CPseudoScript3191AddDependentParameter$voidpublic000010000000
BEGIN_CODE

END_CODE
15CPseudoScript3192setRawScriptTextvoidpublic000010000000
BEGIN_CODE
 
    m_sRawScriptText = am_sRawScriptText;
    RebuildState();
  
END_CODE
15CPseudoScript3193ParNamesBeginstring::iteratorpublic000110000000
BEGIN_CODE

END_CODE
15CPseudoScript3194ParNamesSizeUInt_tpublic000010000000
BEGIN_CODE

END_CODE
15CPseudoScript3195ParNamesEndstring::iteratorpublic000010000000
BEGIN_CODE

END_CODE
15CPseudoScript3196ParIdsBeginUInt_t::iteratorpublic000010000000
BEGIN_CODE

END_CODE
15CPseudoScript3197ParIdsSizeUInt_tpublic000010000000
BEGIN_CODE

END_CODE
15CPseudoScript3198ParIdsEndUInt_t::iteratorpublic000010000000
BEGIN_CODE

END_CODE
15CPseudoScript3199RebuildStatevoidprotected000010000000
BEGIN_CODE

END_CODE
15CPseudoScript3200BindOutputParametervoidprotected000010000000
BEGIN_CODE

END_CODE
17CReadCommand3201CReadCommandpublic000010000000
BEGIN_CODE
 
  
END_CODE
17CReadCommand3202~CReadCommandpublic000010000000
BEGIN_CODE
 
END_CODE
17CReadCommand3203CReadCommand$private000010000000
BEGIN_CODE

END_CODE
17CReadCommand3204operator=CReadCommand&private000010000000
BEGIN_CODE

END_CODE
17CReadCommand3205operator==intpublic010010000000
BEGIN_CODE

END_CODE
17CReadCommand3206Usagevoidprotected100010000000
BEGIN_CODE

END_CODE
17CReadCommand3207NextSwitchSwitch_tprotected100010000000
BEGIN_CODE

END_CODE
17CReadCommand3208CheckInvoidprivate000010000000
BEGIN_CODE

END_CODE
17CReadCommand3209CheckOutfstream*private000010000000
BEGIN_CODE

END_CODE
17CReadCommand3210InMapboolprivate000010000000
BEGIN_CODE

END_CODE
17CReadCommand3211GetEntryvoidprivate000010000000
BEGIN_CODE

END_CODE
18CRunControlPackage3212CRunControlPackagepublic000010000000
BEGIN_CODE

END_CODE
18CRunControlPackage3213~CRunControlPackagepublic000110000000
BEGIN_CODE

END_CODE
18CRunControlPackage3214CRunControlPackage$public000010000000
BEGIN_CODE
 
                
  
END_CODE
18CRunControlPackage3215operator=CRunControlPackage&public000010000000
BEGIN_CODE
 
    if (this == &aCRunControlPackage) return *this;          
    CTCLCommandPackage::operator= (aCRunControlPackage);
  
    return *this;
  
END_CODE
18CRunControlPackage3216operator==intpublic000010000000
BEGIN_CODE
 
    return ((CTCLCommandPackage::operator== (aCRunControlPackage)));
  
END_CODE
18CRunControlPackage3217InitializeRunStatevoidpublic000010000000
BEGIN_CODE

END_CODE
18CRunControlPackage3218StartRunBool_tpublic000010000000
BEGIN_CODE

END_CODE
18CRunControlPackage3219StopRunBool_tpublic000010000000
BEGIN_CODE

END_CODE
18CRunControlPackage3220isRunningBool_tpublic000010000000
BEGIN_CODE

END_CODE
19CSpectrumCommand3221CSpectrumCommandpublic000010000000
BEGIN_CODE
 
END_CODE
19CSpectrumCommand3222~CSpectrumCommandpublic000110000000
BEGIN_CODE
 
END_CODE
19CSpectrumCommand3223CSpectrumCommand$private000010000000
BEGIN_CODE

END_CODE
19CSpectrumCommand3224operator=CSpectrumCommand&private000010000000
BEGIN_CODE

END_CODE
19CSpectrumCommand3225operator==intpublic000010000000
BEGIN_CODE
 
    return ((CTCLPackagedCommand::operator== (aCSpectrumCommand)));
  
END_CODE
19CSpectrumCommand3226Usagevoidprotected100010000000
BEGIN_CODE

END_CODE
19CSpectrumCommand3227MatchSwitchSwitchprotected100010000000
BEGIN_CODE

END_CODE
19CSpectrumCommand3228SortSpectraByIdvoidprotected000010000000
BEGIN_CODE

END_CODE
19CSpectrumCommand3229SortSpectraByNamevoidprotected000010000000
BEGIN_CODE

END_CODE
19CSpectrumCommand3230VectorToResultvoidprotected100010000000
BEGIN_CODE

END_CODE
19CSpectrumCommand3231ExtractIdUInt_tpublic000010000000
BEGIN_CODE

END_CODE
19CSpectrumCommand3232ExtractNamestd::stringpublic000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3233CSpectrumPackagepublic000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3234~CSpectrumPackagepublic000110000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3235CSpectrumPackage$private000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3236operator=CSpectrumPackage&private000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3237operator==intpublic000010000000
BEGIN_CODE
 return (
	    (CTCLCommandPackage::operator== (aCSpectrumPackage)) &&
	    (m_pHistogrammer == m_pHistogrammer)
	    );
  
END_CODE
20CSpectrumPackage3238getNextIdUInt_tpublic100010000000
BEGIN_CODE

    return m_nNextId;
  
END_CODE
20CSpectrumPackage3239getHistogrammerCHistogrammer*public010010000000
BEGIN_CODE

    return m_pHistogrammer;
  
END_CODE
20CSpectrumPackage3240setHistogrammervoidprotected000010000000
BEGIN_CODE
 
    m_pHistogrammer = am_pHistogrammer;
  
END_CODE
20CSpectrumPackage3241setNextIdvoidprotected100010000000
BEGIN_CODE
 
    m_nNextId = am_nNextId;
  
END_CODE
20CSpectrumPackage3242AllocateIdUInt_tprotected100010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3243CreateSpectrumintpublic000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3244ListSpectravoidpublic000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3245ListSpectrumInt_tpublic000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3246ListSpectrum$Int_tpublic000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3247ClearAllvoidpublic000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3248ClearSubsetInt_tpublic000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3249ClearSubset$Int_tpublic000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3250BindAllInt_tpublic000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3251BindListInt_tpublic000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3252BindList$Int_tpublic000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3253UnbindListInt_tpublic000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3254UnbindList$Int_tpublic000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3255UnbindXidListInt_tpublic000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3256UnbindAllvoidpublic000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3257DeleteListInt_tpublic000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3258DeleteList$Int_tpublic000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3259DeleteAllvoidpublic000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3260ListBindingsInt_tpublic000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3261ListBindings$Int_tpublic000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3262ListXidBindingsInt_tpublic000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3263ListAllBindingsvoidpublic000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3264GetChannelBool_tpublic000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3265SetChannelBool_tpublic000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3266WriteInt_tpublic000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3267ReadInt_tpublic000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3268DescribeSpectrumstd::stringprotected000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3269FindDisplayBindingUInt_tprotected000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3270FindDisplayBinding$UInt_tprotected000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3271FormatBindingvoidprotected000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3272SpecTypeToTextchar*public110010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3273DataTypeToTextchar*public110010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3274SpectrumTypeSpectrumType_tpublic100010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3275DatatypeDataType_tpublic100010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3276ValidateIndicesUInt_t*public100010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3277UniquifyNamevoidpublic000010000000
BEGIN_CODE

END_CODE
20CSpectrumPackage3278AllParamsExistBool_tpublic000010000000
BEGIN_CODE

END_CODE
21CStartRun3279CStartRunpublic000010000000
BEGIN_CODE
 
END_CODE
21CStartRun3280~CStartRunpublic000110000000
BEGIN_CODE
 
END_CODE
21CStartRun3281CStartRun$private000010000000
BEGIN_CODE

END_CODE
21CStartRun3282operator=CStartRun&private000010000000
BEGIN_CODE

END_CODE
21CStartRun3283operator==intpublic000010000000
BEGIN_CODE
 
    return (
	    (CTCLPackagedCommand::operator== (aCStartRun))

	    );
  
END_CODE
22CStopRun3284CStopRunpublic000010000000
BEGIN_CODE
 
END_CODE
22CStopRun3285~CStopRunpublic000110000000
BEGIN_CODE
 
END_CODE
22CStopRun3286CStopRun$private000010000000
BEGIN_CODE

END_CODE
22CStopRun3287operator=CStopRun&private000010000000
BEGIN_CODE

END_CODE
22CStopRun3288operator==intpublic000010000000
BEGIN_CODE
 return (
	    (CTCLPackagedCommand::operator== (aCStopRun)) 
	    );
  
END_CODE
23CTapeCommand3289CTapeCommandpublic000010000000
BEGIN_CODE
}
END_CODE
23CTapeCommand3290~CTapeCommandpublic000110000000
BEGIN_CODE
 
END_CODE
23CTapeCommand3291CTapeCommand$private000010000000
BEGIN_CODE

END_CODE
23CTapeCommand3292operator=CTapeCommand&private000010000000
BEGIN_CODE

END_CODE
23CTapeCommand3293operator==intpublic000010000000
BEGIN_CODE
 
    return ((CTCLPackagedCommand::operator== (aCTapeCommand)) );
  
END_CODE
23CTapeCommand3294Usagevoidprotected100010000000
BEGIN_CODE

END_CODE
23CTapeCommand3295ParseSwitchSwitch_tprotected100010000000
BEGIN_CODE

END_CODE
24CTclAnalyzer3296CTclAnalyzerpublic000010000000
BEGIN_CODE

END_CODE
24CTclAnalyzer3297~CTclAnalyzerpublic000010000000
BEGIN_CODE
 
    delete m_pBuffersAnalyzed;
    delete m_pLastSequence;
  
END_CODE
24CTclAnalyzer3298CTclAnalyzer$public000010000000
BEGIN_CODE

      m_pBuffersAnalyzed = new CTCLVariable(*(rSrc.m_pBuffersAnalyzed));
      m_pLastSequence    = new CTCLVariable(*(rSrc.m_pLastSequence));
  
END_CODE
24CTclAnalyzer3299operator=CTclAnalyzer&public000010000000
BEGIN_CODE
 // Assignment
    if(this != &rSrc) {
      CAnalyzer::operator=(rSrc);
      delete m_pBuffersAnalyzed;
      delete m_pLastSequence;
      m_pBuffersAnalyzed = new CTCLVariable(*(rSrc.m_pBuffersAnalyzed));
      m_pLastSequence    = new CTCLVariable(*(rSrc.m_pLastSequence));
    }
    return *this;
  
END_CODE
24CTclAnalyzer3300OnPhysicsvoidpublic000110000000
BEGIN_CODE

END_CODE
24CTclAnalyzer3301OnStateChangevoidpublic000110000000
BEGIN_CODE

END_CODE
24CTclAnalyzer3302IncrementVariablevoidprotected100010000000
BEGIN_CODE

END_CODE
24CTclAnalyzer3303SetVariablevoidprotected100010000000
BEGIN_CODE

END_CODE
24CTclAnalyzer3304ClearVariablevoidprotected100010000000
BEGIN_CODE

    SetVariable(rVar, 0);
  
END_CODE
24CTclAnalyzer3305OnBeginvoidpublic000010000000
BEGIN_CODE

END_CODE
24CTclAnalyzer3306OnEndvoidpublic000010000000
BEGIN_CODE

END_CODE
24CTclAnalyzer3307OnPausevoidpublic000010000000
BEGIN_CODE

END_CODE
24CTclAnalyzer3308OnResumevoidpublic000010000000
BEGIN_CODE

END_CODE
24CTclAnalyzer3309AddEventProcessorvoidpublic000010000000
BEGIN_CODE

END_CODE
24CTclAnalyzer3310OnEventAcceptedvoidpublic000010000000
BEGIN_CODE

END_CODE
24CTclAnalyzer3311OnEventRejectedvoidpublic000010000000
BEGIN_CODE

END_CODE
25CTCLHistogrammer3312CTCLHistogrammerpublic000010000000
BEGIN_CODE

END_CODE
25CTCLHistogrammer3313~CTCLHistogrammerpublic000110000000
BEGIN_CODE

END_CODE
25CTCLHistogrammer3314CTCLHistogrammer$public000010000000
BEGIN_CODE
     
    m_pIntObject = aCTCLHistogrammer.m_pIntObject;
    m_Pseudos    = aCTCLHistogrammer.m_Pseudos;
  
END_CODE
25CTCLHistogrammer3315operator=CTCLHistogrammer&public000010000000
BEGIN_CODE

END_CODE
25CTCLHistogrammer3316operator==intpublic000010000000
BEGIN_CODE

END_CODE
25CTCLHistogrammer3317getInterpreterCTCLInterpreter*public010010000000
BEGIN_CODE
 
    return m_pIntObject;
  
END_CODE
25CTCLHistogrammer3318getPseudoParametersPseudoParameterspublic010010000000
BEGIN_CODE

    return m_Pseudos;
  
END_CODE
25CTCLHistogrammer3319setInterpretervoidprotected000010000000
BEGIN_CODE
 
    m_pIntObject = am_pIntObject;
  
END_CODE
25CTCLHistogrammer3320setPseudoParametersvoidprotected000010000000
BEGIN_CODE

    m_Pseudos = rPseudos;
  
END_CODE
25CTCLHistogrammer3321AddPseudovoidpublic000110000000
BEGIN_CODE

END_CODE
25CTCLHistogrammer3322RemovePseudovoidpublic000010000000
BEGIN_CODE

END_CODE
25CTCLHistogrammer3323FindPseudoCPseudoScript&public000010000000
BEGIN_CODE

END_CODE
25CTCLHistogrammer3324PseudoBeginPseudoParameterIteratorpublic000010000000
BEGIN_CODE

END_CODE
25CTCLHistogrammer3325PseudoEndPseudoParameterIteratorpublic000010000000
BEGIN_CODE

END_CODE
25CTCLHistogrammer3326PseudoSizeUInt_tpublic000010000000
BEGIN_CODE

END_CODE
26CUnbindCommand3327CUnbindCommandpublic000010000000
BEGIN_CODE
 
END_CODE
26CUnbindCommand3328~CUnbindCommandpublic000110000000
BEGIN_CODE
 
END_CODE
26CUnbindCommand3329CUnbindCommand$private000010000000
BEGIN_CODE

END_CODE
26CUnbindCommand3330operator=CUnbindCommand&private000010000000
BEGIN_CODE

END_CODE
26CUnbindCommand3331operator==intpublic000010000000
BEGIN_CODE
 
    return ((CTCLPackagedCommand::operator== (aCUnbindCommand)));
  
END_CODE
26CUnbindCommand3332Usagevoidprotected100010000000
BEGIN_CODE

END_CODE
26CUnbindCommand3333MatchSwitchSwitchprotected100010000000
BEGIN_CODE

END_CODE
27CUngateCommand3334CUngateCommandpublic000010000000
BEGIN_CODE
     
  
END_CODE
27CUngateCommand3335~CUngateCommandpublic000010000000
BEGIN_CODE
 
END_CODE
27CUngateCommand3336CUngateCommand$private000010000000
BEGIN_CODE

END_CODE
27CUngateCommand3337operator=CUngateCommand&private000010000000
BEGIN_CODE

END_CODE
27CUngateCommand3338operator==intpublic010010000000
BEGIN_CODE

    return CTCLPackagedCommand::operator==(aCUngateCommand);
  
END_CODE
27CUngateCommand3339Usagestringprotected100010000000
BEGIN_CODE

END_CODE
28CWriteCommand3340CWriteCommandpublic000010000000
BEGIN_CODE
 
  
END_CODE
28CWriteCommand3341~CWriteCommandpublic000010000000
BEGIN_CODE
 
END_CODE
28CWriteCommand3342CWriteCommand$private000010000000
BEGIN_CODE

END_CODE
28CWriteCommand3343operator=CWriteCommand&private000010000000
BEGIN_CODE

END_CODE
28CWriteCommand3344operator==intpublic010010000000
BEGIN_CODE

END_CODE
28CWriteCommand3345IsFileIdBool_tprotected100010000000
BEGIN_CODE

END_CODE
28CWriteCommand3346GetFileIdInt_tprotected100010000000
BEGIN_CODE

END_CODE
28CWriteCommand3347GetFormatterCSpectrumFormatter*protected100010000000
BEGIN_CODE

END_CODE
28CWriteCommand3348Usagevoidprotected100010000000
BEGIN_CODE

END_CODE
29CXamineEventHandler3349CXamineEventHandlerpublic000010000000
BEGIN_CODE
 
    Set(TK_READABLE);		// Starts out enabled.
  
END_CODE
29CXamineEventHandler3350~CXamineEventHandlerpublic000110000000
BEGIN_CODE
 
END_CODE
29CXamineEventHandler3351CXamineEventHandler$public000010000000
BEGIN_CODE
 
   
    setHistogrammer(aCXamineEventHandler.m_pHistogrammer);

  
END_CODE
29CXamineEventHandler3352operator=CXamineEventHandler&public000010000000
BEGIN_CODE

    if(this != &aCXamineEventHandler) {
      setHistogrammer(aCXamineEventHandler.m_pHistogrammer);
    }
    return *this;
  
END_CODE
29CXamineEventHandler3353operator==intpublic010010000000
BEGIN_CODE

    return ( CTCLFileHandler::operator==(aCXamineEventHandler)      &&
	     (m_pHistogrammer == aCXamineEventHandler.m_pHistogrammer));
  
END_CODE
29CXamineEventHandler3354getHistogrammerCHistogrammer*public010010000000
BEGIN_CODE
 
    return m_pHistogrammer;
  
END_CODE
29CXamineEventHandler3355setHistogrammervoidprotected000010000000
BEGIN_CODE
 
    Clear();			// Disable callback on current fid.
    m_pHistogrammer = m_pHistogrammer;
    setFid(m_pHistogrammer->getDisplayer()->GetEventFd()); // Update file id.
    Set(TK_READABLE);		// Set callback on next fid.
  
END_CODE
29CXamineEventHandler3356OnGatevoidprotected000110000000
BEGIN_CODE

END_CODE
29CXamineEventHandler3357OnButtonvoidprotected000110000000
BEGIN_CODE

END_CODE
59CTclGrammerApp3358RegisterEventProcessorvoidMutatorpublicAdd an event processor to the list of event processors 

maintained by SpecTcl's analyzer.  This can only be 

safely called at the time or after the time that 

CreateAnalysisPipeline is called, since prior to that 

there's no assurance that the analyzer has been instantiated.Add event processor to pipeline tail000010000000
BEGIN_CODE

END_CODE
59CTclGrammerApp3359BindTCLVariablesvoidOperationpublicCalled to bind variables to the TCL interpreter used by SpecTcl.

This member can be overidden, however for SpecTcl to work

correctly it must be overridden as an extension, that is

there should be as the first action a call to:



CTclGrammerApp::BindTCLVariablesBind any CTCLVariables to interpreter.000110000000
BEGIN_CODE

END_CODE
59CTclGrammerApp3360SourceLimitScriptsvoidBehaviorpublicSources initialization scripts.  The scripts

sourced at this point in time are intended to

allow additional variables to be defined and set

as well as limits etc.  It is not safe to do 

arbitrary SpecTcl commands at this point.

Additional 'functional' scripts can be sourced

from an overridden operator()  Note that the

default implementation can be overridden, however it

sources scripts which set various limit variables and

therefore an override should include the code:



CTclGrammerApp::operator()(rInterpreter);

Source variable definition scripts.000110000000
BEGIN_CODE

END_CODE
59CTclGrammerApp3361SetLimitsvoidBehaviorpublicBased on script variables etc. set limits and other statically defined variables.

The default implementation uses this to set the final values for the size of

the display subsystem shared memory, the parameter array size and the

size of the event list.  If this method is overridden, you should call the

base class functionality to ensure that SpecTcl is properly started:



CTclGrammerApp::SetLimits();Finalize limit variables.000110000000
BEGIN_CODE

END_CODE
59CTclGrammerApp3362CreateHistogrammervoidBehaviorpublicCreate the Histogrammer object and link it in as

SpecTcl's data sink.  This behavior can be overidden.

If a different data sink object is created, the global

variable:  gpEventSink must be set to point to it.Link Histogramer sink to SpecTcl.000110000000
BEGIN_CODE

END_CODE
59CTclGrammerApp3363SelectDisplayervoidBehaviorpublicSelects the displayer and hooks it into the histogrammer.  

Note:  In the current architecture, this is a No-Op, however,

in the future, we will support turning on and off displayers, null

displayers and so on and this member function will be useful

at that time.Link Histogrammer to Displayer000110000000
BEGIN_CODE

END_CODE
59CTclGrammerApp3364SetupTestDataSourcevoidBehaviorpublicSets up a test (internal) data source.  The default

behavior is to create  fixed length event with some

gaussian distributions for parameters.  This source is

used by SpecTcl developers to test functionality without

referring to real data.  Note that an eventsource is currently 

necessary to create and setup the run control object. Set up test data source.000110000000
BEGIN_CODE

END_CODE
59CTclGrammerApp3365CreateAnalyzervoidBehavioralpublicCreates a data analyzer.  The histogrammer

in gpEventSink is set as the analyzer's event sink.

Note that by default a CTclAnalyzer is created.

Create the event analyzer.000110000000
BEGIN_CODE

END_CODE
59CTclGrammerApp3366SelectDecodervoidBehavioralpublicSelects the Buffer decoder to be associated with the

data stream.  The default is to instantiate an NSCLBufferDecoder,

connect it to the global pointer: gpBufferDecoder  and in turn

to the analyzer.Select Buffer Decoder.000110000000
BEGIN_CODE

END_CODE
59CTclGrammerApp3367CreateAnalysisPipelinevoidBehavioralpublicThis must be provided by the subclass.  The experimenter

must set up the analysis pipeline which manages the

data received from the data source.  This pipeline

consists of an ordered set of CEventProcessor 

derived objects.Create the event pipeline.001110000000
BEGIN_CODE

END_CODE
59CTclGrammerApp3368AddCommandsvoidBehavioralpublicRegisters the commands and command packages

which make up SpecTcl.  Note that the default

method registers the standard SpecTcl commands.

If an override is supplied to add user commands, you 

must invoke the base class function at some point:



CTclGrammerApp::AddCommands(rInterp);000110000000
BEGIN_CODE

END_CODE
59CTclGrammerApp3369SetupRunControlvoidpublic000010000000
BEGIN_CODE

END_CODE
59CTclGrammerApp3370SourceFunctionalScriptsvoidBehavioralpublicThis function provides an opportunity to 

source scripts which perform functional 

operations either in spectcl or in other (e.g. Tk, Blt)

packages which are now all hooked together properly.

Do functional Tcl initialization.000110000000
BEGIN_CODE

END_CODE
59CTclGrammerApp3371operator()intEntry pointpublicCalled when the tcl interpreter starts up.  The base 

functionality is to call the action member functions

(e.g. CreateAnalyzer) in the appropriate order.  This

an be extended by overriding and delegating the 

operation to the base class or by writing an entirely

new startup scheme as desired.

SpecTcl entry point.000110000000
BEGIN_CODE

END_CODE
60CMySpecTclApp3372BindTCLVariablesvoidoverridepublic Add code to this function to bind any TCL variable to

 the SpecTcl interpreter.  Note that at this time,

 variables have not yet been necessarily created so you

 can do Set but not necessarily Get operations.



000110000000
BEGIN_CODE
CTclGrammerApp::BindTCLVariables(rInterp);
END_CODE
60CMySpecTclApp3373SourceLimitScriptsvoidOverridepublicAdd code here to source additional variable setting

scripts.  At this time the entire SpecTcl/Tk infrastructure

is not yet set up.  Scripts run at this stage can only run

basic Tcl/Tk commands, and not SpecTcl extensions.

Typically, this might be used to set a bunch of initial values

for variables which were bound in BindTCLVariables.000110000000
BEGIN_CODE
CTclGrammerApp::SourceLimitScripts(rInterpreter);
END_CODE
60CMySpecTclApp3374SetLimitsvoidoveridepublicCalled after BindVariables and SourceLimitScripts.

This function can be used to fetch values of bound Tcl

variables which were modified/set by the limit scripts to

update program default values. 000110010000
BEGIN_CODE
CTclGrammerApp::SetLimits();
END_CODE
60CMySpecTclApp3375CreateHistogrammervoidOverridepublicCreates the histogramming data sink.  If you want to override

this in general you probably won't make use of the actual

base class function.  You might, however extend this by 

defining a base set of parameters and histograms from within

the program.000110010000
BEGIN_CODE
CTclGrammerApp::CreateHistogrammer();
END_CODE
60CMySpecTclApp3376SelectDisplayervoidOverride.publicSelect a displayer object and link it to the

histogrammer.  The default code will link Xamine

to the displayer, and set up the Xamine event handler

to deal with gate objects accepted by Xamine interaction.000110010000
BEGIN_CODE
CTclGrammerApp::SelectDisplayer(nDisplaySize, rHistogrammer);
END_CODE
60CMySpecTclApp3377SetupTestDataSourcevoidOverridepublic Allows you to set up a test data source.  At

present, SpecTcl must have a data source of some sort

connected to it... The default test data source produces a 

fixed length event where all parameters are selected from

a gaussian distribution.  If you can figure out how to do it,

you can setup your own data source... as long as you don't

start analysis, the default one is harmless.000110010000
BEGIN_CODE
CTclGrammerApp::SetupTestDataSource();
END_CODE
60CMySpecTclApp3378CreateAnalyzervoidOverridepublicCreates an analyzer.  The Analyzer is connected to the data

source which supplies buffers.  Connected to the analyzer is a

buffer decoder and an event unpacker.  The event unpacker is 

the main experiment dependent chunk of code, not the analyzer.

The analyzer constructed by the base class is a CTclAnalyzer instance.

This is an analyzer which maintains statistics about itself in Tcl Variables.000110010000
BEGIN_CODE
CTclGrammerApp::CreateAnalyzer(pSink);
END_CODE
60CMySpecTclApp3379SelectDecodervoidOverridepublic  Selects a decoder and attaches it to the analyzer.

A decoder is responsible for knowing the overall structure of

a buffer produced by a data analysis system.  The default code

constructs a CNSCLBufferDecoder object which knows the format

of NSCL buffers.000110010000
BEGIN_CODE
CTclGrammerApp::SelectDecoder(rAnalyzer);
END_CODE
60CMySpecTclApp3380CreateAnalysisPipelinevoidOverridepublic  Sets up an analysis pipeline.  This function is required and must

be filled in by the SpecTcl user.  Pipeline elements are objects

which are members of classes derived from the CEventProcessor

class. They should be added to the Analyzer's event processing pipeline

by calling RegisterEventProcessor (non virtual base class member).

   The sample implementation in this

file produces a two step pipeline.  The first step decodes a fixed length

event into the CEvent array.  The first parameter is put into index 1 and so on.

The second step produces a compiled pseudo parameter by adding event array

elements 1 and 2 and putting the result into element 0.

000110010000
BEGIN_CODE

END_CODE
60CMySpecTclApp3381AddCommandsvoidOverridepublicThis function adds commands to extend Tcl/Tk/SpecTcl.

The base class function registers the standard SpecTcl command

packages.  Your commands can be registered at this point.

Do not remove the sample code or the SpecTcl commands will

not get registered.000110010000
BEGIN_CODE
CTclGrammerApp::AddCommands(rInterp);
END_CODE
60CMySpecTclApp3382SetupRunControlvoidOverride.public  Sets up the Run control object.  The run control object

is responsible for interacting with the underlying operating system

and programming framework to route data from the data source to 

the SpecTcl analyzer.  The base class object instantiates a 

CTKRunControl object.  This object uses fd waiting within the 

Tcl/TK event processing loop framework to dispatch buffers for

processing as they become available.000110010000
BEGIN_CODE
CTclGrammerApp::SetupRunControl();
END_CODE
60CMySpecTclApp3383SourceFunctionalScriptsvoidOverridepublic  This function allows the user to source scripts

which have access to the full Tcl/Tk/SpecTcl

command set along with whatever extensions have been

added by the user in AddCommands.  000110010000
BEGIN_CODE
CTclGrammerApp::SourceFunctionalScripts(rInterp);
END_CODE
60CMySpecTclApp3384operator()intOverride.public  Entered at Tcl/Tk initialization time (think of this

as the entry point of the SpecTcl program).  The base

class default  implementation calls the member functions

of this class in an appropriate order.  It's possible for the user

to extend this functionality by adding code to this function.000110010000
BEGIN_CODE
CTclGrammerApp::operator()();
END_CODE
61CEventProcessor3385OnAttachBool_tDefault methodpublicCalled once when the event processor is

registered on the analyzer.  The default action

is null.  If this member returns kfFALSE,

the registration is aborted with an error message.Called on registration000110000000
BEGIN_CODE
return kfTRUE;
END_CODE
61CEventProcessor3386OnBeginBool_tDefault BehaviorpublicCalled when a begin run buffer/event is received.

If kfFALSE is returned, the pipeline is silently aborted.Begin Run000110000000
BEGIN_CODE
return kfTRUE;
END_CODE
61CEventProcessor3387OnEndBool_tDefault behaviorpublicCalled when an end of run event/buffer is received.

If kfFALSE is returned, the processing pipeline is 

silently aborted.  The default implementation is a

no-op returning kfTRUEEnd Run000110000000
BEGIN_CODE
return kfTRUE;
END_CODE
61CEventProcessor3388OnPauseBool_tDefault BehaviorpublicCalled when a pause run event/buffer is received.

Returning kfFALSE will silently abort the remainder of the

event pipeline.  The default is an no-op which returns kfTRUEPause Run.000110000000
BEGIN_CODE
return kfTRUE;
END_CODE
61CEventProcessor3389OnResumeBool_tDefault BehaviorpublicCalled when a resume run event/buffer is received

If this function returns kfFALSE, the remainder of the

event pipeline is silently aborted.  The default 

implementation is a no-op which returns kfTRUE.Resume Run000110000000
BEGIN_CODE
return kfTRUE;
END_CODE
61CEventProcessor3390operator()Bool_tBase class behaviorpublicThis member is called whenever a physics event is 

received.  At least one of the processors in the processing

pipeline must call the analyzer's SetEventSize() member function.

This member informs the analyzer how many bytes are in the raw event.

Other useful members involved in that are:

IncrementEventSize(int nSize=2)      - Adds to the current event size.

GetEventSize()                                 - Retrieves the current event size.



If the function returns kfFALSE, the entire event processing pipeline is 

aborted and the unpacked event being construction is not sent on

to the event sink.Physics Event000110000000
BEGIN_CODE
return kfTRUE;
END_CODE
***END_TABLE***

Parameters
OperID, Parameter Text
***BEGIN_TABLE***
3004 CTCLInterpreter*/pInterp//
3004 CTCLCommandPackage&/rPack//
3006 const  CApplyCommand&/aCApplyCommand//
3007 const  CApplyCommand&/aCApplyCommand//
3008 const  CApplyCommand&/aCApplyCommand//
3010 char* CTCLInterpreter*/pInterp//
3010 CTCLCommandPackage&/rPackage//
3012 const  CAttachCommand&/aCAttachCommand//
3013 const  CAttachCommand&/aCAttachCommand//
3014 const  CAttachCommand&/aCAttachCommand//
3015 char* CTCLResult&/rResult//
3016 char*/pSwitch//
3017 CTCLInterpreter*/pInterp//
3017 CTCLCommandPackage&/rPack//
3019 const  CBindCommand&/aCBindCommand//
3020 const  CBindCommand&/aCBindCommand//
3021 const  CBindCommand&/aCBindCommand//
3022 CTCLInterpreter&/rInterp//
3022 CTCLResult&/rResult//
3023 char* CTCLInterpreter&/rInterp//
3023 CTCLResult&/rResult//
3024 char* const  char*/pSwitch//
3025 CTCLResult&/rResult//
3026 CTCLInterpreter*/pInterp//
3026 CTCLCommandPackage&/rPackage//
3028 const  ChannelCommand&/aChannelCommand//
3029 CTCLInterpreter*/aInt_t//
3029 string&/aInt_t//
3030 const  ChannelCommand&/aChannelCommand//
3031 const  ChannelCommand&/aChannelCommand//
3032 char* const  char*/pSwitch//
3033 CTCLResult&/rResult//
3034 CTCLInterpreter*/pInterp//
3034 CTCLCommandPackage&/rPack//
3036 const  CClearCommand&/aCClearCommand//
3037 const  CClearCommand&/aCClearCommand//
3038 const  CClearCommand&/aCClearCommand//
3039 char* CTCLResult&/rResult//
3040 const  char*/pSwitchText//
3041 CTCLInterpreter*/pInterp//
3043 const  CDataSourcePackage&/aCDataSourcePackage//
3044 const  CDataSourcePackage&/aCDataSourcePackage//
3045 const  CDataSourcePackage&/aCDataSourcePackage//
3049 SourceType_t/am_eSourceType//
3050 CTapeCommand*/pTape//
3051 CAttachCommand*/pAttach//
3052 CTCLResult&/rResult//
3053 CTCLResult&/rResult//
3053 const  char*/pDevice//
3054 CTCLResult&/rResult//
3055 CTCLResult&/rResult//
3055 const  char*/pConnectionString//
3055 UInt_t/nBufferSize//
3056 CTCLResult&/rResult//
3057 CTCLResult&/rResult//
3058 CTCLResult&/rResult//
3065 const  CGateCommand&/aCGateCommand//
3066 const  CGateCommand&/aCGateCommand//
3067 char* char*/pKey//
3069 const  char*/pGateType//
3070 CHistogrammer*/pHistogrammer//
3072 const  CGateFactory&/aCGateFactory//
3073 const  CGateFactory&/aCGateFactory//
3074 const  CGateFactory&/aCGateFactory//
3076 CHistogrammer*/am_pHistogrammer//
3077 GateType/nGateType//
3077 const  vector<string>&/rGates//
3078 GateType/eType//
3078 const  vector<string>&/rParameters//
3078 const  vector<CPoint>&/rPoints//
3082 const  vector<string>&/rParameters//
3082 const  vector<CPoint>&/rPoints//
3083 const  vector<string>&/rParameters//
3083 const  vector<CPoint>&/rPoints//
3084 const  vector<string>&/rBands//
3085 const  string&/rGateNames//
3086 const  vector<string>&/rGateNames//
3087 const  vector<string>&/rGateNames//
3088 const  string&/rParameterName//
3088 UInt_t/nLow//
3088 UInt_t/nHigh//
3089 const  string&/rName//
3089 GateType/eType//
3089 const  char*/pWhich//
3090 const  string&/rName//
3090 GateType/eType//
3090 const  char*/pWhich//
3091 list<CGateContainer*>&/Gates//
3091 const  vector<string>&/rNames//
3091 GateType/eType//
3091 const  char*/pWhich//
3092 GateFactoryExceptionReason/eReason//
3092 CGateFactory::GateType/eType//
3092 const  string&/rDoing//
3094 const  CGateFactoryException&/aCGateFactoryException//
3095 const  CGateFactoryException&/aCGateFactoryException//
3096 const  CGateFactoryException&/aCGateFactoryException//
3100 const  GateFactoryExceptionReason/am_eReason//
3101 const  CGateFactory::GateType/am_eGateType//
3102 char**/am_svReasonTexts//
3105 GateFactoryExceptionReason/eReason//
3106 CTCLInterpreter*/pInterp//
3106 CHistogrammer*/pHistogrammer//
3108 const  CGatePackage&/aCGatePackage//
3109 const  CGatePackage&/aCGatePackage//
3110 const  CGatePackage&/aCGatePackage//
3116 CHistogrammer*/am_pHistogrammer//
3117 CGateCommand*/p//
3118 CApplyCommand*/p//
3119 CUngateCommand*/p//
3120 UInt_t/n//
3121 CTCLResult&/rResult//
3121 const  std::string&/rGateName//
3121 const  CGate*/pGate//
3124 CTCLResult&/rResult//
3124 const  vector<string>&/rGateNames//
3125 CTCLResult&/rResult//
3125 const  vector<UInt_t>&/rIds//
3126 CTCLString&/rResult//
3126 const  string&/rGateName//
3126 const  string&/rSpectrumName//
3127 CTCLString&/rApplication//
3127 const  string&/rName//
3128 CTCLString&/rResult//
3128 const  string&/rName//
3129 CGateContainer*/pGate//
3131 vector<CGateContainer*>&/rpGates//
3132 CTCLInterpreter*/pInterp//
3132 CTCLCommandPackage&/rPackage//
3134 const  CParameterCommand&/aCParameterCommand//
3135 const  CParameterCommand&/aCParameterCommand//
3136 const  CParameterCommand&/aCParameterCommand//
3137 Char_t* CTCLInterpreter&/rInterp//
3137 CTCLResult&/rResult//
3138 const  char*/pSwitch//
3139 CTCLResult&/rResult//
3140 CTCLInterpreter*/pInterp//
3140 CTCLHistogrammer*/rHistogrammer//
3142 const  CParameterPackage&/aCParameterPackage//
3143 const  CParameterPackage&/aCParameterPackage//
3144 const  CParameterPackage&/aCParameterPackage//
3146 CTCLHistogrammer&/rHistogrammer//
3147 CTCLResult&/rResult//
3147 const  char*/pName//
3147 UInt_t/nId//
3147 UInt_t/nBits//
3148 CTCLInterpreter&/rInterp//
3149 CTCLResult&/rResult//
3149 const  char*/pName//
3150 CTCLResult&/rResult//
3150 UInt_t/nId//
3151 CTCLResult&/rResult//
3151 const  char*/pName//
3152 CTCLResult&/rResult//
3152 UInt_t/nId//
3153 CParameter&/rParameter//
3154 CTCLResult&/rResult//
3154 const  char*/pPseudoName//
3154 vector<string>&/rDependents//
3154 const  char*/pBody//
3155 const  string&/rName//
3155 string&/rDescription//
3156 const  string&/rName//
3156 string&/rResult//
3157 list<string>&/rNames//
3158 CTCLInterpreter*/pInterp//
3158 CTCLCommandPackage&/rPackage//
3160 const  CPseudoCommand&/aCPseudoCommand//
3161 const  CPseudoCommand&/aCPseudoCommand//
3162 const  CPseudoCommand&/aCPseudoCommand//
3163 CTCLInterpreter&/rInterp//
3163 CTCLResult&/rResult//
3163 UInt_t/nArgs//
3163 char**/pArgs//
3164 CTCLInterpreter&/rInterp//
3164 CTCLResult&/rResult//
3164 UInt_t/nArgs//
3164 char**/pArgs//
3165 CTCLInterpreter&/rInterp//
3165 CTCLResult&/rResult//
3165 UInt_t/nArgs//
3165 char**/pArgs//
3166 CTCLResult&/rResult//
3167 const  char*/pSwitch//
3168 const  string&/rName//
3168 CTCLInterpreter*/pInterp//
3168 CHistogrammer&/rHistogrammer//
3169 const  string&/rName//
3169 vector<string>&/rDependentParameters//
3169 CHistogrammer&/rHistogrammer//
3169 CTCLInterpreter*/pInterp//
3169 const  string&/ScriptText//
3171 const  CPseudoScript&/aCPseudoScript//
3172 const  CPseudoScript&/aCPseudoScript//
3173 const  CPseudoScript&/aCPseudoScript//
3174 const  CPseudoScript&/aCPseudoScript//
3184 const  list<string>/am_vParameterNames//
3185 const  list<UInt_t>/am_vParameterIds//
3186 const  string/am_sOutputParameter//
3187 const  UInt_t/am_nOutputId//
3188 CTCLInterpreter*/am_pInterpreter//
3189 Bool_t/newvalue//
3190 const  string&/rName//
3190 CHistogrammer&/rHisto//
3191 UInt_t/nId//
3191 CHistogrammer&/rHisto//
3192 const  string/am_sRawScriptText//
3200 const  string&/rName//
3200 CHistogrammer&/rHistogrammer//
3201 CTCLInterpreter*/pInterp//
3201 CTCLCommandPackage&/rPack//
3203 const  CReadCommand&/aCReadCommand//
3204 const  CReadCommand&/aCReadCommand//
3205 const  CReadCommand&/aCReadCommand//
3206 CTCLResult&/rResult//
3207 const  char*/pText//
3208 fstream*/avoid//
3208 int/avoid//
3209 int/afstream*//
3210 int/abool//
3211 StreamEntry&/avoid//
3211 int/avoid//
3212 CTCLInterpreter*/pInterp//
3214 const  CRunControlPackage&/aCRunControlPackage//
3215 const  CRunControlPackage&/aCRunControlPackage//
3216 const  CRunControlPackage&/aCRunControlPackage//
3221 CTCLInterpreter*/pInterp//
3221 CTCLCommandPackage&/rPackage//
3223 const  CSpectrumCommand&/aCSpectrumCommand//
3224 const  CSpectrumCommand&/aCSpectrumCommand//
3225 const  CSpectrumCommand&/aCSpectrumCommand//
3226 char* CTCLResult&/rResult//
3227 const  char*/pSwitch//
3228 std::vector<std::string>&/rvProperties//
3229 std::vector<std::string>&/rvProperties//
3230 CTCLResult&/rResult//
3230 std::vector<std::string>&/rvStrings//
3231 const  std::string&/rProperties//
3232 const  std::string&/rProperties//
3233 CTCLInterpreter*/pInterp//
3233 CHistogrammer*/pHistogrammer//
3235 const  CSpectrumPackage&/aCSpectrumPackage//
3236 const  CSpectrumPackage&/aCSpectrumPackage//
3237 const  CSpectrumPackage&/aCSpectrumPackage//
3240 CHistogrammer*/am_pHistogrammer//
3241 UInt_t/am_nNextId//
3243 CTCLResult&/rResult//
3243 const  char*/pName//
3243 const  char*/pSpecType//
3243 std::vector<std::string>&/rvParameterNames//
3243 std::vector<UInt_t>&/rvResolutions//
3243 const  char*/pDataType//
3244 std::vector<std::string>&/rvProperties//
3245 CTCLResult&/rResult//
3245 const  char*/pName//
3246 CTCLResult&/rResult//
3246 UInt_t/nId//
3248 CTCLResult&/rResult//
3248 std::vector<std::string>&/rvSpectra//
3249 CTCLResult&/rResult//
3249 std::vector<UInt_t>&/rvIds//
3250 CTCLResult&/rResult//
3251 CTCLResult&/rResult//
3251 std::vector<std::string>&/rvNames//
3252 CTCLResult&/rResult//
3252 std::vector<UInt_t>&/rIds//
3253 CTCLResult&/rResult//
3253 std::vector<std::string>&/rvNames//
3254 CTCLResult&/rResult//
3254 std::vector<UInt_t>&/rvIds//
3255 CTCLResult&/rResult//
3255 std::vector<UInt_t>&/rvXids//
3257 CTCLResult&/rResult//
3257 std::vector<std::string>&/rvNames//
3258 CTCLResult&/rResult//
3258 std::vector<UInt_t>&/rvnIds//
3260 CTCLResult&/rResult//
3260 std::vector<std::string>&/rvNames//
3261 CTCLResult&/rResult//
3261 std::vector<UInt_t>&/rvIds//
3262 CTCLResult&/rResult//
3262 std::vector<UInt_t>&/rvXIds//
3263 CTCLResult&/rResult//
3264 CTCLResult&/rResult//
3264 const  string&/rName//
3264 const  vector<UInt_t>&/pIndices//
3265 CTCLResult&/rResult//
3265 const  string&/rName//
3265 const  vector<UInt_t>&/rIndices//
3265 ULong_t/nValue//
3266 string&/rResult//
3266 const  string&/rSpectrum//
3266 ostream&/rOut//
3266 CSpectrumFormatter*/pFormat//
3267 string&/rResult//
3267 istream&/rIn//
3267 CSpectrumFormatter*/pFormat//
3267 UInt_t/fFlags//
3268 CSpectrum&/rSpectrum//
3269 const  std::string&/rName//
3270 UInt_t/nId//
3271 CTCLString&/rString//
3271 UInt_t/nXId//
3271 CSpectrum*/pSpectrum//
3272 char* SpectrumType_t/sType//
3273 DataType_t/dType//
3274 const  char*/pType//
3275 SpectrumType_t/st//
3275 const  char*/pType//
3276 CSpectrum*/pSpec//
3276 const  vector<UInt_t>&/rIndices//
3277 CSpectrum*/pSpectrum//
3278 CSpectrum*/pSpectrum//
3279 CTCLInterpreter*/pInterp//
3279 CTCLCommandPackage&/rPackage//
3281 const  CStartRun&/aCStartRun//
3282 const  CStartRun&/aCStartRun//
3283 const  CStartRun&/aCStartRun//
3284 CTCLInterpreter*/pInterp//
3284 CTCLCommandPackage&/rPackage//
3286 const  CStopRun&/aCStopRun//
3287 const  CStopRun&/aCStopRun//
3288 const  CStopRun&/aCStopRun//
3289 CTCLInterpreter*/pInterp//
3289 CTCLCommandPackage&/rPackage//
3291 const  CTapeCommand&/aCTapeCommand//
3292 const  CTapeCommand&/aCTapeCommand//
3293 const  CTapeCommand&/aCTapeCommand//
3294 char* CTCLResult&/rResult//
3295 const  char*/pSwitch//
3296 CTCLInterpreter&/rInterp//
3296 UInt_t/nP//
3296 UInt_t/nBunch//
3298 const  CTclAnalyzer&/rSrc//
3299 const  CTclAnalyzer&/rSrc//
3300 CBufferDecoder&/rDecoder//
3301 UInt_t/nType//
3301 CBufferDecoder&/rDecoder//
3302 CTCLVariable&/rVar//
3303 CTCLVariable&/rVar//
3303 int/newval//
3304 CTCLVariable&/rVar//
3312 CTCLInterpreter*/m_pInterpreter//
3312 UInt_t/nSpecBytes/knDefaultSpectrumSize/
3314 const  CTCLHistogrammer&/aCTCLHistogrammer//
3315 const  CTCLHistogrammer&/aCTCLHistogrammer//
3316 const  CTCLHistogrammer&/aCTCLHistogrammer//
3319 CTCLInterpreter*/am_pIntObject//
3320 const  PseudoParameters&/rPseudos//
3321 CPseudoScript&/rScript//
3322 const  string&/rPseudoName//
3323 const  string&/rPsuedoName//
3327 CTCLInterpreter*/pInterp//
3327 CTCLCommandPackage&/rPackage//
3329 const  CUnbindCommand&/aCUnbindCommand//
3330 const  CUnbindCommand&/aCUnbindCommand//
3331 const  CUnbindCommand&/aCUnbindCommand//
3332 char* CTCLResult&/rResult//
3333 const  char*/pSwitch//
3334 CTCLInterpreter*/pInterp//
3334 CTCLCommandPackage&/rPack//
3336 const  CUngateCommand&/aCUngateCommand//
3337 const  CUngateCommand&/aCUngateCommand//
3338 const  CUngateCommand&/aCUngateCommand//
3340 CTCLInterpreter*/pInterp//
3340 CTCLCommandPackage&/rPack//
3342 const  CWriteCommand&/aCWriteCommand//
3343 const  CWriteCommand&/aCWriteCommand//
3344 const  CWriteCommand&/aCWriteCommand//
3345 const  char*/pConnectionString//
3346 const  char*/pConnectionString//
3347 const  char*/pFormatter//
3348 CTCLResult&/rResult//
3349 CTCLInterpreter*/pInterp//
3349 CHistogrammer*/pHistogrammer//
3351 const  CXamineEventHandler&/aCXamineEventHandler//
3352 const  CXamineEventHandler&/aCXamineEventHandler//
3353 const  CXamineEventHandler&/aCXamineEventHandler//
3355 CHistogrammer*/am_pHistogrammer//
3356 CDisplayGate&/rXamineGate//
3357 CButtonEvent&/rButton//
3358CEventProcessor&/rEventProcessor//
3359CTCLInterpreter&/rInterp//
3360CTCLInterpreter&/rInterpreter//
3363UInt_t/nDisplaysize//
3363CHistogrammer&/rHistogrammer//
3365CEventSink*/pSink//
3366CAnalyzer&/rAnalyxer//
3367CAnalyzer&/rAnalyzer//
3368CTCLInterpreter&/rInterp//
3370CTCLInterpreter&/rInterp//
3372CTCLInterpreter&/rInterp//
3373CTCLInterpreter&/rInterpreter//
3376UInt_t/nDisplaySize//
3376CHistogrammer&/rHistogrammer//
3378CEventSink*/pSink//
3379CAnalyzer&/rAnalyzer//
3380CAnalyzer&/rAnalyzer//
3381CTCLInterpreter&/rInterp//
3383CTCLInterpreter&/rInterp//
3385CAnalyzer&/rAnalyzer//
3386CAnalyzer&/rAnalyzer//
3386CBufferDecoder&/rDecoder//
3387CAnalyzer&/rAnalyzer//
3387CBufferDecoder&/rBuffer//
3388CAnalyzer&/rAnalyzer//
3388CBufferDecoder&/rDecoder//
3389CAnalyzer&/rAnalyzer//
3389CBufferDecoder&/rDecoder//
3390const Address_t/pEvent//
3390CEvent&/rEvent//
3390CAnzlyer&/rAnalyzer//
3390CBufferDecoder&/rDecoder//
***END_TABLE***

Includes
ClassID, ClassName, Include Text
***BEGIN_TABLE***
1CApplyCommandTCLPackagedCommand.h
1CApplyCommandstring
2CAttachCommandTCLPackagedCommand.h
3CBindCommandTCLPackagedCommand.h
3CBindCommandvector
3CBindCommandstring
4ChannelCommandTCLPackagedCommand.h
5CClearCommandTCLPackagedCommand.h
6CDataSourcePackageTCLCommandPackage.h
6CDataSourcePackagehistotypes.h
8CGateCommandTCLPackagedCommand.h
8CGateCommandhistotypes.h
8CGateCommandGateFactory.h
8CGateCommandstring
9CGateFactoryPoint.h
9CGateFactoryGateContainer.h
9CGateFactoryvector
9CGateFactorystring
9CGateFactorylist
10CGateFactoryExceptionException.h
10CGateFactoryExceptionGateFactory.h
10CGateFactoryExceptionstring
11CGatePackageTCLCommandPackage.h
11CGatePackageGateCommand.h
11CGatePackageApplyCommand.h
11CGatePackageUngateCommand.h
11CGatePackagehistotypes.h
11CGatePackageHistogrammer.h
11CGatePackageGateContainer.h
11CGatePackageGate.h
11CGatePackageSpectrumPackage.h
11CGatePackagevector
11CGatePackagestring
12CParameterCommandEventUnpacker.h
12CParameterCommandBufferDecoder.h
12CParameterCommandEventSink.h
12CParameterCommandTCLInterpreter.h
12CParameterCommandFile.h
12CParameterCommandRunControl.h
12CParameterCommandAnalyzer.h
12CParameterCommandTCLPackagedCommand.h
12CParameterCommandTCLCommandPackage.h
13CParameterPackageTCLCommandPackage.h
13CParameterPackageTCLList.h
13CParameterPackagelist
14CPseudoCommandTCLPackagedCommand.h
15CPseudoScriptNamedItem.h
15CPseudoScriptEvent.h
15CPseudoScriptTCLInterpreterObject.h
15CPseudoScriptHistogrammer.h
15CPseudoScriptTCLObject.h
15CPseudoScriptlist
15CPseudoScriptstring
15CPseudoScriptvector
17CReadCommandTCLPackagedCommand.h
17CReadCommandfstream.h
17CReadCommandsys
17CReadCommandsys
17CReadCommandmap
18CRunControlPackageTCLCommandPackage.h
19CSpectrumCommandTCLPackagedCommand.h
19CSpectrumCommandhistotypes.h
19CSpectrumCommandvector
19CSpectrumCommandstring
20CSpectrumPackageTCLCommandPackage.h
20CSpectrumPackageHistogrammer.h
20CSpectrumPackagehistotypes.h
20CSpectrumPackagestring
20CSpectrumPackagevector
21CStartRunTCLPackagedCommand.h
21CStartRunstring
22CStopRunTCLPackagedCommand.h
22CStopRunstring
23CTapeCommandTCLPackagedCommand.h
23CTapeCommandstring
24CTclAnalyzerhistotypes.h
24CTclAnalyzerAnalyzer.h
24CTclAnalyzerTCLInterpreter.h
24CTclAnalyzerTCLVariable.h
25CTCLHistogrammerPseudoScript.h
25CTCLHistogrammerHistogrammer.h
25CTCLHistogrammerTCLInterpreterObject.h
25CTCLHistogrammerPseudoScript.h
25CTCLHistogrammerlist
26CUnbindCommandTCLPackagedCommand.h
27CUngateCommandTCLPackagedCommand.h
28CWriteCommandTCLPackagedCommand.h
28CWriteCommandstring
29CXamineEventHandlerTCLFileHandler.h
29CXamineEventHandlerHistogrammer.h
29CXamineEventHandlerXamineplus.h
29CXamineEventHandlertk.h
***END_TABLE***

Relation Shape
ShapeID, Type, Text, Multiplicity, Source Node ID, Source Index, LineTexture, IsDisplayByVal, IsDisplayByRef, QualifierSrc
***BEGIN_TABLE***
11NoText0810011
21NoText01710011
30NoText0610011
40NoText0630011
50NoText01110011
60NoText01130011
70NoText01170011
80NoText01310011
90NoText01330011
100NoText01350011
110NoText01810011
120NoText01830011
130NoText02080011
140NoText020130011
150NoText020110011
160NoText02070011
170NoText02090011
180NoText020120011
190NoText020100011
432NoText06530001
650NoText02430001
***END_TABLE***

Branches
Relation Shape ID, Multiplicity, Destination Node ID, Destination Index, Text, Relation Type, Branch Id,  IsDisplayStatic, IsDisplayFriend, IsDisplayPlus, QualifierDest, Offset x, Offset y
***BEGIN_TABLE***
1070aGateFactoryTable1100000
20160aStreamEntry1200000
30230m_pTape0300000
4020m_pAttach0400000
5082m_pGateCommand0500000
6012m_pApplyCommand0600000
70272m_pUngateCommand0700000
80250m_pHistogrammer0800000
90120m_pParameter0900000
100140m_pPseudo01000000
110210m_pStartRun01100000
120220m_pStopRun01200000
130190m_pSpectrum01300000
14052m_pClear01400000
15032m_pBind01500000
160262m_pUnbind01600000
170414m_pChannel01700000
180282m_pWrite01800000
190172m_pRead01900000
43066224300000
651672m_lAnalysisPipeline06800000
***END_TABLE***

Relations
Id,ParentId,Name,Type,Description,SrcVisibility,SrcMultiplicity,SrcLength,IsSrcByRef,IsSrcByVal,IsSrcFriend,IsSrcStatic,SrcRole,SourceClassId,
DestVisibility,DestMultiplicity,DestLength,DestByRef,IsDestByVal,IsDestFriend,IsDestStatic,IsDestRole,DestClassId
***BEGIN_TABLE***
11aGateFactoryTable1private0000008private0000007
22aStreamEntry1private00000017private00000016
33m_pTape0private0000006private00000023
44m_pAttach0private0000006private0000002
55m_pGateCommand0private00000011private0000008
66m_pApplyCommand0private00000011private0000001
77m_pUngateCommand0private00000011private00000027
88m_pHistogrammer0private00000013private00000025
99m_pParameter0private00000013private00000012
1010m_pPseudo0private00000013private00000014
1111m_pStartRun0private00000018private00000021
1212m_pStopRun0private00000018private00000022
1313m_pSpectrum0private00000020private00000019
1414m_pClear0private00000020private0000005
1515m_pBind0private00000020private0000003
1616m_pUnbind0private00000020private00000026
1717m_pChannel0private00000020private0000004
1818m_pWrite0private00000020private00000028
1919m_pRead0private00000020private00000017
2020aCReadCommand0private00000028private00000017
41410private00000060private00000061
42420private00000059private00000061
43432private00000059private00000060
67640private00000029private00000061
6865m_lAnalysisPipeline0private00000024private10000061
***END_TABLE***

General Shape
 ShapeId, Type,Positionx, Position.y, # ConnectPoints metafileName, TextOffset, ShapeSize, Width, Height, Texture, FileName,  Class, Text

***BEGIN_TABLE***
590739781629460100110Gate Command Classes
600809944165306095110Run Control Classes
610157097316960150110Spectrum manipulation commands
620236897016560125110Parameter package classes
6303128974162929660135110Data source command classes
6403886940162596560110110Miscellaneous classses
695520029016f:\Program Files\WC4\note.emf2120159860CEventProcessor is
:subclassed as needed
:to produce actual 
:unpackers, calibrators
:and other elements of
:the processing pipeline
1115481463316f:\Program Files\WC4\note.emf2120176640CMySpecTclApp is
:a skeleton class
:which is filled in
:by the experimenter.
1105504053016f:\Program Files\WC4\note.emf2120158860The event
:processors
:are an oredered
:list (pipeline)
:on the raw and 
:unpacked event.
***END_TABLE***

