'\"
'\" Copyright (c) 2004  Michigan State University
'\" The TCL formatting macros have been shamelessly stolen
'\" from the httpd tcl man page:
'\"
'\" Copyright (c) 1995-1997 Sun Microsystems, Inc.
'\" Copyright (c) 1998-2000 by Ajuba Solutions.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id$
'\" 
'\" The definitions below are for supplemental macros used in Tcl/Tk
'\" manual entries.
'\"
'\" .AP type name in/out ?indent?
'\"	Start paragraph describing an argument to a library procedure.
'\"	type is type of argument (int, etc.), in/out is either "in", "out",
'\"	or "in/out" to describe whether procedure reads or modifies arg,
'\"	and indent is equivalent to second arg of .IP (shouldn't ever be
'\"	needed;  use .AS below instead)
'\"
'\" .AS ?type? ?name?
'\"	Give maximum sizes of arguments for setting tab stops.  Type and
'\"	name are examples of largest possible arguments that will be passed
'\"	to .AP later.  If args are omitted, default tab stops are used.
'\"
'\" .BS
'\"	Start box enclosure.  From here until next .BE, everything will be
'\"	enclosed in one large box.
'\"
'\" .BE
'\"	End of box enclosure.
'\"
'\" .CS
'\"	Begin code excerpt.
'\"
'\" .CE
'\"	End code excerpt.
'\"
'\" .VS ?version? ?br?
'\"	Begin vertical sidebar, for use in marking newly-changed parts
'\"	of man pages.  The first argument is ignored and used for recording
'\"	the version when the .VS was added, so that the sidebars can be
'\"	found and removed when they reach a certain age.  If another argument
'\"	is present, then a line break is forced before starting the sidebar.
'\"
'\" .VE
'\"	End of vertical sidebar.
'\"
'\" .DS
'\"	Begin an indented unfilled display.
'\"
'\" .DE
'\"	End of indented unfilled display.
'\"
'\" .SO
'\"	Start of list of standard options for a Tk widget.  The
'\"	options follow on successive lines, in four columns separated
'\"	by tabs.
'\"
'\" .SE
'\"	End of list of standard options for a Tk widget.
'\"
'\" .OP cmdName dbName dbClass
'\"	Start of description of a specific option.  cmdName gives the
'\"	option's name as specified in the class command, dbName gives
'\"	the option's name in the option database, and dbClass gives
'\"	the option's class in the option database.
'\"
'\" .UL arg1 arg2
'\"	Print arg1 underlined, then print arg2 normally.
'\"
'\" RCS: @(#) $Id$
'\"
'\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
'\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1	\\fI\\$2\\fP	(\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
'\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
'\"	# BS - start boxed text
'\"	# ^y = starting y location
'\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
'\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
'\"	# VS - start vertical sidebar
'\"	# ^Y = starting y location
'\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
'\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
'\"	# Special macro to handle page bottom:  finish off current
'\"	# box/sidebar if in box/sidebar mode, then invoked standard
'\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
'\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
'\"	# DE - end display
.de DE
.fi
.RE
.sp
..
'\"	# SO - start of list of standard options
.de SO
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
'\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\fBoptions\\fR manual entry for details on the standard options.
..
'\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
'\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
'\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.de UL
\\$1\l'|0\(ul'\\$2
..
'\"  End of stolen macros --------------------------------
.TH "SpecTcl Application Programming Interface" 3 0.1 SpecTcl "NSCL Data analysis packages"
.BS
.SH NAME
SpecTclApi \- Fixed application programming interface to SpecTcl
.SH SYNOPSIS
.DS
#include <SpecTcl.h>


class SpecTcl
{
public:
  static SpecTcl* getInstance();
  UInt_t AssignParameterId();
  CParameter* AddParameter(STD(string) name, 
			   UInt_t Id, 
			   STD(string) Units);
  CParameter* AddParameter(STD(string) name, 
			   UInt_t id, 
			   UInt_t scale);
  CParameter* AddParameter(STD(string) name, 
			   UInt_t id, 
			   UInt_t scale, 
			   Float_t low, Float_t high, 
			   STD(string) units);
  CParameter* RemoveParameter(STD(string) name);
  CParameter* FindParameter(STD(string) name);
  CParameter* FindParameter(UInt_t Id);
  ParameterDictionaryIterator BeginParameters();
  ParameterDictionaryIterator EndParameters();
  UInt_t ParameterCount();
  CSpectrum* CreateSpectrum(STD(string) Name, 
			    SpectrumType_t type, 
			    DataType_t dataType, 
			    STD(vector)<STD(string)> parameters, 
			    STD(vector)<UInt_t> channels, 
			    STD(vector)<Float_t>* pLows, 
			    STD(vector)<Float_t>* pHighs);
  CSpectrum* Create1D(STD(string) name, 
		      DataType_t dataType, 
		      CParameter& parameter, 
		      UInt_t channelcount);
  CSpectrum* Create1D(STD(string) name, 
		      DataType_t dataType, 
		      CParameter& parameter, 
		      UInt_t channels, 
		      Float_t lowLimit, Float_t hiLimit);
  CSpectrum* Create2D(STD(string) name, 
		      DataType_t dataType, 
		      CParameter& xParameter, 
		      CParameter& yParameter, 
		      UInt_t xChannels, UInt_t yChannels);
  CSpectrum* Create2D(STD(string) name, 
		      DataType_t dataType, 
		      CParameter& xParameter, CParameter& yParameter, 
		      UInt_t xChannels, Float_t xLow, Float_t xHigh, 
		      UInt_t yChannels, Float_t yLow, Float_t yHigh);
  CSpectrum* CreateG1D(STD(string) name, 
		       DataType_t dataType,
		       STD(vector)<CParameter> parameters, 
		       UInt_t channels);
  CSpectrum* CreateG1D(STD(string) name, 
		       DataType_t dataType, 
		       STD(vector)<CParameter> parameters, 
		       UInt_t channels, 
		       Float_t lowLimit, 
		       Float_t hiLimit);
  CSpectrum* CreateG2D(STD(string) name, 
		       DataType_t dataType, 
		       STD(vector)<CParameter> parameters, 
		       UInt_t xChannels, UInt_t yChannels);
  CSpectrum* CreateG2D(STD(string) name, 
		       DataType_t dataType, 
		       STD(vector)<CParameter> parameters, 
		       UInt_t xChannels, Float_t xLow, Float_t xHigh, 
		       UInt_t yChannels, Float_t yLow, Float_t yHigh);
  CSpectrum* CreateBit(STD(string) name, 
		       DataType_t dataType, 
		       CParameter& parameter, 
		       UInt_t channels);
  CSpectrum* CreateBit(STD(string) name, 
		       DataType_t dataType, 
		       CParameter& parameter, 
		       UInt_t channels, UInt_t lowBit);
  CSpectrum* CreateSummary(STD(string) name, 
			   DataType_t dataType, 
			   STD(vector)<CParameter> parameters, 
			   UInt_t channels);
  CSpectrum* CreateSummary(STD(string) name, 
			   DataType_t dataType, 
			   STD(vector)<CParameter> parameters, 
			   UInt_t nChannels, Float_t low, Float_t high);
  void AddSpectrum(CSpectrum& spectrum);
  CSpectrum* RemoveSpectrum(STD(string) name);
  CSpectrum* FindSpectrum(STD(string) name);
  CSpectrum* FindSpectrum(UInt_t id);
  SpectrumDictionaryIterator SpectrumBegin();
  SpectrumDictionaryIterator SpectrumEnd();
  UInt_t SpectrumCount();
  void   addSpectrumDictionaryObserver(SpectrumDictionaryObserver* observer);
  void   removeSpectrumDictionaryObserver(SpectrumDictionaryObserver* observer);
  void ClearSpectrum(STD(string) name);
  void ClearAllSpectra();
  CGate* CreateGate(CGateFactory::GateType gateType, 
		    STD(vector)<STD(string)> names);
  CGate* CreateGate(CGateFactory::GateType gateType, 
		    STD(vector)<STD(string)> parameters, 
		    STD(vector)<FPoint> points);
  CGate* CreateGate(CGateFactory::GateType   gateType,
		    STD(vector)<FPoint>      points,
		    STD(vector)<STD(string)> spectra);
  CGate* CreateTrueGate();
  CGate* CreateFalseGate();
  CGate* CreateBand(STD(string) xparameter, STD(string) yparameter, 
		    STD(vector)<FPoint> points);
  CGate* CreateContour(STD(string) xParameter, STD(string) yParameter, 
		       STD(vector)<FPoint> points);
  CGate* CreateBandContour(STD(string) firstBand, STD(string) secondBand);
  CGate* CreateNotGate(STD(string) name);
  CGate* CreateAndGate(STD(vector)<STD(string)> gateNames);
  CGate* CreateOrGate(STD(vector)<STD(string)> gateNames);
  CGate* CreateCut(STD(string) parameter, Float_t low, Float_t high);
  CGate* CreateGammaCut(Float_t low, Float_t high, STD(vector)<STD(string)> constituents);
  CGate* CreateGammaBand(STD(vector)<FPoint> points, 
			 STD(vector)<STD(string)> constituents);
  CGate* CreateGammaContour(STD(vector)<FPoint> points, 
			    STD(vector)<STD(string)> constituents);
  void AddGate(STD(string) name, CGate* gate);
  void DeleteGate(STD(string) gateName);
  void ReplaceGate(STD(string) gateName, CGate& newGate);
  CGateContainer* FindGate(STD(string) gateName);
  CGateDictionaryIterator GateBegin();
  CGateDictionaryIterator GateEnd();
  UInt_t GateCount();
  void ApplyGate(STD(string) gateName, STD(string) spectrumName);
  void AddEventProcessor(CEventProcessor& eventProcessor, 
			 const char* name = 0);
  CTclAnalyzer::EventProcessorIterator FindEventProcessor(STD(string) name);
  CTclAnalyzer::EventProcessorIterator FindEventProcessor(CEventProcessor& processor);
  void InsertEventProcessor(CEventProcessor& processor,
			    CTclAnalyzer::EventProcessorIterator where, 
			    const char*  name = 0);
  void RemoveEventProcessor(STD(string) name);
  void RemoveEventProcessor(CTclAnalyzer::EventProcessorIterator here);
  UInt_t ProcessingPipelineSize();
  CTclAnalyzer::EventProcessorIterator ProcessingPipelineBegin();
  CTclAnalyzer::EventProcessorIterator ProcessingPipelineEnd();
  void AddSpectrumFormatter(STD(string) name, CSpectrumFormatter& formatter);
  void AddEventSink(CEventSink& sink, const char* name = 0);
  CEventSinkPipeline::EventSinkIterator FindEventSink(STD(string) sinkName);
  CEventSinkPipeline::EventSinkIterator FindEventSink(CEventSink& sink);
  void InsertEventSink(CEventSink& sink, CEventSinkPipeline::EventSinkIterator here,
		       const char* name = 0);
  CEventSink* RemoveEventSink(STD(string) name);
  CEventSink* RemoveEventSink(CEventSinkPipeline::EventSinkIterator here);
  UInt_t EventSinkPipelineSize();
  CEventSinkPipeline::EventSinkIterator EventSinkPipelineBegin();
  CEventSinkPipeline::EventSinkIterator EventSinkPiplineEnd();
  CTCLInterpreter*  getInterpreter();
};

.DE
.SH DESCRIPTION
.PP
   The SpecTcl class provides a fixed application programming interface to the
interanals of SpecTcl.  Using this class ensures that your code will not
require modification if the internals of SpecTcl change.    The SpecTcl API is
implemented as a ``singleton'' class.  Singleton classes ensure that only a
single instance of the class can be alive at any time.  Unlike classes you may
be used to using, singletons have \fIprivate\fR constructors and destructors.
You get access to a singleton class by invoking its \fBgetInstance()\fR member.
This member returns a pointer to the single instance of the class, if necessary
creating it on the fly.
.PP
The SpecTcl API
class supports interfaces to the following subsections of SpecTcl's
functionality:
.TP
Parameter Dictionary
Parameters can be created, searched for, removed and iterated through.
.TP
Spectra
Spectra of all supported types can be created.  Once created they can be added
to the set of spectra managed by SpecTcl.  Created Spectra can be searched for,
iterated through or removed.  Spectra can also be cleared either individually
or all spectra can be cleared at once.
.TP
Gates
All suported gate types can be created.  In addition, gates can be added to the
set of gates managed by SpecTcl  Gates added to the set added by SpecTcl can be
deleted, replaced, searched and iterated over.  In addition, gates can be
applied to spectra.
.TP
Event Processing Pipeline
The event processing pipeline is responsible for generating the set of
parameters that SpecTcl histograms.   Event processors can be dynamically
added to the pipeline.  Event processors can be give names which will allow you
to search for specific event processors, as well as to remove them.  Event
processors can be inserted at any point in the pipeline.  The event processing
pipeline can be iterated through as well.
.TP
Event Sink Pipeline
The parameters produced by the event sink pipeline are passed to an event sink
pipeline.  Event sinks currently defined by SpecTcl include its histogramming
engine and event filters you create.  User written event sinks are also
supported and this set of interfaces allows you to interact with the event sink
pipeline in much the same way you can interact with the event processing pipeline.
.TP
Spectrum Formatters
Spectrum formatters are responsible for producing  and reading external
representations of spectra.  You can add a spectrum formatter to SpecTcl making
it available to the \fBswrite\fR and \fBsread\fR commands.
.TP
Tcl/Tk
You can get access to an object encapsulated Tcl/Tk interpreter.  The Tcl/Tk
library (Tcl++) supports an object encapsulation of Tcl/Tk.  Using the
functions in that library along with the interpreter you get from the SpecTcl
API allows you to add commands to SpecTcl and manipulate Tcl variables.
.SH "SINGLETON INTERFACE"
.TP
\fBSpecTcl* getInstance()\fR
This \fIstatic\fR function returns an instance to the SpecTcl API object.  If no API object
exists yet, one will be created.  Once called you can invoke API functions
using the object.  For example, the code below adds a new parameter to SpecTcl:

.CS
SpecTcl& api(*(SpecTcl::getInstance()));
api.AddParameter("someposition", api.AssignParameterId(), "mm");
.CE

.SH "PARAMETER INTERFACE"
.PP
The parameter interface allows you to create parameters in the parameter
dictionary. Several common argument types and return value types  are used in
this section of the API: 
.AP CParameter* p out
A pointer to a parameter object.  Many of the functions in this section
return a pointer to a parameter object.
.AP ParameterDictionaryIterator i out
An iterator into the parameter dictionary.  Iterators are Standard Template
Library constructs that act very much like pointers.  Iterators can be
dereferenced like a pointer, incremented and compared to other iterators.
Iterators, as their name implies, are used to iterate through containers (in
this case the parameter dictionary).  The \fBParameterDictionaryIterator\fR
``points'' to an STL pair<string, CParameter*>.
.AP string name in
The name of a parameter.  In SpecTcl, parameters must have unique names.  The
name of the parameter is the first element of the pair ``pointed'' to by
ParameterDictionaryIterators. 
.AP UInt_t Id in
The identification number of a parameter.  Parameters have an \fBid\fR number
which must be unique.  The \fBid\fR number is the index in the event parameter
array into which the parameter will be unpacked.
.AP string Units in
Parameters can have physical units.  The units of a parameter are displayed by
Xamine when spectra involving the parameter are displayed.
.AP UInt_t scale in
Integer parameters have a scale.  The scale defines the range of values the
parameter will take.  Parameters with a scale value will cover the range [0,
2**scale). 
.AP Float_t low,high in
Integer parameters may also have a mapping to a real coordinate space.
\fBlow\fR and \fBhigh\fR represent the range of real coordinate space covered
by the integer parameter.  Spectra can be displayed with either the raw channel
coordinates or with channels labelled in this real coordinate space.
.PP
.TP
\fBUInt_t AssignParameterId();\fR
Returns an unsed parameter id.  This function can be used to provide the
\fIId\fR parameter of many of the functions in this section.
.TP
\fBCParameter* AddParameter(STD(string) \fIname\fB, UInt_t \fIId\fB, STD(string) \fIUnits\fB);\fR
Adds a floating point parameter to the parameter dictionary.  Floating point
parameters are never scaled when they are histogrammed. Instead, the histogram
must be defined to cover a specific range of the parameter space.
\fIname\fR and \fIid\fR must be unique or the function will throw a
\fBCDictionaryException\fR.
.TP
\fBCParameter* AddParameter(STD(string) \fIname\fB, UInt_t \fIId\fB, UInt_t \fIscale\fB);\fR
Creates an integer parameter.  The parameter is assumed to have a range of
values from [0..2**\fIscale\fR).
\fIname\fR and \fIid\fR must be unique or the function will throw a
\fBCDictionaryException\fR.
.TP
CParameter* AddParameter(STD(string) \fIname\fB, UInt_t \fIId\fB, UInt_t \fIscale\fB, Float_t \fIlow\fB, Float_t \fIhigh\fB, STD(string) \fIUnits\fB);\fR
Creates a new integer parameter.  The integer parameter also defines ``mapped''
parameter space.  The mapped parameter space runs from
[\fIlow\fR..\fIhigh\fR).  Thhe mapped parameter space also can have physical
\fIunits\fR associated with it.  These units can be displayed on spectra that
are created on this parameter.
\fIname\fR and \fIid\fR must be unique or the function will throw a
\fBCDictionaryException\fR.
.TP
\fBCParameter* RemoveParameter(STD(string) \fIname\fB);\fR
Removes the parameter named \fIname\fR from the parameter dictionary.
A dynamically allocated pointer to the removed parameter is returned. It is the
caller's responsibility to \fBdelete\fR this parameter.  If there is no
parameter named \fIname\fR, a \fBNULL\fR pointer is returned.  Note that since
delete on a \fBNULL\fR is a no-op, the following is legal and safe:

.CS
     SpecTcl& api(*(SpecTcl::getInstance()));
     delete api.RemoveParameter("NoIdeaIfThisExists");
.CE
.TP
\fBCParameter* FindParameter(STD(string) \fIname\fB);\fR
Locates the parameter named \fIname\fR in the parameter dictionary and returns
a pointer to it.  Note that the pointer returned is a pointer to the object in
the parameter dictionary, not a copy.  Any  modifications you make to the
parameter will be reflected in the way SpecTcl handles the parameter.  If the
named parameter does not exist, a \fBNULL\fR pointer will be returned.  The code
below determines the units associated with a parameter:

.CS
     SpecTcl& api(*(SpecTcl::getInstance()));
     string units;
     CParameter* pParam = api.FindParameter("somename");
     if(pParam) {
        units = pParam->getUnits();
     } 
     else {
        cerr << "No such parameter\\n";
     }

.CE
.TP
\fBCParameter* FindParameter(UInt_t \fIId\fB);\fR
Given a parameter \fIid\fR, this function locates the parameter in the parameter
dictionary and returns a pointer to it.  If there is no parameter in the
dictionary with this \fIi\fR, this function returns a \fBNULL\fR.
.TP
\fBParameterDictionaryIterator BeginParameters();\fR
Returns an iterator that ``points'' to the start of the parameter dictionary.
.TP
\fBParameterDictionaryIterator EndParameters();\fR
Returns an iterator that ``points'' past the end of the parameter dictionary.
This iterator should never be de-referenced.  The code below shows how to use
\fBBeginParameters\fR and \fBEndParameters\fR to output the names of all
parameters in the dictionary:

.CS
    SpecTcl& api(*(SpecTcl::getInstance()));
    ParameterDictionaryIterator i = api.BeginParameters();
    while(i != api.EndParameters()) {
       cout << i->first << endl;            // i `points' to pair<string,CParameter*>
       i++;                                 // `point' to next dictionary entry.
    }
.CE
.TP
\fBUInt_t ParameterCount();\fR
Returns the number of parameters currently defined in the parameter dictionary.
.SH "SPECTRUM CREATION INTERFACE"
.PP
This section of the API allows you to create any of the types of spectra
supported by SpecTcl.  See "SPECTRUM DICTIONARY INTERFACE" for information on
how make spectra known to the
Histogrammer, and \fBspectrum\fR command. Several common parameter types and
return types are used by this section of the interface:
.PP
.AP CSpectrum* p out
A pointer to a created spectrum object.  This object is dynamically created.
It is the responsibility of the caller to delete the spectrum object when the
spectrum is no longer needed.   Note that the \fBspectrum -delete\fR command
deletes spectra that it removes from the spectrum dictionary.
.AP string Name in
The name to be associated with the spectrum.  Note that spectrum creation does
not enforce unique names, however the spectrum dictionary management API does
require that spectra added to the dictionary be given unique names.
.AP SpectrumType_t type in
The type of spectrum being created.  This can be any of the following values:
\fBke1DfR for an ordinary 1d, \fBke2D\fR, for an ordinary 2d,  \fBkeBitmask\fR,
for a bit-mask spectrum, \fBkeSummary\fR, for a summary spectrum, \fBkeG1D\fR,
for a multiply incremented (or Gamma) spectrum, or \fBkeG2D\fR, for a multiply
incremented (or Gamma) 2d spectrum.
.AP DataType_t dataType in
The type of data the spectrum will hold  For 1-d spectra this can be either
\fBkeWord\fR or \fBkeLong\fR.  For 2-d spectra this can be either \fBkeByte\fR
or \fBkeWord\fR.
.AP vector<string> parameters in
An STL vector of names of parameters that are needed to create the spectrum.
.AP vector<UInt_t> channels in
Vector of integers containing the number of channels on each axis that can be
controlled at creation.
.AP vector<Float_t>* pLows in
Pointer to a vector of axis low limits to associate with each axis that can be
controlled at creation.
.AP vector<Float_t>* pHighs in
Pointer to a vector of axis high limits to associate with each axis that can be
controlled at creation.
.AP UInt_t channelcount in
Number of channels in the spectrum.
.AP Float_t lowLimit,hiLimit in
The low and high limits in parameter space covered by the axis.
.AP CParameter& parameter in
The parameter that the spectrum histograms.
.AP UInt_t xChannels,yChannels in
The number of channels on the X and Y axis.
.AP CParameter& xParameter,yParameter in
The parameters on the X and Y axes.
.AP Float_t xLow,xHigh in
The parameter space covered by the x axis.
.AP Float_t yLow,yHigh in
The parameter space covered by the y axis.
.AP vector<CParameters> parameters in
A vector of parameters needed to create the spectrum.
.AP Uint_t lowBit in
The number of the lowest bit that will appear in a bit mask spectrum.
.PP
.TP
\fBCSpectrum* CreateSpectrum(STD(string) \fIName\fB,SpectrumType_t \fItype\fB,
\fBDataType_t \fIdataType\fB,STD(vector)<STD(string)> \fIparameters\fB,
STD(vector)<UInt_t> \fIchannels\fB, 
\fBSTD(vector)<Float_t>* \fIpLows\fB, STD(vector)<Float_t>* \fIpHighs\fB);\fR

This general spectrum creation function can create any spectrum type supported
by SpecTcl.  The type of spectrum created is selectec by the \fItype\fR
parameter. The other parameters must be sufficient in number and type to
support the creation of the desired spectrum or else a
\fBCSpectrumFactoryException\fR will be thrown.  A pointer to the new spectrum
(dynamically created) will be returned.  
.TP
\fBCSpectrum* Create1D(STD(string) \fIname\fB, DataType_t \fIdataType\fB, CParameter& \fIparameter\fB, UInt_t \fIchannels\fB);\fR
Creates a 1D spectrum. A pointer to the new spectrum is returned.  The
\fIchannels\fR parameter not only determines the number of channels on the X
axis, but the range of values of \fIparameter\fR covered by this spectrum is
defined by it as [0..\fIchannels).
.TP
\fBCSpectrum* Create1D(STD(string) \fIname\fB,DataType_t \fIdataType\fB, CParameter& \fIparameter\fB, UInt_t \fIchannels\fB, 
\fBFloat_t \fIlowLimit\fB, Float_t \fIhiLimit\fB);\fR

Creates a 1D spectrum a pointer to the new spectrum is returned.   The
\fIchannels\fR parameter determine how many channels will be on the X axis.
These channels cover the range [\fIlowLimit\fR..\fIhiLimit\fR].  The two
spectrum creations below are essentially identical:
.CS

    SpecTcl& api(*(SpecTcl::getInstance()));
    CParameter*  pParam = api.FindParameter("someParameter");
    api.Create1D("firstone", keLong, *pParam, 1024);
    api.Create1D("secondone", keLong, *pParam, 1024, 0.0, 1023.0);

.CE
.TP
\fBCSpectrum* Create2D(STD(string) \fIname\fB, DataType_t \fIdataType\fB, 
\fBCParameter& \fIxParameter\fB, CParameter& \fIyParameter\fB,
\fBUInt_t \fIxChannels\fB, UInt_t \fIyChannels\fB);\fR

Creates a 2-d spectrum.  A pointer to the spectrum is returned.  The spectrum
will histogram \fIxParameter\fR on the X axis vs. \fIyParameter\fR on the Y
axis.  The X axis will have \fIxChannels\fR channels, and the Y axis
\fIyChannels\fR.   The range of the parameters covered on each axis is
determined by the number of channels on that axis.  For example, the X axis
will cover the range [0..\fIxChannels\fR-1] in parameter space.
.TP
\fBCSpectrum* Create2D(STD(string) \fIname\fB, DataType_t \fIdataType\fB, 
\fBCParameter& \fIxParameter\fB0, CParameter& \fIyParameter\fB, 
UInt_t \fIxChannels\fB, Float_t \fIxLow\fB, Float_t \fIxHigh\fB, 
UInt_t \fIyChannels\fB, Float_t \fIyLow, Float_t \fByHigh);\fR

Creates a 2-d spectrum. A pointer to the new spectrum is returned.  The number
of channels on each axis is determined by \fIxChannels\fR and
\ffIyChannels\fR.  The range of parameter space covered by the X axis is
[\fIxLow\fR..\fIxHigh\fR].  The range of parameter space covered by the Y axis
is [\fIyLow\fR..\fIyHigh\fR].
.TP
\fBCSpectrum* CreateG1D(STD(string) \fIname\fB, DataType_t \fIdataType\fB,
STD(vector)<CParameter> \fIparameters\fB, UInt_t \fIchannels\fB);\fR
Creates a 1-d Gamma spectrum.   Gamma spectra are multiply incremented
spectra.  For each valid parameter specified by \fIparameters\fR, the spectrum
is incremented as described by the value of that parameter.  Note that
\fIchannels\fR not only specifies the number of channesl on the X axis of the
spectrum, but also specifies the range of the parameter covered by the X axis
as [0..\fIchannels]fR-1].
.TP
\fBCSpectrum* CreateG1D(STD(string) \fIname\fB, DataType_t \fIdataType\fB, STD(vector)<CParameter> \fIparameters\fB, 
\fBUInt_t \fIchannels\fB, Float_t \fIlowLimit\fB, Float_t \fIhiLimit\fB);\fR

Creates a 1-d gamma spectrum.  Returns a pointer to the spectrum to the
caller. The X axis is defined as having \fIchannels\fR channels that cover the
range [\fIlowLimit\fR..\fIhiLimit\fR] in parameter space.
.TP
\fBCSpectrum* CreateG2D(STD(string) \fIname\fB, DataType_t \fIdataType\fB,
STD(vector)<CParameter> \fIparameters\fB, 
\fBUInt_t \fIxChannels\fB, UInt_t \fIyChannels\fB);\fR

Creates a 2-d gamma spectrum.  For each pair of parameters described by
\fIparameters\fR  that is valid in an
event, this spectrum will be incremented as described by that ordered pair.
The X axis has \fIxChannels\ channels that cover the range
[0..\fIxChannels\fR-1] in parameter space. Similarly, the Y axis has
\fIyChannels\fR covering [0..\fIyChannels\fR-1].
.TP
\fRCSpectrum* CreateG2D(STD(string) \fIname\fB, DataType_t \fIdataType\fB, STD(vector)<CParameter> \fIparameters\fB, 
\fBUInt_t \fIxChannels\fB, Float_t \fIxLow\fB, Float_t \fIxHigh\fB, 
UInt_t \fIyChannels\fB, Float_t \fIyLow\fB, Float_t \fIyHigh\fB);\fR

Creates a 2-d gamma spectrum that is incremented for each ordered pair of valid
parameters in \fIparameters\fR.  The X axis is has \fIxChannels\fR channels
that cover the range [\fIxLow\fR, \fIxHigh\fR] in parameter space, and
similarly for the Y axis using \fIyChannels\fR, \fIyLow\fR, and \fIyHigh\fR.
.TP
\fBCSpectrum* CreateBit(STD(string) \fIname\fB, DataType_t \fIdataType\fB, CParameter& \fIparameter\fB, UInt_t \fIchannels\fB);\fR
Creates a  bit mask spectrum  For each bit set in the parameter for each event,
the corresponding channel is incremented for example, if the integerized
parameter value is 10 (decimal), channels 1 and 3 will be incremented.
.TP
\fBCSpectrum* CreateBit(STD(string) \fIname\fB, DataType_t \fIdataType\fB, CParameter& \fIparameter\fB,
 UInt_t \fIchannels\fB, UInt_t \fBlowBit\fI);\fR

Creates a bitmask spectrum.  \filowBit\fR determines the bit represented by
channel 0.  If, for example, \fIchannels\fR is 16, and \fIlowBit\fR is 4, the
spectrum will display the increments in bits 4 through 19 of the integerized
parameter value.
.TP
\fBCSpectrum* CreateSummary(STD(string) \fIname\fB, DataType_t \fIdataType\fB, STD(vector)<CParameter> \fIparameters\fB, UInt_t \fIchannels\fB);\fR
Creates a summary spectrum.  Summary spectra allow you to look at several
supposedly identical detector channels in a detector array for anomalies such
as gain mis-matches or dead channels.  A summary spectrum is essentially an
array of 1-d spectra put into a 2-d spectrum.  Each parameter gets a channel on
the X axis and increments its 1-d spectrum along the y axis.  This version of
the function histograms the range [0..\fIchannels\fR-1] for each parameter.
.TP
\fBCSpectrum* CreateSummary(STD(string) \fIname\fB, DataType_t \fIdataType\fB, STD(vector)<CParameter> \fIparameters\fB, 
UInt_t \fInChannels\fB, Float_t \fIlow\fB, Float_t \fIhigh\fB);\fR

Creates a summary spectrum.  The parameter range histogrammed is determined by
\fIlow\fR and \fIhigh\fR.

.SH "SPECTRUM DICTIONARY INTERFACE"
.PP 
The spectrum dictionary interface allows you to add to and remove entries from
the spectrum dictionary.  You can also search and iterate through the
dictionary.  The following are return values and parameters that are used in
this part of the API:
.AP CSpectrum* spec out
A pointer to a spectrum object.  Note that the spectrum creation interface
dynamically creates spectra.  If you no longer need a spectrum you should
delete it.
.AP CSpectrum& spectrum in
A reference to a spectrum.
.AP string name in
The name of a spectrum.
.AP UInt_t id in
The identifier of the spectrum.
.AP SpectrumDictionaryIterator p out
An STL iterator into a spectrum dictionary.  STL iterators are pointer like
objects. As such they can be dereferenced, incremented and compared.  The
SpectrumDictionaryIterator ``points'' to an STL pair<string, CSpectrum*>
.PP
.TP
 \fBvoid AddSpectrum(CSpectrum& \fIspectrum\fB);\fR
Adds a spectrum to the spectrum dictionary.  When a spectrum is in the Spectrum
Dictionary, SpecTcl will increment it as required for each event.  In addition,
SpecTcl's commands will become aware of the spectrum.
These commands include \fBspectrum\fR, \fBchannel\fR, \fBsbind\fR, \fBsread\fR,
and \fBswrite\fR among others.  Adding a spectrum to the Spectrum dictionary
does not imply that the dictionary will manage its storage, however.
.TP
\fBCSpectrum* RemoveSpectrum(STD(string) \fIname\fB);\fR
Removes the spectrum named \fIname\fR from the spectrum dictionary.  The
function returns a pointer to the spectrum that was removed or \fBNULL\fR if
the spectrum does not exist.  Since the API's spectrum creation interface
dynamically allocates spectra, you will typically need to delete the spectrum
at this point if you are done with it.  For example assume a spectrum named
\fIgeorge\fR has been added to the spectrum dictionary to fully remove and
destroy the spectrum:
.CS

    SpecTcl& api(*(SpecTcl::getInstance()));
    CSpectrum* pSpectrum = api.RemoveSpectrum("george");
    delete     pSpectrum;

.CE
.TP
\fBCSpectrum* FindSpectrum(STD(string) \fIname\fB);\fR
Locates a spectrum in the spectrum dictionary and returns a pointer to it.  If
the spectrum does not exist, then \fBNULL\fR is returned.
Note that since the spectrum lives in the spectrum dictionary, you must not use
the pointer to destroy it.  The following sample code locates the spectrum
named \fIgeorge\fR and determines its type, if the spectrum does not exist, the
type is set to keUnknown.  
.CS

   SpecTcl&       api(*(SpecTcl::getInstance()));
   CSpectrum*     pSpectrum = api.FindSpectrum("george");
   SpectrumType_t eType;
   if(pSpectrum) {
      eType = pSpectrum->getSpectrumType();
   }
   else {
      eType = keUnknown;
   }

.CE
.TP
\fBCSpectrum* FindSpectrum(UInt_t \fIid\fB);\fR
Locates a spectrum given it's id.
.TP
\fBSpectrumDictionaryIterator SpectrumBegin();\fR
Returns a start of iteration iterator into the spectrum dictionary.  The sample
code below shows how to print out the names of each spectrum in the
dictionary.  Recall that a SpectrumDictionaryIterator is a pointer like object
to a pair<string, CSpectrum*>, where the string is the name of the spectrum,
and the CSpectrum* is a pointer to the spectrum itself.
.CS

     SpecTcl&                   api(*(SpecTcl::getInstance()));
     SpectrumDictionaryIterator p = api.SpectrumBegin();
     while(p != api.SpectrumEnd()) {
       cerr << p->first << endl;
       p++;
     }

.CE
.TP
\fBSpectrumDictionaryIterator SpectrumEnd();\fR
Returns a spectrum dictionary end of iteration iterator.  This iterator should
never be dereferenced.  It should only be used as an in the code sample above
to determine when to stop iterating.
.TP
\fBUInt_t SpectrumCount();\fR
Returns the number of spectra that are currently in the spectrum dictionary.
.TP
\fBvoid addSpectrumDictionaryObserver(SpectrumDictionaryObserver* observer)
.TP
\fBvoid removeSpectrumDictionaryObserver(SpectrumDictionaryObserver* observer)
Adds or removes a spectrum dictionary observer to the histogrammer.  Spectrum dictionary
observers are classes that have member functions that are invoked
when spectra are added or removed from the dictionary.
Spectrum dictionary observer classes have two member functions:
.CS

  virtual void onAdd(const std::string&    name,  const  CSpectrum*& item) {}
  virtual void onRemove(const std::string& name,  const  CSpectrum*&  item) {}

.CE
.PP
\fBonAdd\fR is called when a spectrum is added and \fbonRemove\fR is called
when a spectrum is removed from the dictionary.  For both spectra, 
\fBname\fR is the name of the spectrum that is involved and 
\fBitem\fR is a reference to a pointer to the spectrum object that is involved.
.SH "SPECTRUM CLEAR FUNCTIONS"
.PP
While each spectrumh has a \fBclear\fR member function, the API provides two clear
convenience functions.  For these:
.AP string name in
is the name of the spectrum to clear.
.PP
.TP
\fBvoid ClearSpectrum(STD(string) \fIname\fB);\fR
If the spectrum \fIname\fR exists in the spectrum dictionary it is cleared.
If the spectrum does not exist, then a CDictionaryException is thrown.
.TP
 \fBvoid ClearAllSpectra();\fR
Clears all of the spectra in the spectrum dictionary.
.SH "GATE CREATION"
.PP
The gate creation API allows you to create any type of gate supported by
SpecTcl.  Once created you may either manually check a gate or you can add it
to the gate dictionary where SpecTcl will automatically check it as needed.
Gates added to the gate dictionary are also known to all SpecTcl gate
manipulation commands such as \fBgate\fR and \fBapply\fR.
.PP
Within the gate dictionary, gates are maintained in gate containers.  Gate
containers allow a gate with a specific name to have a fixed handle that can be
used to reference the gate.  This makes it very easy to modify the definition
of a gate without the effects of that modification rippling through the entire
gate subsystem.
.PP
The gate creation API uses several common parameters and return types:
.AP CGate* pGate out
A pointer to a gate.  The gate creationals all return this.
.AP CGateFactory::GateType gateType in
The type of gate being created.  At present this is one of: And, band,
bandcontour, contour, cut, deleted, falseg, Not, Or, trueg, gammacut,
gammaband and gammacontour.
.AP vector<string> gateNames in
For compound gates; the names of the gates that make up this gate.  The gates
in the name list must have been entered in the gate dictionary.
.AP vector<string> parameters in
The names of the parameters that are important to a primitive gate.
.AP vector<FPoint> points in
The set of points that make up a primitive gate.
.AP vector<string> spectra
The set of spectra that are important to a gamma gate.
.AP string parameter in
The name of the parmeter a cut is defined on.
.AP string xParameter in
The name of the X parameter in a band or contour.
.AP string yParameter in
The name of the Y parameter in a band or contour.
.AP Float_t low,high in
The lower and upper limits of a cut.
.AP string firstBand,secondBand in
The names of the two bands that will be used to create a contour.
.PP
.TP
\fBCGate* CreateGate(CGateFactory::GateType \fIgateType\fB, STD(vector)<STD(string)> \fIgateNames\fB);\fR
Creates a compound gate of the type selected by \fIgateType\fR.  The gate will
be composed of the gates named by the vector \fIgateNames\fR all of the gates
in \fIgateNames\fB must have been entered in the gate dictionary either by
SpecTcl or application software.
.TP
 \fBCGate* CreateGate(CGateFactory::GateType\fR
\fIgateType\fB,STD(vector)<STD(string)> \fIparameters\fB, 
\fBSTD(vector)<FPoint>\fIpoints\fB);\fR
Creates a primitive gate of the type described by \fIgateType\fR.  The gate
is defined on the set of \fIpoints\fR set on the \fIparameters\fR.
.TP
 \fBCGate* CreateGate(CGateFactory::GateType \fIgateType\fB, STD(vector)<FPoint> \fIpoints\fB,
\fBSTD(vector)<STD(string)> \fIspectra\fB);\fR

Creates a gamma gate of the type described by \fIgateType\fR. The coordinates
of the points that make up the gate are in \fIpoints\fR and the gate is defined
on \fIspectra\fR.  Note that there will be drastic changes to semantics of
gamma gates work that may invalidate this interface in the near future.  We
apologize for this instability in the API, but believe that this change in gate
semantics is necessary to meet the analysis needs of SpecTcl's user community.
.TP
\fBCGate* CreateTrueGate();\fR
Creates a gate that is always true when checked.
.TP
\fBCGate* CreateFalseGate();\fR
Creates a gate that is always false when checked.
.TP
\fBCGate* CreateBand(STD(string) \fIxParameter\fB, STD(string) \fIyParameter\fB, STD(vector)<FPoint> \fIpoints\fB);\fR
Creates a band gate defined on \fIxParameter\fR and \fIyParameter\fR.   The
points of the band are in \fIpoints\fR.  A band gate is an open polyline that
connects the gate points.  The gate is \fBtrue\fR if the \fIxParameter\fR, and
\fIyParameter\fR for an event are below the gate line.  Note that the gate
checking engine in SpecTcl is sufficiently intelligent to deal consistently
with pathalogical bands, including those that have switchbacks and loops.  For
these gates, imagine that vertical lines extend downward from the end points of
the gate and are joined at infinity to form a contour.  Insidedness as defined
for contour gates makes the band true.
.TP
\fBCGate* CreateContour(STD(string) \fIxParameter\fB, STD(string) \fIyParameter\fB, STD(vector)<FPoint> \fIpoints\fB);\fR
Creates a contour.  Parameters have identical meanings as for
\fBCreateBand\fR, however the points define a closed polygon.  Events whose
\fIxParameter\fR and \fIyParameter\fR are inside the polygon make the gate
true.  The gate engine for SpecTcl is sufficiently intelligent that it can deal
consistently with pathalogical polygons including polygons with loops, and path
crossings.  Insidedness is defined by an `odd crossing' rule.  A point is
inside the polygon if a line extended to infinity in any direction crosses an
odd number of polygon boundaries.  Note that for practical purposes, the gate
is checked by extending a horizontal line segment from the point to the left end of the
polygon's bounding box and counting the boundary crossings of that line segment.
.TP
\fBCGate* CreateBandContour(STD(string) \fIfirstBand\fB, STD(string) \fIsecondBand\fB);\fR
Creates a band contour.  A band contour is a contour that is formed by joining
the leftmost and right most points of the bands \fIfirstBand\fR and
\fIsecondBand\fR.  While the resulting gate is something very much like the AND
gate of  \fIfirstBand\fR with the NOT of \fIsecondBand\fR, for clarity the gate
produced is actually a contour, and evaluated as a the contour described
above.  This sort of gate is intended to allow users to set off particle groups
in the deltaE-E plot of an Si detector (e.g.), with bands and the from those
bands, produce contours around the individual particle species.  Note that this
implies that if one of the constituent bands is modified, the bandcontour is
\fInot\fR modified.
.TP
\fBCGate* CreateNotGate(STD(string) \fIname\fB);\fR
Creates a gate that is true whenever the gate \fIname\fR is not true, and vica-versa.
.TP
\fBCGate* CreateAndGate(STD(vector)<STD(string)> \fIgateNames\fB);\fR
Creates a gate that is true only when all of the gates in the list
\fIgateNames\fR are true.
.TP
\fBCGate* CreateOrGate(STD(vector)<STD(string)> \fIgateNames\fB);\fR
Creates a gate that is true whenever at least one gate in the list
\fIgateNames\fR is true.
.TP
\fBCGate* CreateCut(STD(string) \fIparameter\fB, Float_t \fIlow\fB, Float_t \fIhigh\fB);\fR
Creates a gate that is a cut on \fIparameter\fB.  The gate is true for every
event where \fIparameter\fB is in the range [\fIlow\fR..\fIhigh\fR].
.TP
\fBCGate* CreateGammaCut(Float_t \fIlow\fB, Float_t \fIhigh\fB,STD(vector)<STD(string)> \fIspectra\fB);\fR
Creates a gamma cut.  Gamma cuts are applied to gamma spectra.  They act as
folds.  For each parameter that is in the gate, the spectrum is incremented for
all other parameters.  
.PP
Note that the semantics of gamma gates and spectra are likely to
change in the near future.  We apologize for this potential instability in the
API, however we feel that the changes anticipated will better serve the needs
of the SpecTcl user community.  For now \fIspectra\fR is a list of spectra on
which to display this cut.
.TP
\fBGate* CreateGammaBand(STD(vector)<FPoint> \fIpoints\fB, STD(vector)<STD(string)> \fIspectra\fB);\fR
Creates a gamma band gate.  The points that define the band are in
\fIpoints\fR.   The spectra that this band should display on are in
\fIspectra\fB.  Gamma bands can only be applied to gamma spectra.  If any pair
of parameters for that spectrum are in the gamma band, the spectrum is
incremented for all other parameters or parameter pairs if 2-d.
.PP
Note that the semantics of gamma gates and spectra are likely to
change in the near future.  We apologize for this potential instability in the
API, however we feel that the changes anticipated will better serve the needs
of the SpecTcl user community.  For now \fIspectra\fR is a list of spectra on
which to display this cut.
.TP
\fBCGate* CreateGammaContour(STD(vector)<FPoint> \fIpoints\fB, STD(vector)<STD(string)> \fIspectra\fB);\fR
Creates a gamma contour.  Gamma contours are handled identically to gamma
bands (see above.. including the warning about gate semantics), however the
spectra gated is incremented when parameters are inside the contour.
.SH "GATE DICTIONARY API"
.PP
The gate dictionary API allows you to add gates to the gate dictionary, delete
gates, replace the definition of existing gates, locate the gate container that
is the invariant handle to a gate and iterate through the gate dictionary. In
addition, you can apply gates in the gate dicationary to a spectrum.
.PP
The gate dictionary is structured as an STL container of pair<string,
CGateContainer*> entries.  The string is the name of the gate, and the
CGateContainer is a pointer like entity that, for all intents and purposes can
be treated as a pointer to the gate.  The address of the gate container will
never change, even if the underlying gate is modified.  This allows you to use
the gate container as an invariant pointer to the gate, regardless of the
gate's definition.
.PP
Common return types and parameters to this section include:
.AP CGate* gate in
A pointer to a gate.
.AP string gateName in
The name of a gate.
.AP CGate& newGate in
A reference to a gate.
.AP CGateContainer* pCGate out
A pointer to a gate container.  The gate container can be used as if it were a
pointer to the underlying gate.  It will remain valid even if the underlying
gate is moedified.  Note that when a gate is deleted, its gate container will
point to a False gate.
.AP CGateDictionaryIterator p out
A gate iterator is a pointer like object that can be dereferenced, incremented
and compared to other CGate DictionaryIterators.  When dereferenced, the gate
iterator `points' to the dictionary entry for a gate which is a pair<string,
CGateContainer*>.
.PP
.TP
\fBvoid AddGate(STD(string) \fIname\fB, CGate* \fIgate\fB);\fR
Adds a gate to the gate dictionary.  The \fIgate\fR will be given the \fIname\fR as
its name.  Gate names must be unique,  therefore a CDictionaryException is
thrown if you attempt to create a gate with a name that is already in the
dictionary. 

Once added, gates will be checked by SpecTcl for each event as
needed.  In addition, gates in the gate dictionary will be visible to SpecTcl's
gate commands such as \fBgate\fR, and \fBapply\fR.  SpecTcl will ensure that
gates that are in the dictionary are displayed on ``appropriate'' spectra.
.TP
\fBvoid DeleteGate(STD(string) \fIgateName\fB);\fR
Deletes the gate named \fIgateName\fR.  If the gate does not exist, a
CDictionaryException is thrown.
.TP
\fBvoid ReplaceGate(STD(string) \fIgateName\fB, CGate& \fInewGate\fB);\fR
The definition of the gate \fIgateName\fR is replaced by that of
\fInewGate\fR.  Since internally all SpecTcl gate references are through gate
containers, this change is immediately visible.  If the gate \fIgateName\fR
does not exist, a CDictionaryException is thrown.
.TP
CGateContainer* FindGate(STD(string) \fIgateName\fB);\fR
Locates the gate container that is the invariant pointer to the gate
\fIgateName\fR. A pointer to the gate container is returned.  Note that if the
gate does not exist, a CDictionaryException is thrown.  The following
sample code shows how this can be used to get the current type of the gate
named \fIgeorge\fR.
.CS

    SpecTcl& api(*(SpecTcl::getInstance()));
    try {
        CGateContainer& pGate(*(FindGate("george")));
        cerr << "The gate george is of type: " << pGate->Type() << endl;
    }
    catch (CDictionaryException& e) {
      cerr << "The gate george does not exist\\n";
    }

.CE
.TP
\fBCGateDictionaryIterator GateBegin();\fR
Returns a start of iteration iterator.  This can be used to loop over the set
of gates in the gate dictionary.  The sample code below shows how to list out
the names of all the gates:
.CS

    SpecTcl& api(*(SpecTcl::getInstance()));
    CGateDictionaryIterator i = api.GateBegin();
    while (i !+ api.GateEnd()) {
      cerr << i->first << endl;
    }

.CE
.TP
\fBCGateDictionaryIterator GateEnd();\fR
Returns an end of iteration iterator to the gate dictionary.
.TP
\fBUInt_t GateCount();\fR
Returns the number of gates in the gate dictionary.
.TP
\fBvoid ApplyGate(STD(string) \fIgateName\fB, STD(string) \fIspectrumName\fB);\fR
Applies a the gate \fIgateName\fR to the spectrum \fIspectrumName\fB  if either
the gate or the spectrum don't exist, a CDictionaryException will be thrown.
The effect of applying the gate is immediate. Note as well that the gate is
applied via a gate container.  Therefore subsequent changes in the gate
definition will be immediately reflected in the way the spectrum is
incremented.
.SH "EVENT PROCESSOR PIPELINE INTERFACE"
.PP
For SpecTcl to work correctly it must have user written code that transforms
raw events into unpacked events (called parameters or parameter arrays or
CEvent's). In order to support good, modular programming practices, SpecTcl
allows the programmer to split up this transformation into sequential stages.
This set of sequentially called transformations is called the \fIEvent
processing pipeline\fR.  The programmer can build up the event processing
pipeline by inserting \fIEvent processors\fR into the pipeline in the order in
which he/she wants them run.  Almost any non\-trivial analysis problem is
typically broken down into manageable steps through this mechanism.  This
mechanism is also used to ``bolt'' several detector systems together into an
experiment, allowing the software development for each detector system to be
done indepedently of the other groups.  At the NSCL, event data are structured
into 'labelled' packets with a leading size.  This allows event processors to
easily ignore packets they do not understand while processing those they do.
.PP
The event processor pipeline interface allows you to append event processors
into the pipeline or insert them prior to any existing element.  As of SpecTcl
3.0, Event processors can be given names, and searched for within the pipeline
by the names they were assigned.  For compatibility with prior versions of
SpecTcl, unnamed event processors are supported (they are assigned a unique
hard to guess name).  Event processors can be dyamically removed from the
pipeline.  For example, if you want to analyze filtered data, you will want to
remove all of the event processing pipeline elements that decode the raw event
data as the filter processor should be used to replace those.  You can also
iterate through the event processing pipeline.
.PP
The event processor pipeline interface uses several common return types and
parameters described below:
.AP CEventProcessor& eventProcessor in
 A reference to an event processor you have created.
.AP "const char*" name in
The name of an event processor in situations where the event processor name is
optional. 
.AP string sname in
The name of an event processor in situations where the event processor name is
mandatory.
.AP CTclAnalyzer::EventProcessorIterator p out
An iterator into the event processor pipeline.  Iterators into the event
processor pipeline are pointer like objects that can be dereferenced,
incremented, and compared to other CTclAnalyzer::EventProcessorIterator
objects.  When dereferenced, they will obtain a pair<string, CEventProcessor*>
where the string is the name of the event processor and the CEventProcessor* is
a pointer to the event processor itself.
.AP 
.PP
.TP
\fBvoid AddEventProcessor(CEventProcessor& \fIeventProcessor\fB, const char* \fIname\fB = 0);\fR
Appends an event processor to the end of the event processor pipeline.  This
will cause the event processor's \fIOnAttach\fR member to be called, notifying
it of the addition to the event pipeline.   If the \fIname\fR parameter is
omitted, a unique non-obvious name is assigned.
.TP
\fBCTclAnalyzer::EventProcessorIterator FindEventProcessor(STD(string) \fIsname\fB);\fR
Returns an iterator to the event processor named \fIsname\fR.  If the event
processor does not exist, the iterator returned is an end of iteration iterator
(compares as equal to \fBProcessingPipelineEnd()\fR).  Recall that the iterator
will `point' to a pair<string, CEventProcessor*> where the string is the name
associated with the event processor.  

Suppose you have registered an event processor named \fIgeorge\fR, of type
GeorgeEventProcessor.  If this event processor has a member named \fBprod\fR,
you can located \fIgeorge\fR and call \fBprod\fR as follows:
.CS

    SpecTcl&  api(*(SpecTcl::getInstance()));
    CTclAnalyzer::EventProcessorIterator p = api.FindEventProcessor("george");
    if(p != api.ProcessingPipelineEnd()) {                // "george" was found.
      try {
         GeorgeEventProcessor* pProc =
                           dynamic_cast<GeorgeEventProcessor*>(p->second);
         // The dynamic cast will throw if "george" is of the wrong type.
    
         pProc->prod();                 // Prod the event processor.

      }
      catch(...) {                      // not of type GeorgeEventProcessor
        cerr << "george is not the right type of event processor\\n";
      }
    }

.CE
.TP
\fBCTclAnalyzer::EventProcessorIterator FindEventProcessor(CEventProcessor& \fIeventProcessor\fB);\fR
Given a reference to an event processor (\fIeventProcessor\fR)  you have entered into the event
processing pipeline, this function returns an iterator that points to the
pair<string, CEventProcessor*> such that the event processor pointer points to
that event processor.  If the event processor is not in the event processor
pipeline, the end of iteration iterator (\fBProcessingPipelineEnd()\fR) is
returned.

Given that you have an event processor object \fIgeorge\fR  in the event
pipeline, the code below lists the names of the event processors that follow it
in the pipeline:

.CS

     SpecTcl& api(*(SpecTcl::getInstance()));
     CTclAnalyzer::EventProcessorIterator p = api.FindEventProcessor(george);
     if (p != api.ProcessingPipelineEnd()) {
        cerr << "My processor is named: " << p->first << endl;
        cerr << "It is followed by: \\n";
        p++;
        while (p != api.ProcessingPipelineEnd()) {
            cerr << p->first << endl;
        }
     }

.CE
.TP
\fBvoid InsertEventProcessor(CEventProcessor& \fIeventProcessor\fB,CTclAnalyzer::EventProcessorIterator \fIwhere\fB, 
\fBconst char*  \fIsname\fB = 0);\fR

Inserts a new event processor in the pipeline prior to the position of the
event processor indicated by the iterator.  The following code is equivalent to
\fBAddEventProcessor\fR:
.CS

     SpecTcl& api(*(SpecTcl::getInstance()));
     api.InsertEventProcessor(george, api.ProcessingPipelineEnd(), "george");

.CE
.TP
\fBvoid RemoveEventProcessor(STD(string) \fIsname\fB);\fR
Removes the event  processor named \fIsname\fR.  If the event processor does
not exist, this is a no-op at this time.  In the future, we reserve the right
to throw a CDictionaryException.
.TP
\fBvoid RemoveEventProcessor(CTclAnalyzer::EventProcessorIterator \fIhere\fB);\fR
Removes the event processor `pointed' to by the iterator \fIhere\fR.
.TP
\fBUInt_t ProcessingPipelineSize();\fR
Returns the number of elements in the event processing pipeline.
.TP
\fBCTclAnalyzer::EventProcessorIterator ProcessingPipelineBegin();\fR
Returns a start of iteration iterator to the event processing pipeline.
.TP
\fBCTclAnalyzer::EventProcessorIterator ProcessingPipelineEnd();\fR
Returns an end of iteration iterator to the event processing pipeline.
.SH "EVENT SINK PIPELINE API"
.PP
Once the event processing pipeline has created a parameter array (CEvent),
bunches of these are grouped into a CEventList object and passed to a pipeline
of event sinks.  Event sinks are expected to do analysis on the unpacked CEvent
objects in the CEventList.  At present, SpecTcl has two predefined types of
event sinks:  CHistogrammer which increments histograms depending on the gate
and histogram definitions it has been given, and CFilter which produce filtered
data sets.  You can produce your own application specific event sinks and add
them to the event sink pipeline if you have a need to do so.
.PP
The API into the event sink pipeline supplies the same functionality as that of
the API for the Event Processing pipeline.  See \fBEVENT PROCESSOR PIPELINE
INTERFACE\fR for a summary of that interface.  The functions in this interface,
all make use of a common set of return types and parameters.  These are
described below:
.AP CEventSink& sink in
A reference to an evernt sink.
.AP "const char*" name in
An optional name to give an event sink in the pipeline.  If none is given, the
subsystem creates a unique unobvious name.
.AP string sinkName in
A mandatory name of an event sink (e.g. as in the searching functions).
.AP CEventSinkPipeline::EventSinkIterator p out
An iterator to the event sink pipeline.  Iterators are pointer like objects
that can be derefrenced, incremented and compared to each other.  Iterators to
elements of the event sink pipeline `point' to STL pair<string, CEventSink*> 
objects.  The \fIstring\fR is the name of the sink while the \fICEventSink*\fR
is a pointer to the event sink at that stage of the pipeline.
.AP CEventSink* pe out
A pointer to an event sink.
.PP
.TP
\fBvoid AddEventSink(CEventSink& \fIsink\fB, const char* \fIname\fB = 0);\fR
Appends an event sink to the event sink pipeline.  Once appended, the event
sink's \fBOnAttach\fR member is called.
.TP
\fBCEventSinkPipeline::EventSinkIterator FindEventSink(STD(string) \fIsinkName\fB);\fR
Locates the iterator that corresponds to the event sink \fIsinkName\fR.  If the
sink is not found, an end of iteration iterator is returned.
.TP
\fBCEventSinkPipeline::EventSinkIterator FindEventSink(CEventSink& \fIsink\fB);\fR
Locates and returns the event sink specified in the event sink pipeline and
returns an iterator to it.  If the sink is not in the event sink pipeline, an
end of iteration iterator is returned.  The code example below shows how to let
the system choose a name for an event sink and then determine what name was
assigned:
.CS

    SpecTcl& api(*(SpecTcl::getInstance()));
    api.AddEventSink(somesink);               // System chooses the name.
    CEventSinkPipeline::EventSinkIterator p = api.FindEventSink(somesink);
    string sinkName = p->first;

.CE
.TP
\fBvoid InsertEventSink(CEventSink& \fIsink\fB, CEventSinkPipeline::EventSinkIterator \fIhere\fB, 
\fBconst char* \fIname\fB = 0);\fR

Inserts a new event sink prior to the sink specified by \fIhere\fR.  The code
below is equivalent to call to \fBAddEventSink\fR.
.CS

    SpecTcl& api(*(SpecTcl::getInstance()));
    api.InsertEventSink(somesink, api.EventSinkPipelineEnd(), "somesink");

.CE
.TP
 \fBCEventSink* RemoveEventSink(STD(string) \fIname\fB);\fR
Removes the sink \fIname\ from the event sink pipeline and returns a pointer to
it.  If the sink does not exist, a \fBNULL\fR pointer is returned.  The
\fBOnDetach\fR member of the sink is called to notify it that it is being
detached from the pipeline.
.TP
\fBCEventSink* RemoveEventSink(CEventSinkPipeline::EventSinkIterator \fIhere\fB);\fR
Removes the event sink `pointed' to by the iterator \fIhere\fR from the event
sink pipeline and returns a pointer to the sink itself.  The \fBOnDetach\fR
member function of the sink is called to notify it that it is being detached
from the pipeline
.TP
 \fBUInt_t EventSinkPipelineSize();\fR
Returns the number of elements int he event sink pipeline.
.TP
\fBCEventSinkPipeline::EventSinkIterator EventSinkPipelineBegin();\fR
Returns a beginning of iteration iterator for the event sink pipeline.
.TP
\fBCEventSinkPipeline::EventSinkIterator EventSinkPiplineEnd();\fR
Returns an end of iteration iterator for the event sink pipelne.  The sample
below shows how to use this function to list the names of the event sinks in
the pipeline:
.CS

    SpecTcl& api(*(SpecTcl::getInstance()));
    CEventSinkPipeline::EventSinkIterator p = api.EventSinkPipelineBegin();
    while (p != api.EventSinkPipelineEnd()) {
      cerr << p->first << endl;
    }

.CE
.SH "MISCELLANEOUS"
.PP
  This section describes API member functions that don't fit nicely into any of
the function groups described above.
.TP
\fBvoid AddSpectrumFormatter(STD(string) \fIname\fB, CSpectrumFormatter& \fIformatter\fB);\fR
SpecTcl's \fBsread\fR and \fBswrite\fR commands accept a swtich
(\fB-format\fR) that specifies the format of the spectrum file that is being
read or written.  The set of formats recognized by these commands is
extensible.   SpecTcl's mechanism for extending this set of formats is to
register a set of named spectrum formatters.  Each formatter is capable of
reading and writing single spectra from or to a C++ input or output stream.

\fBAddSpectrumFormatter\fR is an API function that allows you to register your
own spectrum formatters with SpecTcl.  Once registered, the \fBsread\fR and
\fBswrite\fR commands will understand the formatter and add it to the usage
string for their commands.
.TP
\fBCTCLInterpreter*  getInterpreter();\fR
Returns the object encapsualted Tcl/Tk interpreter being used to process
SpecTcl commands.


