This is gri.info, produced by makeinfo version 4.3 from gri.texi.

INFO-DIR-SECTION Scientific Applications
START-INFO-DIR-ENTRY
* Gri: (gri).  Programming language for scientific illustration
END-INFO-DIR-ENTRY


File: gri.info,  Node: Top,  Next: Introduction,  Prev: (dir),  Up: (dir)

Gri
***

   This manual describes Gri version 2.12.7 (c) 1991-2003, Dan Kelley
at email address dankelley@users.sourceforge.net

   Licensing follows the GNU Public License (*Note License::).

   Gri is an extensible plotting language designed for scientists.  It
can draw x-y plots, contour plots, and image plots, and has rudimentary
programming capabilities.  It is not mouse driven, nor gui-based;
rather, it is an interpreted scriping language.  Users regard it as an
analogue to the latex document formatting language: users gain
considerable power, at the price of a moderate learning curve.

* Menu:

* Introduction::                What Gri is for
* Simple Example::              Introductory example
* Invoking Gri::                Running/viewing/printing Gri
* Getting More Control::        Controlling axes, text, color, etc.

* X-y Plots::                   Drawing x-y linegraphs/scattergraphs
* Contour Plots::               Drawing contour plots
* Images::                      Drawing black+white or color images

* Examples::                    Some real-world examples
* Handling Data::               Dealing with oddly-configured data
* Commands::                    All about the many Gri commands
* Programming::                 How to program in the Gri language
* Environment::                 Related tools
* Emacs Mode::                  Editing Gri code inside Emacs
* History::                     How Gri has changed over time
* Installation::                How to install Gri
* Bugs::                        Known bugs, and how to report more
* Test Suite::                  Series of test programs
* Gri in the Press::            Further reading
* Acknowledgments::             Many folks have helped me with Gri
* License::                     Gri is open-source!

Three indices
* Concept Index::               Detailed index
* Index of Commands::           Commands in Gri
* Index of Builtins::           Builtin variables


File: gri.info,  Node: Introduction,  Next: Simple Example,  Prev: Top,  Up: Top

Introduction
************

   *Gri is a programming language for drawing science-style graphs*.
It is not mouse-driven, and it does not draw business-style graphs
(e.g. pie charts, three-dimensional graphs).  Gri has substantial power
in advanced applications.  It has been proven to be easy to learn; for
simple applications, the learning curve is less than an hour.  Many
users regard Gri as the plotting equivalent of the LaTeX document
preparation system.

   *Computers Gri works on:* unix computers of many types, plus
Microsoft Windows, and Macintosh OSX.  You'll find Gri pre-packaged for
various unixes, e.g. linux/debian, linux/redhat, and freeBSD.

   *Capabilities of Gri* are those scientists commonly want, since Gri
was written by a scientist.  It is not so useful for business people -
e.g., Gri draws xy graphs (*Note X-y Plots::), contour plots (*Note
Contour Plots::), and image plots (*Note Images::), but it will not
draw pie-charts unless you teach it how.  The list of capabilities of
Gri is similar to many packages, but unlike many of the other packages,
Gri gives you control over line widths, fonts, grayscales, etc.  (*Note
Getting More Control::), and it is a programming language of moderate
power.

   *The Gri drawing metaphor* is that of pen on paper.  The ink in the
pen is opaque.  An item drawn in white ink will erase a previously drawn
underlying object drawn in black ink.  For example, to draw a timeseries
curve in which the region between positive data values and the y=0 axis
is filled with black ink, you might use (`draw curve filled') to draw
the timeseries with black ink (the default color), blackening the area
between the curve and the lower axis.  Then you could load white ink
into the pen (using the `set graylevel 1' or `set graylevel white'
command) and white-out a box drawn between the zero line and the lower
axis.  Then you'd load black ink back into the pen (`set graylevel 0')
and draw the curve again, so that the negative part would appear again.

   *Input/output* in Gri may be interactive or non-interactive.  For
interactive use, type `gri' at the system commandline prompt.  For
non-interactive use, with Gri commands in a command-file called
`cmd.gri', type `gri cmd.gri'.

   *Gri output* is in the PostScript page description language.  The
output is therefore of high quality, device-independent, capable of
being inserted into popular text processors (e.g. LaTeX), and easily
displayed.

   *Online help:* the Gri command `help' makes Gri list the first words
of all known commands, along with a hint for getting further help.  To
get more information, type `help' followed by a command-name (e.g.
`help read').  There is also a tiny bit of information stored online
and categorized by topic.  Get this by typing for example `help -
strings' (*Note Online Help::).

   *Data analysis* in Gri is limited.  It has rudimentary data analysis
functions, such as regression, column manipulation, smoothing, etc, but
it is not intended as an integrated analysis/graphics package.

   *System calls* are an easy and important facet of Gri.  It is easy
to use operating system commands within Gri (*Note System::; *Note
Operating System::; *Note Get Env::).  This allows you to use familiar,
powerful tools, and keeps Gri simple.  Particularly useful is the
ability to read files through operating system filters (*Note Open::).

   *Programming Gri* is quite straightforward, and users familiar with
other programming languages find it easy.  If Gri lacks a drawing
method, you can add it fairly easily, since Gri has programming elements
such as `if' statements (*Note If Statements::), `while' loops (*Note
While::), facilities for interacting with the user (*Note Query::), and
mechanisms for storing numbers in "variables" (*Note Variables::), and
text strings in "synonyms" (*Note Synonyms::).  The Gri syntax can be
augmented easily (*Note Adding New Commands::), and these augmentations
can be stored in a startup file (*Note Resource File::), creating
personalized versions of Gri.

   *Manuals:* Gri has an online texinfo manual, a PostScript manual, a
WWW manual, a cookbook and several reference cards.  It also has
several discussion groups (*Note Discussion Group::).

   *Version Numbering Scheme*

   When you launch Gri interactively (without naming a commandfile,
i.e. by just typing `gri' at the unix prompt), you'll see something like

      gri - scientific graphic program (version 2.12.7)
      GPL Copyright 2003 by Dan E. Kelley.
     
      Type `help' for an overview of Gri commands, or see the
      full manual at
          /usr/share/doc/gri-2.12.7/html/index.html
      and its text-only version in the 'gri' INFO node.
     
      Visit http://gri.sourceforge.net for updates and resources.
     gri:

The last line is a prompt, suggesting that you type in Gri commands.
You may type `quit' to get out of gri.

   The first line gives the version number.  You can also get this by
running Gri with the command `gri -v'.  Version numbers have three
numbers separated by periods.  The first number increments for major
changes, the second for smaller changes, the third for still smaller
changes.  The second number also indicates whether a copy is an
experimental version or a more reliable release version.  Experimental
versions have the second digit being an odd integer, while release
versions have this digit being even.


File: gri.info,  Node: Simple Example,  Next: Invoking Gri,  Prev: Introduction,  Up: Top

Simple Gri Program and How to Run it
************************************

   This chapter introduces Gri with a common example: an x-y graph.  The
example is discussed in detail later (*Note X-y Plots::).  The data
files and command files here and throughout the manual should be
available to you in a directory `.../gri/examples' on unix machines.

Gri Command file
================

   Here is a Gri command file to plot a linegraph of a set of (x,y)
data, stored as space-separated columns in a file called `example1.dat':

     # Example 1 -- Linegraph of data in separate file
     open example1.dat     # Open the data file
     read columns x y      # Read (x,y) columns
     draw curve            # Draw data curve
     draw title "Example 1"# Title above plot

The first line is a comment, as are all things following hash symbols
(`#').  (An exception to this rule is made within strings contained
within the double-quote character `"'.  This allows `sed' system
commands to work as expected; (*Note System::).)

   The other lines are Gri command lines; (*Note X-y Plots::) for more
explanation.

Data File
=========

   The data file `example1.dat' looks like:

     0.05 12.5  # first point
     0.25 19    # second point
     0.5  15    # third point
     0.75 15    # ... you get the idea!
     0.95 13

Note that spaces (or tabs) separate numbers.  Any data line may have a
comment on it, just as any command line may.

Running The Command File
========================

   Type `gri example1.gri' at the system prompt.  Gri will create a
PostScript file called `example1.ps'.  For details on running Gri see
*Note Invoking Gri::.

Output Graph
============

   The output PostScript file is called `example1.ps'.

example1.gri

   To view Gri output, use your favorite PostScript previewer.

   Note that in the above example, Gri automatically chose reasonable
scales for the axes, based on the range of the data.  The next chapter
illustrates that Gri also gives you control over such things.


File: gri.info,  Node: Invoking Gri,  Next: Getting More Control,  Prev: Simple Example,  Up: Top

Invoking Gri
************

Invoking Gri in a nutshell
==========================

   First, the short story.  In 90 percent of cases, Gri is run as

     gri myscript

   where the file `myscript.gri' holds a script (list of Gri commands),
and Gri will create a PostScript file called `myscript.ps' with the
output.

   Some folks like to give the `.gri' suffix explicitly, so they would
invoke Gri as

     gri myscript.gri

instead.

   If you'd rather not have `myscript.ps' as the PostScript output file
name (let's say you prefer `graph1.ps') you'd do

     gri -output graph1.ps myscript.gri

   Few readers will need to know more than this.  But, for the rest, the
table in the next section gives full details on all the optional
arguments that Gri can handle.

Using Gri to draw things
========================

   To draw things, invoke Gri as

     gri [OPTIONS] [CmdFile [optional_arguments]]

where the square brackets indicate that the enclosed items are
optional.  The `OPTIONS' item may consist of one or more of the
following (explained below):

     [-batch]
     [-b]
     [-chatty N]
     [-c      N]
     [-debug]
     [-d]
     [-directory_default]
     [-directory pathname]
     [-help]
     [-h]
     [-no_bounding_box]
     [-no_cmd_in_ps]
     [-no_startup_message]
     [-output PS_file_name]
     [-publication]
     [-p]
     [-superuser N]
     [-trace]
     [-t]
     [-yes]
     [-y]
     [-version]
     [-v]
     [-warn_offpage]
     [-no_warn_offpage]

Here, the optional `optional_arguments' are a mechanism to customize
the action of the given Gri script from the commandline.  After Gri
processes standard arguments (e.g. `-t' for tracing), it puts the
remaining commandline arguments into a list.  This behavior is borrowed
from C and othe languages, so Gri borrows the name of the list as well:
it's called the "arg" list, and its elements are available with the RPN
operators named `argc' (*Note Solitary Operators::) and `argv' (*Note
Unary Operators::).

   For a note on usage within the Emacs gri-mode, see *Note Filename
arguments when running gri::.

   *Details of command-line options*

   * `-batch' or `-b' Stops Gri from printing out prompts and hints.

   * `-chatty N' or `-c N' Make Gri print out various informative
     messages.  The numerical value gives a level of chattiness.  A
     value of 1, the default if the `-chatty' code is not supplied,
     tells Gri to keep you informed of some important things, like the
     success in gridding data for contouring.  Higher values make Gri
     tell you more:

     Information printed at various chatty levels:
        * *0* The bare minimum is printed.  Thus invoking Gri as `gri
          -c 0'...  will make it as quiet as can be.

        * *1 or higher* (the default) The full filenames of the
          commandfiles are displayed at startup time.

          `convert columns to grid' prints percentage of grid filled,
          as well as a suite of diagnostics, if you've let it calculate
          the region of influence automatically.  It also prints a
          warning of the time it expects to take, before starting the
          calculation.

          `convert grid to image' prints characteristics of image
          created, including amount of image clipped.

          `read grid data' reports number of data values it could not
          read (since they were nonnumeric).

          `draw symbol' reports number of data points not drawn because
          they were missing or outside clip region (if one exists).

        * *2 or higher* `draw contour' prints value of contour being
          drawn.

          `open "...|"' prints the command to be passed to the operating
          system as well as the name of the temporary file being
          created; also notifies user when the temporary file is
          destroyed.

          `show image' reports histograms in intensity bands of 8 units,
          instead of the default 16 units.

        * *3 or higher* `show image' reports histograms in intensity
          bands of 4 units, instead of the default 16 units.


   * `-debug' or `-d' Sets the built-in variable flag `..debug..' that
     you can use to isolate blocks of code.

   * `-directory_default' Reports directory where `gri.cmd' is expected
     to be found, either in the default location or the one specified
     by `-directory' commandline option.

   * `-directory pathname' Specifies the directory where Gri looks for
     the startup file `gri.cmd'.  (This file teaches Gri the standard
     commands; Gri will report an error and die if it cannot find this
     file.)  If this switch is not provided - and it is normally not -
     then Gri looks for `gri.cmd' in a standard system directory
     (sometimes, but not always, `/usr/local/share/gri/2.12.7') which
     was specified during the compilation of the Gri program itself.
     For more on how Gri looks for `gri.cmd', see the subsection below.

   * `-no_bounding_box' Make the so-called "bounding box" in the
     PostScript file be the full page.  The bounding box is used by
     some PostScript previewers to clip the image to just the drawn
     parts of the page, and is used by the `epsfbox' macro in `latex'
     to automatically determine the geometry of the graph for inclusion
     in text.  Normally the bounding box is calculated automatically,
     to enclose all the items drawn on the page.  But the box may also
     be set with the `set bounding box' command (*Note Set Bounding
     Box::).

   * `-no_cmd_in_ps' Prevent Gri from inserting the lines of the
     commandfile into the PostScript file as comments.  (These comments
     can be used by the `-creator' commandline option (see above), but
     they take up a little bit of space and users might sometimes want
     to get rid of them.)

   * `-no_warn_offpage' Do not warn if items are offpage.  (Contrast
     this with `-warn_offpage'.)

   * `-output PS_file_name' Specify the PostScript filename.  If this
     is not specified, the PostScript filename is derived from the name
     of the commandfile (e.g. `mygraph.gri' produces `mygraph.ps'), or,
     for interactive use, it will have a name like `gri-00.ps', or
     `gri-01.ps' if the former file exists, etc.

   * `-no_startup_message' Stops Gri from printing the startup message.

   * `-publication' or `-p' Sets the built-in variable
     `..publication..' to 1.  You may use this to distinguish between
     working plots and publication plots, as in this example:

          if !..publication..
            draw time stamp
            draw title "working version of plot"
          end if

   * `-superuser' (This option is included here only for completeness.
     It should only be used by developers (who will alter the code to
     print debugging information if `-superuser' is set in addition to
     `-debug').  An optional value can be inserted (e.g. `-superuser
     2') to set the debugging level (retrievable by the function
     superuser()) to indicated integer value.  Specifying the
     `-superuser' command-line option sets the built-in variable
     `..superuser..' to 1 or the specified value.)

     For flag meanings, see `superuser' command (*Note Superuser::).
     Using the question-mark symbol `?' instead of a flag number makes
     Gri print out the list of flags.

   * `-trace' or `-t' Makes Gri print out command lines as they are
     executed; this has the same effect as the `set trace' command.

   * `-version' or `-v' Display version information and exit
     successfully.

   * `-warn_offpage' Causes warnings to be issued for all items drawn
     far off a 8.5x11 inch page.  This is the default.  (Contrast with
     `-no_warn_offpage'.)

   * `-yes' or `-y' Bypasses all `query' commands, making Gri act as
     though the user typed a carriage-return (thus giving the default)
     for each `query'.

   * `-help' or `-h' Prints explanation of options.

   * `CommandFile' If a command file `CommandFile' is specified, then
     commands will be read from that file instead of the keyboard.  If
     the `chatty' level is 1 or larger, Gri prints the names of the
     commandfiles at startup time.  It is conventional but not
     necessary that the filename ends in `.gri'.  If the filename does
     end in `.gri', you may delete this suffix; Gri will assume it as
     implied.


   *Executable scripts.* If you don't need to supply commandline
options, you can put the following line as the first line in your Gri
program

     #!/usr/bin/gri

(or point to wherever Gri is located on your machine), and `chmod +x'
the file.  Then you can run Gri simply by naming the file.  There is no
particular advantage in this, except for saving the typing of a few
characters, but some folks like this.

   *How Gri locates the* `gri.cmd' *file*.  In a normal installation,
Gri finds the `gri.cmd' file all by itself.  However, developers and
some others may wish to control where Gri looks for this file.  The
rules below specify how Gri looks for `gri.cmd'.
_Case 1_
     If `-directory' was given on the commandline used to invoke Gri
     (e.g. `gri -directory /some/place mycommand_file.gri'), then Gri
     will use the `gri.cmd' in the named directory.  An error will
     result if `gri.cmd' is not found there.

_Case 2_
     If `-directory' was not given on the commandline, then Gri looks
     for `gri.cmd' in a location that was specified during compilation.
     If `gri.cmd' is found there, then it is used.  If it is not
     found, then Gri checks to see if an environment variable named
     `GRI_DIRECTORY_LIBRARY' is defined.  If so, then Gri takes this to
     be the name of a directory that contains the `gri.cmd' file.  If
     `gri.cmd' is not found there, an error results.

Extracting commandfile from a PostScript file
=============================================

     gri -creator PostScriptFile

*See also* `-no_cmd_in_ps'.

   The `-creator' flag makes gri examine the indicate PostScript file,
and produce a facsimile of the command file (or interactively-typed
commands) that created this PostScript file.  This is possible because
Gri stores the commands in the PostScript file as specially-marked
comments that can be retrieved and decoded later.

   Note that the commands are stored in the PostScript file at the time
of parsing, not at the time of execution.  Also, `insert' (*Note
Insert::) threads are not traced, at least in this version of Gri; if
user demand for tracing continues, it will be added in a future version.


File: gri.info,  Node: Getting More Control,  Next: Simple Example Revisited,  Prev: Invoking Gri,  Up: Top

Controlling Axes, Fonts, Colors, etc
************************************

   Gri provides a great many things that you can control, if you want
to.  An introduction to some of these things is presented in the
sections below.

* Menu:

* Simple Example Revisited::    Adding more details
* Axis Scaling::                Gri automatically scales and draws axes
* Log And Linear::              Selecting log/linar axes
* Length::                      Adjusting axis length
* Range::                       Adjusting axis range
* Labels::                      Adjusting labels on axes
* Position::                    Positioning the axes
* Fonts::                       Setting fonts
* Pen Color::                   Controlling Pen color


File: gri.info,  Node: Simple Example Revisited,  Next: Axis Scaling,  Prev: Getting More Control,  Up: Getting More Control

An example
==========

   Below is a followup to the previous example, which names the x and
the y axes.

     # Fancier version of Example 1
     open example1.dat
     read columns x y
     set x name "Time, hours"
     set y name "U, m/s"
     draw curve

   The difference is that the x and y axes are named with a `set'
command.  There are many `set' commands, and they are all pretty
simple, e.g. `set x size 15' makes the x-axis be 15 centimeters long,
instead of the default of 10 centimeters.  Indeed, you can control
anything you want in gri, e.g. graph size, line width, fonts, etc etc.
Speaking of fonts, the `$\alpha$' type of latex formatting of Greek
letters is supported in a limited way.  Also, Gri handles ISO-Latin-1
encodings as well as the U.S. style.

   The example below illustrates a few more `set' commands.  This
example is intentionally complicated, being about a good example of the
level of complexity of many plots made by Gri.  Read the comments to see
what is being done, and consult the plot as you read the commandfile.

example3.gri

     # Example 3 -- Controlling scales, etc
     #
     # Example of how to control axis scales, etc.  This example makes
     # two panels, plotting the same data in different ways.
     #
     #
     # ----- PANEL 1 ------------------------------------------------
     #
     # Set up the x axis.
     #
     # Make the x axis run from 0 to 1, with labelled tics each 0.25.
     set x axis 0   1   .25
     # Make the x-axis be 5 cm long; in other words, make the plot 5 cm wide.
     set x size 5
     # Put 2 cm of space between the left edge of the plot and the left
     # edge of the paper.
     set x margin 2
     # Give the x-axis the name "t" with subscript 0.
     set x name "$t_0$"
     #
     # Set up the y axis.
     #
     # Make the y axis run from 10 to 20, with labelled tics at intervals
     # of 5 and smaller, unlabelled tics, at intervals of 1.  Other
     # commands are similar to those for the x-axis.
     set y axis 10 20 5 1
     set y size 10
     set y margin 2
     set y name "F"
     #
     # Now, read our simple data set.
     open example1.dat
     read columns x y
     close
     #
     # Draw a curve connecting these (x,y) data.  Note that the axes, as
     # defined above, will be drawn automatically along with the curve.
     draw curve
     
     
     #
     # ----- PANEL 2 ------------------------------------------------
     #
     # OK, now for a more complicated version.  We'll keep the same data, but
     # redraw it in a new panel, to the right of the first graph.  So, the
     # first step is to increase the x margin.  The {rpn} command simply
     # creates a number which is the sum of the old x margin (stored in
     # the variable ..xmargin..) and the old plot width (stored in
     # the variable ..xsize..), plus an extra 1 cm
     set x margin {rpn ..xsize.. ..xmargin.. + 1 +}
     #
     # Set the line thickness for the curve to 1 point (0.3 mm) and the
     # axis line thickness to 0.2 points (0.1 mm).
     set line width 1.0              # points
     set line width axis 0.2         # points
     # Set the tics to be 1.5 mm.
     set tic size 0.15               # centimetres
     # Draw axes and frame, with axes offset from frame.  Some
     # people find this more attractive.
     set axes style offset
     draw axes 1
     # Now draw the actual curve.
     draw curve
     # Superimpose dots (diameter 1.5 mm) at the data.
     set symbol size 0.15
     draw symbol bullet
     #
     # All done.
     # Draw a title above the plot.
     set font size 20
     \label = "Example 3 -- scales, axes, etc"
     draw label "\label" at          \
         {rpn 8.5 2.54 * "\label" width - 2 /} \
         {rpn ..ytop.. yusertocm 2 +}\
         cm


File: gri.info,  Node: Axis Scaling,  Next: Log And Linear,  Prev: Simple Example Revisited,  Up: Getting More Control

Axis scaling
============

   Gri normally assumes that you are plotting scientific graphs, and
therefore whenever it sees a command like `draw curve' or `draw
symbol', it draws an appropriate axis first.  You can turn this feature
off, by using `draw axes none' before the other `draw' command.

   Furthermore, Gri picks axis scales by itself, by scanning the (`x',
`y') columns.  If you don't like the scales Gri picks, you can override
them (*Note Range::).

   Gri normally draws axes labelled at left and bottom, and with an axis
frame with tics all around.  If you don't like this default axis style
you can specify other styles.  For example, if the commands `draw x
axis' and `draw y axis' are placed before the `draw curve' command, Gri
will realize you've already specified axes, and just draw them on the
left and bottom sides of the box, without completing the axis frame.

   For your general use, Gri stores the minimum and maximum x and y
values of the *axes* in the variables `..xleft..', `..xright..',
`..ybottom..', and `..ytop..'.  It also stores the increments used in
labelling these axes in the `..xinc..'  and `..yinc..' variables.

   To determine the minimum and maximum values of column data, you may
use the built-in RPN functions `min', `max', and `mean' (*Note
Manipulation of Columns etc::).

   Gri stores the last (x,y) pair on a curve (whether data or axis) in
the `..xlast..' and `..ylast..' variables

   Gri stores the axis sizes in `..xsize..' and `..ysize..'.  It stores
the space to the left of the plot in `..xmargin..' and the space below
the plot in `..ymargin..'.


File: gri.info,  Node: Log And Linear,  Next: Length,  Prev: Axis Scaling,  Up: Getting More Control

Logarithmic and linear axes
===========================

   Axes are linear by default; to make logarithmic axes, use commands
`set x type log' and `set y type log'.


File: gri.info,  Node: Length,  Next: Range,  Prev: Log And Linear,  Up: Getting More Control

Axis Length
===========

   The axes are normally 10 centimetres long.  To set the axis lengths
(in centimetres), use commands like `set x size 5' and `set y size 7'.
Some people like the ratio of axes to be in the so-called golden ratio
`(root(5)-1)/2'; to get that, you could do this:

     set x size 15
     set y size {rpn ..xsize.. 5 0.5 power 1 - 2 / *}

   For maps, you'll want the plot scaled so that shapes retain their
aspect ratio.  To do this, do `set x size .cm.' and then do `resize y
for maps' (or vice versa).


File: gri.info,  Node: Range,  Next: Labels,  Prev: Length,  Up: Getting More Control

Axis Range
==========

   To override axis ranges set by Gri, use `set x axis' and `set y
axis'.  With these commands, you specify the range of the axes; you may
also set the interval for numbered tics, and an interval for unnumbered
tics.  The unnumbered tics must be at an interval that divides evenly
into the numbered tic interval, but the numbered tic interval need not
divide into the min/max range.  Thus, `set x axis 0 1.1 0.5' will
create an axis that will range from 0 to 1.1, with labelled tics at the
values 0, 0.5 and 1.


File: gri.info,  Node: Labels,  Next: Position,  Prev: Range,  Up: Getting More Control

Axis Name
=========

   To set the name of the x axis, use `set x name "string"', and
similarly for the y-axis.  The default names are `x' and `y'.


File: gri.info,  Node: Position,  Next: Fonts,  Prev: Labels,  Up: Getting More Control

Axis location
=============

   If you don't like the default position of axes (at left and bottom),
you may get Gri to draw axes anywhere you like, using commands like
`draw y axis at right' (so the y axis is at the right-hand end of the x
range) or `draw x axis at top' (so the x axis is at the top of the
plot); you may even specify an exact location, such as `draw x axis at
22.2'.

   Normally, the x axis is placed at the bottom end of the y axis, and
the y axis is placed at the left end of the x axis.  Some people prefer
a style in which the axes are positioned a small offset away from these
locations.  To get this effect, you may either position the axes
yourself, or simply use the `set axes style offset' command (*Note
Set::).  If you want this axis style for all their plots, put the line
`set axes style offset' in your `~/.grirc' startup file (*Note Resource
File::).


File: gri.info,  Node: Fonts,  Next: Pen Color,  Prev: Position,  Up: Getting More Control

Fonts
=====

   Fonts are selected with `set font to' (*Note Set Font To::) and font
sizes are selected with `set font size' (*Note Set Font Size::).

   Much more about text, including how to draw mathematical symbols,
how to use subscripts and superscipts, how to write non-English
(accented) European text, etc, is discussed (*Note Text::).


File: gri.info,  Node: Pen Color,  Next: X-y Plots,  Prev: Fonts,  Up: Getting More Control

Colour of ink in pen
====================

   The darkness of the "pen" used in drawing commands (for either lines
or for text) is set by `set graylevel .brightness.'.  A brightness
value of 0 corresponds to black ink, and a brightness value of 1
corresponds to white ink.  Values outside this range are clipped to the
nearer endpoint.  Values inside this range choose a proportional
graylevel in between; for example, `set graylevel 0.5' gives a 50
percent gray tone.

   The graylevel applies to text as well as lines.  Often you'll want to
draw a gray line and a black label beside it, or you'll want to set a
graylevel temporarily.  Here's how to do it:

     # Save old graylevl, set, then reset to old
     .old_gray. = ..graylevel..
     set graylevel 0.5
     draw curve
     set graylevel 0
     draw label for last curve "TEST"
     set graylevel .old_gray.

   The color of the "pen" may be set to any value you can describe with
an RGB (red, green, blue) or HSB (hue, saturation, brightness)
specification, or a color name.  This pen color applies to everything,
even text.

The `set color \name' command

   Set the pen color to the indicated name.  There are two types of
names: hexadecimal-triplet names and English names.

   Hexadecimal-triplet names are of a form often used in web-pages.
They consist of exactly 6 characters, which are divided by Gri into
three sets of two characters, specifying the red component, the green
component, and the blue component of the color, respectively.  These
components are in hexadecimal notation, i.e. ranging from 00 to FF,
indicating values from 0 to 255.  For example,
     set color ACD4EF

sets a pastel blue color, almost the color of a robin's egg.

   The English colors are written simply in the form
     set color blue

where the color is from the following list.  (Gri requires that you use
the exact form shown, including the capitilization.)  The color mixes
are identical to those used in X11.

     NAME               RED    GREEN  BLUE
     "white"            1.000  1.000  1.000
     "LightGray"        0.827  0.827  0.827
     "darkslategray"    0.184  0.310  0.310
     "black"            0.000  0.000  0.000
     "red"              1.000  0.000  0.000
     "brown"            0.647  0.165  0.165
     "tan"              0.824  0.706  0.549
     "orange"           1.000  0.647  0.000
     "yellow"           1.000  1.000  0.000
     "green"            0.000  1.000  0.000
     "ForestGreen"      0.133  0.545  0.133
     "cyan"             0.000  1.000  1.000
     "blue"             0.000  0.000  1.000
     "skyblue"          0.529  0.808  0.922
     "magenta"          1.000  0.000  1.000

To get more colors than those provided in the above list, use the `read
colornames' command.

   You should do a test case for your printer to see which colors you
find most to your liking.  You'll want to pick colors that look
different from each other.  In some cases you might want to avoid
dithered colors, since they look too broken on really thin lines.  For
example, on my printer I like the following colors: `black', `red',
`yellow', `green', `cyan', and `magenta'.

The `set color rgb .red. .green. .blue.' command

   This command sets the color using the red-green-blue color model.  If
you are familiar with how colors add (e.g. red plus green yields
yellow), then you might like this, but most people find it easier to use
the `set color hsb ...' style described below.

   Set the individual color components as follows.  The numbers
`.red.', `.green.' and `.blue.' range from 0 (for no contribution of
that color component to the final color) to 1 (for maximal
contribution).  Values less than 0 are clipped to 0; values greater
than 1 are clipped to 1. EXAMPLES:

     set color rgb 0   0   0  # black
     set color rgb 1   1   1  # white
     set color rgb 1   0   0  # bright red
     set color rgb 0.5 0   0  # dark red
     set color rgb 0   1   0  # pure green
     set color rgb 1   1   0  # yellow: red + green

The `set color hsb .hue. .saturation. .brightness.' command

   In this color model, the color ("hue") is specified with a single
parameter.  Many people find this easier than using the corresponding
`rgb' command.

   Set the individual color components as follows.  The numbers
`.hue.', `.saturation.' and `.brightness.' range from 0 to 1.  The
color, represented by `.hue.', ranges from 0 for pure red, through 1/3
for pure green, and 2/3 for pure blue, and back to 1 again for pure
red.  (HINT: It is a good idea to limit the total range of hue you use
to 2/3, instead of 1; otherwise you'll get confused by (nearly)
repeated colors at the crossover.  For example, limit the hue to range
from 1/3 to 1, or 0 to 2/3.)  The purity of the color, represented by
`.saturation.', ranges from 0 (none of the hue is visible) to 1 (the
maximal amount is present).  Less saturated colours are like those you
would get from mixing black paint into colored paint.  The brightness
of the color, represented by `.brightness.', ranges from 0 (black) to 1
(maximal brightness).  Lowering brightness is like decreasing the
intensity of the light you shine on a painting.

   Hue, saturation, and brightness values are all clipped to the range
0 to 1.  EXAMPLES:

     set color hsb 0    1   1  # pure, bright red
     set color hsb 0    1 0.5  # half black, half red
     set color hsb .333 1   1  # pure, bright green


File: gri.info,  Node: X-y Plots,  Next: Linegraphs,  Prev: Pen Color,  Up: Top

X-Y Plots
*********

* Menu:

* Linegraphs::                  x-y graphs with data connected by line segments
* Scattergraphs::               x-y graphs with data indicated by symbols
* Formula Plots::


File: gri.info,  Node: Linegraphs,  Next: Scattergraphs,  Prev: X-y Plots,  Up: X-y Plots

Linegraphs
==========

   The following Gri commands will draw a linegraph.  For the output
graph (*Note Getting More Control::).

   This plots a simple linegraph:

     # Example 1 -- Linegraph using data in a separate file
     
     open example1.dat      # Open the data file
     read columns x y       # Read (x,y) columns
     draw curve             # Draw data curve
     draw title "Example 1" # Title above plot

   Here's what the command lines mean:

   * The first line is a comment.  Anything to the right of a hash-mark
     `#' is considered to be a comment.  (This symbol is also called a
     "pound".)

   * The second line is blank.  Gri ignores blank lines between
     commands.

   * `open example1.dat' tells Gri to open the indicated file (in the
     current directory) as an input data file.  You can specify files
     outside the current directory by using conventional unix-shell
     pathnames (e.g., `open ~/data/TS/section1/T_S.dat' or `open
     ../data/file.dat').  You can even use "synonyms" (*Note
     Synonyms::.) in filenames, as in `open \BASENAME.dat'.

   * `read columns x y' tells Gri to start reading columnar data, the
     first column being `x', the second `y'.  `x' and `y' are
     predefined names for whatever ends up on the horizontal and
     vertical axes.

     The number of data needn't be specified.  Gri reads columns until a
     blank line or end-of-file is found.  You can tell Gri how many
     lines to read with a command like `read columns 10 x y'.  Multiple
     datasets can reside within one file; provided that they are
     separated by a single blank line, Gri can access them by multiple
     `read' commands.

     Like C, Gri expects numbers to be separated by one or more spaces
     or tabs.  Commas are not allowed.  If the columns were reversed,
     the command would be `read columns y x'.  If there were an initial
     column of extraneous data, the command would be `read columns * x
     y', or `read columns x=2 y=3' (*Note Read Columns::).

   * `draw curve' tells Gri to draw a curve connecting the points in
     the `x' and `y' columns. A nice scale will be selected
     automatically.  (You can change this or any other plot
     characteristics easily, as you'll see later.)

   * `draw title' tells Gri to write the indicated string centered
     above the plot. The title *must* be enclosed in quotes.

   * `quit' tells Gri to exit.

   Gri will draw axes automatically, and pick its own scales.

   If you wish to draw several curves which cross each other, you should
try using `draw curve overlying' instead of `draw curve'.  This will
make it easier to distinguish the different curves.


File: gri.info,  Node: Scattergraphs,  Next: Formula Plots,  Prev: Linegraphs,  Up: X-y Plots

Scattergraphs
=============

   This section contains two examples, the first being a fuller
explanation of all the bells and whistles, the second being a simple
explanation of how to get a very quick plot, given just a file
containing a matrix of grid data.

   To get a scattergraph with symbols at the data points, substitute
`draw symbol' for `draw curve'.  Both symbols and a curve result if
both `draw curve' and `draw symbols' are used.  See *Note Getting More
Control:: for an example.

   By default, the symbol used is an x.  To get another symbol, use a
command like `draw symbol 0' or `draw symbol plus'.

   To change the symbol size from the default of 0.2 cm use commands
like `set symbol size 0.1' to set to 1 mm (*Note Set Symbol Size::).

Coding data with symbols
------------------------

   To get different symbols for different data points, insert symbol
codes from the above list as a column along with the x-y data, and
substitute the command `read columns x y z', and then draw them with
`draw symbol'.  Gri will interpret the rounded-integer values of the
`z' columns as symbol codes.  Note that even if you've read in a z
column which you intend to represent symbols, it will be overridden if
you designate a specific symbol in your `draw symbols' command; thus
`draw symbol 0' puts a `+' at the data points whether or not you've
read in a symbol column.

Drawing a symbol legend
-----------------------

   The following example shows how you might write a symbol legend for a
plot.  The legend is drawn 1 cm to the right of the right-hand side of
the axes, with the bottom of the legend one quarter of the way up the
plot; *Note Draw Symbol Legend::.  The lines in the legend are
double-spaced vertically.  To change the location of the legend, alter
the `.legend_x. =' and `.legend_y. =' lines.  To change the spacing,
alter the `.legend_y. +=' line.

     set x axis -1 5 1
     set y axis -1 5 1
     read columns x y z
     0 0 0
     1 1 1
     2 2 2
     3 3 3
     
     draw symbol
     
     # Legend
     .leg_x. = {rpn ..xmargin.. ..xsize.. + 1 +}
     .leg_y. = {rpn ..ymargin.. ..ysize.. 4 / +}
     draw symbol legend 0 "Foo" at .leg_x. .leg_y. cm
     .leg_y. += {rpn "M" ascent 2 *}
     draw symbol legend 1 "Bar" at .leg_x. .leg_y. cm
     .leg_y. += {rpn "M" ascent 2 *}

Coding data with symbol colors
------------------------------

   To get different colors for different symbols, read a color code into
the z column, and do for example `draw symbol bullet color hue z'.  The
numerical color code ranges from 0 (red) through to 1, passing through
green at 1/3 and blue at 2/3.


File: gri.info,  Node: Formula Plots,  Next: Contour Plots,  Prev: Scattergraphs,  Up: X-y Plots

Formula Plots
=============

   There are two methods for formula graphs.

  1. *Use the system yourself.* Do as in this example:

          open "awk 'BEGIN{for(i=0;i<3.141;i+=0.05)\
              {print(i,cos(i))}}' |"
          read columns x y
          close
          draw curve

  2. *Let Gri calculate things for you*

     The simplest is to let Gri calculate things for you with the
     `create columns from function' command (*Note Create::).  The
     command assumes that you have defined the synonym called
     `\function' which defines `y' in terms of `x'.

     Gri uses the program `awk' to create the columns, and cannot work
     without it.

     Here is an example of using `create columns from function':

          show "First 2 terms of perturbation expansion"
          set y axis name horizontal
          set y name "sea-level"
          set x name "$\omega$t"
          
          \b = "0.4" # perturbation parameter b=dH/H
          \xmin = "0"
          \xmax = "6.28"
          \xinc = "3.14 / 20"
          \function = "cos(x)"
          set x axis \xmin \xmax
          create columns from function
          draw curve
          draw title "SOLID LINE  \function"
          
          \function = "(cos(x)+\b/2*(1-cos(2*x)))"
          create columns from function
          set dash 1
          draw curve
          draw title "DASHED LINE \function"
          
          draw title "b = \b"

     Here's another example, in which the curve `y = 1/(\int + \sl*x)'
     is drawn through some data.  Note how `sprintf' is used to set
     `\xmin' and `\xmax' using the scales that Gri has determined in
     reading the data.

          open file.data
          read columns x y
          close
          draw symbol bullet
          \int = "-0.1235"
          \sl = "0.003685"
          sprintf \xmin "%f" ..xleft..
          sprintf \xmax "%f" ..xright..
          \function = "1/(\int + x * \sl)"
          create columns from function
          draw curve



File: gri.info,  Node: Contour Plots,  Next: Pre-gridded Data,  Prev: Formula Plots,  Up: Top

Contour Plots
*************

   Contour plots can be done with either pregridded data or randomly
distributed (ie, ungridded) data.

* Menu:

* Pre-gridded Data::            Contouring f(x1, y1, x2, y2, ...)
* Ungridded Data::              Contouring f(x, y) where (x,y) are not on a grid


File: gri.info,  Node: Pre-gridded Data,  Next: Ungridded Data,  Prev: Contour Plots,  Up: Contour Plots

Pre-gridded Data
================

   This section presents two examples of contouring pre-gridded data,
the first example illustrating a boilerplate program to contour data
stored in a simple matrix form in a file, the second example
illustrating a case with more control of the details (e.g., a nonuniform
grid).

Simple example
--------------

   This example was hardwired to know the size of the grid, etc.  Here's
an example which is more general, in that it determines the dimensions
of the grid data from using unix system commands.  Note that the grid is
set to run from 0 to 1 in both x and y; you'll most likely want to
change that after you see the initial plot, but this should get you
started.

     \file = "somefile.dat"
     \rows = system wc \file      | awk '{print $1}'
     \cols = system head -1 \file | awk '{print NF}'
     set x grid 0 1 /\cols
     set y grid 0 1 /\rows
     open \file
     read grid data \rows \cols
     close
     draw contour

Complicated example
-------------------

   To get a simple contour graph based on pre-gridded data, with full
control of axes, etc, do something like this:

example4.gri

     # Example 4 -- Simple contour graph
     
     #
     # Read x-grid; blank-line means stop reading.
     read grid x
     0
     .2
     1
     
     # Note that the x-grid was irregular.  The y-grid
     # in this example is regular, so we can just set
     # it to range from 10 to 20, incrementing by 2.5.
     set y grid 10 20 2.5
     # Thus we now have a grid 3 wide and 5 high.  Let's
     # read the actual data now.
     read grid data
     1 2 3
     2 3 4
     3 4 5
     4 5 6
     5 6 7
     
     # Now draw contours (automatically set; we could
     # have done `draw contour 2' to draw contour for
     # value 2 or `draw contour 1 10 2' to draw contours
     # ranging from 1 to 10 with an increment of 2.)
     draw contour
     draw title "Example 4"

   Here several new things have been introduced.

   First, you've got to define a grid in xy space.  This example uses a
non-uniform x-grid, and reads it in from the commandfile.  In this form,
the blank line is essential; it tells Gri that the end of data has been
located; if you like, you can specify the number of lines to read, as in
`read grid x 3'.

   The y-grid for this example is uniform, however, so it may be
specified with the `set y grid' command.  It obtains values (10, 12.5,
15, 17.5, 20).  The `set x|y grid' commands accept negative increments.
Furthermore, it is possible to specify the number of steps, rather than
the increment size, by putting `/' before the third number; thus `set x
grid 0 1 /5' and `set x grid 0 1 0.2' are equivalent.

   Having defined a grid, it is time to read in the gridded data.  Here
this is done with the `read grid data' command.  Since Gri already knows
the grid dimensions, it will read the data appropriately.  You could
also have told it (`read grid data 3 5').

   The first dataline is the top of the y-grid.  In other words, the
data appear in the file just as they would on the graph, assuming that
the x-grid and y-grid both increase.

   Sometimes you want to read in the transpose of a matrix.  Gri lets
you do that.  If the `bycolumns' keyword is present at the end of the
`read grid' command, the first dataline will contain the first
*column*, of the data.

   If you have an extraneous column of data to the left of your data
matrix, do `read grid data * 2 3'

   Now Gri has the grid in its head.  We tell it to draw some contours
with the `draw contour' command.   As the comments in the example show,
the contour values will be selected automatically, but you can alter
that.


File: gri.info,  Node: Ungridded Data,  Next: Images,  Prev: Pre-gridded Data,  Up: Contour Plots

Ungridded data
==============

   When you have f=f(x,y) points at random x and y, you must cast them
onto a grid to contour them.  This is a difficult problem.  There are
many ways to grid data, and all have both good and bad features.  You
should try various methods, and various settings of the parameters of
the methods.  If you have a favorite gridding method that you prefer,
you should probably pre-grid the data yourself.  If not, Gri can do it
for you.  Gri has two methods for doing this, the "boxcar" method and
the "objective analysis" method.  Each method puts holes in the grid
wherever there are too few data to map to grid points, unless you
specifically ask to fill in the whole grid.

   The next two sections show first an example, then a discussion of the
methods and how to use them.

Example
-------

   This example uses data taken from Figure 5 of S. E.  Koch and M.
DesJardins and P. J. Kocin, 1983.  "An interactive Barnes objective map
anlaysis scheme for use with satellite and conventional data,", J.
Climate Appl.  Met., vol 22, p. 1487-1503.  Readers should compare
Figures 5 and 6 of that paper to the results shown here.

example5.gri

     # Example 5 - Contouring ungridded data, from figure
     # 5 of Koch et al., 1983, J. Climate Appl. Met.,
     # volume 22, pages 1487-1503.
     open example5.dat
     read columns x y z
     close
     set x size 12
     set x axis 0 12 2
     set y size 10
     set y axis 0 10 2
     draw axes
     set line width symbol 0.2
     set symbol size 0.2
     draw symbol bullet
     set font size 8
     draw values
     set x grid 0 12 0.25
     set y grid 0 10 0.25
     
     # Use default method (Barnes)
     convert columns to grid
     
     set font size 10
     draw contour 0 40 2
     set font size 12
     draw title "Example 5 -- wind (Fig5 Koch et al, 1983)"

Discussion of Methods
---------------------

   The various commands for converting columns to a grid are given in
(*Note Convert Columns To Grid::).  Generally, the Barnes method is
best.

