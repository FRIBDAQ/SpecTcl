This is gri.info, produced by makeinfo version 4.3 from gri.texi.

INFO-DIR-SECTION Scientific Applications
START-INFO-DIR-ENTRY
* Gri: (gri).  Programming language for scientific illustration
END-INFO-DIR-ENTRY


File: gri.info,  Node: Images,  Next: Reading and Creating Image Data,  Prev: Ungridded Data,  Up: Top

Image Plots
***********

   Gri can read in images stored in various formats.  It can also create
image data internally, by converting gridded data, which is quite handy
in some contouring applications.

   Note: if your diagram is to be reproduced by a journal, it is
unlikely that the reproduction will be able to distinguish between any
two graylevels which differ by less than 0.2.  Also, graylevels less
than 0.2 may appear as pure black, while those of 0.8 or more may
appear as pure white.  These guidelines are as specified by American
Geophysical Union (publishers of J. Geophysical Res.), as of 1998.

* Menu:

* Reading and Creating Image Data:: Reading image, and creating from grid data
* Image PostScript Output::     How the image is embedded in the PostScript
* Example Image::               How to plot a satellite image


File: gri.info,  Node: Reading and Creating Image Data,  Next: Image PostScript Output,  Prev: Images,  Up: Images

Reading and Creating Image Data
===============================

   Gri can do black and white image plots, such as satellite images.
There are several ways to create image data in Gri
   * Create images from gridded data using `convert grid to image'.  For
     examples see *Note Grayscale Images::), *Note Combination::, and
     *Note Contouring::.

   * Read raw ascii image data files.  Use `read grid'.

   * Read PGM (portable graymap) ascii files.  (That is, a file with
     magic characters `P1' or `P3' at the start.)  Use the `read image
     pgm' command, for a file opened in ascii mode with `open filename'.

   * Read raw binary data, with or without headers.  Use `read image',
     after skipping any header bytes using the `skip' command, for a
     file opened in binary mode with `open filename binary'.

   * Read a Sun "rasterfile" file (but only in uncompressed form).  Use
     `read image rasterfile' for a file opened in binary mode with
     `open filename binary'.

   * Read a PGM (portable graymap) binary file.  (A file with magic
     characters `P2' or `P4' at the start.)  Use the `read image pgm'
     for a file opened in binary mode with `open filename binary'.

   * Aside: Images can be converted to grids (for contouring) using
     `convert image to grid' (*Note Convert::).

   Once the image is created, its grayscale/colorscale may be
manipulated with the commands `set image grayscale' and `set image
colorscale', which permit linear and histogram-equalized blendings over
the grayscale or color range, or with `read image grayscale' and `read
image colorscale', which permit reading in the grayscale or color
values individually, one for each of the 256 pixel values.

   It is important to understand the structure of image data.  Gri works
only with 8-bit image data.  This means that a given pixel of the image
may have only one of 256 possible values.  The example below uses a
satellite image of surface temperature.  The suppliers of the data
dictate that pixel value 0 corresponds to a temperature of 5C, and a
pixel value of 255 corresponds to 30.5C, so the resolution is 0.1C per
pixel value.  This resolution will be apparent if the output of the
example below is previewed on a grayscale/color monitor -- notice the
quantization in the palette.  This resolution issue is not very
important with satellite images, since you have to use what you are
given by the suppliers of the data.  However, the issue is very
important when you are converting grid data to images.  When Gri
converts grid data to image data, it neccessarily discards information,
because the grid data have resolution to about 6 digits, whereas the
image data have only 8-bit (2-3 digit) resolution.  The `set image
range' commands determines the range of this 8-bit resolution in terms
of user units.  All other things being equal, it would be preferable to
use the smallest range consistent with the range of your data.  If your
grid data ranged from 0 to 1, say, you might `set image range 0 1'.
This would give a resolution in the image of 1/255 in the user units.
But, when Gri converts the grid into an image, it will *clip* all data
outside the indicated range.  In this case, any data greater than 1 in
the grid would translate to *exactly* 1 in the image.  Naturally there
is a tradeoff between having a range large enough to encompass any data
in the grid, and a range small enough to yield adequate resolution.  In
most cases, 8-bit resolution will be adequate, but it is good to be
aware of the limitations.  One should always `draw image palette', and
check it on a color monitor for bandedness, which is a sign of
resolution problems.


File: gri.info,  Node: Image PostScript Output,  Next: Example Image,  Prev: Reading and Creating Image Data,  Up: Images

About The PostScript Output
===========================

   Programmers Note: Gri inserts some special comments in the PostScript
file, to help programmers extract the image data; to extract the
information, you'll have to understand how PostScript handles images.
Gri inserts a single comment line before a line ending in the token
`im':

     %BEGIN_IMAGE
     170.70 170.70 534.86 534.86 128 128 im

The first four numbers are the (x,y) locations of the lower-left and
upper-right corners of the image, in units of points on the page (72
points = 1 inch).  The fifth and sixth numbers are the width of the
image and the height of the image.  The keyword `im' is always present
on this line.  Gri inserts the following comment line at the end of the
image data

     %END_IMAGE


File: gri.info,  Node: Example Image,  Next: Examples,  Prev: Image PostScript Output,  Up: Images

Example (Satellite image)
=========================

   Here's an example that will plot different types of images,
depending on your answers to `query' questions.  The file called
`\filename' is the data file, in binary format with one byte (`unsigned
char' in C) for each pixel, stored with the northwest pixel first, and
the pixel to the east of that next. The file called `\mask' is in the
same format, and the numbers are 0 if the point is over the sea and 1
if over land.  The mask file is used in computing the histograms, which
is done if `\histo' is 1.

   The file in this example covers 128 * 128 pixels over the Gulf of
Maine. The numbers in `\filename' correspond to surface temperatures
according to the equation

     T = 5 + 0.1 * pixel_value

which explains the following lines in the command file:

     \0val = "5"             # 0 in image
     \255val = "30.5"        # 255 in image

   Depending on `\histo', the graymap will be linear or
histogram-enhanced. The histogram method consists of dividing the
cumulative histogram for the values in the image up into 256 levels,
and assigning a graylevel to each.  This has the effect of creating
maximal contrast in all ranges of graylevel. It points up features
really well, but it is a nonlinear mapping, so it is not good for
telling you where gradients are strong or weak.

   Examples are shown for linear mapping and histogram mapping.

example6.gri

example6histogram.gri

     # Example 6 -- Plot IR image of Gulf of Maine
     # Define characteristics of norda images
     # Note that the pixel to temperature conversion formula is
     #
     #   Temperature = 5C + pixel_value / 10
     #
     # where pixel_value ranges from 0 to 255.  Thus, a pixel value of 0
     # corresponds to a temperature of 5C, and 255 corresponds to 30.5C;
     # this is why the limits \0val and \255val, for use by the `set image
     # range' command, take on these values.
     \0val = "5"                     # 0 in image
     \255val = "30.5"                # 255 in image
     .rows. = 128
     .cols. = 128
     .pixel_width. = 2
     .km. = {rpn .cols. .pixel_width. *}
     
     # get filenames
     query \filename "Name image file" ("example6image.dat")
     query \maskname "Name mask  file" ("example6mask.dat")
     
     # get data, then mask, each in 8-bit image format
     open \filename 8bit
     set image range \0val \255val
     read image .rows. .cols. box 0 0 .km. .km.
     close
     open \maskname 8bit
     read image mask .rows. .cols.
     close
     
     # find out what grayscale method to use
     query \histo "Do histogram enhancement? (yes|no)" ("no")
     query \minT  "T/deg for white on page?          " ("10")
     query \maxT  "T/deg for black on page?          " ("15")
     \incT = "1"
     
     # set up scales.
     set x size 12.8
     set y size 12.8
     set x name "km"
     set y name "km"
     set x axis 0 .km. 32
     set y axis 0 .km. 32
     
     # plot image, grayscale, and histogram
     if {"\histo" == "yes"}
         set image grayscale using histogram black \maxT white \minT
     else
         set image grayscale black \maxT white \minT
     end if
     draw image
     draw image palette left \minT right \maxT increment \incT
     draw image histogram
     if {"\histo" == "yes"}
         draw title "Example 6: grayscale histogram enhanced"
     else
         draw title "Example 6: grayscale linear \minT to \maxT"
     end if


File: gri.info,  Node: Examples,  Next: Box Plots,  Prev: Example Image,  Up: Top

Real-world examples
*******************

   The example files in this manual should be available to you directly,
having been installed with Gri; if not, ask your system manager to check
the FTP site.

   Additionally, I've collected a few real life examples here.  Other
sources are the Gri cookbook, available at
<http://gri.sourceforge.net/gri-cookbook/index.html>.

* Menu:

* Box Plots::                   Tukey box plots, which show histograms
* Contouring::                  sample contour plot
* Grayscale Images::            create and plot image, from gridded data
* Combination::                 image and contour combination plot
* Fancy::                       fancy plot with lots of tricks
* Legend::                      plot with annotated curves and legend
* Polygons::                    read geometry, then draw polygon
* TS Diagram::                  temperature-salinity diagrams
* PDF Diagram::                 probability-density function
* Running Means::               skyline plot of running means
* Finite Element Model Mesh::   plotting mesh of FEM-type model
* Handling Data::               samples of handling data


File: gri.info,  Node: Box Plots,  Next: Contouring,  Prev: Examples,  Up: Examples

Box plots
=========

   Box plots were invented by Tukey for eda (exploratory data analysis).
They show nonparametric statistics.  The centre of the box is the
median.  The box edges show the first quartile (q1) and the third
quartile (q3).  The distance from q3 to q1 is called the inter-quartile
range.  The whiskers (lines with crosses on them) extend to the furthest
points still within 1.5 inter-quartile ranges of q1 and q3.  Beyond the
whiskers, all outliers are shown, in open circles up to a distance of 3
inter-quartile ranges beyond q1 and q3, and in closed circles beyond
that.  Below is an example that uses a "new command" to define each box
plot (*Note Adding New Commands::).

example7.gri

     # Example 7 -- Box plots of mixing efficiency vs density ratio (meddy)
     
     `Draw y boxplot from \file at .x.'
     Draw a y boxplot for data in given file, at given
     value of x.
     {
         open \.word4.
         read columns * y
         close
         draw y box plot at \.word6.
     }
     if !..publication..
         draw time stamp
     end if
     set x axis 1 3 1 0.1
     set x name "Density Ratio, $R_\rho$"
     set x margin 4
     set y axis -2 1 1
     #
     # Must fool gri into not drawing the axes, because the y data
     # are already in logspace.
     draw axes none
     Draw y boxplot from example7a.dat at 1.3
     Draw y boxplot from example7b.dat at 1.4
     Draw y boxplot from example7c.dat at 1.5
     Draw y boxplot from example7d.dat at 1.6
     Draw y boxplot from example7e.dat at 1.7
     Draw y boxplot from example7f.dat at 1.8
     Draw y boxplot from example7g.dat at 1.9
     delete y scale
     set y name "Efficiency, $\Gamma$"
     set y type log
     set y axis 0.01 10 1
     draw axes
     draw title "Example 7 -- Box plot"


File: gri.info,  Node: Contouring,  Next: Grayscale Images,  Prev: Box Plots,  Up: Examples

Contouring
==========

   This example plots a section of dT/drho vs x and rho (actually,
sigma-t, as the label indicates).  The contours are unlabelled; I'm only
interested in the zero crossings.

   There are some other useful tricks in this example, such as calling
`awk' and `wc' from the unix system.

   (In the plot shown, all `query' questions were answered with
carriage return, yielding the defaults; the `-p' flag was specified on
execution, so the time stamp was not drawn.)

example8.gri

     # Example 8 -- Plot T=T(x,rho) section of eubex data
     
     `Initialize Parameters'
     {
         \FILE_DATA = "example8a.dat" # T vs rho
         \FILE_LOCN = "example8b.dat" # section distances
         set missing value -99.0
         #
         # Following values from ~/eubex/processing/to_rho_bins/do_rho_inter
         \RHO_MIN = "28.1"
         \RHO_MAX = "27.5"
         \RHO_INC = "-0.002"
         \NY = "301"
         \xmin = "350"
         \xmax = "0"
         \xinc = "-100"
         \ymin = "28.1"
         \ymax = "27.8"
         \yinc = "-0.1"
         \zmin = "0"
         \zmax = "2.5"
     }
     `Initialize Axes'
     /*
     Set up axes
     */
     {
         set x name "km"
         set x size 10
         set x axis \xmin \xmax \xinc
         set y name "$\sigma_T$"
         set y size 5
         set y axis name horizontal
         set y axis \ymin \ymax \yinc
         set y format "%.1f"
     }
     `Initialize Files'
     {
         query \data "Data file?   " ("\FILE_DATA")
         query \locn "Station locn?" ("\FILE_LOCN")
     }
     `Read Data'
     {
         # Read x-locations
         system awk '{print $2}' < \locn > TMP
         system wc TMP | awk '{print $1}' > NUM
         open NUM
         read .gridx_number.
         close
         system rm NUM
         open TMP
         read grid x .gridx_number.
         close
         system rm TMP
         # Create y-locations
         set y grid \RHO_MIN \RHO_MAX \RHO_INC
         #
         # Read data
         open \data
         read grid data \NY .gridx_number.
         close
     }
     `Plot Contours'
     {
         set graylevel .contour_graylevel.
         set clip on
         set line width 0.5
         draw contour -3 3 0.25 unlabelled
         #
         # wide line at 0 degrees
         set line width 2
         draw contour 0 unlabelled
     }
     `Plot Image And Maybe Contours'
     {
         \imagefile = "image"
         set image range \zmin \zmax
         convert grid to image box \xmin  \ymin \xmax \ymax
         query \dohisto "Do histogram scaling? (yes|no)" ("yes")
         \incs = "no"
         if {"\dohisto" == "yes"}
     	set image grayscale using histogram
         else
     	\zinc = "0.25"
     	query \incs "In linear scaling, band at an increment of \zinc?" ("yes")
     	if {"\incs" == "yes"}
     	    set image grayscale black \zmin white \zmax increment \zinc
     	else
     	    set image grayscale black \zmin white \zmax
     	end if
         end if
         write image rasterfile to \imagefile
         show "wrote image rasterfile `\imagefile '"
         draw image
         draw image palette
         query \do_contours "Do contours as well (yes|no)" ("yes")
         if {"\do_contours" == "yes"}
     	Plot Contours
         end if
         draw title "Example 8 -- \data black=\zmin white=\zmax"
         if {"\dohisto" == "yes"}
     	draw title "Histogram enhanced grayscales"
         else
     	if {"\incs" == "yes"}
     	    draw title "Grayscale banded at intervals of \zinc"
     	end if
         end if
     }
     Initialize Parameters
     Initialize Axes
     Initialize Files
     Read Data
     query \doimage "Draw image (yes|no)" ("no")
     if {"\doimage" == "yes"}
         .contour_graylevel. = 1	# white contours
         Plot Image And Maybe Contours
     else
         .contour_graylevel. = 0	# black contours
         Plot Contours
         draw title "Example 8"
     end if


File: gri.info,  Node: Grayscale Images,  Next: Combination,  Prev: Contouring,  Up: Examples

Image created from coarsely gridded data
========================================

   This example reads gridded ascii station data (`Read Data'), creates
an interpolated image (`convert grid ...'), and then plots the image.

   There are some other useful tricks in this example, such as calling
`awk' and `wc' from the unix system.

   (In the plot shown, all `query' questions were answered with
carriage return, yielding the defaults; the `-p' flag was specified on
execution, so the time stamp was not drawn.)

example9.gri

     # Example 9 -- Plot dTdrho-rho section
     
     `Initialize Parameters'
     {
         \FILE_DATA = "example9a.dat" # T vs rho
         \FILE_LOCN = "example9b.dat" # section distances
         #
         # Following values from ~/eubex/processing/to_rho_bins/do_rho_inter
         \RHO_MIN = "28.1"
         \RHO_MAX = "27.5"
         \RHO_INC = "-0.002"
         \NY = "301"
         set missing value -99.0
         \xmin = "350"
         \xmax = "0"
         \xinc = "-100"
         \ymin = "28.1"
         \ymax = "27.8"
         \yinc = "-0.1"
         \zmin = "-10"		# black
         \zmax = "0"			# white
     }
     `Initialize Axes'
     Set up axes.
     {
         set x name "km"
         set x size 10
         set x axis \xmin \xmax \xinc
         set y size 5
         set y name "$\sigma_T$"
         set y axis name horizontal
         set y axis \ymin \ymax \yinc
         set y format %.1lf
         draw axes none
     }
     `Initialize Files'
     {
         query \data "Data file?   " ("\FILE_DATA")
         query \locn "Station locn?" ("\FILE_LOCN")
     }
     `Read Data'
     {
         # Read x-locations
         system awk '{print $2}' < \locn > TMP
         system wc TMP | awk '{print $1}' > NUM
         open NUM
         read .gridx_number.
         close
         system rm NUM
         open TMP
         read grid x .gridx_number.
         close
         system rm TMP
         # Create y-locations
         set y grid \RHO_MIN \RHO_MAX \RHO_INC
         #
         # Read data
         open \data
         read grid data \NY .gridx_number.
         close
     }
     Initialize Parameters
     Initialize Axes
     Initialize Files
     Read Data
     set image range \zmin \zmax
     set image colorscale hsb 0 1 1 \zmin   hsb .6 1 1 \zmax
     convert grid to image box \xmin  \ymin \xmax \ymax
     #
     # Draw the image, then draw the axes.  Note that the image has
     # extends beyond the axes frame, so we will turn clipping
     # on before drawing it, to make a clean picture.
     set clip postscript on
     draw image
     set clip postscript off
     draw axes
     
     #
     # All done.
     draw title "Example 9"
     if {"\dohisto" == "yes"}
         draw title "Histogram enhanced grayscales"
     end if


File: gri.info,  Node: Combination,  Next: Fancy,  Prev: Grayscale Images,  Up: Examples

Combination of image and contour
================================

   The following example reads gridded data and creates an image as in
the previous example, but also superimposes unlabelled white contour
lines.

   (In the plot shown, all `query' questions were answered with
carriage return, yielding the defaults; the `-p' flag was specified on
execution, so the time stamp was not drawn.)

example10.gri

     # Example 10 -- Draw image plot of flushing of dye out of cove
     if !..publication..
         draw time stamp
     end if
     \file = "example10.dat"
     query \contours "Superimpose contours? (yes|no)" ("yes")
     query \file     "Input file name               " ("\file")
     open \file
     read line \header
     read \D
     read .nx.
     read .ny.
     set x name "distance along cove"
     set y name "time"
     set x grid 0 1 /.nx.
     set x axis 0 1 0.5 0.1
     set y grid 0 .ny. / .ny.
     set y axis 0 .ny.
     read grid data * * .ny. .nx.
     set image range 0 20
     set image grayscale black 20 white 0 increment 5
     convert grid to image
     draw image
     if {"\contours" == "yes"}
         set graylevel 1.0
         draw contour 0 20 1 unlabelled
         set graylevel 0.0
     end if
     draw axes
     draw image palette left -1 right 21 increment 5
     draw title "Example 10 -- file=\file header=`\header'"

     # Example 10color -- Draw color image plot
     
     # Test various colorscales.
     # INSTRUCTIONS: Uncomment one of the following '\scale = ' statements
     
     # CASE 1: From black at high values to white at low values
     #\scale = "rgb 0 0 0 20.0 rgb 1 1 1  0.0 increment 5"
     
     # CASE 2: From skyblue at 20 to tan for 0; traverse RGB space
     #         See also case 5, which names the colors.
     #\scale = "rgb 0.529 0.808 0.922 20.0 rgb 0.824 0.706 0.549 0.0 increment 5"
     
     # CASE 3: From skyblue at 20 to tan for 0; traverse HSB space
     #         Is it just me, or is this uglier than case 2?
     #\scale = "hsb 0.548 0.426 0.922 20.0 hsb 0.095 0.334 0.824 0.0 increment 5"
     
     # CASE 4: Use a spectrum; traverse HSB space
     #\scale = "hsb 0 1 1 20.0 hsb 0.6666 1 1  0.0 increment 5"
     
     # CASE 5: From skyblue to tan, traversing RGB space (by default)
     #         (Compare case 2, which uses similar endpoints, with
     #         colors specified with RGB values, and larger increment.)
     #\scale = "skyblue 20.0 tan 0.0 increment 2"
     
     # CASE 6: From skyblue to tan, traversing RGB space (by default)
     #         Compare 2 and 5; note this has continuous increment
     #\scale = "skyblue 20.0 tan 0.0"
     
     # CASE 7: From blue to brown
     \scale = "blue 20.0 brown 0.0 increment 2.5"
     
     open example10.dat
     read line \header
     read \D
     read .nx.
     read .ny.
     set x name "distance along cove"
     set y name "time"
     set x grid 0 1 /.nx.
     set x axis 0 1 0.5 0.1
     set y grid 0 .ny. / .ny.
     set y axis 0 .ny.
     read grid data * * .ny. .nx.
     set image range 0 20
     convert grid to image
     set image colorscale \scale
     draw image
     
     # Draw contours in white ink
     set graylevel 1.0
     draw contour 0 20 1 unlabelled
     set graylevel 0.0
     
     draw axes                               # redraw in case whited out
     draw image palette left -1 right 21 increment 5
     set font size 9
     
     # Title tells what method used
     draw title "Used `draw image colorscale \scale'"


File: gri.info,  Node: Fancy,  Next: Legend,  Prev: Combination,  Up: Examples

Fancy x-y linegraph
===================

   The following code shows a fancy plot with lots of bells and
whistles.

example11.gri

     # Example 11 -- Fancy plot
     # Pen sizes, etc.
     #
     .thin. = 0.5                    # for whole data set
     .thick. = 2                     # for bravo time period
     .gray_for_guiding_lines. = 0.75 # for guiding lines
     .tmin. = 1964                   # time axis
     .tmax. = 1974
     .tinc. = 5
     .tincinc. = 1
     .missing_value. = -9
     \file = "./example11.dat"
     #
     # Guiding lines to draw on both panels.
     #
     .1xl. = 1962
     .1yb. = -3
     .1xr. = 1968
     .1yt. = 3
     .1slope. = {rpn .1yt. .1yb. - .1xr. .1xl. - /}
     .1intercept. = {rpn .1yb. .1slope. .1xl. * -}
     .2xl. = 1966.4
     .2yb. = 3
     .2xr. = 1980
     .2yt. = -1
     .2slope. = {rpn .2yt. .2yb. - .2xr. .2xl. - /}
     .2intercept. = {rpn .2yb. .2slope. .2xl. * -}
     #
     # PANEL 1: Bravo time period.
     #
     set x margin 3
     set x size 15
     set y margin 3
     set y size 5
     # Draw border big enough for this and next panel.
     draw border box {rpn ..xmargin.. 2 -} \
         {rpn ..ymargin.. 2 -} \
         {rpn ..xmargin.. ..xsize.. + 2 +} \
         {rpn ..ymargin.. ..ysize.. 2 * 3 + + 2 +} \
         0.2 0.75
     set missing value .missing_value.
     set ignore error eof
     set x name "Year"
     set x axis .tmin. .tmax. .tinc. .tincinc.
     set y name "Area / 10$^5$km$^2$"
     set y axis -3 3 1
     draw axes
     #
     # Draw index lines 1 and 2.
     #
     # Upward sloped line.
     set line width .thin.
     set graylevel .gray_for_guiding_lines.
     if {rpn .1intercept. ..xright.. .1slope. * + ..ytop.. <}
         draw line from              \
             ..xleft..               \
             {rpn .1intercept. ..xleft.. .1slope. * +} \
             to                      \
             {rpn ..ytop.. .1intercept. - .1slope. /} \
             ..ytop..
     else
         draw line from              \
             ..xleft..               \
             {rpn .1intercept. ..xleft.. .1slope. * +} \
             to                      \
             ..xright..              \
             {rpn .1intercept. ..xright.. .1slope. * +}
     end if
     set graylevel 0
     #
     # Downward sloped line.
     set line width .thin.
     set graylevel .gray_for_guiding_lines.
     if {rpn .2intercept. ..xleft.. .2slope. * + ..ytop.. <}
         draw line from              \
             {rpn ..ytop.. .2intercept. - .2slope. /} \
             ..ytop..                \
             to                      \
             ..xright..              \
             {rpn .2intercept. ..xright.. .2slope. * +}
     else
         draw line from              \
             ..xleft..               \
             {rpn .2intercept. ..xleft.. .2slope. * +} \
             to                      \
             ..xright..              \
             {rpn .2intercept. ..xright.. .2slope. * +}
     end if
     set graylevel 0
     #
     # Finally, draw the data curve on top, after first
     # whiting out a background.
     set input data window x .tmin. .tmax.
     open \file
     read columns x y
     close
     y /= 1e5
     set line width ..linewidthaxis..
     draw zero line
     set line width {rpn .thick. 3 *}
     set graylevel 1
     draw curve
     set graylevel 0
     set line width .thick.
     draw curve
     
     #
     # PANEL 2: Longer timescale.
     #
     delete x scale
     set x margin bigger 5
     set x size 10
     set x name ""
     set y name ""
     set y margin bigger {rpn ..ysize.. 3 +}
     #
     # Draw long data set in thin pen.
     set input data window x off
     open \file
     read columns x y
     close
     y /= 1e5
     #
     # Draw guiding lines, axes, etc.
     set x axis 1952 1980 5 1
     draw axes frame
     set line width .thin.
     set graylevel .gray_for_guiding_lines.
     draw line from .1xl. .1yb. to .1xr. .1yt.
     draw line from .2xl. .2yb. to .2xr. .2yt.
     set graylevel 0
     set line width ..linewidthaxis..
     draw zero line
     
     
     draw x axis at bottom
     .old. = ..fontsize..
     set font size 0
     draw y axis at left
     set font size .old.
     delete .old.
     #
     # Draw full curve (first whiting out region around it).
     set line width {rpn .thin. 4 *}
     set graylevel 1
     draw curve
     set graylevel 0
     set line width .thin.
     draw curve
     #
     # Draw bravo time period (first whiting out region around it).
     set input data window x .tmin. .tmax.
     open \file
     read columns x y
     close
     y /= 1e5
     set line width {rpn .thick. 3 *}
     set graylevel 1
     draw curve
     set graylevel 0
     set line width .thick.
     draw curve
     #
     # Done
     set font size 20
     \label = "Example 11 (Arctic ice anomaly)"
     draw label "\label" at          \
         {rpn 8.5 2.54 * "\label" width - 2 /} \
         {rpn ..ytop.. yusertocm 0.7 +} \
         cm
     if !..publication..
         draw time stamp
     end if


File: gri.info,  Node: Legend,  Next: Polygons,  Prev: Fancy,  Up: Examples

Legends and annotated lines
===========================

   The following example shows how to handle annotated curves and
legends.

example12.gri

     # Example 12 -- Linegraph with key inside plot
     set font size 10                # points (1in = 72pt)
     set x size 10                   # cm
     set y size 10                   # cm
     set x name "Height"
     set y name "Total Energy"
     
     # Following axis setups not necessary; will autoscale if you
     # remove these.
     set x margin 3
     set x axis 800 960 20
     set y margin 3
     set y axis -0.4 1 0.2
     
     # Read data.  Format is columns (x, y1, y2, y3, y4)
     open example12.dat
     read columns x y
     draw curve
     draw label for last curve "1"
     
     rewind
     set line width {rpn ..linewidth.. 1.5 *}
     read columns x * y
     draw curve
     draw label for last curve "2"
     
     rewind
     set line width {rpn ..linewidth.. 1.5 *}
     read columns x * * y
     draw curve
     draw label for last curve "3"
     
     rewind
     set line width {rpn ..linewidth.. 1.5 *}
     read columns x * * * y
     draw curve
     draw label for last curve "4"
     
     # Draw the key.
     # NOTES:
     # (1) This key is inside the plot; its location was chosen
     #     after looking at the data.  To put the key in a different
     #     location, alter the .key_topleft_x. and .key_topleft_y.
     #     variables.  For example, you could put the key to the
     #     right of the plot by changing the next line to:
     #     `.key_topleft_x. = {rpn ..xsize.. 0.5 +}'
     # (2) The variable .dy_inc. is the spacing between lines in
     #     the key.  It should be OK even if you change the
     #     font size above.
     .key_topleft_x. = 0.5           # cm right of left axis
     .key_topleft_y. = 0.5           # cm below top axis
     .dy_inc. = {rpn ..fontsize.. pttocm 1.5 *}
     
     draw label "1 = Model 1A" at    \
         {rpn ..xleft.. xusertocm .key_topleft_x. +} \
         {rpn ..ytop.. yusertocm .key_topleft_y. -} cm
     
     .key_topleft_y. += .dy_inc.
     draw label "2 = Model 2A" at    \
         {rpn ..xleft.. xusertocm .key_topleft_x. +} \
         {rpn ..ytop.. yusertocm .key_topleft_y. -} cm
     
     .key_topleft_y. += .dy_inc.
     draw label "3 = Model 1B" at    \
         {rpn ..xleft.. xusertocm .key_topleft_x. +} \
         {rpn ..ytop.. yusertocm .key_topleft_y. -} cm
     
     .key_topleft_y. += .dy_inc.
     draw label "4 = Model 2B" at    \
         {rpn ..xleft.. xusertocm .key_topleft_x. +} \
         {rpn ..ytop.. yusertocm .key_topleft_y. -} cm
     
     draw title "Example 12 -- Total heating vs height of boundary layer"


File: gri.info,  Node: Polygons,  Next: TS Diagram,  Prev: Legend,  Up: Examples

Drawing gray polygons
=====================

   The following example shows how to draw polygons of a graylevel that
is read in.  It also draws a bullet (within the polygon).  See the help
lines at the start.

     `Draw Polygon And Bullet'
     Draw a polygon of a given graylevel, with a bullet
     (black dot) at an indicated location.  The polygon
     coordinates are read in by this command, as are
     the graylevel and the location of the bullet.
     
     Variables used:
       .black.
       .white.
     
     Input data read:
     
     line   1:
       A code (which is ignored) and a graylevel
       to draw the polygon with. The value for this
       graylevel ranges from .black. (which codes
       to black ink on the paper) to .white.
       (which codes to blank paper).
     
     line   2:
       An (x,y) location for the bullet.
     
     line   3:
       Skipped.
     
     line 4-n:
       Locations of vertices of polygon, ended with a blank line.
     {
       read .code. .graylevel. # Read line 1
       read .x. .y.            # Read line 2
       skip                    # Skip line 3
       read columns x y        # Read a polygon
       # Adjust .graylevel. to range between 0
       # (for black ink) and 1 (for white paper),
       # then set graylevel and draw polygon.
       .graylevel. = {rpn .graylevel. \
           .black. - .white. .black. - /}
       set graylevel .graylevel.
       draw curve filled
       # Draw black bullet
       set graylevel 0
       draw symbol bullet at .x. .y.
       # Clean up local storage.
       delete .code.
       delete .graylevel.
       delete .x.
       delete .y.
     }


File: gri.info,  Node: TS Diagram,  Next: PDF Diagram,  Prev: Polygons,  Up: Examples

Temperature-Salinity Diagram
============================

   Here is how you might draw an oceanographic "TS" (temperature
salinity) diagram:

example13.gri

     # Example 13 -- TS diagram, with isopycnals
     #
     # Draw Axes
     set line width axis 0.25
     set line width 0.75
     .tic_size. = 0.1                # cm
     set symbol size 0.03
     .isopycnal_fontsize. = 8        # for isopycnal labels
     .axes_fontsize. = 10            # for axes
     set font size .axes_fontsize.
     set x margin 2
     set x size 10
     set y margin 2
     set y size 10
     .Smin. = 33.4
     .Smax. = 35.0
     .Sinc. = 0.5
     .Sincinc. = 0.1
     .thetamin. = -2.0
     .thetamax. = 11.0
     .thetainc. = 1.0
     .thetaincinc. = 1.0
     set tic size .tic_size.
     set x name "Salinity / PSU"
     set y name "Potential Temperature / $\circ$C"
     set x axis .Smin. .Smax. .Sinc. .Sincinc.
     set y axis .thetamin. .thetamax. .thetainc. .thetaincinc.
     set axes style offset
     draw axes 1
     set clip on
     .old. = ..fontsize..
     set font size .isopycnal_fontsize.
     draw isopycnal 26.00
     draw isopycnal 26.50 unlabelled
     draw isopycnal 27.00
     draw isopycnal 27.50 unlabelled
     draw isopycnal 28.00
     draw isopycnal 28.50 unlabelled
     draw isopycnal 29.00
     set clip off
     set font size .old.
     #
     # Draw the data.
     open example13.dat
     read columns x y
     draw symbol bullet
     set font size ..
     draw title "Example 13 -- TS diagram, with isopycnals"


File: gri.info,  Node: PDF Diagram,  Next: Running Means,  Prev: TS Diagram,  Up: Examples

Probability Density Function Diagram
====================================

   A common application is to draw the probability density function for
(x,y) data.  Gri has no builtin facility to do this, but the following
example shows how to create the gridded PDF data using a call to the
`perl' system command.  The gridded data thus generated are contoured,
creating a PDF diagram.  As the comments in the program state, the
first call to Perl is specific to a particular dataset, and can be
ignored on first reading; it just creates the file `tmp-xy.\.pid.'.

     # Draw prob-density-function TS diagram for Bravo data
     
     # This first call to perl is specific to the
     # particular (weird) dataset.  All that matters
     # is that a file of (x,y) data is created, and
     # stored in the file called `tmp-xy.\.pid.'
     system perl <<"EOF"
     #
     # Slurp in x[], y[] data
     $dir = "/users/dek/kelley/Labrador/bravo/data";
     $Sfile = "$dir/S_25db_1day";
     $Tfile = "$dir/T_25db_1day";
     open(S, "$Sfile") || die "Can't open input $Sfile";
     open(T, "$Tfile") || die "Can't open input $Tfile";
     open(ST, ">tmp-xy.\.pid.")
         || die "Can't open tmp-xy.\.pid.";
     $day = 5;
     $year = 1964;
     while(<S>) {
         @S = split;
         $_ = <T>;
         @T = split;
         if (240 < $day && $day < 360) {
             for ($i = 0; $i < $#S; $i++) { #all depths
                 print ST "$S[$i] $T[$i]\n";
             }
         }
         $day += 1;
         if ($day > 365) {
             $year++;
             $day = 0;
         }
         if ($year > 1967) { last; }
     }
     EOF
     
     #
     # Create 2D PDF for (x,y) data in file \infile
     # storing the results in \outfile.  X ranges
     # between the indicated limits, with the indicated
     # binsize, as does y.  The synonyms defined
     # on the next 4 lines are the only input this
     # perlscript needs; the perlscript itself is
     # quite general.  For details of what it does,
     # particularly the scaling of the PDF, see
     # the perl comments.
     \xmin = "33.5"; \xmax = "35.5"; \xinc = "0.05";
     \ymin = "-2.0"; \ymax = "11.0"; \yinc = "0.25";
     \infile = "tmp-xy.\.pid."
     \outfile = "tmp-grid.\.pid."
     system perl <<"EOF"
     #
     # Prepare 2 dimensional probability-density-function
     # dataset for contouring by Gri.  This reads (x,y)
     # data from a file called $infile (defined below)
     # and creates an output file called $outfile
     # (also defined below) containing the
     # x-grid, the y-grid, and then the grid data,
     # suitable for reading/contouring by the Gri
     # commands
     #       open tmp-grid.\.pid.
     #       read .number_of_data.
     #       read grid x
     #       read grid y
     #       read grid data
     #       draw contour
     #
     # The values in the output grid are defined so
     # that they sum to the reciprocal of the
     # product of the x binsize and y binsize (see
     # definition of $factor below).
     #
     $xmin = \xmin; $xmax = \xmax; $xinc = \xinc;
     $ymin = \ymin; $ymax = \ymax; $yinc = \yinc;
     $infile = "\infile";
     $outfile = "\outfile";
     #
     # Slurp in the x[], y[] data, storing
     # the total number of data in $n.
     open(IN,  "$infile")   || die "Can't open infile";
     open(OUT, ">$outfile") || die "Can't open outfile";
     $n = 0;
     while(<IN>) {
         ($x[$n], $y[$n]) = split;
         $n++;
     }
     #
     # Zero out matrix (stored in a linear array scanned
     # as one reads a book).
     $cols = int(1 + ($xmax - $xmin) / $xinc);
     $rows = int(1 + ($ymax - $ymin) / $yinc);
     for ($y = $ymax; $y > $ymin; $y -= $yinc) {
         for ($x = $xmin; $x < $xmax; $x += $xinc) {
             $l = int(($x - $xmin) / $xinc
                 + $cols * int(($y - $ymin) / $yinc));
             $sum[$l] = 0;
         }
     }
     #
     # Cumulate (x,y) data into the matrix
     $inside = 0;
     for ($i = 0; $i < $n; $i++) {
         if ($ymin <= $y[$i] && $y[$i] <= $ymax
             && $xmin <= $x[$i] && $x[$i] <= $xmax) {
             $l = int(($x[$i] - $xmin) / $xinc
                 + $cols * int(($y[$i] - $ymin) / $yinc));
             $sum[$l]++;
             $inside++;
         } else {
             print STDERR "($y[$i], $x[$i]) clipped\n";
         }
     }
     #
     # Print number of points (to allow renormalization
     # if the user wishes)
     print OUT "$inside\n";
     #
     # Print x grid, y grid, then grid itself
     for ($x = $xmin; $x < $xmax; $x += $xinc) {
         printf OUT "%lg\n", $x;
     }
     print OUT "\n";
     for ($y = $ymax; $y > $ymin; $y -= $yinc) {
         printf OUT "%lg\n", $y;
     }
     print OUT "\n";
     #
     # The $factor variable scales the PDF.
     $factor = 1 / $xinc / $yinc / $inside;
     for ($y = $ymax; $y > $ymin; $y -= $yinc) {
         for ($x = $xmin; $x < $xmax; $x += $xinc) {
             $l = int(($x - $xmin) / $xinc
                 + $cols * int(($y - $ymin) / $yinc));
             printf OUT "%lg ", $factor * $sum[$l];
         }
         print OUT "\n";
     }
     EOF
     
     # Axes
     set x margin 3
     set x margin 6
     set x name "Salinity [PSU]"
     set y name "Potential Temperature [$\circ$C]"
     set x axis 34.5 34.8 0.1
     set y axis 5 9 1
     draw axes
     
     # PDF
     open tmp-grid.\.pid.
     read .number_of_data.
     read grid x
     read grid y
     read grid data
     .smooth. = 0
     
     # Contours.  Use clipping, since the axes are
     # zooming in on part of the PDF.
     set font size 8
     set contour label position centered
     set clip postscript on
     set line width rapidograph 4x0
     draw contour 0.2 2.2 0.4 unlabelled
     set line width rapidograph 0
     draw contour 0.4 2.4 0.4
     set clip postscript off
     end if


File: gri.info,  Node: Running Means,  Next: Finite Element Model Mesh,  Prev: PDF Diagram,  Up: Examples

Running-Mean Skyline Diagram
============================

   Timeseries data are often cast into running means; e.g. a temperature
record might be cast into monthly mean values.  The following example
shows how to use a perl script to accomplish this easily, producing a
graph with both the raw data (bullets) and the running mean (a skyline
plot).

     `Bin with  x .min. .max. .inc. \in_file \out_file'
     
     Creates \out_file from \in_file.  In each of these
     files, column 1 represents x and column 2 represents
     y.  The \out_file file contains the average values
     of y in x bands of width .inc., centred at .min.,
     (.min.+.inc.), up to .max, and with missing values
     inserted in bands with no x-data in \in_file.
     Each x-band is represented in \out_file by a
     plateau in y, and adjacent bands with
     non-missing data are connnected by vertical
     lines; the effect is a skyline plot of the
     banded means.  Sample application: plot
     monthly means of a variable.
     {
         if {rpn \.words. 8 !=}
             show "ERROR: `\.proper_usage.' called without"
             show " giving all parameters"
             quit 1
         end if
         system perl <<"EOF"
         $min = \.word3.;
         $max = \.word4.;
         $inc = \.word5.;
         open(IN,   "\.word6.")
             || die "`\.proper_usage': no \\in_file";
         open(OUT, ">\.word7.")
             || die "`\.proper_usage': no \\out_file";
     
         $n = ($max - $min) / $inc;
         #
         # Set up bins.
         for($i = 0; $i <= $n; $i++) {
            $xx[$i] = 0;
            $yy[$i] = 0;
            $nn[$i] = 0;
         }
         while(<IN>) {
             ($x, $y) = split(' ');
             $i = int(0.5 + ($x - $min) / $inc);
             $i =      0 if $i <      0;
             $i = $n - 1 if $i > $n - 1;
             $xx[$i] += $x;
             $yy[$i] += $y;
             $nn[$i]++;
         }
         for($i = 0; $i <= $n; $i++) {
             if ($nn[$i] > 0) {
                 $xx[$i] /= $nn[$i];
                 $yy[$i] /= $nn[$i];
                 $xleft  = $min + $inc * ($i - 0.5);
                 $xright = $min + $inc * ($i + 0.5);
                 #
                 # If datum to left non-missing,
                 # just draw vertical line
                 # down to the last yy value.
                 if ($i > 0 && $nn[$i - 1] > 0) {
                     print OUT "$xleft $yy[$i - 1]\n";
                 } else {
                     print OUT "$xleft \.missingvalue.\n"
                 }
                 print OUT "$xleft  $yy[$i]\n";
                 print OUT "$xright $yy[$i]\n";
             }
         }
     EOF
     }
     
     # Bin into months
     Bin with x 1964 1974 {rpn 1 12 /} \
         timeseries.dat tmp.dat
     open tmp.dat
     read columns x y
     close
     draw curve                      # skyline of means
     open timeseries.dat
     read columns x y
     close
     draw symbol bullet              # data
     system rm -f tmp.dat            # clean up


File: gri.info,  Node: Finite Element Model Mesh,  Next: Handling Data,  Prev: Running Means,  Up: Examples

Finite Element Model mesh
=========================

   Finite Element Models (used in fluid mechanics) employ
non-rectangular meshes, and plotting these meshes requires a few
intermediate steps.  Consider the common case of triangular elements.
Suppose two data files exist describing the mesh, the first,
`model.nodes' say, consists of a description of the x-y coordinates of
the nodes (vertices) of the triangles.  The second, `model.elements'
say, consists of a description of which triplet of nodes defines each
triangle in the mesh.  Here, from a sample application, is a node file
called `model.nodes':

     1	1	1
     2	2	1
     3	1	2
     4	3	1.5
     5	2	2
     6	1.5	3

Here is the corresponding file of the elements, called `model.elements'

     1	1	2	3
     2	2	5	3
     3	2	4	5
     4	3	5	6

In each of these files, the first column is a reference number.  Thus,
`model.elements' indicates that the first triangle is defined by the
nodes numbered `1', `2' and `3' as defined in `model.nodes'.  More
specifically, the triangle is defined by vertices at (x,y) locations
(1,1), (2,1), and (1,2).

   A Gri program, named `FEM.gri', to draw the nodes is the following.

     set missing value -99.99
     # Create data using perl-script ...
     system FEM.pl model.nodes model.elements > tmp
     # ... then plot it ...
     open tmp
     read columns x y
     close
     draw curve
     # ... and, finally, clean up the temporary file
     system rm tmp

The work of interpreting the data files is done by the perlscript that
follows, named `FEM.pl'

     #!/usr/bin/perl -w
     $missing = -99.99;              # missing value
     $node_file = $ARGV[0];
     $element_file = $ARGV[1];
     open (NODE, $node_file)
         or die "Cannot open '$node_file' file";
     open (ELEM, $element_file)
         or die "Cannot open '$element_file' file";
     
     # Read in node information, creating arrays
     # named $node_x[] and $node_y[]. Check that
     # the first column (the index) makes sense.
     $max_node = 1;
     while(<NODE>) {
         ($index, $node_x[$max_node], $node_y[$max_node])
             = split;
         die "Node mismatch at index=$index"
             if ($index != $max_node);
         $max_node++;
     }
     
     # Read in triangle elements, into arrays
     # $a[], $b[], and $c[].  Check that the
     # first column (the index) makes sense.
     $max_elem = 1;
     while(<ELEM>) {
         ($index, $a[$max_elem], $b[$max_elem], $c[$max_elem])
             = split;
         die "Element mismatch at index=$index"
             if ($index != $max_elem);
         $max_elem++;
     }
     
     # Print out triangles suitable for plotting in gri.
     for ($i = 1; $i < $max_elem; $i++) {
         print $node_x[$a[$i]], " ", $node_y[$a[$i]], "\n";
         print $node_x[$b[$i]], " ", $node_y[$b[$i]], "\n";
         print $node_x[$c[$i]], " ", $node_y[$c[$i]], "\n";
         # Repeat first, to close the triangle.
         print $node_x[$a[$i]], " ", $node_y[$a[$i]], "\n";
         print $missing, " ", $missing, "\n";
     }


File: gri.info,  Node: Handling Data,  Next: Handling Headers,  Prev: Finite Element Model Mesh,  Up: Examples

Handling Data
=============

* Menu:

* Handling Headers::            How to skip or read header lines
* Ignoring Columns::            Ignoring columns that are not of interest
* Column Algebra::              How to do algebra on columns
* Combining Columns::           Combining columns from separate files
* Plotting Several Columns::    Plotting several y-columns vs one x-column

