/*
		    GNU GENERAL PUBLIC LICENSE
		       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.
                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

			    Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
 (2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

		    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions of the General Public License from time to time.  Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions 
either of that version or of any later version published by the Free Software 
Foundation.  If the Program does not specify a version number of this License,
 you may choose any version ever published by the Free Software Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author to 
ask for permission.  For software which is copyrighted by the Free Software 
Foundation, write to the Free Software Foundation; we sometimes make 
exceptions for this.  Our decision will be guided by the two goals of 
preserving the free status of all derivatives of our free software and of 
promoting the sharing and reuse of software generally.

			    NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR
THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN 
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE 
THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, 
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND 
FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND 
PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, 
YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING 
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR 
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, 
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING 
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO 
LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR 
THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), 
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH 
DAMAGES.

		     END OF TERMS AND CONDITIONS '
*/
static const char* Copyright = "(C) Copyright Michigan State University 1994, All rights reserved";
/*
** Facility:
**   Xamine - NSCL Display program.
** Abstract:
**   sumregion.cc:
**      This file contains code which accepts and draws summing regions.
**      We handle both 1-d and 2-d summing regions.
** Author:
**      Ron Fox
**      NSCL
**      Michigan State Universty
**      East Lansing,  MI 48824-1321
*/

/*
** Include files:
*/
#include <config.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>

#include "XMWidget.h"
#include "XMPushbutton.h"
#include "XMLabel.h"
#include "XMText.h"
#include "XMList.h"
#include "XBatch.h"
#include "dispgrob.h"
#include "dispwind.h"
#include "dispshare.h"
#include "grobjmgr.h"
#include "grobjdisplay.h"
#include "sumregion.h"
#include "panemgr.h"
#include "convert.h"
#include "errormsg.h"
#include "grobjinput.h"
#include "colormgr.h"
#include "chanplot.h"
#include "mapcoord.h"


/*
** Constant definitions:
*/

#define XAMINE_LABEL_OFFSET 3

/*
** The text below is the help text for the dialog that accepts summing
** regions:
*/
static char *help_text[] = {
  "  This dialog prompts you to enter the points that make up a summing\n",
  "region.  A summing region consists of either two points (1-d spectra)\n",
  "which describe a lower and upper limit pair or a coutable set of points\n",
  "which describe a closed polygon.  You can enter points by clicking with\n",
  "the mouse MB1 or by typing in the coordinates on the Next Point type-in line\n",
  "  Summing regions are stored as graphical objects associated with a \n",
  "spectrum.  Graphical objects have names which are intended to be used\n",
  "by you to distinguish between several objects that might be defined\n",
  "on the same spectrum.  A default name is provided in the Object Name\n",
  "type-in.  You can and probably should change this name.\n\n",
  "   The set of points which make up a graphical object are shown in the\n",
  "list box above the Next Point type-in.  You may delete the most recently\n",
  "accepted point either by clicking in the spectrum with any button other\n",
  "than MB1 or by clicking the Delete Point button on the dialog.  If you\n",
  "switch to a different spectrum, all points are deleted\n\n",
  "   When you have edited the graphical object to your satisfaction, you\n",
  "click on one of the buttons in the action area.  These buttons have the\n",
  "following meanings:\n\n",
  "     Ok           - Accept the object and dismiss the dialog.\n",
  "     Apply        - Accept the object and leave the dialog up so that\n",
  "                    you can enter another summing region.\n",
  "     Cancel       - Do not accept the most recently entered object and\n",
  "                    dismiss the dialog.\n",
  "     Help         - Display this dialog.",
  NULL
  };


/*
** Below is the pointer to the object used to accept summing regions:
*/
AcceptSummingRegion *dialog = NULL;
/*
** Below is a pointer to the shared spectra region:
*/
extern spec_shared *xamine_shared;

/*
** This page contains several little functions which serve to relay 
** Motif++ callbacks to appropriate method functions.
*/
inline AcceptSummingRegion *mkobject(XtPointer ud) /* Create object pointer */
{
  AcceptSummingRegion *dialog = (AcceptSummingRegion *)ud;
  return dialog;
}

void 
AcceptSummingRegion::CancelRelay(XMWidget *w, XtPointer ud, XtPointer cd) /* Cancel relay: */
{
  mkobject(ud)->CancelCallback(cd);
}
void 
AcceptSummingRegion::ApplyRelay(XMWidget *w, XtPointer ud, XtPointer cd) /* Apply relay: */
{
  mkobject(ud)->ApplyCallback(cd);
}
void 
AcceptSummingRegion::OkRelay(XMWidget *w, XtPointer ud, XtPointer cd)  /* OK relay: */
{
  mkobject(ud)->OkCallback(cd);
}
void 
AcceptSummingRegion::TextPointRelay(XMWidget *w, XtPointer ud, XtPointer cd) /* Txt in relay */
{
  mkobject(ud)->TextPoint();
}
void 
AcceptSummingRegion::Delete_relay(XMWidget *w, XtPointer ud, XtPointer cd) /* Delete last pt */
{
  AcceptSummingRegion *o = mkobject(ud);
  
  XMWidget *pane = Xamine_GetSelectedDrawingArea();
  o->ClearPoints(pane);
  o->DelPoint();
  o->DrawPoints(pane);
}

/*
** Functional Description:
**   AcceptSummingRegion:
**     This is a constructor for the Accept Summing region class.
**     We build the widget hierarchy for the point prompter and
**     set up the initial state of the prompter.
** Formal Parameters:
**   char *name:
**      Name given to the widgets.
**   XMWidget *parent:
**      Parent widget of this whole thing.
**   char **help_text:
**      Pointer to the list of help strings.
*/
AcceptSummingRegion::AcceptSummingRegion(char *name, XMWidget *parent,
					 char **help_text) :
       ObjectInput(parent, name, help_text) 
{
  /* Build the widgets that will live in the point_prompts form: */

  Points         = new XMScrolledList(name, *point_prompts);
  DeleteLast     = new XMPushButton(name, *point_prompts, Delete_relay,
				    this);
  DeleteLast->Label("Delete Last");
  NextLabel      = new XMLabel(name, *point_prompts, "Next Point:");
  NextPoint      = new XMTextField(name, *point_prompts);

  object = NULL;		/* Null out the object so that Rebuild works.  */

  /* Lay out the widgets within the form.   */

  /*  The points list box is placed in the upper left corner of the form: */
  /*  To paste the list box we actually need the widget corresponding to  */
  /*  the parent of the list box:                                         */
  
  Widget scroller = Points->GetScrolledWindow();
  

  point_prompts->SetTopAttachment(scroller,      XmATTACH_FORM);
  point_prompts->SetLeftAttachment(scroller,     XmATTACH_FORM);
 
  /* Glue the delete last button to the list box on the left side, form on
  ** the right and top of form on the  top.  Bottom hangs free
  */

  point_prompts->SetTopAttachment(*DeleteLast,    XmATTACH_NONE);
  point_prompts->SetRightAttachment(*DeleteLast,  XmATTACH_FORM);
  point_prompts->SetBottomAttachment(*DeleteLast, XmATTACH_NONE);
  point_prompts->SetLeftAttachment(*DeleteLast,   XmATTACH_WIDGET);
  point_prompts->SetLeftWidget(*DeleteLast,      scroller);

  /*
  ** Glue the Next Point label to the form on the left and right and the
  ** list widget on the top.
  */
  point_prompts->SetLeftAttachment(*NextLabel,  XmATTACH_FORM);
  point_prompts->SetRightAttachment(*NextLabel, XmATTACH_FORM);
  point_prompts->SetTopAttachment(*NextLabel,   XmATTACH_WIDGET);
  point_prompts->SetTopWidget(*NextLabel,      scroller);

  /* Glue the point input text field to the form on the left right and bottom
  ** and to it's label on the top:
  */
  point_prompts->SetLeftAttachment(*NextPoint,   XmATTACH_FORM);
  point_prompts->SetRightAttachment(*NextPoint,  XmATTACH_FORM);
  point_prompts->SetBottomAttachment(*NextPoint, XmATTACH_FORM);
  point_prompts->SetTopAttachment(*NextPoint,    XmATTACH_WIDGET);
  point_prompts->SetTopWidget(*NextPoint,       *NextLabel);

  /* Set up the constant set of callbacks that drive the widget behavior */

  AddCancelCallback(CancelRelay, this);
  AddApplyCallback(ApplyRelay, this);
  AddOkCallback(OkRelay, this);
  NextPoint->AddActivateCallback(TextPointRelay, this);

}

/*
** Functional Description:
**   AcceptSummingRegion::ClearState:
**      This function clears the current input state.
**      This consists of removing all points from the list widget,
**      clearing the object (if it exists or unmanaging and going away if
**      it doesn't).
*/
void AcceptSummingRegion::ClearState()
{

  /* Clear the graphical object.    */

  if(object == NULL) {
    UnManage();
    return;
  }
  object->clrpts();

  /* Clear the points from the list widget:  */

  Points->ClearItems();
}

/*
** Functional Description:
**   AcceptSummingRegion::DrawPoints:
**     This function draws the summing represented by the object.
**     basically this is just a matter of setting up the call to
**     Xamine_DrawSumRegion.
** Formal Parameters:
**     XMWidget *pane:
**        Pointer to the widget to draw in.
**     Xamine_RefreshContext *ctx:
**        If non-null, the refresh context of the update
**        that's in progress. Used to locate the appropriate
**        drawing pixmap.
*/
void 
AcceptSummingRegion::DrawPoints(XMWidget *pane,
			     Xamine_RefreshContext *ctx)
{
  /* We need to get the display attributes of the spectrum associated with
  ** this pane, since it has the flipped flag and labelling flags.  If it
  ** Does not exist, then we cancel the input function.
  */

  win_attributed *att = Xamine_GetDisplayAttributes(row, col);
  if(att == NULL) {
    UnManage();
    return;
  }

  /* We need to check to see if the object is still alive.  If not then we
  ** also unmanage and vanish.   If there are no points, then we just
  ** return without drawing.
  */

  if(object == NULL) {
    UnManage();
    return;
  }
  if(object->pointcount() == 0) {
    return;
  }

  /* If a draw is in progress, and we are not in the callback stage of the
  ** draw, then any drawing we do now will at best be wasted and at worst
  ** be partly overwritten, causing funny (even number of draws) output.
  ** Therefore we just return in that case and let the callback time deal
  ** with the draw when it happens:
  */
  pane_db *pdb = Xamine_GetPaneDb();
  if( (pdb->refresh_state(row, col) != rfsh_idle)   &&
      (pdb->refresh_state(row, col) != rfsh_callback))
    return;
  /*
  ** draw the object:
  */

  object->draw(pane, Xamine_GetDisplayAttributes(row,col), False);
}
/*  Clear points... this is just draw points in disguise since we
**  are using XOR drawing.  The implicit assumption is that the 
**  lines are already visible.
*/
void AcceptSummingRegion::ClearPoints(XMWidget *pane,
			      Xamine_RefreshContext *ctx)
{
  DrawPoints(pane, ctx);
}

/*
** Functional Description:
**   AcceptSummingRegion::ClearDialog:
**    This method clears all the points from the dialog.
**    This is done by calling the ClearItems method of the Points object.
*/
void AcceptSummingRegion::ClearDialog()
{
  Points->ClearItems();
}

/*
** Functional Description:
**   AcceptSummingRegion::AddPoint:
**      This function adds a point  The point has been transformed to
**      spectra coordinates but flips are still missing.  This is a consequence
**      of the way that the Converter's work.  The points are represented on
**      the list widget using the order given in the input point itself.
** Formal Parameters:
**   point &pt:
**     The point to accept.
*/
void AcceptSummingRegion::AddPoint(point &pt)
{

  /*  The object must be defined and the attributes must still exist: */

  if(object == NULL) {
    UnManage();
    return;
  }
  win_attributed *att = Xamine_GetDisplayAttributes(row, col);
  if(att == NULL) {
    UnManage();
    return;
  }

  /* If the spectrum is 1-d, and if there are already 2 points, then we
  ** first delete the last point since we're only allowed 2 points in a
  ** summing region.
  */

  if(att->is1d() && (object->pointcount() == 2)) {
    DelPoint();			/* This does both the object and the list.  */
  }

  /* Now we add the point to the list, taking into account the flip: */

  point p;			/* This will be the grobj point. */
  if(att->isflipped()) {
    p.x = pt.y;
    p.y = pt.x;
  }
  else {
    p.x = pt.x;
    p.y = pt.y;
  }
  object->addpt(p.x, p.y);	/* Add the properly ordered point. */
  char pstring[80];
  if(att->ismapped()) {
    float fpx, fpy;
    if(att->isflipped()) {
      fpy = Xamine_XChanToMapped(att->spectrum(), pt.y);
      if(att->is1d()) {
	fpx = pt.x;
      } else {
	fpx = Xamine_YChanToMapped(att->spectrum(), pt.x);
      }
    } else {
      fpx = Xamine_XChanToMapped(att->spectrum(), pt.x);
      if(att->is1d()) {
	fpy = pt.y;
      } else {
	fpy = Xamine_YChanToMapped(att->spectrum(), pt.y);
      }
    }
    sprintf(pstring, "%.1f %.1f", fpx, fpy);
  } else {
    sprintf(pstring, "%d %d", pt.x, pt.y);
  }
  Points->AddItem(pstring);
  Points->SetBottomItem();	/* Scroll up if needed to show last item.  */
  NextPoint->SetText("");  /* Clear the input point.             */

}

/*
** Functional Description:
**   AcceptSummingRegion::DelPoint:
**     This function deletes a point from the summing region. Two things
**     must be done (we assume the caller takes care of things like
**     displaying the points).  First the most recent point must be removed
**     from the object.  Second the most recent point must be removed from
**     the list box.
*/
void AcceptSummingRegion::DelPoint()
{
  /* First the usual check to make sure the object is still defined. */

  if(object == NULL)  {
    UnManage();
    return;
  }

  if(object->pointcount() <= 0) return;	/* Return if no points left. */

  /* Delete the point from the list box: */

  Points->DeleteItem();

  /* Now delete the most recent point from the graphical object's point list */

  object->delpt();
}

/*
** Functional Description:
**   AcceptSummingRegion::DoAccept:
**     This function performs the mechanics of accepting a graphical object.
**     A 1-d summing region is exactly two points.  A 2-d summing region is
**     at least 3 points (user's responsible for making them non-colinear).
*/
Boolean AcceptSummingRegion::DoAccept()
{
  XMWidget *pane = Xamine_GetDrawingArea(row, col);

  /* IF the object is NULL, then we unmanage and exit: */

  if(object == NULL) {
    UnManage();
    return False;
  }
  /* If the attributes block is null, then return too: */

  win_attributed *att = Xamine_GetDisplayAttributes(row, col);
  if(att == NULL) {
    UnManage();
    return False;
  }
  /* We first make sure the number of points is correct: */

  if(att->is1d() && (object->pointcount() != 2)) {
    Xamine_error_msg(Xamine_Getpanemgr(),
		     "1-d Summing regions require 2 points to be accepted");
    return False;
  }
  if(!att->is1d() && (object->pointcount() < 3)) {
    Xamine_error_msg(Xamine_Getpanemgr(),
	     "2-d Summing regions require at least 3 points to be accepted");
    return False;
  }
  /* Now we clear the point echoes and the list box.  */

  ClearPoints(pane);
  ClearDialog();

  /* Finally, accept the object by calling Xamine_EnterGrobj... after setting
  ** the spectrum number and object name.
  */
  object->setspectrum(att->spectrum());
  char *s = ObjectInput::GetText();
  object->setname(s);
  XtFree(s);
  grobj_generic *o;

  if(!(o = Xamine_EnterGrobj(object))) {
    char errormsg[80];
    strcpy(errormsg, "Could not enter graphical object\n");
    strcat(errormsg, strerror(errno));
    Xamine_error_msg(Xamine_Getpanemgr(), errormsg);
    return False;
  }
  else {
    ChooseDefaultName();
  }

  o->draw(pane, att, True);

  /* Cleanup:  Clear the points and redraw the pane to show the 
  ** object in permanent form. Also return True to indicate success.
  */

  object->clrpts();
  return True;

}

/*
** Functional Description:
**   AcceptSummingRegion::SelectChanged:
**     This function adds to the behavior for SelectChanged for the
**     base class.  In particular, we must rebuild the graphical object since
**     the type of spectrum might have changed.
** Formal Parameters:
**   int oldc, oldr:
**     Prior row and column.
**   int newc, newr:
**     New row and column to work with.
*/
void AcceptSummingRegion::SelectChanged(int oldc, int oldr, int newc, int newr)
{
 GraphicalInput::SelectChanged(oldc, oldr, newc, newr);
 RebuildObject();
}

/*
** Functional Description:
**   AcceptSummingRegion::ChooseDefaultName:
**     This function sets the graphical object's default name.  We get that
**     from the next graphical object id number
*/
void AcceptSummingRegion::ChooseDefaultName()
{
  char namestr[80];
  sprintf(namestr, "Summing Region %03d", Xamine_GetNextObjectId());
  ObjectInput::SetText(namestr);
}

/*
** Functional Description:
**   AcceptSummingRegion::RebuildObject:
**      This function deletes any existing graphical object and 
**      builds a new one as appropriate to the current row and column.
*/
void AcceptSummingRegion::RebuildObject()
{
  /* First get rid of any prior graphical object: */

  if(object != NULL) {
    delete object;
    object = NULL;
  }
  /* Next see what we should be building: */

  win_attributed *att = Xamine_GetDisplayAttributes(row, col);
  if(att == NULL) {		/* Pane is empty so... */
    UnManage();
    return;			/* Give up on accepting stuff. */
  }
  if(att->is1d()) {
    object = new grobj_sum1d;
  }
  else {
    object = new grobj_sum2d;
  }
}

/*
** Functional Description:
**    AcceptSummingRegion::TextPoint:
**      This function is called when it is necessary to accept a typed in
**      point.  The point is validated, the text is cleared and the
**      point is entered in both the graphical object and the list box.
*/
void AcceptSummingRegion::TextPoint()
{
  char *s = NextPoint->GetText();
  float    x,y;

  /*  Get the spectrum attributes.. needed to validate point values. */

  win_attributed *att = Xamine_GetDisplayAttributes(row, col);
  if(att == NULL) {
    UnManage();
    return;
  }
  int spec = att->spectrum();	// Spectrum id number.

  /* Convert the point to numerical equivalents and complain if it won't. */

  if(sscanf(s,"%f %f", &x,&y) != 2) {
    XtFree(s);
    Xamine_error_msg(Xamine_Getpanemgr(),
		     "Please type in a valid pair of coordinates");
    return;
  }
  XtFree(s);

  // If the points are accepted on a mapped spectrum, they must be transformed
  // into channel coordinates, since they were entered in real coordinates.
  // 
  if(att->ismapped()) {
    if(att->isflipped()) {
      // Flipped:  y transforms via the X axis transform:

      y = Xamine_XMappedToChan(spec, y);

      // X is either counts (1d) or transforms via y if 2d:

      if(!att->is1d()) {
	x = Xamine_YMappedToChan(spec, x);
      }
    } else {
      // Not flipped, x must always transform:

      x = Xamine_XMappedToChan(spec, x);
      
      // If a 2-d y must also transform:
      
      if(!att->is1d()) {
	y = Xamine_YMappedToChan(spec, y);
      }
    }
  }

  /* Validate the points.  We don't require that the points be inside the
  ** displayed region.  Only that they be inside the spectrum itself.
  */

  point pt;
  pt.x = (int)x;			/* Point orientation doesn't change with */
  pt.y = (int)y;			/* flip. */

  if(att->isflipped()) {	/* But for checking we must flip x/y. */
    x = pt.y;
    y = pt.x;
  }
  /* regardles... x chans must be checked: */

  if( (x < 0) || (x >= xamine_shared->getxdim(spec))) {
    Xamine_error_msg(Xamine_Getpanemgr(),
		     "Coordinate must be inside spectrum bounds");
    return;
  }
  if( !att->is1d()) {		/* Check y dim if 2-d */
    if( (y < 0) || (y >= xamine_shared->getydim(spec))) {
      Xamine_error_msg(Xamine_Getpanemgr(),
		       "Coordinate must be inside spectrum bounds");
      return;
    }
  }

  /* Now we can add the point: */

  XMWidget *pane = Xamine_GetDrawingArea(row, col);
  ClearPoints(pane);
  AddPoint(pt);
  DrawPoints(pane);
     

}

/*
** Functional Description:
**   Xamine_AcceptSummingRegion:
**     This function initiates the editing and acceptance of a summing
**     region graphical object.  This is done by popping up (instantiating
**     if need be) an AcceptSummingRegion object.
** Formal Parameters: (most ignored).
**    XMWidget *w:
**      The function is a callback.  This is the widget which initiated the
**      summing region acceptance.
**    XtPointer ud:
**      This is a pointer to user data associated with the callback.
**      At present, no user data is expected.
**    XtPointer cd:
**      This is a pointer to a callback type specific data structure
**      which is not used.
*/
void Xamine_AcceptSummingRegion(XMWidget *w, XtPointer ud, XtPointer cd)
{
  /* If there is already some graphical input in progress, we indicate this
  ** and return without doing anything.
  */
  panemgr_select_callback cb;
  XtPointer userd;
 
  Xamine_GetSelectCallback(&cb, &userd);
  if(cb != NULL) {
    Xamine_error_msg(w,
       "Graphical input is already in progress. Please finish or cancel it");
    return;
  }

  /* If the dialog does not exist, then we build it. */

  if(dialog == NULL) {
    dialog = new AcceptSummingRegion("Summing region",
				     w, help_text);
    dialog->AddCallback(XtNdestroyCallback, Xamine_DestroyGraphicalInput, 
			(XtPointer)&dialog);
    dialog->AddCallback(XtNpopdownCallback, Xamine_DestroyGraphicalInput,
			(XtPointer)&dialog);
  }
  /* Set the current row/column: */

  dialog->setrow(Xamine_PaneSelectedrow());
  dialog->setcol(Xamine_PaneSelectedcol());

  /* Manage the dialog */

  dialog->Manage();
}

/*
** Functional Description:
**   Xamine_Draw1dCut:
**     This local function draws a 1-d cut.  A 1-d cut
**     is drawn as a pair of lines (much like a 1-d expansion area prior to
**     acceptance.  The lines will be either vertically or horizontally oriented.
**     Note that clipping may make one or both lines
**     invisible.  We rely on the clipping region to be set to eliminate
**     off window lines and lines that would be in the margins.
** Formal Parameters:
**   Display *d:
**     Pointer to the display connection.
**   Drawable win:
**     The thing we're drawing into.
**   GC ctx:
**     The graphical context to use when drawing.
**   XMWidget *wid:
**     The widget we're drawing in.
**   Xamine_Converter *cvt:
**     The converter to use to convert spectrum coordinates to tube coordinates.
**     (inputs will need to be flipped if flip is on).
**   Boolean flipped:
**      True if orientation is flipped.
**   grobj_sum1d *object:
**      Points to the object.
*/
void 
Xamine_Draw1dCut(Display *d, Drawable win, GC ctx, 
		 XMWidget *wid,
		 Xamine_Converter *cvt, 
		 Boolean flipped, 
		 grobj_generic *object)
{
  Dimension nx;			/* Need the X extent of window for flipped */

  wid->GetAttribute(XmNwidth, &nx);

  /* Construct the label in case labelit is true: */

  char label[10];
  sprintf(label, " S%d", object->getid());

  grobj_point *pt1 = object->getpt(0); // First point
  grobj_point *pt2 = (grobj_point*)NULL;
  int xlow = pt1->getx();
  int xhigh;
  if(object->pointcount() > 1) {
    pt2 = object->getpt(1);
    xhigh= pt2->getx();
    if(xlow > xhigh) {
      xhigh = xlow;
      xlow  = pt2->getx();
    }
  }

  // start by assuming pt1 is left and pt2 is right, then correct
  // as needed:


  // Assuming xlow/xhigh are in channel coordinates, we want xhigh to 
  // display on the right side of the channel and xlow on the left so:

  xhigh++;
  int xpix,ypix;
  // The drawing depends on whether or not the axis is flipped.
  if(flipped) {
    cvt->SpecToScreen(&xpix, &ypix, xlow);
    XDrawLine(d, win, ctx, xpix, ypix-1, (int)nx, ypix-1);
    if(pt2) {
      cvt->SpecToScreen(&xpix, &ypix, xhigh);
      XDrawLine(d, win, ctx, xpix, ypix+1, (int)nx, ypix+1);
    }
  } else {
    cvt->SpecToScreen(&xpix, &ypix, xlow);
    XDrawLine(d, win, ctx, xpix, ypix, xpix, 0);
    if(pt2) {
      cvt->SpecToScreen(&xpix, &ypix, xhigh);
      XDrawLine(d, win, ctx, xpix-1, ypix, xpix-1, 0);    
    }
  }
  return;

  /* While summing regions are supposed to only consist of a pair of points,
  ** we display all points in the graphical object just in case this definition
  ** gets generalized later.
  */

  for(int i = 0; i < object->pointcount(); i++) {
    grobj_point *pt = object->getpt(i);	/* Get a point. */
    int xpix, ypix;
    if(flipped) {		/* Flipped -> horizontal line */
      cvt->SpecToScreen(&xpix, &ypix, pt->getx());
      XDrawLine(d,win, ctx,	/* This is a horizontal line from the axis */
		xpix, ypix,	/* out to the right side of the picture. */
		(int)nx, ypix);
    }
    else {			/* Unflipped -> vertical line */
      cvt->SpecToScreen(&xpix, &ypix, pt->getx());
      XDrawLine(d, win, ctx,
		xpix, ypix,
		xpix, 0);
    }
  }
}

/*
** Functional Description:
**   Xamine_Draw2dContour:
**      This function is called to draw a 2-d contour.  A 2-d contour
**      is a closed polygon of points.
** Formal Parameters:
**   Display *d:
**     Connection id for the display.
**   Drawable w:
**     Drawable identifier that we're drawing into.
**   GC gc:
**     Grahpical context which describes the visual attributes of the draw.
**   XMWidget *wid:
**     Widget that we draw into.  I don't think this function uses it but
**     we require it to be passed for call uniformity with the 1d.
**   Xamine_Converter *cvt:
**     A coordinate converter which will convert the X,Y spectrum coordinates
**     to screen coordinates.
**   Boolean flipped:
**     True if the axes of the pane are flipped.
**   grobj_sum2d *object:
**      Pointer to the object to be drawn.
*/
void 
Xamine_Draw2dContour(Display *d, Drawable w, GC gc,
			    XMWidget *wid, Xamine_Converter *cvt,
			    Boolean flipped, 
			    grobj_generic *object)
{
  /* Summing regions are closed polygons.  They are drawn by 
  ** using an XLineBatch object.   The polygon is closed by drawing the
  ** first point first and last as well.
  */
  XLineBatch poly(d, w, gc);
  for(int i = 0; i < object->pointcount(); i++) {
    grobj_point *pt = object->getpt(i);	/* Get a point and... */
    int xpix, ypix;		        /* convert from spectrum to  */
    if(flipped)			        /* screen/pixel coordinates. */
      cvt->SpecToScreen(&xpix, &ypix, pt->gety(), pt->getx());
    else
      cvt->SpecToScreen(&xpix, &ypix, pt->getx(), pt->gety());
    poly.draw((short)xpix, (short)ypix);
  }
  /* Now close the polygon by drawing the last point. (if there are at least
  ** 3 points.
  */
  grobj_point *pt = object->getpt(0); /* Get first point to close the poly */
  int xpix, ypix;		        /* convert from spectrum to  */
  if(flipped)			        /* screen/pixel coordinates. */
    cvt->SpecToScreen(&xpix, &ypix, pt->gety(), pt->getx());
  else
    cvt->SpecToScreen(&xpix, &ypix, pt->getx(), pt->gety());

  if(object->pointcount() >= 3) {
    poly.draw((short)xpix, (short)ypix);
  }
  poly.flush();			/* Draw the lines. */
}

/*
** Functional Description:
**   Xamine_DrawSumRegion:
**     This function draws a summing region in a drawable given all the stuff
**     necessary to show how to draw it (See parameters below).  The
**     action is to determine first if the spectrum is 1-d or 2-d.  If 1-d,
**     then Draw1dSumRegion is called.  If 2-d then Draw2dSumRegion is called.
**     The drawing region is assumed to be defined by the clipping region in
**     The graphical context which is in turn assumed to cover only the
**     spectrum region of the display.
** Formal Parameters:
**   Display *d:
**     Identifies the X-11 connection to the display.
**   Drawable win:
**     Identifies the X-11 drawable that the graphics will be drawn in.
**   GC ctx:
**     Graphical context to do the draws with.
**   XMWidget *wid:
**     Widget in which the draw is done (needed for Xamine_LabelObject
**   Xamine_Converter *cvt:
**     Points to a converter that will convert the spectrum coordinates to
**     screen coordinates. Note that the clipping state will be temporarily
**     turned off for 2-d's to make drawing easy.
**   Boolean flipped:
**     True if the spectrum coordinate axes are flipped.
**   Boolean labelit:
**     True if graphical objects are to be labelled.
**   grobj_generic *object:
**     The object itself.
*/
void 
Xamine_DrawSumRegion(Display *d, Drawable win, GC ctx, XMWidget *wid,
		     Xamine_Converter *cvt,
		     Boolean flipped, Boolean labelit,
		     grobj_generic *object)
{
  /* The methods for drawing a 1-d and 2-d object are so different, that
  ** we branch out at this early stage to draw the objects appropriately.
  */
  cvt->NoClip();	   /* use the clip region to reject off window lines  */

  switch(object->type()) {
  case summing_region_1d:
    Xamine_Draw1dCut(d, win, ctx, wid,
		     cvt, flipped,
		     object);
    if(labelit) {
      char label[10];
      Dimension nx;

      sprintf(label, "S%d", object->getid());
      wid->GetAttribute(XmNwidth, &nx);
      for(int i = 0; i < object->pointcount(); i++) {
	int xpix, ypix;
	grobj_point *pt = object->getpt(i);
	cvt->SpecToScreen(&xpix, &ypix, pt->getx());
	if(flipped) {
	  Xamine_LabelGrobj(d, win, ctx, wid,
			    label, 
			    (xpix + (int)nx)/2, 
			    ypix + XAMINE_LABEL_OFFSET);
	}
	else {
	  Xamine_LabelGrobj(d,win,ctx,wid,
			    label,
			    xpix, ypix/2);
	}
      }		  
    }
    break;
  case summing_region_2d:
    Xamine_Draw2dContour(d, win, ctx, wid,
		    cvt, flipped, 
		    object);

    /* If labeling is enabled, then we draw the label text at the position of
    ** of the first point in the object.
     */
    if(labelit) {
      char labeltxt[10];
      int xpix, ypix;
      grobj_point *pt = object->getpt(0);

      if(flipped) {
	cvt->SpecToScreen(&xpix, &ypix, pt->gety(), pt->getx());
      }
      else {
	cvt->SpecToScreen(&xpix, &ypix, pt->getx(), pt->gety());
      }
      sprintf(labeltxt, " S%d", object->getid());
      Xamine_LabelGrobj(d, win, ctx, wid, labeltxt, 
			xpix, ypix + XAMINE_LABEL_OFFSET);
    }
    break;
  default:
    Xamine_error_msg(Xamine_Getpanemgr(),
			 "Xamine_DrawSumRegion -- not given a summing region");
    break;
  }
  cvt->Clip();
}
/*
  Destroy the summing region... requires clean up much like a cancel
  since this is only called when a destroy was done and that can only
  be done on an active widget:
*/

AcceptSummingRegion::~AcceptSummingRegion() {
    if(object != NULL)
      delete object;
    delete NextPoint;
    delete NextLabel;
    delete DeleteLast;
    delete Points;
  }
