#
#    This software is Copyright by the Board of Trustees of Michigan
#    State University (c) Copyright 2014.

#
#    You may use this software under the terms of the GNU public license
#    (GPL).  The terms of this license are described at:
#
#     http://www.gnu.org/licenses/gpl.txt
#
#     Author:
#             Ron Fox
#            NSCL
#            Michigan State University
#            East Lansing, MI 48824-1321
#

package provide browser 2.0
package require Tk
package require snit
package require img::png


#   browser provides a snit megawidget called "browser" which allows
#   the user to browse SpecTcl objects in a hierarchical manner
#   currently implemented as a ttk::treeview with scrollbars.  The object types that can
#   be browsed include:
#     Spectra
#     Parameters (tree and otherwise)
#     TreeVariables
#     Gates
#
#  Options:
#
#        The following allow the attachment
#        of scripts to the right click of top level folders.
#
#     -spectrumfoldercommand  script
#     -parameterfoldercommand script
#     -variablefoldercommand  script
#     -gatefoldercommand      script
#
#       The following allow the attachment of scripts
#       to double-clicks of spectra, parameters, variablesand gates:
#
#     -spectrumscript        script
#     -parameterscript       script
#     -variablescript        script
#     -gatescript            script
#
#       The following allow the attachment of scripts to right clicks
#       of spectra, parameters, variables and gates:
#
#     -spectrumrightclick    script
#     -parameterrightclick   script
#     -variablerightclick    script
#     -gaterightclick       script
#
#      The following control what is visible in the browser:
#
#      -restrict   {list of toplevel folders to view} (at present this is not dynamic!!).
#      -detail     bool
#      -showcolumns {list of columns to show}         (at presnt this is not dynamic!!).
#      -filtergates script     Run gate defs through script and only display those for which script is true
#      -filterparameters script As for -filtergates but with parameters.
#      -filterspectra script  as for -filtergates but with specrtra.
#
#     Geometric aspects:
#      -width     - Width of the browser window               (at present not dynamic)
#      -treewidth - Width of the tree column of the browser.  (at present not dynamic)
#
#  Each of these categories is represented as a folder whose contents contain the
#  objects of that type.  By convention in SpecTcl/Treeparameter, .'s are path
#  separators.  The tree hierarchy will generate, as needed, subfolders to reflect
#  the pathing hierarchy generated by the user.
#

#   Locate ourself and read in the  we require:
#

namespace eval browser {
    variable here [file dirname [info script]]
}

image create photo ::browser::spectrumicon -format gif \
                                           -file [file join $::browser::here icons   spectrumicon.gif]
image create photo ::browser::gateicon     -format gif \
                                           -file [file join $::browser::here icons  gateicon.gif]
image create photo ::browser::paramicon    -format gif \
                                           -file [file join $::browser::here icons   treeparicon.gif]
image create photo ::browser::varicon      -format gif \
                                           -file [file join $::browser::here icons  treevaricon.gif]
image create photo ::browser::axisicon     -format gif \
                                           -file [file join $::browser::here icons  axisicon.gif]
image create photo ::browser::pointicon    -format gif \
                                           -file [file join $::browser::here  icons  pointicon.gif]
image create photo ::browser::pseudoicon   -format gif \
                                           -file [file join $::browser::here  icons  pseudoicon.gif]
image create photo ::browser::foldericon   -format png \
    -file [file join $::browser::here icons folder.png]

::snit::widget browser {

    # the subwidgets in this frame:

    component tree
    component xscroll
    component yscroll

    option -spectrumfoldercommand  {}
    option -parameterfoldercommand {}
    option -variablefoldercommand  {}
    option -gatefoldercommand      {}


    option -spectrumscript         {}
    option -parameterscript        {}
    option -variablescript         {}
    option -gatescript             {}


    option -spectrumrightclick     {}
    option -parameterrightclick    {}
    option -variablerightclick     {}
    option -gaterightclick        {}

    option -restrict   -default [list spectra parameters gates variables] \
	-configuremethod configRestrict
    option -detail     1
    option -showcolumns -default [list type gate low high bins value units] \
	-configuremethod configColumns

    option -filtergates {}
    option -filterparameters {}
    option -filterspectra    {}

    option -width 8in
    option -treewidth 2.5in

    delegate option * to tree
    delegate method * to tree
    
    variable parameterTerminals -array [list]
    variable spectrumTerminals  -array [list]
    variable variableTerminals  -array [list]

    #---
    
    variable topLevelIds [list]
    
    # Map item types to top level folder text strings.
    
    variable typeToNames -array {
        spectrum Spectra
        parameter Parameters
        variable  Variables
        gate      Gates
    }
    variable dTypeToNames -array {
        l long
        w word
        b byte
    }
    
    constructor {args} {
	# install and layout the widgets in the frame>

	install tree using ttk::treeview $win.tree \
	    -yscrollcommand [list $win.yscroll set] -xscrollcommand [list $win.xscroll set] \
	    -height 32
	install xscroll using scrollbar $win.xscroll -orient horizontal -command [list $win.tree xview]
	install yscroll using scrollbar $win.yscroll -orient vertical   -command [list $win.tree yview]
	grid $tree $yscroll -sticky nsew
	grid $xscroll       -sticky nsew

	#  Invariant tree configuration:
	
	set allcolumns [list type gate low high bins value units]
	$tree configure -columns $allcolumns
	foreach colname $allcolumns {
	    $tree heading $colname -text $colname
	    $tree column $colname -stretch 1 -anchor w -width 100
	}
	$tree heading #0 -text "Tree"
        bind $tree <<TreeviewOpen>> [mymethod _openFolder]
	
	# Force default configuration

	foreach option [array names options] {
	    $self configure $option $options($option)
	}

	$self configurelist $args; # overrides to defaults.

	# Populate the tree:

        #set timing [time {
	#$self fillAllFolders
        #}]
        

    }
    #----------------------------------------------------------------------------------
    #  configuration management:

    ##
    #  -showcolumns - affects both the columns displayed as well as the
    #                 -show results for the tree:
    #
    method configColumns {option value} {
	set options($option) $value
	$tree configure -displaycolumns [concat $value]
	set showList tree
	if {[llength $value] > 0} {
	    set showList [concat $showList headings]
	}
	$tree configure -show $showList
    }
    ##
    # -restrict - This will just update the options(-restrict) variable and
    #             perform an update which repopulate the entire tree:
    #
    method configRestrict {option value} {
	set options($option) $value
	$self update
    }
    #------------------------------------------------------------------------------------
    # Public methods:

    

    ##
    # update
    #   Updates the contents of the browser:
    #
    method update {} {
	$self fillAllFolders
    }
    #-------------------------------------------------------------------------------------
    # Private methods.

    # fillAllFolders
    #    Destructively restock all folders;
    #
    method fillAllFolders {} {
        # Unset the terminal look up tables for the unpopulated parts of the
        # tree.
        
        array unset parameterTerminals *
        array unset spectrumTerminals  *
        
        
	# Kill off the top level folders:

        set timing [time {
	foreach id $topLevelIds {
	    $tree delete $id
	}
        }]
        
	set topLevelIds [list]

	# Stock only those in the -restrict list:

        if {[lsearch -exact $options(-restrict) spectra] != -1} {
            set timing [time { 
            $self fillSpectrumFolder
            }]
            
        }
        if {[lsearch -exact $options(-restrict) parameters] != -1} {
            set timing [time {
             $self fillParameterFolder
             }]
        }
        if {[lsearch -exact $options(-restrict) variables] != -1} {
            set timing [time {
            $self fillVariableFolder
            }]
        }
        if {[lsearch -exact $options(-restrict) gates] != -1} {
            set timing [time {
            $self fillGateFolder
            }]
        }

	#  Bindings for folders:

        
        set timing [time {
	$tree tag bind spectrumFolder <Button-3> \
	    [mymethod FolderContextDispatch -spectrumfoldercommand %X %Y]
	$tree tag bind parameterFolder <Button-3> \
	    [mymethod FolderContextDispatch -parameterfoldercommand %X %Y]
	$tree tag bind variableFolder <Button-3> \
	    [mymethod FolderContextDispatch -variablefoldercommand %X %Y]
	$tree tag bind gateFolder <Button-3> \
	    [mymethod FolderContextDispatch -gatefoldercommand %X %Y]


	# Bindings for the items in the folders:

	# gates:

	$tree tag bind gate <Button-1> [mymethod selectElement %x %y]
	$tree tag bind gate <Double-1> [mymethod onElementDoubleClick -gatescript %x %y]
	$tree tag bind gate <Button-3> [mymethod onElementContext -gaterightclick %x %y %X %Y]

	# Spectra:

	$tree tag bind spectrum <Button-1> [mymethod selectElement %x %y]
	$tree tag bind spectrum <Double-1> [mymethod onElementDoubleClick -spectrumscript %x %y]
	$tree tag bind spectrum <Button-3> [mymethod onElementContext -spectrumrightclick %x %y %X %Y]; # ]


	# Parameters:

	$tree tag bind parameter <Button-1> [mymethod selectElement %x %y]
	$tree tag bind parameter <Double-1> [mymethod onElementDoubleClick -parameterscript %x %y]
	$tree tag bind parameter <Button-3> [mymethod onElementContext -parameterrightclick %x %y %X %Y]

	# Variables:

	$tree tag bind variable <Button-1>  [mymethod selectElement %x %y]
	$tree tag bind variable <Double-1>  [mymethod onElementDoubleClick -variablescript %x %y]
	$tree tag bind variable <Button-3>  [mymethod onElementContext -variablerightclick %x %y %X %Y]

        }]
        

    }

    # fillSpectrumFolder
    #      Fills in the Spectrum folder with spectrum definitions.  At the top level,
    #      We just fill in the name and type.  Then we need to dispatch to type dependent
    #      methods to figure out how to fill in the rest of spectrum information.
    #      As with all the fill*Folder functions, the existing spectra are first removed from
    #      the folder.  See insertSpectrum for information about how to add a single spectrum.
    #
    method fillSpectrumFolder {} {
	
        # Create the top level folder for spectra:
    
        set spectrumFolder [$tree insert {} end -text Spectra \
                    -open 0 -tags spectrumFolder -image ::browser::foldericon]
        lappend topLevelIds $spectrumFolder
    
    
        # Now we're ready to populate the subtree:
        # Step 2:  Create a list of spectra filtered by any -filterspectra script each element
        #          itself a list containing:
        #           name, type, gate, "" "" "" "" ""  definition.
        #
        set timing [time {
        set spectrumList [list]
        foreach definition [spectrum -list -showgate] {
            if {$options(-filterspectra) ne ""} {
            if {![uplevel #0 $options(-filterspectra) [list $definition]] } {
                continue;	# Skip if filter script rejected.
            }
            }
            set name [lindex $definition 1]
                set gate [lindex $definition end]
                if {$gate eq "-TRUE-"} {
                    set gate ""
                }
            lappend spectrumList [list \
                          $name                   \
                          "[lindex $definition 2] [lindex $definition 5]"  \
                          $gate     \
                          "" "" "" "" ""          \
                          $definition]				  
        }
        }]
    
        # Fill in the spectrum tree:
    
        set timing  [time {
            $self fillSpectrumSubtree $spectrumFolder $spectrumList
        }]

    }
    # fillParameterFolder
    #      Fills the parameter folder with the set of parameters that are now defined.
    #      Previously existing parameters in the folder are first destroyed.
    #      this is suitable for a wholesale refresh of the gui.. it is not
    #      so useful for adding a single parameter.  See the addParameterByName method for that.
    #
    method fillParameterFolder {} {
	# Create the top level folder for parameters

	set paramFolder [$tree insert {} end -text Parameters \
			     -open 0 -tags parameterFolder -image ::browser::foldericon]
	lappend topLevelIds $paramFolder

	# Stock with parameters:
	#  Make the list of parameters we are going to display in the tree:
	#  This is a 2 element list of parameter name, parameter definition:
	#

    set timing [time {
	set parameterList [list]
    foreach parameter [parameter -list] {
        if {$options(-filterparameters) != ""} {
            if {![eval $options(-filterparameters) [list $parameter]]} {
                continue
            }
        }
        lappend parameterList [list [lindex $parameter 0] $parameter]
	}
    }]

	# Recursively stock the parameter tree algorithm is pretty much the same as
	# for fillSpectrumSubtree

    set timing [time {
        $self fillParameterSubtree $paramFolder $parameterList
    }]


   
    }
    # fillVariableFolder
    #      Fills the variable folder with the set of treevariables that are now defined.
    #      note that only treevariables are put in the folder, not ordinary Tcl vars.
    #      as that could be a strain on the user. Prior to filling, the existing
    #      variables are wiped out.  This function is best used to do a full refresh.
    #
    #
    method fillVariableFolder {} {
	# Create the the variable folder:

	set varFolder [$tree insert {} end -text Variables \
			   -open 0 -tags variableFolder -image ::browser::foldericon]

	lappend topLevelIds $varFolder


	set vars [treevariable -list]
	set varCount [llength $vars]
	set varNum   0
	set treeVariables [list]
        foreach variable $vars {
	    incr varNum
            set rawname [lindex $variable 0]
            set value   [lindex $variable 1]
            set units   [lindex $variable 2]

	    lappend treeVariables [list $rawname $value $units]

        }
	$self fillVariableSubtree $varFolder $treeVariables

		      
    }
    # fillGateFolder
    #    Fills the gate folder with the set of gates that are now defined.
    #    The type column is filled with the gate type and gate type specific0
    #    subnodes are created for each gate.
    #
    method fillGateFolder {} {

	set gateFolder [$tree insert {} end -text Gates \
			    -open 0 -tags gateFolder -image ::browser::foldericon]
	lappend topLevelIds $gateFolder

	# Create the list of filtered gates:

	set gateList [list]
	set gates [gate -list]
	set filter $options(-filtergates)

	if {$filter ne ""} {
	    foreach gate $gates {
		if {[uplevel #0 $filter [list $gate]]} {
		    lappend gateList $gate
		}
	    }
	} else {
	    set gateList $gates
	}
	$self fillGateSubtree $gateFolder $gateList
    }

    ## fillSpectrumSubtree
    #    Recursively fills the spectrum tree.
    #    The spectrum list we've been given is considere to be sorted.
    #    We take each spectrum and split the remaining name into
    #    a list of path elements.
    #    - For each path list that has more than one element we create
    #      a folder and recurse for the remainder of the path.
    #    - For each path list that has only  one element we create a terminal
    #      spectrum node.
    #    Note that this automatically correctly handles the case where
    #    A name is both a path lead in as well as a terminal node e.g.:
    #    x and x.left, x.right for a PPAC position.
    #
    # @param id           - Id of parent fror all nodes that will be created.
    # @param spectrumList - List of spectrum definitions.
    #                       Note that the 0'th element of each of these is the
    #                       remaining path name.
    #
    method fillSpectrumSubtree {id spectrumList} {
        array set folders [list]; # Will hold folder nodes.
        array set terminals [list]; # Will hold terminal nodes.
    
        foreach spectrum $spectrumList {
            set nameList [split [lindex $spectrum 0] .]
            if {[llength $nameList] == 1} {
                set terminals($nameList) $spectrum; #  One path element means terminal node
            } else {
                # Folder
                set spectrum [lreplace $spectrum 0 0 [join [lrange $nameList 1 end] .]]; # Remainder of path.
                lappend folders([lindex $nameList 0]) $spectrum; # list of stuff in the folder.
            }
        }
        # Now create the folders and their subtrees...sort by index of the folders array:
    
        foreach folderName [lsort [array names folders]] {
            set folderId [$tree insert $id end -text $folderName -image ::browser::foldericon]
            $self fillSpectrumSubtree $folderId $folders($folderName)
        }
            # remember the terminal nodes for this folder so that we can
            # populate them on a folder open:

        set spectrumTerminals($id) [array get terminals]
        return	
    }

    ##
    # addSpectrum
    #   Adds a spectrum at the end of the list below the given parent
    #
    # @param parent - Parent id.
    # @param item   - List element created by fillSpectrumFolder.
    #
    # @return id    - the tree id of the element created.
    #
    # @note if the spectrum definition is empty "" we are creating a subfolder for the given 
    #       name, otherwise we are creating a spectrum along with its elements for each parameter
    #       and axis definition.
    #
    method addSpectrum {parent item} {
        
        set spectrumDef [lindex $item 8]
        if {$spectrumDef eq ""} {
            set icon ::browser::foldericon
            return [$tree insert $parent end -text [lindex $item 0] \
                -image ::browser::foldericon \
                -values [lrange $item 1 7] -tags spectrum]
        } else {
            return [$self _insertSpectrum $parent end $item]
        }
        return
    

    }
    ##
    # setSpectrumSubInfo id type parameters axes
    #      Fills in any required child nodes for a spectrum.  This is type dependent.
    #      Note that in the case of 1-d spectra (type 1, g1, b, and S),
    #      We fill in the x axis low/high/bins on the parent node just to make
    #      it a bit easier for the user.
    #      For 2-d type spectra, we'll have subsidiary nodes for each axis that
    #      will have this information.
    #      In any case we list the parameters and their information as well.
    # 
    #   @param  id            - The treeview ident of the primary node.
    #   @param  spectrumType  - The spectrum type.
    #   @param  parameters    - The parameters used by the spectrum.
    #   @param  axes          - The axis definitions used by the spectrum.
    #
    method setSpectrumSubInfo {id spectrumType parameters axes} {

        # Branch out depending on the type of spectrum:

        switch -exact -- $spectrumType {
	    1 {
		$self set1dSubInfo $id $parameters $axes
	    }
	    2 {
		$self set2dSubInfo $id $parameters $axes
	    }
	    g1 {
		$self setg1SubInfo $id $parameters $axes
	    }
	    g2 {
		$self setg2SubInfo $id $parameters $axes
	    }
	    gd {
		$self setgdSubInfo $id $parameters $axes
	    }
	    s {
		$self setSummarySubInfo $id $parameters $axes
	    }
	    b {
		$self setBitmaskSubInfo $id $parameters $axes
	    }
	    S {
		$self setStripchartSubInfo $id $parameters $axes
	    }
	    m2 {
		$self set2dMultipleSubInfo $id $parameters $axes
	    }
            gs {
                $self setGammaSummarySubInfo $id $parameters $axes
            }
        2dmproj {
            $self setM2ProjectionInfo $id $parameters $axes
        }
	    default {}
        }
    }
    ##
    # set1dSubInfo id parameters axes
    #      Sets the subnode information for a 1-d spectrum:
    #      The info for the single axis is loaded into the
    #      the primary node's data. If the parameters is a
    #      treeparameter, units are also loaded.
    #      The parameter is loaded as a subnode, if a tree parameter its info
    #      is loaded as well.
    # 
    # @param id         - The spectrum node's id in the treeview.
    # @param parameters - A single parameter name.
    # #param  axes       - A list containing a single axis definition list.
    #
    method set1dSubInfo {id parameters axes} {
        set axis  [lindex $axes 0]
        $self addAxisInfo           $id $axis $parameters
        $self addEntryParameter     $id 0 $parameters

    }
    ##
    # set2dSubInfo id parameters axes
    #     Fils in the subnode information for a 2-d spectrum.
    #     This consists of two subnodes, one for the x axis and one for the y axis.
    #     The x axis is labelled with X : xparametername
    #     The y axis is labelled with Y : yparametername
    #     For both axes, the low, high, bins are taken from the axis definitions
    #
    # @param id         - Id of the parent node.
    # @param parameters - list containing x, y parameters.
    # @param axes       - list containing the axis specifications.
    method set2dSubInfo {id parameters axes} {
        foreach parameter $parameters axis $axes name {X Y} {
            $self addAxis $id $name $parameter $axis
        }
    }
    ##
    # setg1SubInfo id parameters axes
    #      Fills in subnodes for a g1 spectrum:
    #      The axis information is placed on the spectrum line, and we create one
    #      parameter subnode for each parameter in the spectrum.  The icon for each parameter
    #      is the treeparameter icon, to distinguish it from being an axis specification.
    #      No data is supplied with each parameter.   There is no axis subnode.
    #      If the first parameter in the parameter list is a treeparamter, its units are
    #      used as the axis units. under the assumption that all paramters will have the same
    #      units.
    # 
    #   @param  id          - The id of the parent node.
    #   @param  parameters  - List of parameters for the spectrum.
    #   @param  axes        - The single axis specification for the spectrum.
    #
    method setg1SubInfo {id parameters axes} {

        # Extract the axis information and add it to the existing data for id.

        set axis [lindex $axes 0]
        $self addAxisInfo $id $axis [lindex $parameters 0]


        $self setFold $id

        #  Now a parameter subnode for each parameter in the gamma spectrum:

        set paramnumber 0
        foreach parameter $parameters {
            $self addEntryParameter $id $paramnumber $parameter
            incr paramnumber
        }

    }
    ##
    # setg2SubInfo id parameters axes
    #      Fills in any required child nodes for a g2 spectrum.  These
    #      consist of:
    #      - A fold subnode if the spectrum has a fold applied.
    #      - An x and a y axis subnode.  The limits/bins on the axis are taken
    #        from the axis specification.  If the first parameter in the spectrum
    #        is a tree parameter, the units for both axes are taken from it on the
    #        assumption that a gamma spectrum with mixed units has no reason to live.
    #      - A parameter axis for each parameter in the list.
    #
    # @param id         - The id of the parent node.
    # @param parameters - list of parameters in this spectrum.
    # @param axes       - list of axes.
    method setg2SubInfo {id parameters axes} {
        set axisid [$self addAxis $id X [lindex $parameters 0] [lindex $axes 0]]
        $tree item $axisid -text X

        set axisid [$self addAxis $id Y [lindex $parameters 0] [lindex $axes 1]]
        $tree item $axisid -text Y

        $self setFold $id

        set paramno 0
        foreach param $parameters {
            $self addEntryParameter $id $paramno $param
            incr paramno
        }

    }
    ##
    # setM2ProjectionInfo $id $parameters $axes
    #   Set the sub information for an m2 projection spectrum.
    #   This will have two axes, x and y.  The projection axis will be indicatedd.
    #   The parameters for each axis will be listed under the axis.  There will
    #   also be a list of gates that define the ROI of the projection.
    #
    # @param id - the id of the parent node (under which all this is put.)
    # @param parameters - actually a three element list containing, in order
    #                  *  The list of parameters as x1 y1 x2 y2 ...
    #                  *  x | y giving the projection direction,.
    #                  *  list of gates used to define the projection ROI.
    # @param axes - A list of axes.  There will be exactly one axis definition
    #               because this is a projection.
    #
    method setM2ProjectionInfo {id parameters axes} {
        set params [lindex $parameters 0]
        set direction [lindex $parameters 1]
        set roiGates [lindex $parameters 2]
        set axis [lindex $axes 0]
        
        #  We're going to create an x and y axis under id.  The parameters
        #  will then be listed under the appropirate axis.  The
        #  Axis parameters will be the definitions for the projected axis
        #  and empty for the other.
        
        if {$direction eq "x"} {
            set xaxisId [$self addAxis $id X "" $axis]
            set yaxisId [$self addAxis $id Y "" ""]
        } else {
            if {$direction eq "y"} {
                set xaxisId [$self addAxis $id X "" ""]
                set yaxisId [$self addAxis $id Y "" $axis]
            }
        }
        #  Add the parameter definitions under the appropriate axis:
        
        for {set i 0} {$i < [llength $params]} {} {
            set xname [lindex $params $i]
            incr i
            set yname [lindex $params $i]
            incr i
            
            $self addParameter $xaxisId $xname [parameter -list $xname]
            $self addParameter $yaxisId $yname [parameter -list $yname]
        }
        #  Next we'll add the gates that define the ROI:
        
        foreach gateName $roiGates {
            set fullDescription [lindex [gate -list $gateName] 0]
            set type [lindex $fullDescription 2]
            
            set gateid \
                [$tree insert $id end -text $gateName \
                 -image ::browser::gateicon -value $type -tags gate]
            $self setGateSubInfo $gateid $type [lindex $fullDescription 3]
        }
        
        
    }
    ##
    #  setgdSubInfo id parameters axes
    #    Set the sub information for a gamma 2d deluxe spectrum.
    #    Note that the parameters parameter is a 2 element list of
    #    the x and y parameters.
    #
    # @param id - Parent node id.
    # @param parameters - list of parameters in the spectrum.
    # @param list of axis definitions.
    #
    method setgdSubInfo {id parameters axes} {
        set xparams [lindex $parameters 0]
        set yparams [lindex $parameters 1]
    
    
        set axisid [$self addAxis $id X "" [lindex $axes 0]]
        $tree item $axisid -text X
    
    
        set axisid [$self addAxis $id Y "" [lindex $axes 1]]
        $tree item $axisid -text Y
    
    
        set i 0
    
        foreach x $xparams {
            $self addEntryParameter $id $i "X: $x"
            incr i
        }
        foreach y $yparams {
            $self addEntryParameter $id $i "Y $y"
            incr i
        }
    }
    ##
    # setSummarySubInfo id parameters axes
    #     Fills in any required child nodes for a summaryy spectrum.
    #     The summary spectrum has the following subnodes:
    #     - X axis which is labeled X : parameters
    #       for which the low is 0, the high is nparams -1 and the bins are nparams.
    #       and for which there are no units.
    #     - Y axis which is labelled Y and has info from the first of the parameters.
    #     - A parameter entry for each parameter in the spectrum
    #     The spectrum itself is given the y axis info.
    # 
    # @param  id         - Id of the node we are adding children to.
    # @param  parameters - List of parameter names involved in the spectra.
    # @param  axes       - Axis specifications.
    #
    method setSummarySubInfo {id parameters axes} {
        $self addAxis $id X parameters "0 [expr [llength $parameters]-1] [llength $parameters]"
        set xid [$self addAxis $id Y [lindex $parameters 0] [lindex $axes 0]]
        $tree item $xid -text Y

        $self addAxisInfo $id [lindex $axes 0] [lindex $parameters 0]

        set pno 0
        foreach parameter $parameters {
            $self addEntryParameter $id $pno $parameter
            incr pno
        }
    }
    ##
    # setBitmaskSubInfo id parameters axes
    #      Fills in any required child nodes etc. for a bitmask spectrum.
    #      The top level gets the axis limit information, units are not relevant.
    #      A parameter subnode is created for the parameter from which the mask is being
    #      computed.
    # 
    # @param  id          - Id of the spectrum node we are filling in
    # @param   parameters  - list of parameters that make the spectrum (one really)
    # @param   axes        - list of axis specifications (one really).
    #
    method setBitmaskSubInfo {id parameters axes} {
        set axis [lindex $axes 0]
        $self addAxisInfo $id $axis $parameters
        $self addEntryParameter $id 0 $parameters
    }
    ##
    # setStripchartSubInfo id parameters axes
    #     Fills in required child nodes for a stripchart spectrum from the time parameter
    #     This consists of an axis specification in the spectrum itself.
    #     and a pair of parameters with labels that look like:
    #     Time  : parametername
    #     Value : parametername
    # 
    # @param  id         : The id of the spectrum node.
    # @param  parameters : The time and value parameter for the spectrum.
    # @param  axes       : The single axis specification.
    #
    method setStripchartSubInfo {id parameters axes} {
        set axis [lindex $axes 0]
        set timep [lindex $parameters 0]
        set valuep [lindex $parameters 1]

        $self addAxisInfo $id $axis $timep
        $self addEntryParameter $id 0 "Time  : $timep"
        $self addEntryParameter $id 1 "Value : $valuep"

    }
    ##
    # set2dMultipleSubInfo id parameters axes
    #     Fills in the required sub info for a 2d multiply incremented
    #     spectrum.  We add 2 axes named arbitrarily X and Y
    #     and list all the parameters and their information as well.
    #
    #
    #  @param  id         : Id of the spectrum node.
    #  @param  parameters : list of parameter names.
    #  @param  axes       : 2 axis specifications.
    #
    method set2dMultipleSubInfo {id parameters axes} {
        set axisid [$self addAxis $id X "" [lindex $axes 0]]
	$tree item $axisid -text X

        set axisid [$self addAxis $id Y "" [lindex $axes 1]]
	$tree item $axisid -text Y


	set i 0
	foreach parameter $parameters {
	    $self addEntryParameter $id $i $parameter
	    incr i
	}
    }
    ##
    #  setGammaSummarySubInfo id parameters axes
    #
    #  Set the sub information for a gamma summary spectrum.
    #  We'll have one axis, which is the Y axis, and that will
    #  display as on a 1-d spectrum.
    #  We'll have strip subfolders numbered for the x axis coordinate
    #  each strip subfolder will have entries for each parameter in that strip.
    #
    # @param id - Id of parent tree node.
    # @param parameters - list of parameters involved.
    # @param axes       - list of axis specifications.
    #
    method setGammaSummarySubInfo {id parameters axes} {
        
    #  Add the y axis as our axis information:

      set axis [lindex $axes 0]
      set c    [lindex $parameters 0]

      set p [lindex $c 0]

      $self addAxisInfo $id $axis $p

      set xChannel 0
      set param 0

      foreach channel $parameters {

      # Add a folder for a channels parameters.

        set name Channel$xChannel
        set channelId [$tree insert $id end -text $name -image ::browser::foldericon]

        foreach parameter $channel {
        # Add a parameter definition.

          $self addEntryParameter $channelId $param $parameter

          incr param
        }
        incr xChannel
      }
    }
 
    ##
    # addAxisInfo id specification parameter
    #     Adds axis specification information to the indicated node.
    #     this consists of low, high, bins, and if the parameter is
    #     a treeparam, units.
    # 
    #    @param id             - Id of the node to add this info to.
    #    @param specification  - SpecTcl axis specification string.
    #    @param parameter      - Parameter name.
    #
    method addAxisInfo {id specification parameter} {
	


        set data [$tree item $id -values]
        if {[llength $specification] == 3} {
            set low   [format %.2f [lindex $specification 0]]
            set high  [format %.2f [lindex $specification 1]]
            set bins  [lindex $specification 2]
        } else {
            set low ""
            set high ""
            set bins ""
        }
        set units ""
        set info [treeparameter -list $parameter]
        if {$info != ""} {
            set info [lindex $info 0]
            set units [lindex $info 5]
        }
	#Replace the new information into the values data:

	set data [lreplace $data 2 6 $low $high $bins "" $units]
        $tree item $id -values $data
    }
    ##
    # addAxis id name parameter specification
    #     Adds an axis subnode to the node id (presumably a spectrum).
    #     - The axis limits are taken from the specification
    #     - The label of the axis is "$name : parametername"
    #     - The units of the axis are taken from the treeparameter units
    #       if the parameter is a tree parameter.
    # 
    # @param  id            - ID of spectrum node to which the axis is being added.
    # @param  name          - axis name (usually X or Y).
    # @param  parameter     - Name of parameter from which to draw the parameter informatino.
    # @param  specification - Axis limit specification
    # @return The new node id.
    method addAxis {id name parameter specification} {
	set axisid [$tree insert $id end -text "$name : $parameter" -image ::browser::axisicon \
			-values [list "" "" "" "" "" ""  ""]]
        $self addAxisInfo $axisid $specification $parameter
        return $axisid
    }
    ##
    # addEntryParameter id number name
    #      Adds a parameter subnode to a treeview entry The parameter node just shows the
    #      paramter name with a parameter icon.
    # 
    # @param   id      - Id of the treeview node to which this is being added.
    # @param   number  - A parameter index number used to name the node.
    # @param   name    - A parameter name used to label the node.
    #
    # @return    The new node id.
    #
    method addEntryParameter {id number name} {
        return [$tree insert $id end -text $name -image ::browser::paramicon]

    }
    ##
    # setFold id
    #     Adds a fold node to id if there is a fold applied to the
    #     spectrum.  A fold is represented as a gate node labelled:
    #     "Folded on : gatename
    #
    # @param id - the id of the node in which to apply the fold.
    #
    method setFold id {

	# Figure out the full spectrum name by crawling back up the path.
	# Note that the top level is Spectra and must not be used.
	#
	
	set nameList [list]
	set here $id
	while {[$tree parent $here] ne ""} {
	    lappend nameList [$tree item $here -text]; # bottom to top list.
	    set here [$tree parent $here]
	}
	set nameList [lreverse $nameList]; # Top to bottomlist. Spectra....


        set name [$self ItemName $id]


        set fold [fold -list $name]
        if {$fold != ""} {
            set fold [lindex $fold 0]
            set foldname "Folded on : [lindex $fold 1]"
	    $tree insert $id end -text $foldname -image ::browser::gateicon

        }
    }
    ## 
    #  ItemName id
    #
    #  Given the id of an item that is a spectrum, parameter, gate etc.
    #  Determines its full path name.  This is done by getting parent names
    #  up until and not including the top level folder, then joining them in 
    #  top to bottom path order with '.''s.
    #
    # @param id - The id of the item we're trying to get a name for.
    # 
    # @return - the full path name of the item.
    #
    method ItemName id {
        set nameList [list]
        set here $id
        while {[$tree parent $here] ne ""} {
            lappend nameList [$tree item $here -text]; # bottom to top list.
            set here [$tree parent $here]
        }
        set nameList [lreverse $nameList]; # Top to bottomlist. Spectra....


        return [join $nameList .]


    }
    ##
    # FullPath
    #    Just like ItemName above, however the folder name is also returned.
    #
    method FullPath id {
        set nameList [list]
        set here $id
        while {$here ne ""} {
            lappend nameList [$tree item $here -text]
            set here [$tree parent $here]
        }
        set nameList [lreverse $nameList]
        return [join $nameList .]
	
    }
    ##
    # fillParameterSubtree id parameters
    #   Fills a parameter subtree by
    #   - Creating folders for all non-terminal nodes in parameters.
    #   - Creating parameter nodes for all terminal nodes in parameters.
    #
    # @param id - The id of the parent node in which we are going to insert children.
    # @param parameters - List where each element contains in order the residual path string
    #                     and the parameter definition.
    #
    method fillParameterSubtree {id parameters} {
        array set folders [list]
        array set terminal [list]
    
        foreach element $parameters {
            set pathList [split [lindex $element 0] .]
            if {[llength $pathList] == 1} {
            # Terminal node
            
            set terminal($pathList) [lindex $element 1];	# elements contain parameter defs.
            
            } else {
            set residualPath [join [lrange $pathList 1 end] .]
            set element [lreplace $element 0 0 $residualPath]
            lappend folders([lindex $pathList 0]) $element;	# List of children.
            }
        }
        # Create the folders and recurse on them to create their children:
    
        foreach folder [lsort [array names folders]] {
            set folderId [$tree insert $id end -text $folder -image ::browser::foldericon]
            $self fillParameterSubtree $folderId $folders($folder)
        }
            ##
            #  Maintain the terminals information:
            #
            set parameterTerminals($id) [array get terminal];   # Terminals for id.
            return


    }
    ##
    # addParameter id name definition
    #
    #  Adds a parameter definition to the list of parameters...this is a parameter terminal node.
    #
    # @param id   - Id of parent node.
    # @param name - Terminal part of path  name.
    # @param def  - Parameter definition.
    # @param where - index at which to add the parameter, defaults to end.
    # @return id - id of the parameter entry in the tree.
    #
    method addParameter {id name def {where end}} {
        set fullName [lindex $def 0]; # full path name to parameter.
    
        set pid [$self addEntryParameter $id 0 $name $where]
    
        # Figure out the values we need to put..only there if tree parameter:
    
        set treeInfo [treeparameter -list $fullName]
        if {$treeInfo != ""} {
            set info [lindex $treeInfo 0]; #  tree parameter has info.
            set bins  [lindex $info 1]
            set low   [lindex $info 2]
            set hi    [lindex $info 3]
            set units [lindex $info 5]
        } else {
            set bins "";	# Non tree parameter has nothing.
            set low  ""
            set hi   ""
            set units ""
        }
        $tree item $pid \
            -tag Parameter -values [list "" "" $low $hi $bins "" $units] \
            -tags parameter
    
    
        # If the parameter is a pseudo, we are going put the dependent parameters as subnodes:
    
        if {$options(-detail)} {
            set pseudoInfo [pseudo -list $fullName]
            if {$pseudoInfo != ""} {
                $tree item $pid -image ::browser::pseudoicon
                set pseudoInfo [lindex $pseudoInfo 0]
                set dependencies [lindex $pseudoInfo 1]
                set pseudonum 0
                foreach dependentParam $dependencies {
                        $self addEntryParameter $pid $pseudonum $dependentParam
                        incr pseudonum
                }
            }
        }
        return $pid
    }
    ##
    # addEntryParameter id number name
    #      Adds a parameter subnode to a treeview entry The parameter node just shows the
    #      paramter name with a parameter icon.
    # Parameters:
    #    id      - Id of the treeview node to which this is being added.
    #    number  - A parameter index numer -- ignored there for compatibility with vsn 1.0 of the pkg.
    #    name    - A parameter name used to label the node.
    #    where   - Where to add the parameter, defaults to end.
    # Returns:
    #     The new node id.
    #
    method addEntryParameter {id number name {where end}} {
        set pid [$tree insert \
            $id $where -text $name -image ::browser::paramicon]

        return $pid
    }
    ##
    # fillVariableSubtree 
    #
    # Fills  variable subtree given a parent and a list of variables that may or
    # or may not be terminal.  This is recursive.
    # For each variable that is not yet in terminal form the first path element is stripped out
    # and turned into a fodler and that folder is filled.
    #
    # @param id - Parent id.
    # @param variables - List of variables where the first item is the residual path, followed by
    #                    the value and units currently held by the variable.
    #
    method fillVariableSubtree {id variables} {
        array set folders [list]
        array set terminal [list]
    
        # Build up the folders and terminal arrays.
    
        foreach variable $variables {
            set name [lindex $variable 0]
            set pathList [split $name .]
            if {[llength $pathList] == 1} {
            set terminal($name) $variable
            } else {
            set residualPath [join [lrange $pathList 1 end] .]
            set variable [lreplace $variable 0 0 $residualPath]
            lappend folders([lindex $pathList 0]) $variable
            }
        }

        # Create folders and recurse:
    
        foreach folder [lsort [array names folders]] {
            set folderId [$tree insert $id end -text $folder -image ::browser::foldericon]
            $self fillVariableSubtree $folderId $folders($folder)
        }
        # Enter the terminal nodes:

        set variableTerminals($id) [array get terminal]
    }
    ##
    # fillGateSubtree
    #
    #  Fills a gate subtree..  by now the pattern should be familiar,
    #  Gate names are divided into path elments gate are divided into terminal and folder nodes
    #  depending on whether they have only one or more than one path elements.
    #  folder nodes; create the folder, strip off the first path element and recurse.
    #  terminal nodes create the gate entry.
    #  Since filling in gate information can be comlex depending on the gate type,
    #  once the gate node is created, fillGateInformation is invoked to fill in the details
    #  (which could mean additional nodes for some gate types).
    #
    # @param id    - The node id of the parent of this subtree.
    # @param gates - List of gate descriptions that should populate this subtree.
    #
    method fillGateSubtree {id gates} {
        array set folders [list]
        array set terminals [list]

        foreach gate $gates {
            # Only show non 'F' gates -- as those are deleted gates.
            if {[lindex $gate 2] ne "F"} {
                set path [split [lindex $gate 0] .]
                if {[llength $path] == 1} {
                    set terminals($path) $gate
                } else {
                    set residual [join [lrange $path 1 end] .]
                    set gate [lreplace $gate 0 0 $residual]
                    lappend folders([lindex $path 0]) $gate
                }
            }
        }
        # Create folders and curse and recurse.
    
        foreach folder [lsort [array names folders]] {
            set folderId [$tree insert $id end -text $folder -image ::browser::foldericon]
            $self fillGateSubtree $folderId $folders($folder)
        }
    
        # Create terminal nodes.
        
    
        foreach gate [lsort [array names terminals]] {
            set description $terminals($gate)
            $self _insertGate $id end $gate $description
            
           # set type [lindex $description 2]
           # set gateId [$tree insert $id end -text $gate -image ::browser::gateicon \
           #         -values $type -tags gate]
           # $self setGateSubInfo $gateId $type [lindex $description 3]
        }
    }
    #
    # setGateSubInfo id type description
    #    Sets appropriate subordinate information for a gate.
    #    This is done by independent gate type handlers that know
    #    the format of the gate description field (which varies from gate type to
    #    gate type).
    # 
    # @param   id           - treeview id of the gate we are elaborating.
    # @param   type         - Gate type (from SpecTcl gate description.
    # @param   description  - Gate dependent description information.
    #
    method setGateSubInfo {id gateType description} {
        switch -exact -- $gateType {
            s {
                $self setSliceSubInfo $id $description
            }
            b -
            c {
                $self set2DGateSubInfo $id $description
            }
            * -
            + -
            "-" {
                $self setCompoundGateSubinfo $id $description
            }
            gs {
                $self setGammaSliceSubinfo $id $description
            }
            gb -
            gc {
                $self setGamma2DGateSubinfo $id $description
            }
            em -
            am -
            nm {
                $self setMaskGateSubinfo $id $description
            }
            default {
            }
        }
    }

    ##
    # setSliceSubInfo id description
    #    Sets the subinfo for a slice gate.
    #    This consists of:
    #    - A parameter subnode containing the name of the parameter
    #      the gate is tested on.
    #    - A Point subnode labelled "limits : (low,hi)
    #      showing the extent of the gate on the parameter.
    #
    # parameters:
    #  @param  id          - The id in the treeview of the gate on which
    #                  these subnodes will be created.
    #  @param  description - The gate dependent description which is a list
    #                  of the form {parameter-name {low high}}
    method setSliceSubInfo {id description} {
        # Parse the description:

        set parameter [lindex $description 0]
        set limits    [lindex $description 1]

        $self addEntryParameter $id 0 $parameter
        $self addPoint $id 1 "limits : " $limits
    }
    ##
    # addPoint id number prefix point
    #     Adds a point subnode to the indicated id.
    #     A point subnode is labelled as "prefix (x,y)"
    #     A point is labelled with the pointicon.
    # 
    #    @param id      - Id of node to which this point is getting added.
    #    @param number  - Index of the point
    #    @param prefix  - Prefix string for the point label
    #    @param point   - The point coordinates.
    #
    #
    method addPoint {id number prefix point} {
        set label [format "$prefix (%.2f,%.2f)" [lindex $point 0] [lindex $point 1]]
	$tree insert $id end  -text $label -image ::browser::pointicon

    }
    ##
    # set2DGateSubInfo id description
    #    Sets the appropriate subordinate information for a 2d gate
    #    (band or contour).
    #    - We create a parameter subentry for each of the parameters in the gate.
    #      These will be labelled X : parametername
    #    - We create a subfolder named 'points' and an entry in it for each
    #      point labelled (x,y).
    # 
    #   @param id           - The treeview id of the entity we are creating these subnodes under.
    #   @param description  - The gate descrption which consists of an n element list.  The
    #                  First element is a 2 element sublist containing the x/y parameter names
    #                  The subsequent elements are the x/y points as {x y} sublists.
    #
    method set2DGateSubInfo {id description} {
        set parameters [lindex $description 0]
        set points     [lrange  $description 1 end]

        $self addEntryParameter $id 0 "X : [lindex $parameters 0]"
        $self addEntryParameter $id 1 "Y : [lindex $parameters 1]"

        set pno 0
        foreach point $points {
            $self addPoint $id Points.$pno "" $point
            incr pno
        }

    }
    ##
    # setCompoundGateSubinfo id description
    #    Sets appropriate subordinate information for compound gate.
    #    Compound gates consist of/depend on other gates.
    #    For each gate we produce a simple gate subentry
    #    simple gate subentries look like gates but don't show any subordinate
    #    detail other than the gate type.
    # Parameters:
    #  @param  id           - The id of the gate we are creating subordinate information for.
    #  @param  description  - The gate description, which in this case is,
    #                  the list of names of subordinate gates.
    #
    method setCompoundGateSubinfo {id description} {
        foreach gate $description {
            set type [lindex [lindex [gate -list $gate] 0] 2]
	    $tree insert $id end -text $gate -image ::browser::gateicon \
		-values $type

        }
    }
    ##
    # setGammaSliceSubinfo id description
    #    Sets the appropriate subordinate information for a gamma slice.
    #    This consists of a single point and a list of parameters and Parameters folder.
    #    The point is labelled "Limits : (hi,low)"
    # 
    # @paream   id          - The treeview id of the gate to which we are adding
    #                         the subordinates.
    # @param   description - The description of the gate.
    #
    method setGammaSliceSubinfo {id description} {
        set point      [lindex $description 0]
        set parameters [lindex $description 1]

        set parno 0
        foreach parameter $parameters {
            $self addEntryParameter $id Parameters.$parno $parameter
            incr parno
        }
        $self addPoint $id $parno "Limits : " $point

    }
    ##
    # setGamma2DGateSubinfo id description
    #    Set the appropriate subordinate information for a 2d gamma gate
    #    (gc, gb). This consists of a list of parameters in a parameter folder
    #    and a list of points in a Points folder.
    #
    # 
    # @param  id          : Id of the gate we are filling in (in the treeview)
    # @param  description : Gate description which consists of a list of points and
    #                       a list of parameters.
    #
    method setGamma2DGateSubinfo {id description} {
        set points     [lindex $description 0]
        set parameters [lindex $description 1]

        set parno 0
        foreach parameter $parameters {
            $self addEntryParameter $id Parameters.$parno $parameter
            incr parno
        }

        set pnum 0
        foreach point $points {
            $self addPoint $id Points.$pnum "" $point
            incr pnum
        }
    }
    ##
    # setMaskGateSubinfo id description
    #    Sets appropriate subordinate informatino for a bitmask
    #    gate (type em, am, nm).  We list the parameter
    #    and the mask.  The mask is listed as a 'point'
    #    however the label is just mask = (hex of mask).
    #    Since the 'point' is not really a point, we must manually
    #    create the point.
    #
    # @param  id           - Id of the gate for which  we are making subordinate data.
    # @param  description  - The gate description which consists of a parameter and mask.
    #
    method setMaskGateSubinfo {id description} {
        set parameter [lindex $description 0]
        set mask      [lindex $description 1]
        set masklabel [format "mask = 0x%x" $mask]

        $self addEntryParameter $id 0 $parameter
	$tree insert $id end -text $masklabel -image ::browser::pointicon

    }
    ##
    # getSelection
    #       Returns a list consisting of:
    #       The full names of all the selected entities in the browser tree.
    #       Note that the item type prefix (e.g. Gates or Spectrum) is still
    #       present.
    #       If there are no elements selected, an empty list is returned.
    # Returns:
    #     A list of names in the selection. 
    #     The elements of this list are translated back  to names 
    #     (the _BLTFOLDER is removed from intermediate path entries.
    #
    method getSelection {} {
        set selected [$tree selection];         # These are ID's.
        set names [list]
        foreach id $selected {
            lappend names [$self FullPath $id]
        }
        return $names
    }
    #-------------------------------------------------------------------------
    #
    # Event dispatch and handling.

    ##
    # mymethod FolderContextDispatch Option %X %Y
    #       Dispactches folder context menu requests.  These are typically
    #       requested via a right click over a top level folder.
    # 
    # @param    OptionName   - the name of the option array element that is holding
    #                the user supplied script to call or {} if there is none.
    #                the X/Y coordinates of the click are passed to the caller.
    # @param x,y     - The coordinates of the click relative to the widget.
    #
    method FolderContextDispatch {OptionName x y} {
        set script $options($OptionName)
        if {$script != ""} {
            uplevel #0 $script $x $y
        }
    }
    ##
    # selectElement x y
    #     Sets the selEction to the element at x,y
    #
    method selectElement {x y} {
        set id [$tree identify row  $x $y]
        if {$id != ""} {
	    $tree selection set $id
        }
    }
    ##
    # onElementDoubleClick Option x y
    #      Dispatches user scripts on double clicks on SpecTcl elements.
    #      (e.g. Spectra, Gates, Parameters, Variables.
    # 
    #   @parameter Option   - Name of the option that should have the user script body.
    #   @parameter  x,y      - Coordinates of the click.
    # @note
    #    The user script is called:
    #        userscript path
    #    Where path is the path of the nearest element under the pointer when the doubleclick occured.
    #
    method onElementDoubleClick {Option x y} {

        set script $options($Option)
        if {$script != ""} {
            set id [$tree identify row  $x $y]
            if {$id != ""} {
                set path [$self FullPath $id]
                uplevel #0  $script  $path
            }
        }
    }
    ##
    # onElementContext Option x y X Y
    #     Invokes a context click (right button) for
    #     an element:
    # Parameters:
    #    Option   - Name of the option that should have the user script body.
    #    x,y      - Coordinates of the click.
    #    X,Y      - Absolute coordinates of the click.
    # Note:
    #     The user script is called:
    #        userscript path X Y
    #
    method onElementContext {Option x y X Y} {
        set script $options($Option)
    
        if {$script eq ""} return; # No callback.
        
        set id [$tree identify row $x $y]
        if {$id ne ""} {
            set name [$self FullPath $id]
    
            uplevel #0 $script $name $X $Y
        }
    }
    ##
    # deleteElement
    #    Given a type and full path, removes the element from the tree.
    #    This _should_ only be called with objects not folders.
    #
    # @param itemType - Type of object: spectrum, gate, parameter, variable
    # @param fullName - Full name e.g. this.that.the.other
    # @note - it is not an error for the element not to have an id. In theory,
    #         the containing folder may never have been opened.
    # @note - given the note above, any removed elements should be filtered out
    #         to prevent them from coming into existence if the folder is
    #         later opened.
    #
    method deleteElement {itemType fullName} {
        
        # Hierarchy top is the top level from which we're going to search.
        
        set hierarchyTop [$self _getTopFolderId $itemType]
        if {$hierarchyTop eq ""} {
            error "$type does not have a folder in the browser."
        }
        # Find the element in the hierarchy.  If it does not exist.
        #  Not biggy.
        
        set id [$self _findElement $hierarchyTop $fullName]
        if {$id ne ""} {
            $tree delete $id
        }
        #
        # @todo  Need also to get rid of it from the terminals...
        #  so that close open won't then display it -note
        #  no help for refresh though.
    }
    ##
    # addNewSpectrum
    #    Adds a spectrum to the set of spectra.
    #    What this requires:
    #    - Generate a spectrum description as expected by addSpectrum.
    #    - Figure out the id of the containing folder.
    #    - Put this spectrum into the set of items in that folder.
    #    - If the folder is open, insert an item at the right part of
    #      the children.
    #
    # @param name - name of the spectrum.
    method addNewSpectrum {name} {
        set spectra [spectrum -list $name]
        set spectrum [lindex $spectra 0];      #Spectrum definition string.
       
        set info [_makeSpectrumInfo $spectrum]
        
        
        # Get the id of the folder that holds the spectrum name:
        
        set name [lindex $spectrum 1]
        set parentId [$self _getParent spectrum $name]
        
        # Add the spectrum to the parent's list... if it exists and
        # resort (that's the simplest..)
        
        
        if {[array names spectrumTerminals $parentId] eq $parentId} {
            set currentSpectra $spectrumTerminals($parentId)
            lappend currentSpectra $info
            set currentSpectra [lsort -increasing -ascii -index 0 $currentSpectra]
        }
        
        # If the folder is open then figure out where in the spectra
        # we need to add and add it.
        
        if {[$tree item $parentId -open]} {
            set children [$tree children $parentId]
            
            # See if its in the middle, if so insert.
            
            set newid ""
            set index 0
            set terminalName [lindex [split $name .] end]
            foreach child $children {
                set name [$tree item $child -text]
                if {$name > $terminalName} {
                    set newid [$self _insertSpectrum \
                        $parentId $index $info]
                    break
                }
                incr index
            }
            # If not in the middle, then add at end.
            
            if {$newid eq ""} {
                $self _insertSpectrum $parentId end $info
            }
        }
    }
    ##
    # addNewParameter
    #    Adds a parameter to a tree where it does not yet exist:
    #    - find the owning folder.
    #    - If that parameter has a terminals entry that's filled in.
    #    - If the folder is opened, the parameter is added to the folder at
    #      the appropriate position.
    #
    #  @param name - name of the parameter -- must exist.
    #
    method addNewParameter {name} {
        
        # Generate the terminal data and the folder.
        
        set def [parameter -list $name]
        if {[llength $def] == 0} {
            error "Parameter $name does not exist"
        }
        set def [lindex $def 0]
        set path [split $name .]
        set terminalName [lindex $path end]
        
        # Now get the folder id:
        
        set folderId [$self _getParent parameter $name]
        
        #  Two cases
        # 1. the folder has a terminals entry - then we need
        #    to insert this into that list.
        # 2. the folder has been opened, in which case we need to add
        #    this parameter at the right point in the children.
        #
        
        if {[array names parameterTerminals $folderId] eq $folderId} {
            # folder was never opened:
            
            set terminalList $parameterTerminals($folderId)
            lappend terminalList [list $terminalName  $def]
            set parameterTerminals($folderId) [lsort \
                -ascii -increasing -index 0 $terminalList]
            
        } else {
            set children [$tree children $folderId]
            set index 0
            set id ""
            foreach child $children {
                set childName [$tree item $child -text]
                if {$childName > $terminalName} {
                    set id [$self addParameter \
                        $folderId $terminalName $def $index]
                    break
                }
                incr index
            }
            # If we've still not inserted, insert at end:
            
            if {$id eq ""} {
                $self addParameter $folderId $terminalName $def end
            }
        }
    }
    ##
    # addNewGate
    #   Adds a new gate to the browser.
    #   - Find the owning folder
    #   - For gates, there tend to be few enough the entire tree was built
    #     so we just need to figure out where to put the gate and add it.
    #
    # @param name - name of the gate.
    #
    method addNewGate name {
        set description [gate -list $name]
        if {[llength $description] == 0 } {
            error "gate $name does not exist"
        }
        set description [lindex $description 0]
        
        #  Figure out the parent folder id and the terminal name:
        
        set folderId [$self _getParent gate $name]
        set path [split $name .]
        set terminalName [lindex $path end]
        
        # Figure out where to insert the gate and use _insertGate to do so.
        
        set children [$tree children $folderId]
        set index 0
        set id ""
        foreach child $children {
            set childName [$tree item $child -text]
            if {$childName > $terminalName} {
                set id [$self _insertGate                         \
                    $folderId $index $terminalName $description]
                break
            }
            
            incr index
        }
        if {$id eq ""} {
            $self _insertGate $folderId end $terminalName $description
        }
    }
        
    #-------------------------------------------------------------------------
    #  Internal methods.
    
    ##
    # _openFolder
    #   Open a folder.
    #   - Figure out the id of the folder being opened.
    #   - If there are terminal nodes associated with the folder add them
    #     and delete them.
    #
    method _openFolder {} {
        set id [$tree focus]
        
        # If a parameter, add parameter terminals:
        
        if {[array names parameterTerminals $id] ne ""} {
	# Create the parameter definitionsL
            array set terminal $parameterTerminals($id)
            foreach param [lsort [array names terminal]] {
                $self addParameter $id $param $terminal($param)
            }
            array unset parameterTerminals $id
            return
        }
        if {[array names spectrumTerminals $id] ne ""} {
            array set terminals $spectrumTerminals($id)
            foreach spectrum [lsort [array names terminals]] {
                $self addSpectrum $id $terminals($spectrum)
            }
            array unset spectrumTerminals $id
            return
        }
        if {[array names variableTerminals $id] ne ""} {
            array set terminal $variableTerminals($id)
            foreach variable [lsort [array names terminal]] {
                set varInfo  $terminal($variable)
                set valueList [list "" "" "" "" "" [lindex $varInfo 1] [lindex $varInfo 2]]
                $tree insert $id end -text $variable -image ::browser::varicon \
                    -values $valueList -tags variable
            }
            
        }
        
    }
    ##
    # _getTopFolderId
    #    Given a top folder type, gets the id of that folder.
    #    If that folder does not exist, an empty string is returned.
    #
    # @param otype - this is a string in the set spectrum, parameter, variable, gate
    # @return id of the top level folder for that type of thing or "" if there
    #         is none.
    #
    method _getTopFolderId {otype} {
        if {[array names typeToNames $otype] eq ""} {
            return "";                   # no such type is no such folder.
        }
        
        set typeFolderName $typeToNames($otype)
        foreach id $topLevelIds {
            set folderName [$tree item $id -text]
            if {$folderName eq $typeFolderName} {
                return $id
            }
        }
        #  Not found -- should not happen but we'll be a good sport and
        #  return ""
        
        return ""
    }
    ##
    # _findElement
    #   Given an element path name, finds its id relative to a top level
    #   category folder.
    #
    # @param folder  - Id of the folder being searched.
    # @param name   - fully qualified name of the item to search for.
    # @return id    - id of the item or "" if there is no match.
    #
    method _findElement {folder name} {
        
       #
       #   Break up the name into its path elements.
       #   We then have to find the folder path that contains the terminal
       #   and the find the terminal in that folder.
       #
       set path [split $name .]
       
       set topFolder $folder
       foreach folder $path {  ;         # Really includes the terminal too.
        
            set subelements [$tree children $topFolder]
            #
            #   If there are no subelements just done now
            # 
            if {[llength $subelements] == 0} { return "" }  
            set result ""
            foreach item $subelements {
                set itemName [$tree item $item -text]
                
                if {$itemName eq $folder} {
        
                    set result $item
                    break;               # found.
                }
            }
            #   IF not found then return else next level:
            
            if {$result eq "" } {
                return ""
            }
            set topFolder $result
       }
       return $result
    }
    ##
    # _insertSpectrum
    #   Insert a spectrum and its sub information at the specified parent
    #   and point in the tree.
    #
    # @param parent  - Parent id.
    # @param index   - where in the list of children to put this item.
    # @param info    - spectrum information as follows:
    #    0   Terminal name.
    #    1-7 Stuff to put in the values.
    #    8 Full spectrum definition from spectrum -list -showgate
    # @return id     - id of the item created.
    method _insertSpectrum {parent index info} {
        
        
        set id [$tree insert $parent $index -text [lindex $info 0]    \
                -image  ::browser::spectrumicon\
                -values [lrange $info 1 7] -tags spectrum]
    
        # If this is actually a spectrum we need to set its subinfo:
    
        set spectrumDef [lindex $info 8]
        if {$spectrumDef ne ""} {
            set type       [lindex $spectrumDef 2]
            set parameters [lindex $spectrumDef 3]
            set axes       [lindex $spectrumDef 4]
    
            $self setSpectrumSubInfo $id $type $parameters $axes
        }
        return $id        
    }
    ##
    # _makeSpectrumInfo
    #    Given a spectrum definition, create the spectrum information
    #    stored in the spectrumTerminals array list elements.
    #
    #   See _insertSpectrum for a description of the list elements.
    #
    # @param def - spectrum definition.
    # @return list - the spectrum information list.
    #
   
    proc _makeSpectrumInfo {def} {
        set fullName [lindex $def 1]
        set fullPath [split $fullName .]
        set terminalName [lindex $fullPath end]
        
        set valueCols [_makeSpectrumTopColumns $def]
        
        set result [list $terminalName {*}$valueCols $def]
        return $result
    }
    
    ##
    # _makeSpectrumTopColumns
    #
    #  Create the top level column -values values for a spectrum
    #
    #   The first value is a two element list containing the spectrum
    #   and data types. If a gate is applied to the spectrum, that is the
    #   second element.  If only one axis is present there will be additional
    #   fields that specify the low, high and bins for the axis.
    #   In this case, there will also be a units taken from the first parameter
    #   of the paramters that go into the spectrum.
    #
    # @param info - spectrum info.
    # @return list of values to put in the columns of data associated with
    #         the top level of a spectrum item..
    #
    proc _makeSpectrumTopColumns {info} {
        set stype [lindex $info 2]
        set dtype [lindex $info 5]
        set params [lindex $info 3]
        set param1 [lindex $params 0]
        set axes   [lindex $info  4]
        
        #  Spectrum type and data type:
        
        set result [list [list $stype $dtype]]
        
        # Gate application
        
        set application [apply -list [lindex $info 1]]
        set appliedGateDescription [lindex [lindex $application 0] 1]
        set appliedGateType [lindex $appliedGateDescription 2]
        if {$appliedGateType ne "T"} {
            lappend result $appliedGateType
        } else {
            lappend result {};                 # No gate applied if T gate
        }
        
        # If we have one axis we can give its info -- otherwise empty elements.
        
        if {[llength $axes] == 1} {
           set axis [lindex $axes 0]
           set low [lindex $axis 0]
           set hi  [lindex $axis 1]
           set bins [lindex $axis 2]
           lappend result $low $hi $bins {};    # (no value).
           
           set treeinfo [treeparameter -list $param1];  # Try for units.
           if {[llength $treeinfo] == 0} {
                lappend result {} ;                # no units
           } else {
                set units [lindex [lindex $treeinfo 0] 5]
                lappend result {}
           }
        } else {
            lappend result {} {} {} {} {}
        }
        
        return $result 
    }
    ##
    # _insertGate
    #    Inserts a gate into the tree at a specific point (parent and index)
    #
    # @param parent - id of parent
    # @param where  - Where to insert the gate.
    # @param terminal - Terminal name.
    # @param description - Full Gate Description.
    # @return id - id of the gate element inserted.
    #
    method _insertGate {parent where terminal description} {
        set type [lindex $description 2]
        set gateId [$tree insert $parent $where -text $terminal \
            -image ::browser::gateicon \
            -values $type -tags gate]
        $self setGateSubInfo $gateId $type [lindex $description 3]
        return $gateId
    }
    ##
    # _getParent
    #    Given an object type and a fully qualified name returns the
    #    id of the folder that should hold that object.  The assumption is
    #    That this folder exists.  If not, an error is thrown.
    #    The folder need not have the object yet.
    #
    # @param objType - object type : spectrum, gate, parameter variable
    # @param name    - fully qualified name.
    # @return id     - the id of the folder that is the next to last path element
    #                  of name.
    #
    method _getParent {objType name} {
        set folderId [$self _getTopFolderId $objType]
        
        
        #  Split the name, lop off the last element to get the path to the
        #  folder we're hunting:
        
        set folderPath [split $name .]
        set folderPath [lrange $folderPath 0 end-1]
        
        # Special case.  empty path is a child of the ultimate parent:
        
        if {$folderPath eq ""} {
            return $folderId
        }
        
        #  _findElement can do the rest:
        
        return [$self _findElement $folderId [join $folderPath .]]
    }
}

