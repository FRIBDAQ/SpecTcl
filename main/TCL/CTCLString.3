'\" t
.\"     Title: CTCLString
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.76.1 <http://docbook.sf.net/>
.\"      Date: 11/23/2015
.\"    Manual: [FIXME: manual]
.\"    Source: [FIXME: source]
.\"  Language: English
.\"
.TH "CTCLSTRING" "3" "11/23/2015" "[FIXME: source]" "[FIXME: manual]"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CTCLString \- Provide a wrapper for the \fBTcl_DString\fR data type and its API
.SH "SYNOPSIS"
.sp
.nf
#include <TCLString\&.h>
\&.\&.\&.
class CTCLString
{
public:
  CTCLString ();
  CTCLString (const char* pString  ) ;
  CTCLString(const std::string& rString);
  CTCLString(const Tcl_DString& rString);
  CTCLString (const CTCLString& aCTCLString );
  ~ CTCLString ();

  CTCLString& operator= (const CTCLString& aCTCLString);
  int operator== (const CTCLString& aCTCLString);
  int operator!= (const CTCLString& aCTCLString);
  int operator> (const CTCLString& aCTCLString);
  int operator< (const CTCLString& aCTCLString);
  int operator>=(const CTCLString& aCTCLString);
  int operator<=(const CTCLString& aCTCLString);

  Tcl_DString& getString();
  CTCLString& Append (const std::string& rString, Int_t nLength=\-1);
  CTCLString& Append (const CTCLString&  rString, Int_t nLength=\-1);
  CTCLString& Append (Tcl_DString&       pString, Int_t nLength=\-1);
  CTCLString& Append (const char*        pString, Int_t nLength=\-1);
  CTCLString& AppendElement (const Tcl_DString*      pRhs);
  CTCLString& AppendElement (const CTCLString&       rRhs);
  CTCLString& AppendElement (const std::string&      rRhs);
  CTCLString& AppendElement (const char*             pRhs);
  CTCLString& AppendElement(DFloat_t value, const char* pFormat = "%f");
  CTCLString& AppendElement(long value, const char* pFormat = "%i");

  CTCLString& StartSublist ()  ;
  CTCLString& EndSublist ()  ;
  UInt_t  Length () const ;
  CTCLString& Truncate (UInt_t nNewLength)  ;
  Bool_t isCommand () const  ;

  Bool_t Match (const char*       pPattern) const;
  Bool_t Match (std::string&      rPattern) const;
  Bool_t Match (const CTCLString& rPattern) const;

  operator const char* () const;
  operator std::string () const;
  operator Tcl_DString* ();
};
    
.fi
.SH "DESCRIPTION"
.PP
The Tcl API provides a dynamic string type
\fBTcl_DString\fR\&. For many purposes, the C++
\fBstd::string\fR
is sufficient, however the
\fBTcl_DString\fR
list building functions are unmatched in
\fBstd::string\fR\&.
CTCLString
is an object oriented wrapping of a
\fBTcl_DString\fR
.SH "METHODS"
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
\fBCTCLString\fR ();
\fBCTCLString\fR (const \fBchar\fR* \fIpString\fR) ;
\fBCTCLString\fR(const \fBstd::string\fR& \fIrString\fR);
\fBCTCLString\fR(const \fBTcl_DString\fR& \fIrString\fR);
\fBCTCLString\fR (const \fBCTCLString\fR& \fBaCTCLString\fR );
            
.fi
.if n \{\
.RE
.\}
.PP
Constructs a
CTCLString
object\&. With the exception of the first constructor, which produces an empty string, all of these constructors initialize the contents of the underlying
Tcl_DString
with the string representation of their parameter\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
\fBCTCLString\fR& \fBoperator=\fR (const \fBCTCLString\fR& \fIrhs\fR);
        
.fi
.if n \{\
.RE
.\}
.PP
Supports assignment to a
CTCLString
from another;
\fIrhs\fR\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
\fBint\fR \fBoperator==\fR (const \fBCTCLString\fR& \fIrhs\fR);
\fBint\fR \fBoperator!=\fR (const \fBCTCLString\fR& \fIrhs\fR);
\fBint\fR \fBoperator>\fR (const \fBCTCLString\fR& \fIrhs\fR);
\fBint\fR \fBoperator<\fR (const \fBCTCLString\fR& \fIrhs\fR);
\fBint\fR \fBoperator>=\fR(const \fBCTCLString\fR& \fIrhs\fR);
\fBint\fR \fBoperator<=\fR(const \fBCTCLString\fR& \fIrhs\fR);
        
.fi
.if n \{\
.RE
.\}
.PP
Relational operators provide for lexicographic copmarisons between the object and
\fIrhs\fR
which is another
CTCLString\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
\fBTcl_DString\fR& \fBgetString\fR();
        
.fi
.if n \{\
.RE
.\}
.PP
Returns a reference tothe underlying
\fBTcl_DString\fR
of the object\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
\fBCTCLString\fR& \fBAppend\fR (const \fBstd::string\fR& \fIString\fR,
                  \fBInt_t\fR \fInLength\fR=\-1);
\fBCTCLString\fR& \fBAppend\fR (const \fBCTCLString\fR& \fIString\fR,
                  \fBInt_t\fR \fInLength\fR=\-1);
\fBCTCLString\fR& \fBAppend\fR (\fBTcl_DString\fR&       \fIString\fR,
                  \fBInt_t\fR \fInLength\fR=\-1);
\fBCTCLString\fR& \fBAppend\fR (const \fBchar\fR*            \fIString\fR,
                  \fBInt_t\fR \fInLength\fR=\-1);
        
.fi
.if n \{\
.RE
.\}
.PP
Appends a section of
\fIString\fR
to the
CTCLString
that is being built up\&. The first
\fInLength\fR
characters are appended\&. if
\fInLength\fR
is
\-1
then all
\fIString\fR
is appended\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
\fBCTCLString\fR& \fBAppendElement\fR (const \fBTcl_DString\fR*  \fIitem\fR);
\fBCTCLString\fR& \fBAppendElement\fR (const \fBCTCLString\fR&   \fIitem\fR);
\fBCTCLString\fR& \fBAppendElement\fR (const \fBstd::string\fR&  \fIitem\fR);
\fBCTCLString\fR& \fBAppendElement\fR (const \fBchar*\fR         \fIitem\fR);
\fBCTCLString\fR& \fBAppendElement\fR(\fBDFloat_t\fR \fIitem\fR,
                         const \fBchar*\fR \fIpFormat\fR = "%f");
\fBCTCLString\fR& \fBAppendElement\fR(\fBlong\fR     \fIitem\fR,
                         const \fBchar*\fR \fIpFormat\fR = "%i");
        
.fi
.if n \{\
.RE
.\}
.PP
Appends
\fIitem\fR
as a list element to the end of the string\&. If necessary quotation is performed to ensure the item is treated as a single list element\&. The
\fIpFormat\fR
parameter controls the conversion of non string data types to a string and is of the form of any control sequence used by sprintf\&. For example
"i = %d"
could be used to convert an integer to a label and its value which would be appended to the string as e\&.g\&.
{i = 1234}
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
\fBCTCLString\fR& \fBStartSublist\fR ()  ;
\fBCTCLString\fR& \fBEndSublist\fR ()  ;
        
.fi
.if n \{\
.RE
.\}
.PP
Used in conjuntion with
\fBAppendElement\fR
these start and end sublists which are list elements that consist of lists\&. Sublists can be nested to any depth\&. For example:
.sp
.if n \{\
.RS 4
.\}
.nf
    CTCLString s;
    s\&.AppendElement("a");
    s\&.StartSublist();
    s\&.AppendElement("b");
    s\&.AppendElement("c");
    s\&.StartSublist();
    s\&.AppendElement("d");
    s\&.AppendElement("e");
    s\&.EndSublist();
    s\&.AppendElement("f");
    s\&.EndSublist();
    s\&.AppendElement("g");
            
.fi
.if n \{\
.RE
.\}
.sp
Would make the
\fIs\fR
contain the string
"a {b c {d e} f} g"
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
\fBUInt_t\fR  \fBLength\fR() const ;
        
.fi
.if n \{\
.RE
.\}
.PP
Returns the number of characters in the string\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
CTCLString& Truncate (UInt_t nNewLength)  ;
        
.fi
.if n \{\
.RE
.\}
.PP
Truncates the string to the first
\fInNewLength\fR
characters\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
\fBBool_t\fR \fBisCommand\fR () const  ;
        
.fi
.if n \{\
.RE
.\}
.PP
Analyzes the string and returns
kfTRUE
if the string is a \*(Aqwell formed command\*(Aq\&. Note that a well formed command may still have syntax and execution errors\&. This just ensures that a string has a balanced set of quoting characters\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
\fBBool_t\fR \fBMatch\fR (const \fBchar\fR*           \fIPattern\fR) const;
\fBBool_t\fR \fBMatch\fR (\fBstd::string\fR&      \fIPattern\fR) const;
\fBBool_t\fR \fBMatch\fR (const \fBCTCLString\fR& \fIPattern\fR) const;
        
.fi
.if n \{\
.RE
.\}
.PP
Returns
kfTRUE
if the contents of the string matches the
\fIPattern\fR
parameter\&. The
\fIPattern\fR
parameter can contain all of the wildcards in
glob
style pattern matching\&. See REFERENCES below for moer information about glob style matching\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
operator const char* () const;
operator std::string () const;
operator Tcl_DString* ();
    
.fi
.if n \{\
.RE
.\}
.PP
These operators are implicit and explicit type conversion operators that allow a
CTCLString
object to be treated as a
\fBchar*\fR
pointing to a null terminated string, a
\fBstd::string\fR
object, or a
\fBTcl_DString\fR
pointer\&.
.SH "SEE ALSO"
.PP
Tcl_DStringAppend(3tcl), Tcl_DStringAppendElement(3tcl), Tcl_DStringEndSublist(3tcl), Tcl_DStringFree(3tcl), Tcl_DStringGetResult(3tcl), Tcl_DStringInit(3tcl), Tcl_DStringLength(3tcl), Tcl_DStringResult(3tcl), Tcl_DStringSetLength(3tcl), Tcl_DStringStartSublist(3tcl)
.SH "REFERENCES"
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
J\&.K\&. Ousterhout \fITcl and the Tk Toolkit\fR
Addison\-Wesley Professional Computing Series 1994 see section 9\&.2
            
.fi
.if n \{\
.RE
.\}
.sp

