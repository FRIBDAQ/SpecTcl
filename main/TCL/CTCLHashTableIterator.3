'\" t
.\"     Title: CTCLHashTableIterator
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.76.1 <http://docbook.sf.net/>
.\"      Date: 11/23/2015
.\"    Manual: [FIXME: manual]
.\"    Source: [FIXME: source]
.\"  Language: English
.\"
.TH "CTCLHASHTABLEITERATO" "3" "11/23/2015" "[FIXME: source]" "[FIXME: manual]"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CTCLHashTableIterator \- Iterator for visiting all elements of a CTCLHashTable
.SH "SYNOPSIS"
.sp
.nf

#include >TCLHashTableIterator\&.h>
\&.\&.\&.
template <class T>
class CTCLHashTableIterator
{

public:
  CTCLHashTableIterator (Tcl_HashTable*   pTable);
  CTCLHashTableIterator (const CTCLHashTableIterator& aCTCLHashTableIterator );
  virtual ~ CTCLHashTableIterator ( );

  CTCLHashTableIterator operator=
                     (const CTCLHashTableIterator& aCTCLHashTableIterator);
  int operator== (const CTCLHashTableIterator& aCTCLHashTableIterator);
  CTCLHashTableItem<T>* getCurrentEntry() const;
  Tcl_HashTable* getHashTable() const;

  CTCLHashTableIterator& operator++ ();
  CTCLHashTableIterator operator++ (int i);
  CTCLHashTableItem<T>& operator* ();
  CTCLHashTableItem<T>* operator\->();

};



    
.fi
.SH "DESCRIPTION"
.PP

CTCLHashTableIterator
objects are created and returned by
CTCLHashTableIterator::\fBbegin\fR
and
CTCLHashTableIterator::\fBend\fR\&. These objects are pointer like objects to
CTCLHashTableItem
objects within the hash table\&.
.PP
If you imagine that all containers can have an ordering defined on them, iterators are like pointers to elements of this ordering\&. Dereference operators yield an element of the container, and increment operators make the iterator \*(Aqpoint\*(Aq to the next element in the container according to the ordering\&.
.PP
For more information on both hash tables and iterators see the REFERENCES\&. For information about the classes that are related to this, consult manpages pointed to by the SEE ALSO section\&.
.SH "METHODS"
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBCTCLHashTableIterator\fR (\fBTcl_HashTable\fR* \fIpTable\fR);
  \fBCTCLHashTableIterator\fR(const \fBCTCLHashTableIterator\fR& \fIrhs\fR);
        
.fi
.if n \{\
.RE
.\}
.PP
Construct a hash table iterator\&. Normally you will not need to use these constructors directly\&. They will be created, instead by
CTCLHashTable::\fBbegin()\fR
or
CTCLHashTable::\fBend()\fR\&.
\fIpTable\fR
is a pointer to an existing
\fBTcl_HashTable\fR
created via
\fBTcl_InitHashTable\fR\&.
\fIrhs\fR
is an existing
CTCLHashTableIterator
object whose state will be used to initialize the object under construction\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBCTCLHashTableIterator\fR \fBoperator=\fR
                     (const \fBCTCLHashTableIterator\fR& \fIrhs\fR);
  \fBint\fR \fBoperator==\fR(const \fBCTCLHashTableIterator\fR& \fIrhs\fR);
        
.fi
.if n \{\
.RE
.\}
.PP

\fBoperator=\fR
allows you to assign the state of one
CTCLHashTableIterator
to another\&. When the assignment is complete, the left hand side object will be \*(Aqpointing\*(Aq to the same object as the right hand side object but be separately incrementable\&.
.PP

\fBoperator==\fR
allows you to compare two iterators for equality\&. equality is defined as the two iterators being defined on the same underlying hash table, pointing to the same element, and having the same increment context (e\&.g\&. an increment of both iterators will leave them both pointing to the same hash table item (different from the one prior to the increment)\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
\fBCTCLHashTableItem<T>\fR* \fBgetCurrentEntry\fR() const;
\fBTcl_HashTable\fR* \fBgetHashTable\fR() const;
        
.fi
.if n \{\
.RE
.\}
.PP
These two functions get at the information the iterator is encapsulating\&.
\fBgetCurrentEntry\fR
returns a pointer to the entry that the iterator si currently \*(Aqpointing\*(Aq at\&. This is identical to the
\fBoperator\->\fR
function\&.
\fBgetHashTable\fR
returns a pointer to the underlying
\fBTcl_HashTable\fR
created by
\fBTcl_InitHashTable\fR\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
CTCLHashTableIterator& operator++ ();
CTCLHashTableIterator operator++ (int i);
            
.fi
.if n \{\
.RE
.\}
.PP
These two function support both pre and post increment operations on an iterator\&. There are slight differences in semantics between these operators best illustrated with a sample code fragment\&. In the fragment below, i is an
CTCLHashTableIterator
.sp
.if n \{\
.RS 4
.\}
.nf
CTCLHashTableItem item1 = *i++;   // item 1 is the item pointed to prior to increment
CTCLHashTableItem item2 = *++i;   // item 2 is the item pointed to after increment\&.
            
.fi
.if n \{\
.RE
.\}
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
\fBCTCLHashTableItem<T>\fR& \fBoperator*\fR ();
\fBCTCLHashTableItem<T>\fR* \fBoperator\->\fR();
        
.fi
.if n \{\
.RE
.\}
.PP
These operators allow
CTCLHashTableIterator
objects to be treated like pointers to
CTCLHashTableItem
objects\&.
\fBoperator*\fR
provides \*(Aqpointer\*(Aq dereferencing that allows code like:
.sp
.if n \{\
.RS 4
.\}
.nf
                (*i)\&.getItem();
            
.fi
.if n \{\
.RE
.\}
.PP

\fBoperator\->\fR
provides a pointer to struct like semantics allowing code like:
.sp
.if n \{\
.RS 4
.\}
.nf
                i\->getItem();
            
.fi
.if n \{\
.RE
.\}
.sp
.SH "SEE ALSO"
.PP
CTCLHashTable(3), CTCLHashTableItem(3), Tcl_InitHashTable(3tcl), Tcl_FirstHashEntry(3tcl), Tcl_NextHashEntry(3tcl)
.SH "REFERENCES"
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
Niklaus Wirth \fIAlgorithms + Data Structures = Programs\fR
Prentice Hall Series in Automatic Computation 1976 See section 4\&.6

Musser, Derge, Saini: \fISTL Tutorial and Reference Guide\fR
Addison\-Wesley Professional Computing Series; 2001 ISBN 0\-201\-37923\-6
        
.fi
.if n \{\
.RE
.\}
.sp

