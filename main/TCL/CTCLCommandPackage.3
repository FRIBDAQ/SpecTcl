'\" t
.\"     Title: CTCLCommandPackage
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.76.1 <http://docbook.sf.net/>
.\"      Date: 11/23/2015
.\"    Manual: [FIXME: manual]
.\"    Source: [FIXME: source]
.\"  Language: English
.\"
.TH "CTCLCOMMANDPACKAGE" "3" "11/23/2015" "[FIXME: source]" "[FIXME: manual]"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CTCLCommandPackage \- Group several related Tcl command extensions and common services they may require together\&.
.SH "SYNOPSIS"
.sp
.nf
#include <TCLCommandPackage\&.h>
\&.\&.\&.
typedef std::list <CTCLProcessor*>   CommandList;
typedef CommandList::iterator  CommandListIterator;

class CTCLCommandPackage  : public CTCLInterpreterObject
{

public:
  CTCLCommandPackage (CTCLInterpreter* pInterp,
                      const std::string& rSignon=std::string("Unnamed pkg"));
  CTCLCommandPackage(CTCLInterpreter* pInterp,
                     const char* pSignon = "Unnamed pkg");
  virtual ~ CTCLCommandPackage ( );
  CTCLCommandPackage (const CTCLCommandPackage& aCTCLCommandPackage );
  CTCLCommandPackage& operator= (const CTCLCommandPackage& aCTCLCommandPackage);
  int operator== (const CTCLCommandPackage& aCTCLCommandPackage);

  std::string getSignon() const;
  CommandList getCommandList() const;
protected:
  void setSignon (std::string am_sSignon);

public:
  void Register ()  ;
  void Unregister ()  ;
  void AddProcessor (CTCLProcessor* pProcessor);
  void AddProcessors(CommandList& rList);
  CommandListIterator begin ();
  CommandListIterator end ();
};
    
.fi
.SH "DESCRIPTION"
.PP
Extensions to Tcl often come in a set of related commands\&. These commands may require access to a common set of services\&. The
CTCLCommandPackage
along with the
CTCLPackagedCommand
provide a pair of base classes that facilitate the construction of such commands\&.
.PP
The pattern to follow to derive class from
CTCLCommandPackage
This class defines and implements common services for the related commands\&. The constructor of the derived class will also create instances of classes derived from
CTCLPackagedCommand\&. These objects define and implement the related commands\&. These command processors will be added to the package via
\fBAddProcessor\fR, and
\fBAddProcessors\fR\&.
.PP
When the
CTCLCommandPackage::\fBRegister\fR
function is called, all of the commands added to the package will be registered as well\&. When a command processor is invoked, it can call its
\fBgetMyPackage\fR
member function to obtain a pointer to the owning package and therefore access to the services this package provides\&.
.SH "METHODS"
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBCTCLCommandPackage\fR(\fBCTCLInterpreter\fR* \fIpInterp\fR,
                      \fBconst std::string\fR& \fIrSignon\fR=\fBstd::string\fR("Unnamed pkg"));
  \fBCTCLCommandPackage\fR(\fBCTCLInterpreter\fR* \fIpInterp\fR,
                     \fBconst char\fR* \fIpSignon\fR = "Unnamed pkg");
  \fBCTCLCommandPackage\fR (\fBconst CTCLCommandPackage\fR& \fIaCTCLCommandPackage\fR );
        
.fi
.if n \{\
.RE
.\}
.PP
Constructs instances of the package\&.
\fIpInterp\fR
is a pointer to the interpreter object on which these commands will be registered\&.
\fIsignon\fR
is a text string that will be emitted to
stderr
when the package is asked to register its commands\&. This string is typically a credit or copyright notice for the package\&. It can be empty if the user desires\&.
.PP
The first and second form of the constructor only differ in how the signon message is passed\&. The final form of the constructor is a copy constructor\&. While copy construction is legal it is anticipated that this will not normally be used as command packages are usually
singleton
objects\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBstd::string\fR \fBgetSignon\fR() const;
        
.fi
.if n \{\
.RE
.\}
.PP
Retrieves the signon string from the current object\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBCommandList\fR \fBgetCommandList\fR() const;
            
.fi
.if n \{\
.RE
.\}
.PP
Retrieves the list of commands that are managed by this package\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBvoid\fR \fBsetSignon\fR (\fBstd::string\fR \fIam_sSignon\fR);
        
.fi
.if n \{\
.RE
.\}
.PP
Allows derived classes to set the signon string after construction is complete\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBvoid\fR \fBRegister\fR ()  ;
  \fBvoid\fR \fBUnregister\fR ()  ;
        
.fi
.if n \{\
.RE
.\}
.PP

\fBRegsiter\fR
registers all of the commands in the package with the package\*(Aqs interpreter\&.
\fBUnregister\fR
unregisters these commands\&. It is therefore not advisable to change the set of commands in the package between registration and unregistration\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBvoid\fR \fBAddProcessor\fR(\fBCTCLProcessor\fR* \fIpProcessor\fR);
  \fBvoid\fR \fBAddProcessors\fR(\fBCommandList\fR& \fIrList\fR);
        
.fi
.if n \{\
.RE
.\}
.PP
These functions add command processors to the package\&. Any type of processor can be added to the package, however usually
CTCLPackagedCommand
derived objects are in order to provide a mechanism to access the package services\&.
\fIpProcessor\fR
is a pointer to a single processor while
\fIrList\fR
is a reference to a list of such processors\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBCommandListIterator\fR \fBbegin\fR ();
  \fBCommandListIterator\fR \fBend\fR ();
        
.fi
.if n \{\
.RE
.\}
.PP
Returns STL list iterators to the beginning and off the end of the set of command packages\&. List iterators behave roughly like pointers\&. In this case, pointers to
CTCLProcessor*\&. Incrementing an interator \*(Aqpoints\*(Aq it to the next item in the list\&. A full discussion of STL iterators is well beyond the scope of this man page\&. See references below\&.
.SH "SEE ALSO"
.PP
CTCLProcessor(3), CTCLPackagedCommand(3)
.SH "REFERENCES"
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
Musser, Derge, Saini: \fISTL Tutorial and Reference Guide\fR
Addison\-Wesley Professional Computing Series; 2001 ISBN 0\-201\-37923\-6
        
.fi
.if n \{\
.RE
.\}
.sp

