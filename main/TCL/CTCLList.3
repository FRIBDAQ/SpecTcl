'\" t
.\"     Title: CTCLList
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.76.1 <http://docbook.sf.net/>
.\"      Date: 11/23/2015
.\"    Manual: [FIXME: manual]
.\"    Source: [FIXME: source]
.\"  Language: English
.\"
.TH "CTCLLIST" "3" "11/23/2015" "[FIXME: source]" "[FIXME: manual]"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CTCLList \- Provide access to Tcl List parsing\&.
.SH "SYNOPSIS"
.sp
.nf
#include <TCLList\&.h>
\&.\&.\&.
class CTCLList  : public CTCLInterpreterObject
{

public:
  CTCLList (CTCLInterpreter* pInterp);
  CTCLList (CTCLInterpreter* pInterp, const  char* am_pList  );
  CTCLList (CTCLInterpreter* pInterp, const std::string& rList);
  CTCLList (const CTCLList& aCTCLList );

  CTCLList& operator= (const CTCLList& aCTCLList);
  int operator== (const CTCLList& aCTCLList);
  int operator!= (const CTCLList& aCTCLList);

  const char* getList() const;

  int Split (StringArray& rElements)  ;
  int Split (int& argc, char*** argv);

  const char* Merge (const StringArray& rElements)  ;
  const char* Merge(int argc, char** argv);

};


        
.fi
.SH "DESCRIPTION"
.PP
Tcl Lists are white space separated words\&. It is definition of words and quoting issues that makes the parsing of lists less than straightforward\&.
.PP
Fortunately, Tcl provides several list processing functions\&. The concept of a list and access to list processing functions are encapsulated in the
CTCLList
class\&.
.SH "METHODS"
.PP

.sp
.if n \{\
.RS 4
.\}
.nf

\fBCTCLList\fR (\fBCTCLInterpreter\fR* \fIpInterp\fR);
\fBCTCLList\fR (\fBCTCLInterpreter\fR* \fIpInterp\fR,
          const  \fBchar\fR* \fIpList\fR  );
\fBCTCLList\fR (\fBCTCLInterpreter\fR* \fIpInterp\fR,
          const \fBstd::string\fR& \fIrList\fR);
\fBCTCLList\fR (const \fBCTCLList\fR& \fIrhs\fR);
        
.fi
.if n \{\
.RE
.\}
.PP
These four functions provide various ways to create a
CTCLList
object\&. The first constructor creates an empty list\&. The next two, create a list that has an initial value given by either the
NULL
terminated string
\fIpList\fR, or the
\fBstd::string\fR
object
\fIrList\fR\&. The final constructor creates a list that is a duplicate of the list described by the object
\fIrhs\fR\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf

  \fBCTCLList\fR& \fBoperator=\fR (const \fBCTCLList\fR& \fIrhs\fR);
  \fBint\fR \fBoperator==\fR (const \fBCTCLList\fR& \fIrhs\fR);
  \fBint\fR \fBoperator!=\fR (const \fBCTCLList\fR& \fIrhs\fR);
            
.fi
.if n \{\
.RE
.\}
.PP
These function provide assignment (\fBoperator=\fR), equality comparison (\fBoperator==\fR), and inequality comparison (\fBoperator!=\fR) with another
CTCLList
object,
\fIrhs\fR\&. Assignment is defined as copying the string format of the list\&. Equality comparison is defined as the both interpreter and strings being equal\&. Inequality is defined as !operator==\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  const \fBchar\fR* \fBgetList()\fR const;
            
.fi
.if n \{\
.RE
.\}
.PP

\fBgetList\fR
returns an immutable pointer to the string rerpesentation of the list\&. Note that the const qualfier on the pointer means that attempts to dereference the pointer which would modify the list result in error messages\&. For Example:
.sp
.if n \{\
.RS 4
.\}
.nf
        CTCLList aList(pInterp, "some list");
        const char* pData = aList\&.getList();
        *pData = \*(AqS\*(Aq;         // Compiler error!!!!
            
.fi
.if n \{\
.RE
.\}
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
\fBint\fR \fBSplit\fR (\fBStringArray\fR& \fIrElements\fR)  ;
\fBint\fR \fBSplit\fR (\fBint\fR& \fIargc\fR,
           \fBchar\fR*** \fIargv\fR);
            
.fi
.if n \{\
.RE
.\}
.PP
Splits a list up into its component words\&.
\fIrelements\fR
is a
\fBstd::vector<std::string>\fR
into which the elements will be split\&.
\fIargc\fR
is a reference to an integer into which the number of elements will be put\&.
\fIargv\fR
is a pointer to a
\fBchar\fR** into which will be placed a pointer to dynamically allocated storage containing a list of
\fIargc\fR
pointers to the words in the string\&. This storage must be released by the caller with
\fBTcl_Free\fR\&. For example:
.sp
.if n \{\
.RS 4
.\}
.nf
                CTCLList someList(pInterp, someInitialContents);
                \&.\&.\&.
                int argc;
                char** argv;
                someList\&.Split(argc, &argv);
                //
                //  \&.\&.\&. do something with the data
                //
                \&.\&.\&.
                //
                // Done with the list elements\&.
                //
                Tcl_Free((char*)argv);
            
.fi
.if n \{\
.RE
.\}
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
const \fBchar\fR* \fBMerge\fR (const \fBStringArray\fR& \fIrElements\fR)  ;
const \fBchar\fR* \fBMerge\fR(\fBint\fR argc,
                 \fBchar\fR** \fIargv\fR);
        
.fi
.if n \{\
.RE
.\}
.PP
Merges a bunch of words in to a list\&. If necessary, quoting is performed to ensure that words that have whitespace or other special characters will be correctly formatted into the list\&.
\fIrElements\fR
is a
\fBstd::vector<std::string>\fR
of words that will be merged into the string\&.
\fIargc\fR
is a count of the number of words, and
\fIargv\fR
is a pointer to an array of pointers to the words stored as
NULL
terminated strings\&. The return value is the final string representation of the list after the merge operation has been performed\&.
.SH "SEE ALSO"
.PP
CTCLInterpreter(3), CTCLInterpreterObject(3), Tcl_Free(3tcl)
