'\" t
.\"     Title: CTCLFileHandler
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.76.1 <http://docbook.sf.net/>
.\"      Date: 11/23/2015
.\"    Manual: [FIXME: manual]
.\"    Source: [FIXME: source]
.\"  Language: English
.\"
.TH "CTCLFILEHANDLER" "3" "11/23/2015" "[FIXME: source]" "[FIXME: manual]"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CTCLFileHandler \- Base class for building object oriented Tcl File event handlers\&.
.SH "SYNOPSIS"
.sp
.nf
#include <TCLFileHandler\&.h>
\&.\&.\&.

class CTCLFileHandler  : public CTCLInterpreterObject
{
  CTCLFileHandler(CTCLInterpreter* pInterp,
                   UInt_t am_nFid = STDIN_FILENO);
  CTCLFileHandler(CTCLInterpreter* pInterp,
                  FILE* pFile);
  CTCLFileHandler (const CTCLFileHandler& aCTCLFileHandler );
  ~CTCLFileHandler ( );
  CTCLFileHandler& operator= (const CTCLFileHandler& aCTCLFileHandler);
  int operator== (const CTCLFileHandler& aCTCLFileHandler) const;

  UInt_t getFid() const;

  virtual   void operator() (int mask)   = 0;

  void Set (int mask)  ;
  void Clear ()  ;
};

    
.fi
.SH "DESCRIPTION"
.PP
Tcl supplies an event loop\&. It is possible to add events specifications to this loop\&. One very useful event type is based on readability or writability of a file descriptor\&. The
CTCLFileHandler
allows you to create an object oriented file handler, and register it with the event loop so that you can gain control when, for example, a file becomes readable\&.
.PP
As
CTCLFileHandler
is an abstract base class, it is necessary to create a derived class\&. The derived class should implement the
\fBoperator()\fR
which will be called when the specific event is fired\&. An instance of this derived class should be created, and then the
\fBSet\fR
and
\fBClear\fR
members used to establish and remove the event handler\&.
.SH "METHODS"
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBCTCLFileHandler\fR(\fBCTCLInterpreter\fR* \fIpInterp\fR,
                   \fBUInt_t\fR \fInFid\fR = STDIN_FILENO);
  \fBCTCLFileHandler\fR(\fBCTCLInterpreter\fR* \fIpInterp\fR,
                  \fBFILE\fR* \fIpFile\fR);
  \fBCTCLFileHandler\fR (const \fBCTCLFileHandler\fR& \fIaCTCLFileHandler\fR );
        
.fi
.if n \{\
.RE
.\}
.PP
Constructs a file handler object\&.
\fIpInterp\fR
is a pointer to the interpreter on which the file handler will be registered\&. The file can be specified either by
\fInFid\fR, a file descriptor, or
\fIpFile\fR
an stdio File stream pointer\&.
.PP
A copy constructor allows the creation of a copy of the file handler object given
\fIaCTCLFileHandler\fR
an existing one\&. This is normally not useful\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBCTCLFileHandler\fR& \fBoperator=\fR (const \fBCTCLFileHandler\fR& \fIaCTCLFileHandler\fR);
  \fBint\fR \fBoperator==\fR (const \fBCTCLFileHandler\fR& \fIaCTCLFileHandler\fR) const;
            
.fi
.if n \{\
.RE
.\}
.PP
These functions support assignment and equality comparison\&. Note that these functions are usually not very useful for file handlers\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBUInt_t\fR \fBgetFid()\fR const;
        
.fi
.if n \{\
.RE
.\}
.PP
Returns the file id that is associated with the event\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  virtual   \fBvoid\fR \fBoperator\fR() (\fBint\fR \fImask\fR)   = 0;
            
.fi
.if n \{\
.RE
.\}
.PP
The user\*(Aqs derived class must override this to provide the desired funtionality when event fires\&.
\fImask\fR
indicates which event fired the function and can be an or of the following:
TCL_READABLE
if the file can be read without blocking,
TCL_WRITABLE
if the file can be written without blocking, or
TCL_EXCEPTION
if some exceptional condition occured on the file\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBvoid\fR \fBSet\fR (\fBint\fR \fImask\fR)  ;
  \fBvoid\fR \fBClear\fR ()  ;
        
.fi
.if n \{\
.RE
.\}
.PP

\fBSet\fR
establishes the event handler for the set of conditions described in
\fImask\fR\&. The valid bits for
\fImask\fR, are described in the documentation for the
\fImask\fR
parameter to
\fBoperator()\fR\&.
.SH "SEE ALSO"
.PP
CTCLObject(3), CTCLInterpreter(3) Tcl_CreateFileHandler(3tcl), Tcl_DeleteFileHandler(3tcl)
