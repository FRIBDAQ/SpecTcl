'\" t
.\"     Title: CTCLChannel
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.76.1 <http://docbook.sf.net/>
.\"      Date: 11/23/2015
.\"    Manual: [FIXME: manual]
.\"    Source: [FIXME: source]
.\"  Language: English
.\"
.TH "CTCLCHANNEL" "3" "11/23/2015" "[FIXME: source]" "[FIXME: manual]"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CTCLChannel \- Provide a C++ abstraction wrapper for Tcl Channels\&.
.SH "SYNOPSIS"
.sp
.nf
#include <TCLChannel\&.h>
\&.\&.\&.
class CTCLChannel : public CTCLInterpreterObject
{
public:

  CTCLChannel(CTCLInterpreter* pInterp,
              std::string      Filename,
              const char*      pMode,
              int              permissions);
  CTCLChannel(CTCLInterpreter* pInterp,
              int              argc,
              const char**           pargv,
              int              flags);
  CTCLChannel(CTCLInterpreter* pInterp,
              int              port,
              std::string      host)
  CTCLChannel(CTCLInterpreter* pInterp,
              int              port,
              Tcl_TcpAcceptProc* proc,
              ClientData       AppData);
  CTCLChannel(CTCLInterpreter* pInterp,
              Tcl_Channel      Channel);
  CTCLChannel(const CTCLChannel& rhs);
  virtual ~CTCLChannel();

  Tcl_Channel getChannel() const;
  bool ClosesOnDestroy() const;

  int Read( void** pData, int nChars);
  int Write(const void* pData, int nBytes);

  bool atEof();
  void Flush();
  void Close();
  void Register();
  void SetEncoding(std::string Name);
  std::string GetEncoding();

    
.fi
.SH "DESCRIPTION"
.PP
The Tcl API supplies an I/O abstraction layer on top of the operating systems I/O subsystem\&. This layer makes use of what Tcl documentation refers to a s
channels\&. A channel represents a connection to an I/O endpoint (source or sink of data or both)\&. The
CTCLChannel
class allows you to wrap a C++ class around a Tcl channel\&.
.PP
Using a
CTCLChannel, rather than direct operating system I/O allows you to improve the portability of your program, as well as allowing I/O from the TCL scripting level to be cleanly mixed with I/O at the C/C++ level\&.
.SH "METHODS"
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBCTCLChannel\fR(\fBCTCLInterpreter\fR* \fIpInterp\fR,
              \fBstd::string\fR      \fIFilename\fR,
              \fBconst char\fR*      \fIpMode\fR,
              \fBint\fR              \fIpermissions\fR);
  \fBCTCLChannel\fR(\fBCTCLInterpreter\fR* \fIpInterp\fR,
              \fBint\fR              \fIargc\fR,
              \fBconst char\fR**           \fIpargv\fR,
              \fBint\fR              \fIflags\fR);
  \fBCTCLChannel\fR(\fBCTCLInterpreter\fR  * \fIpInterp\fR,
              \fBint\fR              \fIport\fR,
              \fBstd::string\fR      \fIhost\fR);
  \fBCTCLChannel\fR(\fBCTCLInterpreter\fR* \fIpInterp\fR,
              \fBint\fR              \fIport\fR,
              \fBTcl_TcpAcceptProc\fR* \fIproc\fR,
              \fBClientData\fR      \fIAppData\fR);
  \fBCTCLChannel\fR(\fBCTCLInterpreter\fR* \fIpInterp\fR,
              \fBTcl_Channel\fR      \fIChannel\fR);
  \fBCTCLChannel\fR(\fBconst CTCLChannel\fR& \fIrhs\fR);
        
.fi
.if n \{\
.RE
.\}
.PP
These constructors wrap a
CTCLChannel
object around a Tcl channel\&. The variety of constructors reflects the variety of endpoints around which a
\fBTcl_Channel\fR
can be wrapped\&.
.PP
The first of the constructors attaches the object to a file via
\fBTcl_OpenFileChannel\fR\&.
\fIpInterp\fR
is the channel the file is associated\&.
\fIFilename\fR
is the name of the file the channel is connected to\&.
\fIpMode\fR
is the connection mode which can be any of of the mode values for the Tcl
\fBopen\fR
scripting command\&.
\fIpermissions\fR
represents the permissions mask fo rthe file in POSIX format\&. See open(2) for information about the possible mode bit values\&.
.PP
The second form of the constructor connects a channel that is a pipe to a program\&. The program and its command line arguments are specified via the
\fIargc\fR
and
\fIpargv\fR
parameters\&. The
\fIflags\fR
parameter specifies how the stdio channels of the program are or are not disposed into the channel\&. Valid bits are:
TCL_STDIN,
TCL_STDOUT,
TCL_STDERR,
TCL_ENFORCE_MODE\&. See the
\fBTcl_OpenCommandChannel\fR
manpage for information about the meaning of these bits\&.
.PP
The third form of the constructor constructs a channel that connects to a TCP/IP server, via
\fBTcl_OpenTcpClient\fR\&. The
\fIport\fR
parameter specifies the port number on which the server is listening, while
\fIhost\fR
is the name of the host to which the connection should be formed\&. The host name can either be a DNS resolvable host name or the textual encoding of the TCP/IP address of the host (e\&.g\&. string("spdaq22\&.nscl\&.msu\&.edu") or string("35\&.9\&.56\&.56")\&. This function will block until the connection is accepted by the server\&.
.PP
The fourth form of the constructor creates a channel that is a Tcp/IP server\&.
\fIport\fR
is the port number on which the server listens for connections\&.
\fIproc\fR
is a function that will be called when a connection has been accepted by the Tcl event loop\&.
\fIAppData\fR
is application data that is passed, without interpretation to
\fIproc\fR\&. See the
\fBTcl_OpenTcpServer\fR
manpage for more information about how the
\fIproc\fR
is called\&.
.PP
The fifth form of the constructor creates a
CTCLChannel
object by wrapping an existing
\fBTcl_Channel\fR;
\fIChannel\fR
which has been obtained directly from the Tcl application programming interface\&.
.PP
The final form of the constructor copies an existing
CTCLChannel
object so that the two objects refer to the same channel\&. The object is created so that it will not close the channel on destruction\&. Note however that the source channel may, depending on how it was constructed\&. It is up to the application programmer to ensure that channels are closed at appropriate times\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBTcl_Channel\fR \fBgetChannel\fR() const;
        
.fi
.if n \{\
.RE
.\}
.PP
Returns the underlying
\fBTcl_Channel\fR
this object is wrapped around\&. Once this is obtained, it can be usd in any Tcl API call that requires a channel\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBbool\fR \fBClosesOnDestroy\fR() const;
        
.fi
.if n \{\
.RE
.\}
.PP
When a
CTCLChannel
is copy constructed into being it is flagged such that destruction will not close the underlying channel\&. the return value from this function is
true
if the object will close the underlying channel on destruction and
false
if the object will not close the underlying channel on destruction\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBint\fR \fBRead\fR( \fBvoid\fR** \fIpData\fR,
           \fBint\fR \fInChars\fR);
  \fBint\fR \fBWrite\fR(\fBconst void\fR* \fIpData\fR,
           \fBint\fR \fInBytes\fR);
        
.fi
.if n \{\
.RE
.\}
.PP

\fBRead\fR
transfers data from the channel to the users\*(Aqs buffer;
\fIpData\fR\&.
\fInChars\fR
is the number of characters of data that will be transferred\&.
\fBWrite\fR
transfers
\fInBytes\fR
bytes
data to the chnnel from
\fIpData\fR\&. Both function return the number of characters actually transferred\&. An important note about the
\fInChars\fR
parameter: If the channel is not opened as a binary channel, this parameter is the number of UTF\-8 characters transferred\&. Depending on the characters actually transmitted, this may not be the same as the number of bytes transmitted\&. The return value is the number of units (bytes or characters) actually transferred\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf

  \fBbool\fR \fBatEof\fR();
        
.fi
.if n \{\
.RE
.\}
.PP
Returns
true
if the underlying channel is at the end of file\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBvoid\fR \fBFlush\fR();
        
.fi
.if n \{\
.RE
.\}
.PP
Tcl channels are internally buffered\&. The
\fBFlush\fR
member flushes internal output buffers to the underlying I/O endpoint\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBvoid\fR \fBClose\fR();
        
.fi
.if n \{\
.RE
.\}
.PP
Closes the underlying channel\&. Note that this is normally done on destruction unless the channel object was created via copy construction\&. If the channel was registered to be visible to the interpreter, it is unregistered as well\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBvoid\fR \fBRegister\fR();
        
.fi
.if n \{\
.RE
.\}
.PP
Makes the channel visible to the interpreter\&. This allows the user to return the channel name to the script level at which point it can be used in Tcl script commands that operate on channels\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBvoid\fR \fBSetEncoding\fR(\fBstd::string\fR \fIName\fR);
  \fBstd::string\fR \fBGetEncoding\fR();
        
.fi
.if n \{\
.RE
.\}
.PP
These functions allow the user to get and set the encoding for the channel\&. See the
\fBfconfigure\fR
Tcl man page for more information about this\&.
.SH "SEE ALSO"
.PP
close(3tcl), fconfigure(3tcl), open(2), Tcl_OpenCommandChannel(3tcl), Tcl_OpenFileChannel(3tcl), Tcl_OpenTcpClient(3tcl), Tcl_OpenTcpServer(3tcl)
