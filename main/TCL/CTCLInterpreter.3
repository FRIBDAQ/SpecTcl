'\" t
.\"     Title: CTCLInterpreter
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.76.1 <http://docbook.sf.net/>
.\"      Date: 11/23/2015
.\"    Manual: [FIXME: manual]
.\"    Source: [FIXME: source]
.\"  Language: English
.\"
.TH "CTCLINTERPRETER" "3" "11/23/2015" "[FIXME: source]" "[FIXME: manual]"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CTCLInterpreter \- Encapsulate a Tcl interpreter\&.
.SH "SYNOPSIS"
.sp
.nf
#include <string>
#include <vector>
#include <TCLInterpreter\&.h>

class CTCLInterpreter
{
public:
  CTCLInterpreter ();
  CTCLInterpreter (Tcl_Interp* am_pInterpreter  );

  Tcl_Interp* getInterpreter()
  std::string Eval (const char* pScript) ;
  std::string Eval(const CTCLString& rScript);
  std::string Eval(const std::string& rScript);

  std::string EvalFile (const char* pFilename)   ;
  std::string EvalFile(const CTCLString& rFilename);
  std::string EvalFile(const std::string& rFilename);

  std::string GlobalEval (const char* pScript)   ;
  std::string GlobalEval (const CTCLString& rScript) ;
  std::string GlobalEval(const std::string& rScript) ;

  std::string RecordAndEval (const char* pScript, Bool_t fEval=kfFALSE);
  std::string RecordAndEval(const CTCLString& rScript,
                            Bool_t fEval=kfFALSE);
  std::string RecordAndEval(const std::string& rScript,
                            Bool_t fEval = kfFALSE);

  std::string ExprString (const char* pExpression)   ;
  std::string ExprString(const CTCLString& rExpr);
  std::string ExprString(const std::string& rExpr);

  Long_t ExprLong (const char* pExpression)   ;
  Long_t ExprLong (std::string& rExpression);
  Long_t ExprLong (const CTCLString& rExpr);

  DFloat_t ExprDouble (const char* pExpression)   ;
  DFloat_t ExprDouble (const CTCLString& rExpression);
  DFloat_t ExprDouble(const std::string& rExpression);

  Bool_t ExprBoolean (const char*  pExpression)   ;
  Bool_t ExprBoolean (const CTCLString& rExpression);
  Bool_t ExprBoolean(const std::string& rExpression);

  std::string TildeSubst (const char* pFilename) const  ;
  std::string TildeSubst (const CTCLString& rName) const;
  std::string TildeSubst (const std::string& rName) const;

  Tcl_Interp* operator\-> ();
  operator Tcl_Interp* ();
};



    
.fi
.SH "DESCRIPTION"
.PP

CTCLInterpreter
encapsulates a
\fBTcl_Interp*\fR
in an object\&. Method invocations on that object provide access to many of the Tcl interpreter\&. See METHODS below for more information about htis\&.
.SH "METHODS"
.PP

\fBCTCLInterpreter () \fR
.PP

\fBCTCLInterpreter\fR
(
\fBTcl_Interp\fR*
\fIpInterp\fR)
.PP
Constructs an interpreter object\&. The first form of this constructor creates a new
\fBTcl_Interp*\fR
using
\fBTcl_CreateInterp()\fR
and wraps the object around it\&. All members of the object will operate on that newly created interpreter\&. The second form, wraps an object around
\fIpInterp\fR, a previously created
\fBTcl_Interp*\fR\&. Note that in either case on destruction,
\fBTcl_DeleteInterp()\fR
is called on the wrapped interpreter\&.
.PP

\fBTcl_Interp\fR*
\fBgetInterpreter\fR()
.PP
Returns the interpreter that is being wrapped by this object\&. This interpreter can be used as an
\fIinterp\fR
parameter for any
\fBTcl_xxxxxx\fR
call in the Tcl API\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
\fBstd::string\fR \fBEval\fR(\fBconst char\fR* \fIpScript\fR) ;
\fBstd::string\fR \fBEval\fR(\fBconst CTCLString\fR& \fIrScript\fR);
\fBstd::string\fR \fBEval\fR(\fBconst std::string\fR& \fIrScript\fR);
            
.fi
.if n \{\
.RE
.\}
.PP
Evaluates the script passed as a parameter\&. The only differences between these functions is the form of the script parameter\&. Each function will return the result of the script\&. If there is an error in the script, a
CTCLException
will be thrown that will describe what happened\&. For example:
.sp
.if n \{\
.RS 4
.\}
.nf
    std::string commands;
    CTCLInterpreter interp;     // New intepreter\&.
    \&.\&.\&.
    // after commands has been built up:

    string result
    try {
        result = interp\&.Eval(commands);
        cout << "Eval of " << commands << " was "
             <<  result << endl;
    }
    catch (CTCLException &e) {
        cerr << "Eval of " << commands << " failed: "
             << e\&.ReasonText() << endl;
    }
    // If no exception, result is usable as the output of the eval\&.

            
.fi
.if n \{\
.RE
.\}
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBstd::string\fR \fBEvalFile\fR(\fBconst char\fR* \fIpFilename\fR)   ;
  \fBstd::string\fR \fBEvalFile\fR(\fBconst CTCLString\fR& \fIrFilename\fR);
  \fBstd::string\fR \fBEvalFile\fR(\fBconst std::string\fR& \fIrFilename\fR);
        
.fi
.if n \{\
.RE
.\}
.PP
Sources the specified file in and executes it as a script in the interpreter that is wrapped by the object\&. The only difference between these functions is how the name of the file is passed\&. The return value is the script result\&. A
CTCLException
will be thrown in the event the script reports an error\&. See the example in
CTCLInterpreter::\fBEval\fR
to see how to catch and report this kind of exception\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBstd::string\fR \fBGlobalEval\fR(\fBconst char\fR* \fIpScript\fR);
  \fBstd::string\fR \fBGlobalEval\fR(\fBconst CTCLString\fR& \fIrScript\fR);
  \fBstd::string\fR \fBGlobalEval\fR(\fBconst std::string\fR& \fIrScript\fR);
            
.fi
.if n \{\
.RE
.\}
.PP
This function evaluates a script at the global level\&. Note that
CTCLInterpreter::\fBEval\fR, and
CTCLInterpreter>::\fBEvalFile\fR
evaluates the script at whatever call level the interpreter is currently executing at\&. The only difference between the methods above is how the script is passed\&. The functions all return the interpreter result after the script executes\&. If the script reports an error, a
CTCLException
will be thrown\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBstd::string\fR \fBRecordAndEval\fR (\fBconst char\fR* \fIpScript\fR,
                       \fBBool_t\fR \fIfEval\fR=kfFALSE);
  \fBstd::string\fR \fBRecordAndEval\fR(\fBconst CTCLString\fR& \fIrScript\fR,
                       \fBBool_t\fR \fIfEval\fR=kfFALSE);
  \fBstd::string\fR \fBRecordAndEval\fR(\fBconst std::string\fR& \fIrScript\fR,
                      \fBBool_t\fR \fIfEval\fR=kfFALSE);
            
.fi
.if n \{\
.RE
.\}
.PP
Records a script in the Tcl interpreter history and, if
\fIfEval\fR
is
kfTRUE, evaluates it as well\&. The return value is the interpreter result, which is only meaningful if the script was evalutated\&. If the script reports an error, a
CTCLException
is thrown\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBstd::string\fR \fBExprString\fR(\fBconst char\fR* \fIpExpression\fR);
  \fBstd::string\fR \fBExprString\fR(\fBconst CTCLString\fR& \fIrExpr\fR);
  \fBstd::string\fR \fBExprString\fR(\fBconst std::string\fR& \fIrExpr\fR);
            
.fi
.if n \{\
.RE
.\}
.PP
Evaluates an expression (as if with the
\fBexpr\fR
Tcl command), and returns the result of the evaluation as a string\&. If the expression has an error, a
CTCLException
will be thrown\&. The only difference between these functions is how the expression is passed\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBLong_t\fR \fBExprLong\fR(\fBconst char\fR* \fIpExpression\fR)   ;
  \fBLong_t\fR \fBExprLong\fR(\fBstd::string\fR& \fIrExpression\fR);
  \fBLong_t\fR \fBExprLong\fR(\fBconst CTCLString\fR& \fIrExpr\fR);
            
.fi
.if n \{\
.RE
.\}
.PP
Evaluates an expression (as if with the
\fBexpr\fR
Tcl command)\&. If the result can be converted into an integer, it is returned as a
\fBLong_t\fR\&. If the expression either cannot be converted to an integer (e\&.g\&. it\*(Aqs a non\-numerical expression), or if the expression contains an error, a
CTCLException
will be thrown\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBDFloat_t\fR \fBExprDouble\fR(\fBconst char\fR* \fIpExpression\fR)   ;
  \fBDFloat_t\fR \fBExprDouble\fR(\fBconst CTCLString\fR& \fIrExpression\fR);
  \fBDFloat_t\fR \fBExprDouble\fR(\fBconst std::string\fR& \fIrExpression\fR);
            
.fi
.if n \{\
.RE
.\}
.PP
Evaluates the parameter as an expression (as if with the
\fBexpr\fR
Tcl command)\&. If the result can be converted to a floating point value it is returned as the function value\&. If not, or if there is an error in the expression, a
CTCLException
is thrown\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBBool_t\fR \fBExprBoolean\fR(\fBconst char\fR*  \fIpExpression\fR)   ;
  \fBBool_t\fR \fBExprBoolean\fR(\fBconst CTCLString\fR& \fIrExpression\fR);
  \fBBool_t\fR \fBExprBoolean\fR(\fBconst std::string\fR& \fIrExpression\fR);
            
.fi
.if n \{\
.RE
.\}
.PP
Evaluates the parameter as an expression (as if with the
\fBexpr\fR
Tcl command)\&. If the result can be interpreted as a boolean, it is returned as the function value\&. If not, or if there is an error in the expression, a
CTCLException
is thrown\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBstd::string\fR \fBTildeSubst\fR(\fBconst char\fR* \fIpFilename\fR) const  ;
  \fBstd::string\fR \fBTildeSubst\fR(\fBconst CTCLString\fR& \fIrName\fR) const;
  \fBstd::string\fR \fBTildeSubst\fR(\fBconst std::string\fR& \fIrName\fR) const;
            
.fi
.if n \{\
.RE
.\}
.PP
Performs tilde substitution on its parameter\&. Tilde substitution means that leading  characters are expanded to the current user\*(Aqs home directory path, while a leading  followed by a word that is a username will be expanded to the home directory path of that user\&. The expanded value is returned\&. Note thatthe use of this member is deprecated as the underlying Tcl library function is also deprecated\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBTcl_Interp\fR* \fBoperator\->\fR();
  \fBoperator Tcl_Interp* \fR();
        
.fi
.if n \{\
.RE
.\}
.PP
These two functions allow objects that are
CTCLInterpreter
objects to be treated as if they were
\fBTcl_Interp*\fR\*(Aqs\&.
\fBoperator\->\fR
supports dereferncing to fields of the wrapped interpreter (note that this is now deprecated within Tcl itself)\&.
\fBoperator Tcl_Interp*\fR
supports dynamic type conversion from a
CTCLInterpreteter
object and a
\fBTcl_Interp*\fR
pointer\&.
.SH "DEFECTS"
.PP
It is not possible to avoid destroying the interpreter when the object is destroyed\&.
.SH "SEE ALSO"
.PP
CTCLException, CTCLApplication, CTCLChannel, CTCLCommandPackage, CTCLFileHandler, CTCLList, CTCLObject, CTCLObjectProcessor, CTCLTimer, CTCLVariable
