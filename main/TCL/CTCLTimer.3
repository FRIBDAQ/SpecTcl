'\" t
.\"     Title: CTCLTimer
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.76.1 <http://docbook.sf.net/>
.\"      Date: 11/23/2015
.\"    Manual: [FIXME: manual]
.\"    Source: [FIXME: source]
.\"  Language: English
.\"
.TH "CTCLTIMER" "3" "11/23/2015" "[FIXME: source]" "[FIXME: manual]"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CTCLTimer \- Abstract base class for C++ objects attached to timer events\&.
.SH "SYNOPSIS"
.sp
.nf
#include <TCLTimer\&.h>
\&.\&.\&.
class CTCLTimer  : public CTCLInterpreterObject
{
public:
  CTCLTimer ();
  CTCLTimer(CTCLInterpreter* pInterp, UInt_t nMsec = 0);
  virtual ~CTCLTimer ( );


  Tk_TimerToken getToken() const;
  UInt_t getMsec() const;
  Bool_t IsSet() const;

  virtual   void operator() ()   = 0;

  void Set ()  ;
  void Set(UInt_t nms);
  void Clear ()  ;
};


    
.fi
.SH "DESCRIPTION"
.PP
Tcl/Tk provide a mechanism for scheduling functions to be executed after a time delay specified in milliseconds\&. The
CTCLTimer
class is an abstract base class that provides an interface into the API for that facility\&. To use
CTCLTimer
you must create a class derived from
CTCLTimer
that overrides and implement the
\fBoperator()\fR
function\&. Create an object from the resulting function class\&. Use the object\*(Aqs
\fBSet\fR
and
\fBClear\fR
members to schedule or cancel a scheduled execution\&. The code fragment example below shows how to do this to create a class that periodically emits the text "Tick" to stderr\&. Many #include directives are missing for brevity\&.
.sp
.if n \{\
.RS 4
.\}
.nf
// Interface to Ticker normally goes in a header\&.
class Ticker : public CTCLTimer
{
public:
    Ticker(CTCLInterpreter* pInterp, int seconds);
    virtual ~Ticker();

    virtual void operator()();
};
\&.\&.\&.
// Implementation of Ticker normally goes in a \&.cpp

// Constructor of Ticker:

Ticker::Ticker(int seconds) :
    CTCLTimer(pInterp, seconds*1000)
{
    Set();                   // Schedule first one\&.
}
// Destructor\&.\&. chain to base class\&.
Ticker::~Ticker() {}

// called when timer goes off:
void
Ticker::operator()() {
    cerr << "Tick\en";
    Set();                 // Schedule next one\&.
}
\&.\&.\&.


Ticker Tick(pInterp, 1);  // Tick every second\&.

            
.fi
.if n \{\
.RE
.\}
.sp
.SH "METHODS"
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
\fBCTCLTimer\fR ();
\fBCTCLTimer\fR(\fBCTCLInterpreter\fR* \fIpInterp\fR,
          \fBUInt_t\fR \fInMsec\fR = 0);
          
.fi
.if n \{\
.RE
.\}
.PP
Construct timer objects\&. The first form of the constructor creates a timer object that must be later bound into an interpreter via a call to
CTCLInterpreterObject::\fBBind\fR\&. The seconf form of the contructor creates a timer object that is already bound to
\fIpInterp\fR
and has an initial schedule delay of
\fInMsec\fR\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  Tk_TimerToken getToken() const;
  UInt_t getMsec() const;
          
.fi
.if n \{\
.RE
.\}
.PP
These two members access internal state of the object\&.
\fBgetToken\fR
returns the
\fBTk_TimerToken\fR
associated with the timer object\&. This is the Tcl/Tk token that identifies the timer request to the interpreter\&.
\fBgetMsec\fR
retrieves the current value of the delay parameter in milliseconds\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  virtual   void operator() ()   = 0;
        
.fi
.if n \{\
.RE
.\}
.PP
This function must be overidden and implemented in concrete timer classes\&. See the example in DESCRIPTION above\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf

  void Set ()  ;
  void Set(UInt_t nms);
  Bool_t IsSet() const;
        
.fi
.if n \{\
.RE
.\}
.PP

\fBSet\fR
schedules the object for execution\&. If
\fInms\fR
is provided it is saved as the scheduling parameter and determines the delay in milliseconds before
\fBoperator()\fR
is next called\&. If not provided, the most recently used delay will be used again\&.
.PP

\fBIsSet\fR
returns
kfTRUE
if the timer is currently pending, or
kfFALSE
if no pending timer request is active\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  void Clear ()  ;
        
.fi
.if n \{\
.RE
.\}
.PP
If a Timer request is pending, cancels it\&. If no timer request is pending, this function does nothing, and does not report an error\&.
.SH "SEE ALSO"
.PP
CTCLInterpreterObject(3)
.SH "REFERENCES"
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
Musser, Derge, Saini: \fISTL Tutorial and Reference Guide\fR
Addison\-Wesley Professional Computing Series; 2001 ISBN 0\-201\-37923\-6
See section 2\&.4 for a description and discussion of function objects\&.
            
.fi
.if n \{\
.RE
.\}
.sp

