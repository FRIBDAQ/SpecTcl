'\" t
.\"     Title: CTCLVariable
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.76.1 <http://docbook.sf.net/>
.\"      Date: 11/23/2015
.\"    Manual: [FIXME: manual]
.\"    Source: [FIXME: source]
.\"  Language: English
.\"
.TH "CTCLVARIABLE" "3" "11/23/2015" "[FIXME: source]" "[FIXME: manual]"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CTCLVariable \- Encapsulate Tcl interpreter variables\&.
.SH "SYNOPSIS"
.sp
.nf
#include <TCLVariable\&.h>

class CTCLVariable  : public CTCLInterpreterObject
{
public:
  CTCLVariable (std::string am_sVariable,  Bool_t am_fTracing  );
  CTCLVariable (CTCLInterpreter* pInterp,
                std::string am_sVariable,  Bool_t am_fTracing  );
  CTCLVariable (const CTCLVariable& aCTCLVariable );

  CTCLVariable& operator= (const CTCLVariable& aCTCLVariable);
  int operator== (const CTCLVariable& aCTCLVariable) const;

  std::string getVariableName() const;
  Bool_t IsTracing() const;

  void setVariableName (const std::string am_sVariable);
  virtual   char*  operator() (char* pName,
                               char* pSubscript,
                               int Flags)  ;

   static  char* TraceRelay (ClientData pObject, Tcl_Interp* pInterpreter,
                             tclConstCharPtr  pName,
                             tclConstCharPtr pIndex,
                             int flags)  ;

  const char* Set (const char* pValue, int flags=TCL_LEAVE_ERR_MSG |
                                                 TCL_GLOBAL_ONLY)  ;
  const char* Set (const char* pSubscript, char* pValue,
                   int flags=TCL_LEAVE_ERR_MSG | TCL_GLOBAL_ONLY)  ;
  const char* Get (int flags=TCL_LEAVE_ERR_MSG | TCL_GLOBAL_ONLY,
                   char* pIndex=0)  ;
  int Link (void* pVariable, int Type)  ;
  void Unlink ()  ;
  int Trace (int flags=TCL_TRACE_READS | TCL_TRACE_WRITES | TCL_TRACE_UNSETS,
             char* pIndex = (char*)kpNULL)  ;

  void UnTrace ()  ;

};
.fi
.SH "DESCRIPTION"
.PP

CTCLVariable
allows an existing or new Tcl interpreter variable to be encapsulated so that it can be accessed, traced or linked in C++ code\&.
.SH "METHODS"
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBCTCLVariable\fR(\fBstd::string\fR \fIsName\fR,
             \fBBool_t\fR \fIfTracing\fR  );
  \fBCTCLVariable\fR (\fBCTCLInterpreter\fR* \fIpInterp\fR,
             \fBstd::string\fR \fIsName\fR,
             \fBBool_t\fR \fIfTracing\fR  );
  \fBCTCLVariable\fR (\fBconst CTCLVariable\fR& \fIaCTCLVariable\fR );
            
.fi
.if n \{\
.RE
.\}
.PP
In the first two cases,
\fIsName\fR
is the name of the variable that will be wrapped by this object\&. The variable name can contain namespace qualifications as well as indices\&. If
\fIfTracing\fR
is true, the object is set to record that it is tracing the variable\&. Normally this parameter should be allowed to default to
kfFALSE, and the trace member functions used to set explicit traces\&. For the final form of the constructor (copy constructor),
\fIaCTCLVariable\fR
is a
CTCLVariable
that will be copied into this object\&.
.PP
In the first form of the constructor, one must later call the
\fBBind\fR
function (see CTCLInterpreterObject), to bind the variable to a specific interpreter prior to accessing it\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBCTCLVariable\fR& \fBoperator=\fR(\fBconst CTCLVariable\fR& \fIrhs\fR);
            
.fi
.if n \{\
.RE
.\}
.PP
Assigns the
\fIrhs\fR
object to this one\&. A reference to the left hand side of the assignment is returned\&. The semantics of assignment are not that the variable values are assigned, but that the left side of the assignment becomes a functional equivalent of
\fIrhs\fR, that is it stands for the same object and has the same traces (if any) set\&. Thus, if
\fIrhs\fR
wraps the interpreter variable
\fIa\fR
and the object on the left side wraps interpreter variable
\fIb\fR
after the assignment executes, the left side object will be wrapping
\fIa\fR\&. A reference to the object on the left hand side of the assignment is returned\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBint\fR \fBoperator==\fR(\fBconst CTCLVariable\fR& \fIrhs\fR) const;
            
.fi
.if n \{\
.RE
.\}
.PP
Compares this object for functional equality with
\fIrhs\fR\&. Functional equality is defined as the two objects referring to the same variable, in the same interpreter, and having traces set on the same operations\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBstd::string\fR \fBgetVariableName\fR() const;
            
.fi
.if n \{\
.RE
.\}
.PP
Returns the name of the Tcl variable that is wrapped by this object\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
\fBint\fR \fBTrace\fR(\fBint\fR \fIflags\fR=TCL_TRACE_READS | TCL_TRACE_WRITES | TCL_TRACE_UNSETS,
          \fBchar\fR* \fIpIndex\fR = (\fBchar\fR*)kpNULL)  ;
\fBvoid\fR \fBUnTrace\fR ()  ;
\fBBool_t\fR \fBIsTracing\fR() const;
virtual \fBchar\fR*  \fBoperator()\fR (\fBchar\fR* \fIpName\fR,
                        \fBchar\fR* \fIpSubscript\fR,
                        \fBint\fR \fIFlags\fR)  ;
            
.fi
.if n \{\
.RE
.\}
.PP
This set of functions supports variable tracing\&. In Tcl, a trace is a function that is called when some event of interest occurs on a varialbe\&. The possible events are read, write, and unset\&. To effectively use variable tracing, you must create a subclass of
CTCLVariable, override its
\fBoperator()\fR
member to handle the trace and call
\fBTrace\fR
to initiate tracing\&.
.PP
The
\fBTrace\fR
member initiates tracing on the variable\&.
\fIflags\fR
describes when the trace should fire\&. See the manpage for
\fBTcl_TraceVar\fR
for information about the legal flag values\&.
.PP

\fBUntrace\fR
cancels all traces on the variable represented by this object\&.
.PP

\fBIsTracing\fR
returns
kfTRUE
if tracing is being performed on the variable\&.
.PP
When a trace fires, the
\fBoperator()\fR
member will be called\&. This is why you must override the
CTCLVariable
base class to do anything useful with a trace\&. The parameters to the call are;
\fIpName\fR
is the name of the variable that has been traced\&.
\fIpSubscript\fR
is the array subscript in the event the trace fires on an array or element of an array, and is
NULL
otherwise\&.
\fIFlag\fR
describes why the trace fired\&. Again, see the
\fBTcl_TraceVar\fR
manpage for more information\&. Note that for write traces, the variable has already been set\&. Modifying the value of the traced variable within a trace function will not fire any additional traces\&. The
\fBoperator()\fR
function must return a
NULL
pointer if the trace is successful\&. It must return a pointer to an error message if the trace is not successful\&. An example of an unsuccessful trace might be a write trace that ensures that only particular values are assigned to the variable\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
const \fBchar\fR* \fBSet\fR(const \fBchar\fR* \fIpValue\fR,
                \fBint\fR \fIflags\fR=TCL_LEAVE_ERR_MSG |
                          TCL_GLOBAL_ONLY)  ;
const \fBchar\fR* \fBSet\fR(const \fBchar\fR* \fIpSubscript\fR,
               \fBchar\fR* \fIpValue\fR,
               \fBint\fR \fIflags\fR=TCL_LEAVE_ERR_MSG | TCL_GLOBAL_ONLY)  ;
            
.fi
.if n \{\
.RE
.\}
.PP
Sets the value of the variable to the string pointed to by
\fIpValue\fR
The second form of this assumes that the
CTCLVariable
represents an array and the
\fIpSubscript\fR
parameter specifies the subscript of the array that is being set\&. The
\fIflags\fR
parameter is fully documented in the Tcl manpage for Tcl_SetVar
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
const \fBchar\fR* \fBGet\fR(\fBint\fR \fIflags\fR=TCL_LEAVE_ERR_MSG | TCL_GLOBAL_ONLY,
              \fBchar\fR* \fIpIndex\fR=0)  ;
            
.fi
.if n \{\
.RE
.\}
.PP
Retrieves the current value of a variable\&. If the
\fIpIndex\fR
parameter is supplied, the variable wrapped by
CTCLVariable
is assumed to be an array and
\fIpIndex\fR
points to the subscript of the element to retrieve\&. The
\fIflags\fR
parameter is fully documented in the Tcl_GetVar manpage\&. The return value of the function is a null terminated character string that is the current value of the variable\&. If the variable does not exist, then a
NULL
is returned\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
\fBint\fR \fBLink\fR(\fBvoid\fR* \fIpVariable\fR,
         \fBint\fR \fIType\fR)  ;
\fBvoid\fR \fBUnlink\fR()  ;
            
.fi
.if n \{\
.RE
.\}
.PP

\fBLink\fR
and
\fBUnlink\fR
support variable linking\&. Variable linking is when a Tcl variable is made to track the value of a C/C++ variable or C++ member variable of an object\&.
\fBLink\fR
establishes the link\&.
\fIpVariable\fR
points to the C or C++ variable or member variable to link to this
CTCLVariable\&. The
\fIType\fR
parameter is one of following values:
TCL_LINK_INT,
TCL_LINK_DOUBLE,
TCL_LINK_BOOLEAN,
TCL_LINK_WIDE_INT, or
TCL_LINK_STRING
indicating the type of the variable to which
\fIpVariable\fR
points\&. For all but
TCL_LINK_STRING,
\fIpVariable\fR
points to a variable of the type indicated, and that variable will be linked\&. for
TCL_LINK_STRING,
\fIpVariable\fR
points to a
\fBchar*\fR
which should be initialized to point to
NULL\&. The Tcl interpreter will use
\fBTcl_Alloc\fR
and
\fBTcl_Free\fR
to maintain a dynamically allocated string pointed to by that pointer which reflects the value of the variable\&. If the C/C++ program modifies this string, it must
\fBTcl_Free\fR
the prior value and
\fBTcl_Alloc\fR
a new value with the new variable value\&.
.SH "DEFECTS"
.PP
No
\fBoperator!=\fR
has been defined\&.
.PP
There is no protection against multiple links\&.\&.\&. the most recent link for an underlying Tcl variable is the one effective\&.
.SH "SEE ALSO"
.PP
CTCLInterpreter(3), CTCLInterpreterObject(3), Tcl_GetVar(3tcl), Tcl_LinkVar(3tcl), Tcl_SetVar(3tcl), Tcl_TraceVar(3tcl)
