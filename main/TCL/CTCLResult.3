'\" t
.\"     Title: CTCLResult
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.76.1 <http://docbook.sf.net/>
.\"      Date: 11/23/2015
.\"    Manual: [FIXME: manual]
.\"    Source: [FIXME: source]
.\"  Language: English
.\"
.TH "CTCLRESULT" "3" "11/23/2015" "[FIXME: source]" "[FIXME: manual]"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CTCLResult \- Provide an object oriented interace to the Tcl interpreter result\&.
.SH "SYNOPSIS"
.sp
.nf
#include <TCLResult\&.h>
\&.\&.\&.
class CTCLResult  : public CTCLObject
{
  CTCLResult (CTCLInterpreter* pInterp, bool reset=true );
  CTCLResult (const CTCLResult& aCTCLResult );
  virtual ~CTCLResult ( );

  CTCLResult& operator= (const CTCLResult& aCTCLResult);
  CTCLResult& operator= (const char* rhs);
  CTCLResult& operator=(std::string    rhs);

  int operator== (const CTCLResult& aCTCLResult) ;
  int operator!= (const CTCLResult& rhs);

  CTCLResult& operator+= (const char* pString);
  CTCLResult& operator+= (const std::string& rString);

  void Clear ()  ;
  void AppendElement (const char* pString)  ;
  void AppendElement (const std::string& rString);
  void commit() const;
  std::string getString();
};

    
.fi
.SH "DESCRIPTION"
.PP
Each Tcl command can return
result string
the result string can be used by subsequent commands in the event the command operated successfully, or by
\fBcatch\fR
commands if the command failed\&.
CTCLResult
provides an extension of the
CTCLObject
class that builds up a string which can then be comitted to the result\&.
.SH "METHODS"
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
\fBCTCLResult\fR(\fBCTCLInterpreter\fR* \fIpInterp\fR,
           \fBbool\fR \fIreset\fR=true );
\fBCTCLResult\fR(const \fBCTCLResult\fR& \fIaCTCLResult\fR);
          
.fi
.if n \{\
.RE
.\}
.PP
Constructs a Tcl interpreter result string\&.
\fIpInterp\fR
is the interpeter that will be associated with this result\&.
\fIreset\fR
controls whether or not the result string is reset when constructed, or if it is loaded with the current value of the result string\&. In the case of copy construction, the interpreter associated with
\fIaCTCLResult\fR
is used\&.
\fIaCTCLResult\fR
is committed to the interpreter result, and the object under construction is then loaded from that interpreter\*(Aqs result\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBCTCLResult\fR& \fBoperator=\fR (const \fBCTCLResult\fR& \fIrhs\fR);
  \fBCTCLResult\fR& \fBoperator=\fR (const \fBchar\fR* \fIrhs\fR);
  \fBCTCLResult\fR& \fBoperator=\fR(\fBstd::string\fR    \fIrhs\fR);
        
.fi
.if n \{\
.RE
.\}
.PP
Assigns a value to the result from
\fIrhs\fR\&. If the
\fIrhs\fR
is a
CTCLResult, then the
\fIrhs\fR
is first committed to its interpreter result, the left hand object is then bound to the same interpreter as
\fIrhs\fR
and loaded with the result string of that interpreter\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBint\fR \fBoperator==\fR (const \fBCTCLResult\fR& \fIrhs\fR) ;
  \fBint\fR \fBoperator!=\fR (const \fBCTCLResult\fR& \fIrhs\fR);
        
.fi
.if n \{\
.RE
.\}
.PP
These functions suport comparison\&. Equality comparison is true (\fBoperator==\fR) if the interpreters match as the assumption is that the user is working to maintain coherency if several
CTCLResult
objects are simultaneously live on a single interpreter\&. Inequality (\fBoperator!=\fR) is defined as true when
\fBoperator==\fR
is false\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
\fBCTCLResult\fR& \fBoperator+=\fR (const \fBchar\fR* \fIrhs\fR);
\fBCTCLResult\fR& \fBoperator+=\fR(const \fBstd::string\fR& \fIrhs\fR);
        
.fi
.if n \{\
.RE
.\}
.PP

\fIrhs\fR
is textually appended to the result string being built up\&. Note that the semantics of this are different than for the base class where
\fBoperator+=\fR
is a list append\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBvoid\fR \fBClear\fR()  ;
          
.fi
.if n \{\
.RE
.\}
.PP
Clears the result string being built up as well as clearing the underlying interpreter\*(Aqs result\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBvoid\fR \fBAppendElement\fR(const \fBchar\fR* \fIitem\fR)  ;
  \fBvoid\fR \fBAppendElement\fR(const \fBstd::string\fR& \fIitem\fR);
          
.fi
.if n \{\
.RE
.\}
.PP
Appends
\fIitem\fR
to the result string being built up as a list element\&. This means that under some circumstances extra quoting may be done to ensure that the result will be maintained as a valid list\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
  \fBvoid\fR \fBcommit\fR() const;
  \fBstd::string\fR \fBgetString\fR();
        
.fi
.if n \{\
.RE
.\}
.PP

\fBcommit\fR
sets the interpreter result string equal to the string being built up in the object\&.
\fBgetString\fR
does a commit and then returns the string\&.
.SH "SEE ALSO"
.PP
CTCLObject(3)
