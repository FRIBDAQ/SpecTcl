#!/usr/bin/env python
import io
import pickle
import sys, os
sys.path.append(os.getcwd())

import json
import httplib2
import pandas as pd

import numpy as np
import matplotlib
matplotlib.use("Qt5Agg")
import matplotlib.pyplot as plt
import matplotlib.cm as cm

from PyQt5 import QtCore
from PyQt5.QtWidgets import *
import CPyConverter as cpy

from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar
import matplotlib.gridspec as gridspec
from copy import copy
from mpl_toolkits.axes_grid1 import make_axes_locatable

class Menu(QWidget):
    def __init__(self, *args, **kwargs):
        super(Menu, self).__init__(*args, **kwargs)

        layout = QHBoxLayout()
        layout.addWidget(self.create_menuBox())
        self.setLayout(layout)

    def create_menuBox(self):
        menuBox = QGroupBox("Menu")

        self.exitButton = QPushButton("Exit", self)
        self.updateButton = QPushButton("Get Data", self)        
        self.configButton = QPushButton("Configure", self)
        self.saveButton = QPushButton("Save Geometry", self)
        self.loadButton = QPushButton("Load Geometry", self)      
        
        self.slider_label = QLabel("Refresh Interval (0 s)")                        
        self.slider = QSlider(QtCore.Qt.Horizontal, self)
        self.slider.setMinimum(0)
        self.slider.setMaximum(30)

        layout = QHBoxLayout()        
        layout.addWidget(self.exitButton)
        layout.addWidget(self.updateButton)        
        layout.addWidget(self.slider_label)        
        layout.addWidget(self.slider)
        layout.addWidget(self.configButton)
        layout.addWidget(self.saveButton)
        layout.addWidget(self.loadButton)   
        layout.addStretch(1)
        
        menuBox.setLayout(layout)
        menuBox.setMaximumHeight(100)

        return menuBox
        
class Plot(QWidget):
    def __init__(self, *args, **kwargs):
        super(Plot, self).__init__(*args, **kwargs)

        self.figure = plt.figure()
        self.canvas = FigureCanvas(self.figure)
        self.toolbar = NavigationToolbar(self.canvas, self)
        self.plusButton = QPushButton("+", self)
        self.minusButton = QPushButton("-", self)
        self.toolbar.addWidget(self.plusButton)
        self.toolbar.addWidget(self.minusButton)
        
        layout = QVBoxLayout()
        layout.addWidget(self.toolbar)
        layout.addWidget(self.canvas)
        self.setLayout(layout)
        
class Configuration(QWidget):
    def __init__(self, *args, **kwargs):
        super(Configuration, self).__init__(*args, **kwargs)

        self.width = 240
        self.oldrow = 0
        self.oldcol = 0        

        layout = QHBoxLayout()
        layout.addWidget(self.create_typeBox())
        layout.addWidget(self.create_defBox())
        layout.addWidget(self.create_lstBox())                
        self.setLayout(layout)
        
    def create_typeBox(self):
        spectrumTypeBox = QGroupBox("Spectrum Type")

        self.button1D = QRadioButton("1D")
        self.button2D = QRadioButton("2D")
        self.button2D_option = QComboBox()
        self.button2D_option.addItem("Dark")
        self.button2D_option.addItem("Light")
        
        typelayout = QVBoxLayout()        
        typelayout.addWidget(self.button1D)
        hl = QHBoxLayout()
        hl.addWidget(self.button2D)
        hl.addWidget(self.button2D_option)        
        typelayout.addLayout(hl)
        typelayout.addStretch(1)
        
        spectrumTypeBox.setLayout(typelayout)
        spectrumTypeBox.setMaximumHeight(self.width)

        return spectrumTypeBox

    def create_defBox(self):
        spectrumCreateBox = QGroupBox("Spectrum Definition")        
        
        self.spectrum_name_label = QLabel("Spectrum Name")                
        self.spectrum_name = QLineEdit(self)
        self.buttonSpectrumCreate = QPushButton("Create/Replace", self)
        self.buttonSpectrumClear = QPushButton("Clear", self)
        self.buttonSpectrumDelete = QPushButton("Delete", self)                

        self.listParams_label = []
        self.listParams_label_low = []
        self.listParams_label_high = []
        self.listParams_label_bins = []                                
        self.listParams = []
        self.listParams_low = []
        self.listParams_high = []
        self.listParams_bins = []
        for i in range(2):        
            self.listParams_label.append(QLabel("Parameter"))
            self.listParams_label_low.append(QLabel("Low"))
            self.listParams_label_high.append(QLabel("High"))            
            self.listParams_label_bins.append(QLabel("Bins"))
            self.listParams.append(QComboBox())            
            self.listParams_low.append(QLineEdit(self))
            self.listParams_high.append(QLineEdit(self))
            self.listParams_bins.append(QLineEdit(self))            

        deflayout = QGridLayout()
        deflayout.addWidget(self.spectrum_name_label, 0, 0)
        deflayout.addWidget(self.spectrum_name, 1, 0)
        deflayout.addWidget(self.buttonSpectrumCreate, 1, 1)
        deflayout.addWidget(self.buttonSpectrumClear, 1, 2)                        
        deflayout.addWidget(self.buttonSpectrumDelete, 1, 3)                
        for i in range(2):        
            deflayout.addWidget(self.listParams_label[i], i*2+2, 0)
            deflayout.addWidget(self.listParams_label_low[i] , i*2+2, 1)
            deflayout.addWidget(self.listParams_label_high[i] , i*2+2, 2)
            deflayout.addWidget(self.listParams_label_bins[i], i*2+2, 3)
            deflayout.addWidget(self.listParams[i], i*2+3, 0)
            deflayout.addWidget(self.listParams_low[i], i*2+3, 1)
            deflayout.addWidget(self.listParams_high[i], i*2+3, 2)
            deflayout.addWidget(self.listParams_bins[i], i*2+3, 3)
        deflayout.setSpacing(1)
        
        spectrumCreateBox.setLayout(deflayout)
        spectrumCreateBox.setMaximumHeight(self.width)

        return spectrumCreateBox

    def create_lstBox(self):
        spectrumListBox = QGroupBox("Spectrum List")
        
        self.histo_list_label = QLabel("List of Spectra")
        self.histo_list = QComboBox()
        self.histo_geo_label = QLabel("Geometry")        
        self.histo_geo_row = QComboBox()
        self.histo_geo_col = QComboBox()        
        self.histo_geo_add = QPushButton("Add", self)
        self.histo_geo_update = QPushButton("Update", self)
        self.histo_geo_delete = QPushButton("Erase", self)                
        self.gates_name_label = QLabel("Gate name")                
        self.gates_name = QLineEdit(self)
        self.gates_list_label = QLabel("List of Gates")
        self.gates_list = QComboBox()
        self.gates_create = QPushButton("Create", self)
        self.gates_apply = QPushButton("Apply", self)
        self.gates_delete = QPushButton("Delete", self)                
        self.fit_label = QLabel("Fitting Functions")
        self.fit_list = QComboBox()
        self.fit_list.addItem("Gaussian")
        self.fit_list.addItem("Expo")        
        self.fit_list.addItem("Pol1")
        self.fit_list.addItem("Pol2")
        self.fit_list.addItem("Pol3")                                
        self.fit_list.addItem("Custom")                                        
        self.fit_button = QPushButton("Fit", self)
        self.fit_range_label = QLabel("Fitting Range")
        self.fit_range_label_min = QLabel("Min")
        self.fit_range_label_max = QLabel("Max")        
        self.fit_range_min = QLineEdit(self)
        self.fit_range_max = QLineEdit(self)                
        self.fit_results_label = QLabel("Output")
        self.fit_results = QTextEdit()
        self.fit_results.setReadOnly(True)        
        
        hl = QHBoxLayout()
        hl.addWidget(self.histo_geo_add)
        hl.addWidget(self.histo_geo_update)
        hl.addWidget(self.histo_geo_delete)        

        hl2 = QHBoxLayout()
        hl2.addWidget(self.gates_name)
        hl2.addWidget(self.gates_create)

        hl3 = QHBoxLayout()
        hl3.addWidget(self.gates_list)
        hl3.addWidget(self.gates_apply)
        hl3.addWidget(self.gates_delete)                                

        hl4 = QHBoxLayout()
        hl4.addWidget(self.histo_geo_row)
        for i in range(1,6):
            self.histo_geo_row.addItem(str(i))
            self.histo_geo_col.addItem(str(i))            
        hl4.addWidget(self.histo_geo_col)
        self.row = int(self.histo_geo_row.currentText())
        self.col = int(self.histo_geo_col.currentText())        
        self.oldrow = self.row
        self.oldcol = self.col        
        
        vlayout = QVBoxLayout()
        vlayout.addWidget(self.histo_list_label)
        vlayout.addWidget(self.histo_list)
        vlayout.addWidget(self.histo_geo_label)        
        vlayout.addLayout(hl4)
        vlayout.addLayout(hl)
        vlayout.addWidget(self.gates_name_label)
        vlayout.addLayout(hl2)
        vlayout.addWidget(self.gates_list_label)                
        vlayout.addLayout(hl3)
        vlayout.addStretch()
        
        vlayout2a = QHBoxLayout()
        vlayout2a.addWidget(self.fit_range_label_min)
        vlayout2a.addWidget(self.fit_range_label_max)        

        vlayout2b = QHBoxLayout()        
        vlayout2b.addWidget(self.fit_range_min)
        vlayout2b.addWidget(self.fit_range_max)        
        
        vlayout2 = QVBoxLayout()        
        vlayout2.addWidget(self.fit_label)
        vlayout2.addWidget(self.fit_list)
        vlayout2.addWidget(self.fit_button)
        vlayout2.addWidget(self.fit_range_label)
        vlayout2.addLayout(vlayout2a)
        vlayout2.addLayout(vlayout2b)        
        vlayout2.addStretch()

        vlayout3 = QVBoxLayout()                
        vlayout3.addWidget(self.fit_results_label)
        vlayout3.addWidget(self.fit_results)                                        
        
        lstlayout = QHBoxLayout()
        lstlayout.addLayout(vlayout)
        lstlayout.addLayout(vlayout2)
        lstlayout.addLayout(vlayout3)        
        
        spectrumListBox.setLayout(lstlayout)
        spectrumListBox.setMaximumHeight(self.width)

        return spectrumListBox

class MainWindow(QMainWindow):
    def __init__(self, *args, **kwargs):
        super(MainWindow, self).__init__(*args, **kwargs)

        self.setWindowTitle("Project Phantom Snake")

        # global variables
        self.timer = QtCore.QTimer()
        self.setWindowFlags(QtCore.Qt.WindowMaximizeButtonHint | QtCore.Qt.WindowMinimizeButtonHint)
        self.originalPalette = QApplication.palette()
        self.clear = False

        self.yhigh = 1024
        self.vmin = 0
        self.vmax = 1024        

        # self selection of position in canvas
        self.i = 0
        self.j = 0
        # click selection of position in canvas
        self.selected_row = 0
        self.selected_col = 0
        
        # tools for selected plots
        self.rec = 0
        self.inx = 0
        self.isSelected = False

        # helper for histo type
        self.h_lst = []
        self.tmp = 0 # global index for plot_index from location in figure
        self.index = 0 # global index for self plotting
        self.isFull = False
        self.Start = False        

        # dictionaries for parameters
        self.param_list = {}
        # dataframe for spectra
        self.spectrum_list = pd.DataFrame()

        # configuration widget flag
        self.isHidden = False

        # window configuration flag
        self.isLoaded = True
        
        # dictionary for window geometry
        self.win_geometry = {}
        
        #######################
        # Main layout GUI
        #######################        
        
        mainLayout = QVBoxLayout()
        mainLayout.setContentsMargins(0,0,0,0)
        mainLayout.setSpacing(1)
        
        # top menu
        self.wTop = Menu()
        self.wTop.setFixedHeight(100)
        
        # config menu
        self.wConf = Configuration()
        self.wConf.setFixedHeight(225)
        
        # plot widget
        self.wPlot = Plot()
        
        # gui composition
        mainLayout.addWidget(self.wTop)
        mainLayout.addWidget(self.wConf)
        mainLayout.addWidget(self.wPlot)        
         
        widget = QWidget()
        widget.setLayout(mainLayout)
        
        self.setCentralWidget(widget)

        #################
        # Signals
        #################

        # top menu signals
        self.wTop.exitButton.clicked.connect(self.close)
        self.wTop.updateButton.clicked.connect(self.update)                
        self.wTop.slider.valueChanged.connect(self.self_update)
        self.wTop.configButton.clicked.connect(self.configure)                
        self.wTop.saveButton.clicked.connect(self.saveGeo)
        self.wTop.loadButton.clicked.connect(self.loadGeo)          
        
        # configuration signals
        self.at_startup()
        self.wConf.histo_geo_row.activated.connect(lambda: self.initialize_canvas(int(self.wConf.histo_geo_row.currentText()), int(self.wConf.histo_geo_col.currentText())))
        self.wConf.histo_geo_col.activated.connect(lambda: self.initialize_canvas(int(self.wConf.histo_geo_row.currentText()), int(self.wConf.histo_geo_col.currentText())))
        self.wConf.histo_geo_add.clicked.connect(self.add_plot)
        self.wConf.histo_geo_update.clicked.connect(self.update_plot)        
        self.wConf.histo_geo_delete.clicked.connect(self.delete_plot)        
        self.wConf.button2D_option.activated.connect(self.change_bkg)        
        
        # plotting signals
        self.wPlot.plusButton.clicked.connect(lambda: self.zoomIn(self.wPlot.canvas))
        self.wPlot.minusButton.clicked.connect(lambda: self.zoomOut(self.wPlot.canvas))        

        self.wPlot.canvas.mpl_connect("resize_event", self.on_resize)
        self.wPlot.canvas.mpl_connect("button_press_event", self.interact_fig)

    def on_resize(self, event):
        self.wPlot.figure.tight_layout()
        self.wPlot.canvas.draw()

    def interact_fig(self, event):
        if event.dblclick:
            print("TBD")
        # single click selects the subplot
        else:
            if not event.inaxes: return
            self.inx = list(self.wPlot.figure.axes).index(event.inaxes)
            self.selected_row, self.selected_col = self.plot_position(self.inx)
            for i, plot in enumerate(self.wPlot.figure.axes):
                # retrieve the subplot from the click
                if (i == self.inx):
                    self.update_spectrum_info()
                    if self.isSelected == True:
                        self.isSelected= False
                        self.rec.remove()
                    else:
                        self.rec = self.create_rectangle(plot)
                        self.isSelected= True
            self.wPlot.canvas.draw()

    def create_rectangle(self, plot):
        autoAxis = plot.axis()
        percentTB = 0.04;
        percentLR = 0.06;
        tb = (autoAxis[3]-autoAxis[2])*percentTB;        
        lr = (autoAxis[1]-autoAxis[0])*percentLR;
        rec = matplotlib.patches.Rectangle((autoAxis[0]-lr,autoAxis[2]-tb),
                                           (autoAxis[1]-autoAxis[0])+2*lr,
                                           (autoAxis[3]-autoAxis[2])+2*tb, fill=False, color='red', alpha=0.3, lw=2)
        rec = plot.add_patch(rec)
        rec.set_clip_on(False)        
        return rec
        
    # At startup we need:
    # - the full parameter list as dictionary - (id,name) 
    # - a canvas based on the geometry 
    
    def at_startup(self):
        self.create_parameter_list()
        self.initialize_canvas(self.wConf.row, self.wConf.col)

    def create_parameter_list(self):
        self.update_parameter_list()
        for key, value in self.param_list.items():
            for i in range(2):            
                self.wConf.listParams[i].addItem(value)
        
    def initialize_canvas(self, row, col):
        self.win_geometry.clear()
        self.wPlot.figure.clear()
        self.initialize_figure(self.create_figure(row, col))
        self.wPlot.canvas.draw()
        
    def initialize_figure(self, grid):
        self.h_lst.clear()
        for i in range(self.wConf.row):
            for j in range(self.wConf.col):
                a = self.wPlot.figure.add_subplot(grid[i,j])
        # initialize list of figure
        for z in range(self.wConf.row*self.wConf.col):
            self.h_lst.append(0)
            
    def create_figure(self, row, col):
        self.wConf.row = row
        self.wConf.col = col
        self.grid = gridspec.GridSpec(ncols=self.wConf.col, nrows=self.wConf.row, figure=self.wPlot.figure)
        return self.grid

    def select_plot(self, index):
        for i, plot in enumerate(self.wPlot.figure.axes):
            # retrieve the subplot from the click
            if (i == index):
                return plot
        
    def plot_position(self, index):
        cntr = 0
        # convert index to position in geometry
        for i in range(self.wConf.row):
            for j in range(self.wConf.col):            
                if index == cntr:
                    return i, j
                else:
                    cntr += 1

    def plot_index(self, row, col):
        # convert position in geometry into index
        if (row+col == 0):
            self.tmp = 0
        else:
            self.tmp += 1

        if (self.tmp == self.wConf.row*self.wConf.col):
            self.tmp = 0
        return self.tmp
            
    def increment_position(self):
        # used only to erase one by one the histograms - I may want to replace it at some point because quite useless
        # with the new index method
        if (self.wConf.col*self.wConf.row == 1):
            self.i = 0
            self.j = 0            
            return self.i, self.j
        else: # geometry case not 1x1
            if (self.wConf.col != self.wConf.oldcol or self.wConf.row != self.wConf.oldrow): # check if it changed, we need to reset the indices
                self.i = 0
                self.j = 0
                self.wConf.oldcol = self.wConf.col
                self.wConf.oldrow = self.wConf.row
                return self.i, self.j
            else:
                if (self.j < self.wConf.col-1):
                    self.j += 1
                    return self.i, self.j
                else:
                    if (self.i < self.wConf.row-1):
                        self.i += 1
                        self.j = 0
                        return self.i, self.j

                if (self.i == self.wConf.row-1 and self.j == self.wConf.col-1):
                    self.i = 0
                    self.j = 0
                    return self.i, self.j

    # hide/show configuration of the canvas
    def configure(self):
        if self.isHidden == False:
            self.wConf.hide()
            self.isHidden = True
        else:
            self.wConf.show()
            self.isHidden = False

    # save geometry window
    def saveGeo(self):
        fileName = self.saveFileDialog()
        f = open(fileName,"w")
        tmp = {"row": self.wConf.row, "col": self.wConf.col, "geo": self.win_geometry}
        print(tmp)
        f.write(str(tmp))
        f.close()

    # load geometry window
    def loadGeo(self):
        fileName = self.openFileNameDialog()
        f = open(fileName,"r").read()
        infoGeo = eval(f)
        self.wConf.row = infoGeo["row"]
        self.wConf.col = infoGeo["col"]
        # change index in combobox to the actual loaded values
        index_row = self.wConf.histo_geo_row.findText(str(self.wConf.row), QtCore.Qt.MatchFixedString)
        index_col = self.wConf.histo_geo_col.findText(str(self.wConf.col), QtCore.Qt.MatchFixedString)
        if index_row >= 0 and index_col >= 0:
            self.wConf.histo_geo_row.setCurrentIndex(index_row)
            self.wConf.histo_geo_col.setCurrentIndex(index_col)
            self.initialize_canvas(infoGeo["row"],infoGeo["col"])
            self.win_geometry = infoGeo["geo"]
            if len(self.win_geometry) == 0:
                QMessageBox.about(self, "Warning", "You saved an empty pane geometry...")
            else:
                print(self.win_geometry)
            self.isLoaded = True

    def openFileNameDialog(self):
        options = QFileDialog.Options()
        options |= QFileDialog.DontUseNativeDialog
        fileName, _ = QFileDialog.getOpenFileName(self,"QFileDialog.getOpenFileName()", "","Window Files (*.win);;All Files (*)", options=options)
        if fileName:
            return fileName;
        
    def saveFileDialog(self):
        options = QFileDialog.Options()
        options |= QFileDialog.DontUseNativeDialog
        fileName, _ = QFileDialog.getSaveFileName(self,"QFileDialog.getSaveFileName()","","Window Files (*.win);;All Files (*)", options=options)
        if fileName:
            return fileName
            
    def update_parameter_list(self):
        tmpl = httplib2.Http().request("http://localhost:8080/spectcl/parameter/list")[1]
        tmp = json.loads(tmpl.decode())
        tmpid = []
        tmpname = []
        for dic in tmp['detail']:
            for key in dic:
                if key == 'id':
                    tmpid.append(dic[key])
                elif key == 'name':
                    tmpname.append(dic[key])
        ziplst = zip(tmpid, tmpname)
        self.param_list = dict(ziplst)


    # when clicking update we need to access the shared memory and
    # update the spectrum information in the data frame
    def update(self):
        # creates a dataframe for spectrum info
        s = cpy.CPyConverter().Update()
        self.spectrum_list = pd.DataFrame(
            {'id': s[0],
             'names': s[1],
             'dim' : s[2],
             'binx': s[3],
             'minx': s[4],
             'maxx': s[5],
             'biny': s[6],
             'miny': s[7],
             'maxy': s[8],
             'data': s[9]}
        )
        # add list of parameters for each spectrum to the dataframe
        self.create_spectrum_parameters();
        # update the list of defined spectra
        self.create_spectrum_list()        
        # update information for current selected spectrum
        self.update_spectrum_info() # default first histo of the list
        
    # add list of parameters for each spectrum to the dataframe        
    def create_spectrum_parameters(self):
        tmpl = httplib2.Http().request("http://localhost:8080/spectcl/spectrum/list")[1]
        tmp = json.loads(tmpl.decode())
        tmppar = []
        for dic in tmp['detail']:
            for key in dic:
                if key == 'parameters':
                   tmppar.append(dic[key]) 
        # adds list to dataframe           
        self.spectrum_list['parameters'] = tmppar
        
    # update the list of defined spectra
    def create_spectrum_list(self):
        for name in self.spectrum_list['names']:
            if self.wConf.histo_list.findText(name) == -1:
                self.wConf.histo_list.addItem(name)
                
    # update information for current selected spectrum
    def update_spectrum_info(self):
        # access name and id for the current spectrum
        self.current_spec = str(self.wConf.histo_list.currentText())
        #self.current_spec = self.wConf.histo_list.itemText(index)
        if self.current_spec == "":
            QMessageBox.about(self, "Warning", "Please click 'Get Data' to access the shared memory...")
        else:
            # update info on gui for spectrum name
            self.wConf.spectrum_name.setText(self.current_spec)
            # extra data from data frame to fill up the gui 
            select = self.spectrum_list['names'] == self.current_spec
            df = self.spectrum_list.loc[select]
            dim = df.iloc[0]['dim']
            if dim == 1:
                self.wConf.button1D.setChecked(True)
            else:
                self.wConf.button2D.setChecked(True)
            self.check_histogram();
            for i in range(dim):
                index = self.wConf.listParams[i].findText(df.iloc[0]['parameters'][i], QtCore.Qt.MatchFixedString)
                if index >= 0:
                    self.wConf.listParams[i].setCurrentIndex(index)
                if i == 0:
                    self.wConf.listParams_low[i].setText(str(df.iloc[0]['minx']))
                    self.wConf.listParams_high[i].setText(str(df.iloc[0]['maxx']))
                    self.wConf.listParams_bins[i].setText(str(df.iloc[0]['binx']))
                else :
                    self.wConf.listParams_low[i].setText(str(df.iloc[0]['miny']))
                    self.wConf.listParams_high[i].setText(str(df.iloc[0]['maxy']))
                    self.wConf.listParams_bins[i].setText(str(df.iloc[0]['biny']))

    # looking for type 0 (not set) histograms 
    def check_index(self):
        if any(x == 0 for x in self.h_lst) == self.isFull:
            self.index = 0
            self.isFull = True
            return self.index
        else:
            idx = next((i for i, x in enumerate(self.h_lst) if x==0), None)
            if idx is not None:
                self.index = idx
                return self.index
            else:
                self.Start = True
            
        if self.Start == True:
            if self.index == self.wConf.row*self.wConf.col-1:
                self.index = 0
            else:
                self.index += 1

        return self.index
        
    def add_plot(self):
        # updating histogram info
        self.update_spectrum_info()        

        idx = 0
        # self adding 
        if self.isSelected == False:
            idx = self.check_index()
        # position selected by user
        else:
            self.delete_plot()
            idx = self.inx

        self.win_geometry[idx] = self.current_spec
        self.add(idx)

        # keep track of the histogram type for zooming 
        if self.wConf.button1D.isChecked():
            self.h_lst[idx] = 1            
        elif self.wConf.button2D.isChecked():
            self.h_lst[idx] = 2            

        self.wPlot.canvas.draw()

    def add(self, index):
        a = self.select_plot(index)
        x,y = self.plot_position(index)        
        a.clear()
        if self.isSelected == True:
            a = self.wPlot.figure.add_subplot(self.grid[self.selected_row,self.selected_col])
        else:
            a = self.wPlot.figure.add_subplot(self.grid[x,y])
        self.isSelected = False
        self.plot_histogram(a, index)
        
    def delete_plot(self):
        # updating histogram info        
        self.update_spectrum_info()        
            
        # self removing
        idx = 0
        if self.isSelected == False:
            x,y = self.increment_position()
            idx = self.plot_index(x,y)
        else:
            idx = self.inx

        a = self.select_plot(idx)
        # if 2d histo I need a bit more efforts for the colorbar
        if self.h_lst[idx] == 2:
            im = a.images
            if im is not None:
                cb = im[-1].colorbar
                cb.remove()
        a.clear()
        self.isSelected = False
        self.h_lst[idx] = 0
        self.isFull = False
        
        self.wPlot.canvas.draw()
        
    def update_plot(self):
        # add plot if geometry == 1x1 otherwise you have to add by hand
        if (self.wConf.col*self.wConf.row == 1):
            self.add_plot()
        # else update the canvas
        self.wPlot.figure.tight_layout()
        self.wPlot.canvas.draw()        

    def change_bkg(self):
        if any(x == 2 for x in self.h_lst) == True:
            indices = [i for i, x in enumerate(self.h_lst) if x == 2]
            for index in indices:
                self.isSelected = False # this line is important for automatic conversion from dark to light and viceversa
                self.add(index)
        self.wPlot.canvas.draw()
                
    def self_update(self):
        self.wTop.slider_label.setText("Refresh interval ({} s)".format(self.wTop.slider.value()))
        if self.wTop.slider.value() != 0:
            self.timer.setInterval(1000*int(self.wTop.slider.value()))
            self.timer.timeout.connect(self.update)
            self.timer.timeout.connect(self.update_plot)            
            self.timer.start()
        else:
            self.timer.stop()
    
    def plot_histogram(self, histo, index):
        name = self.win_geometry[index]
        if (name == ''):
            return histo
        else:
            select = self.spectrum_list['names'] == name
            df = self.spectrum_list.loc[select]
            w = df.iloc[0]['data']

        # check if histogram is empty
        if self.wConf.button1D.isChecked():
            empty = sum(w)
        elif self.wConf.button2D.isChecked():
            empty = sum(w[1])
            
        if (empty == 0):
            self.isEmpty = True
            histo.set_ylim(0,512)
            QMessageBox.about(self, "Warning", "The shared memory is still empty...")
        else:
            self.isEmpty = False
            dim = df.iloc[0]['dim']        
            xbins = self.wConf.listParams_bins[0].text().replace(' ', '')
            xmin = self.wConf.listParams_low[0].text().replace(' ', '')
            xmax = self.wConf.listParams_high[0].text().replace(' ', '')
            if (dim == 1):
                histo.set_ylim(0,self.yhigh)
                X = self.create_range(int(xbins), float(xmin), float(xmax))
                histo.hist(X, len(X), weights=w, range=[float(xmin),float(xmax)], histtype='step')
                plt.xlim(xmin=float(xmin), xmax=float(xmax))
                x_label = str(df.iloc[0]['parameters'])
                plt.xlabel(x_label,fontsize=10)
            elif (dim == 2):
                ybins = self.wConf.listParams_bins[1].text().replace(' ', '')
                ymin = self.wConf.listParams_low[1].text().replace(' ', '')
                ymax = self.wConf.listParams_high[1].text().replace(' ', '')
                divider = make_axes_locatable(histo)
                cax = divider.append_axes("right", 0.25, pad=0.05)
                if (self.wConf.button2D_option.currentText() == 'Dark'):
                    palette = 'plasma'
                else:
                    palette = copy(plt.cm.plasma)
                    w = np.ma.masked_where(w < 0.1, w)
                    palette.set_bad(color='white')
                self.img2d = histo.imshow(w, interpolation='none', extent=[float(xmin),float(xmax),float(ymin),float(ymax)],
                                          aspect='auto', origin='lower', vmin=self.vmin, vmax=self.vmax, cmap=palette)
                plt.colorbar(self.img2d, cax=cax, orientation='vertical')
            return histo

    def zoomIn(self, canvas):
        # remove rectangle from plot
        if self.isSelected == True:
            self.rec.remove()
        else:
            canvas.draw()
        # zoom ONLY the selected one
        for i, ax in enumerate(self.wPlot.figure.axes):
            if (i == self.inx):
                if self.h_lst[i] == 1:
                    ylow, self.yhigh = ax.get_ylim()
                    self.yhigh /= 2
                    ax.set_ylim(0,self.yhigh) 
                if self.h_lst[i] == 2:
                    self.vmax /= 2
                    self.img2d.set_clim(vmax=self.vmax)
                if (self.isSelected == True):
                    self.rec = self.create_rectangle(ax)
        canvas.draw()
            
    def zoomOut(self, canvas):
        if self.isSelected == True:
            self.rec.remove()
        else:
            canvas.draw()            
        # zoom ONLY the selected one            
        for i, ax in enumerate(self.wPlot.figure.axes):
            if (i == self.inx):
                if self.h_lst[i] == 1:
                    ylow, self.yhigh = ax.get_ylim()
                    self.yhigh *= 2
                    ax.set_ylim(0,self.yhigh) 
                if self.h_lst[i] == 2:
                    self.vmax *= 2
                    self.img2d.set_clim(vmax=self.vmax)
                if (self.isSelected == True):
                    self.rec = self.create_rectangle(ax)
        canvas.draw()
            
    def create_range(self, bins, vmin, vmax):
        x = []
        step = (vmax-vmin)/bins
        for i in np.arange(vmin, vmax, step):
            x.append(i)
        return x

    def check_histogram(self):
        if self.wConf.button1D.isChecked():
            self.create_disable2D(True)
        else:
            self.create_disable2D(False)
            
    def create_disable2D(self, value):
        if value==True:
            self.wConf.listParams[1].setEnabled(False)
            self.wConf.listParams_low[1].setText("")
            self.wConf.listParams_low[1].setReadOnly(True)
            self.wConf.listParams_high[1].setText("")
            self.wConf.listParams_high[1].setReadOnly(True)
            self.wConf.listParams_bins[1].setText("")
            self.wConf.listParams_bins[1].setReadOnly(True)            
        else:
            self.wConf.listParams[1].setEnabled(True)
            self.wConf.listParams_low[1].setReadOnly(False)
            self.wConf.listParams_high[1].setReadOnly(False)            
            self.wConf.listParams_bins[1].setReadOnly(False)

