<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                      "file:///usr/share/xml/docbook/schema/dtd/4.5/docbookx.dtd
"
>
<book>
    <bookinfo>
      <title>SpecTcl User guide.</title>
      <author><firstname>Ron</firstname><surname>Fox</surname></author>
      <revhistory>
          <revision>
             <revnumber>1.0</revnumber>
             <date>May 12, 2017 and following</date>
             <authorinitials>RF</authorinitials>
             <revremark>Original Release</revremark>
          </revision>
      </revhistory>
    </bookinfo>
    <chapter>
        <title>Introduction</title>
        <para>
            SpecTcl (pronounced Spectacle) is a general purpose histogramming
            program intended for use with nuclear physics data.  It was developed
            at the NSCL to provide an easy to use, easy to program online analysis
            program.  This manual refers to SpecTcl version 5.0 and later.
        </para>
        <para>
            This document will contain the following chapters:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    <link linkend='chap.overview' endterm='chap.overview.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='chap.starting' endterm='chap.starting.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='chap.filters' endterm='chap.filters.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='chap.startup' endterm='chap.startup.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='chap.scripting' endterm='chap.scripting.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='chap.gui' endterm='chap.gui.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='chap.filteranalysis' endterm='chap.filteranalysis.title' />
                </para>
            </listitem>
        </itemizedlist>
    </chapter>
    <chapter id='chap.overview'>
        <title id='chap.overview.title'>Overview of how SpecTcl works</title>
        <para>
            The program name, SpecTcl, says a lot about how SpecTcl is built.
            Spec, stands for Spectra and Tcl for the Tcl/Tk scripting language.
            SpecTcl implements an extension to that language as its command language.
            This allows users to not only type simple commands at the program,
            but to write scripts of commands and, using the Tk toolkit,
            easily write graphical user interfaces that bolt on top of SpecTcl.
        </para>
        <para>
            SpecTcl is often compared to Root, although our application domain
            is intended to be quite different.  SpecTcl concentrates on making
            it easy to create histograms, define condtions (gates) and
            apply those conditions to spectra.   That's its focus.  Root
            is a general purpose anaylis framework of classes.
        </para>
        <para>
            By confining our problem domain to making histograms, we can
            simplify the process of tailoring SpecTcl to a specific analysis
            task.  In Root, for example, you are typically required to write
            the entire analysis from raw data to desired output products.
            Since SpecTcl knows that our output products are just histograms,
            we can relieve of the task of creating and incrementing histograms.
        </para>
        <para>
            Here's a simplified picture of the flow of data through SpecTcl:
        </para>
        <figure>
            <title>Flow of data through SpecTcl</title>
            <graphic format='PNG' fileref='spectcldataflow.png' />
        </figure>
        <para>
            Events packaged in accordance with the format of some dat acquisition
            system's outer format arrive at a SpecTcl
            <firstterm>Buffer Decoder</firstterm> object.  The buffer decoder
            is responsible for knowing about the outer format of the data (sometimes
            called the data envelope). It opens those envelopes and produces
            events.
        </para>
        <para>
            A logical pipeline of event processors is given each event.  The
            event processors in this pipeline are the only bits of software
            needed to tailor SpecTcl to a specific analysis problem.  Each stage
            of the pipeline has access to the raw event and the parameters that
            have been produced by previous stages of the pipeline.
        </para>
        <para>
            The parameters that have been produced by this
            <firstterm>event processing pipeline</firstterm> are then passed
            on to the histogrammer.  The histogrammer uses a set dictionaries of
            parameters, spectra gates and gate applications to, given the parameters
            of each event, determine how to increment the spectra.
        </para>
        <para>
            A visualization component of SpecTcl provides a view into the
            histograms, gates and their applications to the user.
        </para>
        <para>
            Several important points about SpecTcl:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Event processing is done as background processing from
                    so the user interface, including the command interpreter,
                    is live during event processing.
                </para>
            </listitem>
            <listitem>
                <para>
                    SpecTcl can accept event data from two types of sources; files
                    and UNIX pipes.  The unix pipe data source allows SpecTcl
                    to be attached to online data acquisition systems to do
                    analysis of live data.
                </para>
            </listitem>
            <listitem>
                <para>
                    Creation of histograms, gates and application of gates to
                    spectra is totally dynamic and can occure while analysis is
                    in progress.
                </para>
            </listitem>
        </itemizedlist>
    </chapter>
    <chapter id='chap.starting'>
        <title id='chap.starting.title'>Getting started with SpecTcl</title>
        <para>
            This chapter will help you get started using SpecTcl.  The audience
            is users who have never used SpecTcl before, or people who will be
            applying SpecTcl to a new analysis problem (e.g a new detector system).
        </para>
        <para>
            In the remainder of this chapter we'll describe:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    The sorts of objects SpecTcl understands.
                </para>
            </listitem>
            <listitem>
                <para>
                    How to create, delete and manipulate these parameters.
                </para>
            </listitem>
            <listitem>
                <para>
                    How to start with a new SpecTcl skeleton and, after writing
                    a new set of event processor, build a version of SpecTclthat
                    is tailored to your analysis tasks.
                </para>
            </listitem>
            <listitem>
                <para>
                    What sorts of data sources SpecTcl works from and how
                    to start analyzing data from a data source.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            Note that in this chapter we're not going to assume the existence
            of any SpecTcl graphical user interface.  If you write SpecTcl
            scripts you'll need to know something about the raw SpecTcl
            command interface.  This chapter and the reference manuals for
            SpecTcl are your sources for this information.
        </para>
        <section>
            <title>SpecTcl Objects and how to use them</title>
            <para>
                SpecTcl performs its analysis using several classes of objects.
                Once you have an unpacked event, it is the configuration of these
                objects rather than any programming on your part that
                determines how the analysis is performed.
            </para>
            <para>
                First we're going to list and describe the types of objects
                SpecTcl uses in analysis and then we will go into a bit more
                detail about each object and the commands that manipulate
                them.
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        <firstterm>Parameters</firstterm>;  Parameters are the
                        output of event processors, the code that connects SpecTcl
                        to the event data from the experiment that's being analyzed.
                        Typically, event data consists of data from some set
                        of digitizer hardware.  Each digitizer may package
                        the data in different ways.
                    </para>
                    <para>
                        The actual conversion values from each digitizer is
                        usually a parameters.  Parameters taht come from these
                        raw data values are called <firstterm>raw parameters</firstterm>.
                    </para>
                    <para>
                        One can also derive parameters by performing computations
                        on other parameters.  For example, you can take a raw
                        digitizer channel value and apply some calibration
                        function to it.   Parameters that are the results of
                        computations on other parameters are called
                        <firstterm>computed parameters</firstterm>, or sometimes
                        <firstterm>psuedo parameters</firstterm>.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <firstterm>Spectra</firstterm> are histograms.  SpecTcl
                        has a rich set of histograms.  Histograms are the 'output'
                        of SpecTcl. 
                    </para>
                    <para>
                        SpecTcl is normally run in conjunction with a visualization
                        program. Originally, this program was <application>Xamine</application>.
                        More recently a new visualization program, called
                        <application>Spectra</application> provides visualization based
                        on the Root toolkit.
                    </para>
                    <para>
                        SpecTcl can locates spectra in a shared memory region.
                        This permits high speed access to bulk spectrum data
                        by visualization programs.   Spectra that have been
                        located in shared memory are said to be
                        <firstterm>bound</firstterm> to the displayer.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <firstterm>Gates</firstterm> are conditions. Gates can
                        be primitive regions of interest that are draw on spectra.
                        They can also be boolean combinations of other gates.
                        These latter gates are often called
                        <firstterm>compound gates</firstterm> while the
                        former are called <firstterm>primitive gates</firstterm>.
                    </para>
                    <para>
                        An important point often lost by beginning (and sometimes
                        experienced) SpecTcl users is that while gates might be
                        created by drawing them on spectra in a displayer, they
                        actually represent tests that are performed on one or
                        more <emphasis>parameters</emphasis>.  Spectra are
                        only involved in gate creation because the regions of
                        interest in parameter space are often most easily
                        seen by looking at spectra that involve the parameter.
                    </para>
                    <para>
                        You can think of a gate as a boolean function on the
                        parameters of each event.  
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <firstterm>Gate Application</firstterm>.  Gates by
                        themselves are useles.  What makes a gate useful is
                        that it can be <emphasis>applied</emphasis> to a
                        spectrum.  When a spectrum has a gate applied to it,
                        the spectrum is only incremented for events that
                        make that gate <literal>true</literal>.
                    </para>
                    <para>
                        Note that really all Spectra have gates applied to them.
                        What are normally called ungated spectra actually are
                        spectra that have a <literal>True</literal> gate applied
                        to them.  A True gate is true for all events regardless
                        of any parameter values.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Earlier, we alluded to computed, or psuedo parameters.
                        There are two ways you can create a computed parameter.
                        <orderedlist>
                            <listitem>
                                <para>
                                    You can provide the computation as part of
                                    your event processor.
                                </para>
                            </listitem>
                            <listitem>
                                <para>
                                    You can provide a Tcl <command>proc</command>
                                    that is evaluated for each event to
                                    compute the computed parameter.   This latter
                                    approach, while slower than compiled code,
                                    provides a mechanism to add new parameters
                                    to SpecTcl without recompiling your tailored
                                    SpecTcl.
                                </para>
                            </listitem>
                        </orderedlist>
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <firstterm>Filters</firstterm>;  Usually analysis, at least
                        initially, procedes in several stages.   Often each stage
                        of analysis refines the set of events that are interesting
                        to the experiment.  The unpacking of each event from raw
                        format can be time consuming as well.
                    </para>
                    <para>
                        A filter is a way to save a new event file that consists
                        of a subset of the parameters of a subset of events.
                        The file is saved in a form that is much easier to unpack
                        than normal raw event files.  Thus the analysis of these
                        files can be substantially faster 
                    </para>
                </listitem>
            </itemizedlist>
            <section>
                <title>Creating and describing parameters.</title>
                <para>
                    The creation and description of parameters has evolved
                    considerably since the first versions of SpecTcl.  Much of
                    this evolution is thanks to the vision and contributions of
                    Daniel Bazin at the NSCL.
                </para>
                <para>
                    The first version of SpecTcl provided a flat array of integer
                    parameters.  Relatively quickly, this flat array of integers
                    became a flat array of double precision floating point
                    values.
                </para>
                <para>
                    This flat array of double precision floats is still used
                    internally by the histogramming kernel SpecTcl uses to
                    take the parameters from an event and increment the
                    appropriate channels of appropriate spectra.
                </para>
                <para>
                    What Daniel Bazin created was an overlay that lives on top
                    of this flat array that provides:
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            The ability to structure the parameter space in
                            a manner that better matched the parameters of
                            each analysis problem.
                        </para>
                        <para>
                            He provided classes that allow parameters to transparently
                            live in C/C++ structs as well as array like objects
                            containing parameters.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            The ability to associate with each parameter information
                            about its range, preferred binning, when histogrammed
                            and units of measure.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            A parameter naming convention that allowed graphical
                            user interfaces to present potentially large parameter
                            sets hierchically in a manner that typically reflects
                            the structs in which the programming constructs live.
                        </para>
                    </listitem>
                </itemizedlist>
                <para>
                    This package, called <firstterm>TreeParameter</firstterm> was
                    first adopted in SpecTcl and then later rewritten to provide
                    additional functionality and a tighter integration with the
                    SpecTcl event processing framework.  We'll say more about
                    tree parameters when we describe event processors.
                </para>
                <para>
                    This bit of history is by way of explanation of the two
                    sets of parameter manipulation commands that today's
                    SpecTc provides.
                </para>
                <para>
                    SpecTcl provides three commands that deal with parameters:
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            <command>parameter</command> provides access to the
                            underlying array of floats.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <command>treeparameter</command> provides access to
                            the structured overlay on to of the parameter array.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <command>psuedo</command> provides support for
                            dynamically computed parameters (Tcl scripts that
                            create new parameters).
                        </para>
                    </listitem>
                </itemizedlist>
                <section>
                    <title>The <command>parameter</command> command</title>
                    <para>
                        Recall that at the lowest levesl of SpecTcl, parameters
                        are stored in a flat array-like object.  The user's
                        event processors store specific parameters at specific
                        indices in that object.
                    </para>
                    <para>
                        Parameter indices are not something humans have an easy
                        time with.  The <command>parameter</command> allows you
                        to maintain a mapping between textual names and the
                        indices in the parameter array.  When you create objects
                        that require one or more parameters, then can then be
                        specifiec by name, and SpecTcl can use this
                        <firstterm>parameter dictionary</firstterm> to look up
                        the actual parameter.
                    </para>
                    <para>
                        The <command>parameter</command> command accepts an optional
                        switch that modifes what it does.  If no switch is
                        provided, the <option>-new</option> switch is implied
                        and a new mapping is created.  There are several
                        forms of the parameter command for creating new mappings:
                    </para>
                    <informalexample>
                        <programlisting>
parameter ?-new? name id resolution
parameter ?-new? name id resolution {low high units}
parameter >-new? name id ?units?
                        </programlisting>
                    </informalexample>
                    <para>
                        The multiplicity of forms of the parameters represent
                        evolutions of parameters from simple integers to
                        scaled integers and finally to double values.
                        The command arguments are as follows for these versions
                        of <command>parameter -new</command>:
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term><parameter>name</parameter></term>
                            <listitem>
                                <para>
                                    The name to be given to the specified index
                                    of the parameter array.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><parameter>id</parameter></term>
                            <listitem>
                                <para>
                                    The index of the parameter for which a
                                    mapping is being created.  The index is
                                    also referred to in SpecTcl as the
                                    <firstterm>parameter id</firstterm>.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><parameter>resolution</parameter></term>
                            <listitem>
                                <para>
                                    When parameters were solely integer or
                                    scaled integers, this represents the number
                                    of bits of resolution the underlying parameter
                                    has.  For example, an ADC that has the range
                                    <literal>[0,4096) </literal> will have 12
                                    bits of resolution.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><parameter>units</parameter></term>
                            <listitem>
                                <para>
                                    Documents the units of measure associated with
                                    a parameter.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><parameter>low</parameter> <parameter>high</parameter></term>
                            <listitem>
                                <para>
                                    For scaled parameters represents the limits of the
                                    parameter being represented.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                    <para>
                        The other most commonly used form of the parameter command
                        is when the <option>-list</option> switch is used.
                        In this case, the result of the command is a list of
                        the parameters in a form that is easily parsed by
                        Tcl scripts.
                    </para>
                    <informalexample>
                        <programlisting>
parameter -list ?pattern?
                        </programlisting>
                    </informalexample>
                    <para>
                        Lists information about the parameter mappings that have
                        been defined.  If <parameter>pattern</parameter> is
                        provided, only those parameters
                        whose names that match that pattern
                        are listed.  Pattern can contain any of the wildcard
                        characters used in filename matching in UNIX (glob
                        pattern).  Not providing a pattern is identical to
                        providing <literal>*</literal> as the pattern, listing
                        all parameters.
                    </para>
                    <para>
                        The result is  well formatted Tcl list.  See the
                        reference manual for the form of this list, however
                        for many cases you just need to know that each list
                        element describes a parameter as a sublist.  The
                        first element of each sublist (element 0) is the
                        parameter name, and the second, the parameter id
                        (index into the parameter array).
                    </para>
                </section>
                <section>
                    <title>The <command>treeparameter</command> command</title>
                    <para>
                        The <command>treeparameter</command> command manipulates
                        parameters defined within the tree parameter subsystem
                        that is layered on top of the parameter array.
                        From the event unpacker point of view, tree parameters
                        are represented by a <classname>CTreeParameter</classname>
                        object or an indexed element of a
                        <classname>CTreeParameterArray</classname> array like object.
                        Each of those can be treated as a double.
                    </para>
                    <para>
                        Metadata is associated with each tree parameter and,
                        in most user interfaces that know about tree parameters,
                        these metatdata are used to inform the user about the
                        recommended histogram binning for that parameter.
                    </para>
                    <para>
                        Tree parameters also have a name.  This name matches the
                        name of the underlying <command>parameter</command>
                        name.  For <classname>CTreeParameter</classname>
                        objects, new parameters are created as needed and two
                        instances of a <classname>CTreeParameter</classname>
                        object that have been given the same name will refer
                        to the same underlying parameter.
                    </para>
                    <para>
                        Tree parameters can be created, listed and their
                        metadata modified.  The form of the
                        <command>treeparameter</command> command that
                        creates a tree parameter is:
                    </para>
                    <informalexample>
                        <programlisting>
treeparameter -create name low high bins units
                        </programlisting>
                    </informalexample>
                    <para>
                        Creates a new tree parameter.  The tree parameter will
                        correspond to the underlying parameter <parameter>name</parameter>.
                        <parameter>units</parameter> are the units of measure
                        of the parameter. <parameter>low</parameter> is the
                        recommended low limit of spectra axes that are created
                        on this parameter.  <parameter>high</parameter>
                        is the recommended high limit of spectra axes that are
                        created on this parameter.
                        <parameter>bins</parameter> is the recommended number
                        of bins on axes on this parameter.
                    </para>
                    <para>
                        Since creating an e.g. <classname>CTreeParameter</classname>
                        instance creates a tree parameter, this command is intended
                        to take legacy parameters (those that are populated
                        directly into the parameter array), and wrap them in the
                        metadata associated with a tree parameter.
                    </para>
                    <para>
                        To list the set of defined tree parameters and their
                        metadata.
                    </para>
                    <informalexample>
                        <programlisting>
treeparameter -list ?pattern?
                        </programlisting>
                    </informalexample>
                </section>
                <section>
                    <title>The <command>pseudo</command> command</title>
                    <para>
                        The pseudo command allows you to compute a parameter
                        from existing parameters to produce a new computed parameter.
                        Pseudo parameters are created as follows:
                    </para>
                    <informalexample>
                        <programlisting>
pseudo name parameters body
                        </programlisting>
                    </informalexample>
                    <para>
                        
                        Prior to defining a pseudo, the new parameter must have
                        been created using either the <command>parameter</command>
                        or <parameter>treeparameter</parameter> commands.
                    </para>
                    <para>
                        The best way to understand this command is to think of it
                        as a variation on the Tcl <command>proc</command> command.
                        <parameter>name</parameter> is the name of the new parameter
                        and will be used to construct the name of the proc that
                        actually computes the new parameters.
                        <parameter>parameters</parameter> is a list of existing
                        parameter names that are required to produce the parameter.
                        <parameter>body</parameter> is a script whose value
                        will become the pseudo parameter's value.
                    </para>
                    <para>
                        A new proc is created.  The proc is created with
                        two formal parameters for each parameter.  The first
                        parameter, has the same name as the SpecTcl parameter
                        and is the value of that parameter for each event.
                        The second parameter is the parameter name with
                        <literal>isValid</literal> appended and is a boolean
                        that is true if the parameter has a value for that
                        event.
                    </para>
                    <para>
                        Here's a sample of a <command>psuedo</command>
                        command that sums to value <literal>par1</literal>
                        and <literal>par2</literal> 
                        together:
                    </para>
                    <informalexample>
                        <programlisting>
pseudo sum { par1 par2 } {
   if {$par1isValid &amp;&amp; $par2isValid} {
      return [expr $par1 + $par2]
   } else {
       return -1
   }
}
                        </programlisting>
                    </informalexample>
                    <para>
                        Note that psuedo parameter scripts have no mechanism to
                        indicate they are not defined for an event.  The best
                        you can do is return a value that is outside the useful
                        range of the parameter.
                    </para>
                </section>
            </section>

        </section>
        <section>
            <title>Creating/listing spectra</title>
            <para>
                Spectra can be created, or deleted at any time.  The
                <command>spectrum</command> command is the main command
                for manipulating spectra.
            </para>
            <para>
                SpecTcl has a rich set of spectrum types in addition to the
                normal 1d and 2d spectrum types.  This section will describe
                only the most commonly used spectrum types.  If you don't see
                the spectrum type you want, have a look at the reference
                manual for more.
            </para>
            <para>
                As with the <command>parameter</command>, <command>spectrum</command>
                is followed by a switch that describes the operation it is supposed
                to do.  If no switch is supplied <option>-new</option> is
                assumed.
            </para>
            <para>
                The general form of the <command>spectrum</command> command
                to create a new spectrum is:
            </para>
            <informalexample>
                <programlisting>
spectrum -new name type parameter-list axis-speclist ?datatype?
                </programlisting>
            </informalexample>
            <para>
                <parameter>name</parameter> is the name of the new spectrum.
                Spectrum names must be unique. <parameter>type</parameter>
                is a one or two letter code that indicates the type of the
                spectrum that will be created.
                <parameter>parameter-list</parameter> is the list of parameter
                names that are needed to create the spectrum.  The number
                and organization of this list depends on the spectrum
                type. <parameter>axis-speclist</parameter> is a list of axis
                specifications.
            </para>
            <para>
                The optional <parameter>datatype</parameter> parameter is one of
                <literal>byte</literal>, <literal>word</literal> or
                <literal>long</literal> which indicate whether channels are
                8, 16 or 32 bits wide respectively.  The default is
                <literal>long</literal>.  These days there's no compelling
                reason to use any other data type.  This parameter dates from
                when systems had much less memory than they do today.
            </para>
            <para>
                We're going to describes the following spectrum types:
            </para>
            <variablelist>
                <varlistentry>
                    <term><literal>1</literal> - 1d spectrum.</term>
                    <listitem>
                        <para>
                            This spectrum requires a single parameter
                            and a single axis specification.  The parameter
                            value is scaled as defined by the binning of the
                            single axis the resulting channel is incremented
                            if the gate applied to the spectrum is true.
                        </para>
                        <para>
                            The form of the axis specification is:
                            <literal>{{low high bins}}</literal>.  Where
                            <parameter>low</parameter> and <parameter>high</parameter>
                            are the axis limits (the range of parameter values that
                            lie within the spectrum) and <parameter>bins</parameter>
                            is the number of bins in the axis.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>2</literal> - 2d spectrum</term>
                    <listitem>
                        <para>
                            This spectrum requires two parameters that are in order
                            the X and Y parameters.  It also requires two axis
                            specifications which specify the x and y axis
                            limits and binning.
                        </para>
                        <para>
                            For each event, the axis specifications are used to
                            compute an x and y channel which is then incremented
                            if the spectrum's gate is true.
                        </para>
                        <para>
                            The form of the axis specification is:
                            <literal>{{xlow xhigh xbins} {ylow yhigh ybins}}</literal>.
                            Where each axis has low and high cutoffs for its
                            parameter and bin counts.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>s</literal> - summary spectrum</term>
                    <listitem>
                        <para>
                            The summary spectrum is a way to monitor several
                            similar channels simultaneously.  The summary
                            spectrum takes an arbitrarily long list of parameter
                            names.  
                        </para>
                        <para>
                            While summary spectra are displayed as 2-d spectra,
                            the X axis definition is determined by the number
                            of parameters in the parameter list.  The
                            only axis definition, therefore is the Y axis definition.
                        </para>
                        <para>
                            One useful way to think of the summary spectrum is
                            as 2d display of vertical strips where each vertical
                            strip is a 1-d histogram of the channel in that x
                            position.
                        </para>
                        <para>
                            Typically summary spectra are used for a set of parameters
                            that have a similar meaning (such as the energy parameters
                            from and array of detectors).  By looking at a summary
                            spectrum you can quickly see channels that are not working
                            or not gain matched (if you're attempting to gain match
                            these channels).
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                The <command>spectrum</command> command can also list all or some
                of the spectrum definitions.  As with <command>parameter</command> <option>-list</option>,
                <command>spectrum</command> <option>-list</option> lists
                the spectra in a format that is easy for Tcl scripts to interpret.
                As with <command>parameter</command> <option>-list</option>,
                <command>spectrum</command> <option>-list</option> can take
                an optional pattern parameter that selects only spectra whose name
                match the pattern.  Once more the pattern works exactly like
                a unix filename pattern (glob pattern), and accepts all of
                the wild card characters accepted by file name patterns.
            </para>
            <para>
                <command>spectrum</command> <option>-list</option> can also accept
                a <option>-showgate</option> option.  This must appear before
                any filter pattern.  If <option>-showgate</option> is used,
                each spectrum definition will also list the gate that's applied
                to the spectrum.
            </para>
            <para>
                <command>spectrum</command> <option>-list</option> returns a
                Tcl list.  Each Tcl list element describes one spectrum and
                that spectrum is described as a Tcl list.  A common error in
                writing Tcl scripts is to remember that even if you are using
                <command>spectru</command> <option>-list</option> to list
                the definition of a single spectrum, there is still going to be
                an outer list with a single element.
            </para>
            <para>
                The spectrum description list has the following elements (in order):
            </para>
            <variablelist>
                <varlistentry>
                    <term><literal>spectrum id</literal></term>
                    <listitem>
                        <para>
                            This is an integer that uniquely identifies the spectrum.
                            It's a pretty useless bit of information that you
                            can ignroe.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>name</literal></term>
                    <listitem>
                        <para>
                            The name of the spectrum.  This is what SpecTcl
                            and humans use to identify the spectrum.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>type</literal></term>
                    <listitem>
                        <para>
                            This is the spectrum type. See the reference
                            documentation for a full list of the large set of
                            spectrum types SpecTcl supports.  Recall that
                            <literal>1</literal> means the spectrum is a
                            simple 1-d spectrum,
                            <literal>2</literal> means the spectrum is a simple
                            2-d spectrum and <literal>s</literal> means the
                            spectrum is a summary spectrum.  
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>parameter list</literal></term>
                    <listitem>
                        <para>
                            The list of parameters used to create the spectrum.
                            The actual organization of this list depends on the
                            spectrum type.  1-D spectra will just have a single
                            parameter.  2-D spectra will have 2 and summary
                            spectra will have the list of parameters on the X
                            axis of the spectrum.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>axis definitions</literal></term>
                    <listitem>
                        <para>
                            This is a list o axis definitions.  Each axis
                            definition is a three element list of
                            low limit, high limit and bins for the axis.
                        </para>
                        <para>
                            1-D spectra will have a single axis definition
                            that describes the limits and binning of the x axis.
                            2-D spectra will have two axis definitions;
                            the first for the X axis, the second for the Y axis.
                            summary spectra will also have a single axis definition
                            but this will define the binning on the y axis.
                        </para>
                        <para>
                            See the reference documentation for more about
                            the axis definitions for each spectrum type.  Note
                            again this element is a list of axis definitions,
                            even when there's only one definition.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>data type</literal></term>
                    <listitem>
                        <para>
                            The data type <literal>byte</literal>, <literal>word</literal>
                            or <literal>long</literal> used to store each channel
                            of the spectrum.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>applied gate</literal></term>
                    <listitem>
                        <para>
                            If <option>-showgate</option> was used, there will
                            be an additional list element that is the name of
                            the gate applied to the spectrum.  
                        </para>
                        <para>
                            Ungated spectra area actually gated on a gate that
                            is always true named <literal>-TRUE-</literal>.
                            This gate is created by SpecTcl automatically.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                The <command>spectrum</command> command can also be used
                to delete spectra.  Spectrum names are unique.  In order to redefine
                a spectrum, you must first delete it.  The form of the command
                to do this is:
            </para>
            <informalexample>
                <programlisting>
spectrum -delete spectrum-name
                </programlisting>
            </informalexample>
            <para>
                Where <parameter>spectrum-name</parameter> is the  name of the
                spectrum you want to delete.
            </para>
            <para>
                A command closely related to the <command>spectrum</command>
                command is <command>sbind</command>.   Recall that
                SpecTcl does not have an intrinsic visualizer, but has an external
                program, Xamine or the Root based Spectra.   In order to
                facilitate high speed transfer of bulk channel data from SpecTcl
                to these displayers, SpecTcl can place a spectrum's channel data
                into a shared memory region.
            </para>
            <para>
                The <command>sbind</command> command can bind a set of specific
                spectra or all spectra to shared memory.  Note that it is harmless
                to attempt to bind the same spectrum more than once to shared memory.
                The two forms of the <command>sbind</command> command are:
            </para>
            <informalexample>
                <programlisting>
sbind <option>-all</option>
sbind <parameter>name1</parameter> ?<parameter>name2...</parameter>
                </programlisting>
            </informalexample>
            <para>
                Where <parameter>name1</parameter> and so on are spectrum
                names.
            </para>
        </section>
        <section>
            <title>Defining and applying gates</title>
            <para>
                Recall that gates are conditions that can be applied to
                spectra.  When applied to a spectrum, that spectrum only increments
                for events that make the applied gate true.  This section will
                describe how to create, list and apply gates.  Note that unlike
                spectra, gates are mutable.   Defining a gate with the name
                of an existing gate is not an error but changes the definition
                of the existing gate.
            </para>
            <para>
                SpecTcl has two classes of gates.  Simple gates are those that
                are directly set on parameters (such as slices, contours or bands).
                Compound gates represent boolean operations perfromed on one or
                more other gates.  Compound gates allow you to define
                very complex conditions on spectra.
            </para>
            <para>
                The <command>gate</command> command allows you to create and modify
                gates.  The <command>apply</command> command allows you to
                apply a gate to one or more spectra, as well as to list the
                gate applications.
            </para>
            <note>
                <title>NOTE</title>
                <para>
                    Both the Xamine and Spectra visualizers allow you to
                    graphically create gates.   It is important to note that gates
                    are not <emphasis>defined</emphasis> on spectra but on
                    parameters.  The axes of the spectra on which a gate is
                    drawn determines the set of parameters on which it is
                    applied.
                </para>
            </note>
            <para>
                SpecTcl supports a very rich set of gate types.  In this
                section we're only going to look at using the command line
                to create slices, contours, and several types of compound gates.
            </para>
            <para>
                The form of the gate command that creates a new gate or modifies
                an existing gate is:
            </para>
            <informalexample>
                <programlisting>
gate <replaceable>name type description</replaceable>
                </programlisting>
            </informalexample>
            <para>
                The <parameter>name</parameter> parameter is the name of a new
                gate or the name of a gate whose definition will be modified.
                <parameter>type</parameter> is the type of the gate (it is possible
                to change the type of an existing gate).
                <parameter>description</parameter> is a descsription of the gate.
                The gate description is a Tcl list whose contents depend on the
                type of gate being created.   As usual, see the reference information
                for more information about gate types and their description lists.
            </para>
            <formalpara>
                <title>Slice gates</title>
                <para>
                    Slice gates or cuts represent a region of interest in a
                    single parameter.  Both Xamine and Spectra allow you to
                    graphically define slices.
                </para>
            </formalpara>
            <itemizedlist>
                <listitem>
                    <para>
                        The gate type for a slice is <literal>s</literal>. The
                        description is a two element Tcl list.  The first
                        elemment is the name of the parameter on which the
                        slice is set.  The second element is a two element
                        list that contains the lower and upper limits of the
                        gate.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The gate is true for any event where that parameter is
                        defined and lies between the gate limits inclusive.
                    </para>
                </listitem>
            </itemizedlist>
            <example>
                <title>Creating a slice gate from the command line</title>
                <programlisting>
gate gdr s {energy {100 350}}
                </programlisting>
            </example>
            <formalpara>
                <title>Contour Gates</title>
                <para>
                    Contour gates represent two dimensional areas of interest.
                    A contour gate is set on two parameters, an X and Y
                    parameter and is true for all events that define both
                    parameters and for which the parameters fall inside the
                    contour.  
                </para>
            </formalpara>
            <para>
                Note that insidedness is well defined even for unusual
                contours (e.g. multi-lobed contours or contours that wind).
                A point is inside a contour if a line drawn in any direction
                from the point crosses an odd number of boundaries.  It is
                outside if a line drawn in any direction crosses an even number
                of boundaries (<literal>0</literal> is considered even).
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        <literal>c</literal> is the type code for a contour.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The description is  three element Tcl list.  The
                        first element is the name of the X parameter.  The
                        second element is the name of the Y parameter.  The
                        third element is, itself a list.
                    </para>
                    <para>
                        Elements of the third element are themselves two
                        element lists that represent the coordinates of the
                        vertices of the contour.
                    </para>
                </listitem>
            </itemizedlist>
            <example>
                <title>Creating a contour gate</title>
                <programlisting>
gate alphas c {X TOF {{10 10 } {200 10} {200 200} {10 200}}}}
                </programlisting>
            </example>
            <formalpara>
                <title>Compound gates</title>
                <para>
                    Compound gates should be thought of as boolean operations performed
                    on previously defined gates.  Note that one or more of the
                    previously defined gates can be compound gates as well.
                    This nesting allows you to build up arbitrarily complex
                    logical conditions.
                </para>
            </formalpara>
            <para>
                The description of a compound gate is simply the list of gates
                that make up the compound gate.
                These gates are called <firstterm>member gates</firstterm>.
                The following compound
                gate types are the most common.  See the reference material
                for a complete list of gate types and their representations.
            </para>

            <variablelist>
                <varlistentry>
                    <term><literal>-</literal> - not gate</term>
                    <listitem>
                        <para>
                            Not gates only operate on a single gate.  The
                            resulting gate inverts the sense of the member gate.
                            That is the not gate is true only if the member gate
                            is false.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>*</literal> - and gate</term>
                    <listitem>
                        <para>
                            The resulting gate is true only if
                            <emphasis>all</emphasis> member gates
                             are true.  This represents the boolean and
                             of the gates.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>+</literal> - or gate</term>
                    <listitem>
                        <para>
                            The resulting gate is true if <emphasis>any</emphasis>
                            of the member gates is true.  This represents the
                            boolean or of the gates.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <example>
                <title>Sample compound gates</title>
                <programlisting>
gate real - background
gate anyAlpha + {alpha1 alpha2 alpha3 alpha4}
gate 30MeVAlpha * {alpha 30Mev}
                </programlisting>
            </example>
            <formalpara>
                <title>listing gates</title>
                <para>
                    As with the <command>parameter</command> command,
                    the <command>gate</command> command can be given a
                    <option>-list</option> option.  When this is done, the
                    command lists all or some of the gates that are currently defined.
                </para>
            </formalpara>
            <para>
                The form of this command is:
            </para>
            <informalexample>
                <programlisting>
gate <option>-list</option> ?<replaceable>pattern</replaceable>>
                </programlisting>
            </informalexample>
            <para>
                The optional pattern specifies a gate name pattern that must
                be matched to list the gate.   The pattern can contain all of
                the wild card characters that are used in Unix shell filename
                patterns (glob pattern).
            </para>
            <para>
                The returned value from the command is a Tcl list whose elements
                describe a gate.  The gate descriptions are themselves
                Tcl lists that contain the following elements:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        <literal>name</literal> the name of the gate.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>id</literal> a numeric id for the gate.  This
                        is relatively useless for users.  The name of the
                        gate is used to refer to the gate within SpecTcl.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>type</literal>  The gate type character.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>description</literal>  The gate description.
                        The contents of this Tcl list depend on the gate type
                        but is the same as the description used to create the
                        gate.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                There is also a <command>gate</command> <option>-delete</option>
                form of the command.  This accepts a list of gates that are
                "deleted".  In order to provide uniform, predictable behavior
                in compound gates that depend on gates that are deleted, gates
                are not actually deleted but replaced with a
                <literal>false</literal> gate.  A false gate is never true.
            </para>
            <formalpara>
                <title>Applying gates</title>
                <para>
                    Gates are only useful when applied to one or more spectra.
                    A spectrum will only increment if sufficient parameters exist
                    for the spectrum and the gate applied to it is true for
                    that event.
                </para>
            </formalpara>
            <para>
                The <command>apply</command> command applies gates to
                spectra.  It looks like this:
            </para>
            <informalexample>
                <cmdsynopsis>
                    <command>
apply <replaceable>gatename spec1 ?spec2 ...?</replaceable>                        
                    </command>
                </cmdsynopsis>
            </informalexample>
            <para>
                Where <parameter>gatename</parameter> is the name of a gate and
                the remaining parameters are names of spectra the gate will be
                applied to.  If a spectrum already has a gate applied,
                this replaces that gate.  A spectrum can only have one gate at
                a time applied to it.
            </para>
        </section>
        <section>
            <title>
                Tailoring a new SpecTcl skeleton
            </title>
            <para>
                SpecTcl is a framework, not a complete program.  The process
                of preparing a version of SpecTcl that is specialized to your
                data is called <firstterm>Tailoring</firstterm>. The result
                of this process is called a <firstterm>Tailored SpecTcl</firstterm>.
                This chapter provides an overview of the tailoring process.
                For more information, see the SpecTcl programming guide and
                the SpecTcl programming reference.
            </para>
            <para>
                In this section, we'll introduce:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        Obtaining a starting point for tailoring.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Event processors and how they see parameters and
                        tree parameters.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        How to write an event processor.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        How to set up SpecTcl's pipeline of event processors
                    </para>
                </listitem>
                <listitem>
                    <para>
                        How to modify the skeleton Makefile to incorporate your
                        software into the build of your tailored SpecTcl.
                    </para>
                </listitem>
            </itemizedlist>
            <section>
                <title>The SpecTcl skeleton</title>
                <para>
                    Our discussion of SpecTcl tailoring assumes you are starting
                    from scratch.  More likely, if you are part of an
                    extablished research group, you can start from one or more
                    existing tailored SpecTcls.  Work with your group to start
                    from that SpecTcl.
                </para>
                <para>
                    SpecTcl installation provides a starting point for
                    building a tailored SpecTcl.  This starting point is called
                    the <firstterm>SpecTcl Skeleton</firstterm>.  It is located in
                    the <filename>Skel</filename> directory of the SpecTcl
                    installation directory.  At the NSCL,
                    <filename>/usr/opt/spectcl/current</filename> is a symbolic
                    link that points to the version of SpecTcl we recommend for
                    use in new applications.
                </para>
                <para>
                    If you are starting fresh, your first step is to obtain
                    a copy of the SpecTcl skeleton.  We want to put that into
                    an empty directory:
                </para>
                <informalexample>
                    <programlisting>
<command>mkdir myspectcl</command>
<command>cp /usr/opt/spectcl/current/Skel/* .</command>
<command>cd    myspectcl</command>
                    </programlisting>
                </informalexample>
                <para>
                    The skeleton provides the following files;
                </para>
                <variablelist>
                    <varlistentry>
                        <term><filename>MySpecTclApp.h</filename></term>
                        <listitem>
                            <para>
                                Header file for the class that you must fill
                                in to configure SpecTcl.  SpecTcl is an application
                                framework.  This means that you don't have a
                                <function>main</function> function.  You have an
                                <firstterm>Application Object</firstterm> that
                                sets up your part of SpecTcl and then the framework
                                calls your code at appropriate times.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><filename>MySpecTclApp.cpp</filename></term>
                        <listitem>
                            <para>
                                Implementation of the application class that you
                                must fill in to configure SpecTcl.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><filename>Makefile</filename></term>
                        <listitem>
                            <para>
                                A starting point for a Makefile to build
                                SpecTcl.  As you add compilation modules, you'll
                                need to modify this Makefile to reflect this.
                                The Makefile is built so that this should be
                                easy, even if you are not familiar with
                                <application>make</application> and Makefiles.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><filename>SpecTclRC.tcl</filename></term>
                        <listitem>
                            <para>
                                This is a starting point for a SpecTcl startup
                                script.  Recall that the Tcl in SpecTcl stands
                                for the Tcl scripting language.  This script sets
                                up the default user interface environment.
                            </para>
                            <para>
                                For more about startup scripts see:
                                <link linkend='chap.startup' endterm='chap.startup.title' />
                                For more about scripting SpecTcl, see:
                                <link linkend='chap.scripting' endterm='chap.scripting.title' />
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    If you run <command>make</command> to build the SpecTcl
                    distributed from the <filename>Skel</filename> directory,
                    you will wind up with what us developers call
                    <firstterm>plain vanilla SpecTcl</firstterm>.  Several
                    parameters will be defined and a test event generator
                    can be started (with the <command>start</command> command)
                    so that you can play with SpecTcl's user interface and
                    visualization tools.
                </para>
            </section>
            <section>
                <title>Event processors, parameters and tree parameters</title>
                <para>
                    The main job of tailoring SpecTcl consists of providing
                    code that takes a raw event and turns it into a set of
                    parameters.  SpecTcl does this by allowing you to register
                    a set of <firstterm>event processors</firstterm> and
                    invoking them in the order registered.  This ordered list
                    of event processors, sometimes called unpackers, is
                    called SpecTcl's <firstterm>analysis pipeline</firstterm>.
                </para>
                <para>
                    The term analysis pipeline is intended to make you think about
                    how to organize your event processors so that, via sequential
                    steps, you take the raw event and produce the parameters
                    you of interest.  Each stage of this pipeline makes
                    available not only the raw event, but the results of
                    previous pipeline stages.
                </para>
                <para>
                    When planning your event processors,
                    remember, simple software is easier to debug than complex
                    and small functions are easier to debug than long.
                </para>
                <para>
                    Event processors are created by making a derived class
                    from the <classname>CEventProcessor</classname> base class.
                    This base class is defined in <filename>EventProcessor.h</filename>.
                    This and all SpecTcl headers are in the <filename>include</filename>
                    subdirectory of your SpecTcl installation.
                </para>
                <para>
                    Here's the important part of that header:
                </para>
                <example>
                    <title>CEventProcessor base class definition</title>
                    <programlisting>
class CEventProcessor {
 public:
  virtual Bool_t operator()(const Address_t pEvent,
                            CEvent&amp; rEvent,
                            CAnalyzer&amp; rAnalyzer,
                            CBufferDecoder&amp; rDecoder); // Physics Event.

  virtual Bool_t OnAttach(CAnalyzer&amp; rAnalyzer); // Called on registration.
  virtual Bool_t OnBegin(CAnalyzer&amp; rAnalyzer,
p
                         CBufferDecoder&amp; rDecoder); // Begin Run.
  virtual Bool_t OnEnd(CAnalyzer&amp; rAnalyzer,
                       CBufferDecoder&amp; rBuffer); // End Run.
  virtual Bool_t OnPause(CAnalyzer&amp; rAnalyzer,
                         CBufferDecoder&amp; rDecoder); // Pause Run.
  virtual Bool_t OnResume(CAnalyzer&amp; rAnalyzer,
                          CBufferDecoder&amp; rDecoder); // Resume Run.
  virtual Bool_t OnOther(UInt_t nType,
                         CAnalyzer&amp; rAnalyzer,
                         CBufferDecoder&amp; rDecoder); // Unrecognized buftype.

  virtual Bool_t OnEventSourceOpen(std::string name);
  virtual Bool_t OnEventSourceEOF();
  virtual Bool_t OnInitialize();
};

                    </programlisting>
                </example>
                <para>
                    As you can see from the function names, the event
                    processor provides methods that are called at well
                    defined points in data analysis.  For example,
                    <methodname>OnBegin</methodname> is called when
                    a begin run item is seen in the data source.
                </para>
                <para>
                    The only method you normally have to fill in is
                    the function call operator <methodname>operator()</methodname>.
                    Let's look at the parameters passed to this method:
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <type>const Address_t</type> <parameter> pEvent</parameter>
                        </term>
                        <listitem>
                            <para>
                                This parameter points to the raw event.  What
                                this looks like depends on two things; the readout
                                you actually use and the way the buffer decoder
                                strips event out of the stream of encapsulated
                                events from the underlying data acquisition system.
                            </para>
                            <para>
                                For NSCLDAQ-11.x events, you will get a pointer
                                to the body of the event (not the body header).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>CEvent&amp; </type> <parameter>rEvent</parameter></term>
                        <listitem>
                            <para>
                                Recall that SpecTcl's raw parameter model is
                                a flat array of parameters.  In this model,
                                the parameter id is the index into this array.
                                <classname>CEvent</classname> is an array like
                                object (supports indexing) that expands as needed
                                depending on how it's indexed.  <parameter>rEvent</parameter>,
                                therefore is the raw parameter array for this
                                event.
                            </para>
                            <para>
                                <classname>CEvent</classname> contains elements
                                of the class <classname>ValidValue</classname>.
                                These elements can be treated as if they were
                                <type>double</type>s.  They also record whether or
                                not they've been assigned a value and have
                                a <methodname>isValid</methodname> 
                            </para>
                            <para>
                                If you decided to use the tree parameter framework,
                                you must create the appropriately named
                                <classname>CTreeParameter</classname>
                                 <classname>CTreeParameterArray</classname> objects.
                                 Each element of these can also be treated as a
                                 <type>double</type> and has an
                                 <methodname>isValid</methodname> method.
                                 We'll see more about this later when we
                                look at an example event processor.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>CAnalyzer&amp; </type>rAnalyzer</term>
                        <listitem>
                            <para>
                                SpecTcl's analyzer directs the flow of control
                                for data analysis.   It's the object that
                                actually calls your event processors and
                                the object that calls the histogrammer to
                                process the events you produced.
                            </para>
                            <para>
                                For the most part you don't need to be concerned
                                with the anaylzer, however at least one of your
                                event processors must invoke the analyzer's
                                <methodname>SetEventSize</methodname> method.
                                This method tells the analyzer how many bytes
                                large the raw event occupies so that the
                                buffer decoder and event processor know how
                                to find the next event given this one.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>CBufferDecoder&amp; </type>rDecoder</term>
                        <listitem>
                            <para>
                                The buffer decoder is the SpecTcl object that
                                is responsible for breaking up larger units
                                of data into events and other item types.
                                In many cases you won't need to do anything
                                with this.
                            </para>
                            <para>
                                An exception is when you need to inspect information
                                in the body header of an event (the buffer decoder
                                object is then an instance of <classname>CRingBufferDecoder</classname>).
                                In that cast you can use
                                <methodname>hasBodyHeader</methodname> to determine
                                if there is a body  header and <methodname>getBodyHeaderPointer</methodname>
                                to retrieve  a pointer to the body header.
                            </para>
                        </listitem>
                    </varlistentry>
                            
                </variablelist>
                <para>
                    Let's look at two simple event processors.  The first one
                    unpacks a fixed length event into a sequential set of
                    raw event array parameters.  The second one shows how to
                    do the same unpacking with tree parameters.  We're going
                    to assume that the first 16 bit element of the raw
                    event is the number of 16 bit words in the event (self inclusive)
                    and that all of the parameters are 16 bit integers.
                </para>
                <para>
                    The differences betwee these two event processors is only
                    in the implementation file.  Both share a common header
                    which we'll call SimpleEvp.h:
                </para>
                <example>
                    <title>Sample Event processor header</title>
                    <programlisting>
#ifndef SIMPLEEVP_H
#define SIMPLEEVP_H                     <co id='evp.h.guard' />
#include &lt;config.h&gt;                     <co id='evp.h.config'/>
#include &lt;EventProcessor.h&gt;             <co id='evp.h.baseinc' />



class SimpleEventProcssor : public CEventProcessor  <co id='evp.h.classdecl' />
{
public:
  Bool_t operator()(const Address_t pEvent, CEvent&amp; rEvent,   <co id='evp.h.fcnoperator' />
                    CAnalyzer&amp; rAnalyzer, CBufferDecoder&amp; rDecoder);
};



#endif

                    </programlisting>
                </example>
                <calloutlist>
                    <callout arearefs='evp.h.guard'>
                        <para>
                            Best practices call for header files to be guarded
                            against multiple inclusion like this.  The first time
                            the header is included,
                            <literal>SIMPLEEVP_H</literal>is not defined
                            and therefore the body of the <literal>#ifndef</literal>
                            is executed.  That defines <literal>SIMPLEEVP_H</literal>
                            so that subsequent includes of this file won't
                            double define anything.
                        </para>
                    </callout>
                    <callout arearefs='evp.h.config'>
                        <para>
                            The <filename>config.h</filename> contains definitions
                            of data types and preprocessor symbols that all
                            SpecTcl headers may need.  Its inclusion should be
                            the first thing the header does once it's passed its
                            guard.
                        </para>
                    </callout>
                    <callout arearefs='evp.h.baseinc'>
                        <para>
                            Our class, <classname>SimpleEventProcessotr</classname>
                            extends the base class <classname>CEventProcessor</classname>.
                            Doing so requires knowing the shape of the base class.
                            The <filename>EventProcessor.h</filename> header
                            provides this definition.
                        </para>
                    </callout>
                    <callout arearefs='evp.h.classdecl'>
                        <para>
                            This line defines our new class as one derived from,
                            or extending <classname>CEventProcessor</classname>.
                        </para>
                    </callout>
                    <callout arearefs='evp.h.fcnoperator'>
                        <para>
                            We need to indicate that we are overriding the
                            function call operator (<methodname>operator()</methodname>).
                            This declaration does that.  The function call operator
                            is invoked once per physics event.
                        </para>
                    </callout>
                </calloutlist>
                <para>
                    Let's look at an implementation of <classname>SimpleEventProcessor</classname>
                    that uses the SpecTcl raw parameter array.  This is passed
                    to the function call operator as the
                    <parameter>rEvent</parameter> parameter. We are going to
                    make a few simplifications:
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            We assume that parameters have been declared consecutively starting
                            at parameter id 0>
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            We assume that we know that the byte ordering of the
                            system that generated the data is the same as
                            the byte ordering of the system running SpecTcl.
                            There are facilities to do transparent byte ordering
                            (<classname>TranslatorPointer</classname> e.g.)
                            which, for the sake of simplicity won't be used in this
                            example.
                        </para>
                    </listitem>
                </itemizedlist>
                <para>
                    The file <filename>SimpleRaw.cpp</filename> implements
                    the event processor for the raw event array:
                </para>
                <example>
                    <title>Simple Event processor for raw parameter arrays</title>
                    <programlisting>
#include "SimpleEvp.h"
#include &lt;stdint.h&gt;
#include &lt;TCLAnalyzer.h&gt;


Bool_t
SimpleEventProcessor::operator()(const Address_t pEvent, CEvent&amp; rEvent,
                                 CAnalyzer&amp; rAnalyzer, CBufferDecoder&amp; rDecoder)
{
  uint16_t* params   = reinterpret_cast&lt;uint16_t*&gt;(pEvent);    <co id='simple.raw.ptr' />
  CTclAnalyzer&amp; ana = reinterpret_cast&lt;CTclAnalyzer&amp;>&gt;(rAnalyzer); <co id='simple.raw.tclanalyzer' />
  uint32_t nWords = *params++;                                       <co id='simple.raw.size' />
  ana.SetEventSize(nWords*sizeof(uint16_t));                         <co id='simple.raw.setsize' />

  nWords--;

  for (unsigned  i =  0; i &lt; nWords; i++) {
    rEvent[i] = *params++;                                          <co id='simple.raw.store' />
  }



  return kfTRUE;                                                <co id='simple.raw.return' />
}

                    </programlisting>
                </example>
                <calloutlist>
                    <callout arearefs='simple.raw.ptr'>
                        <para>
                            <type>Address_t</type> is a typedef for
                            <type>void*</type>.  This line turns it into a
                            pointer to unsigned 16 bit integers as our
                            data consists entirely of 16 bit unsigned integers.
                        </para>
                    </callout>
                    <callout arearefs='simple.raw.tclanalyzer'>
                        <para>
                            One of the things we must do is report the event
                            size, in bytes to the analyzer.  It turns out the
                            analyzer is actually a <classname>CTclAnalyzer</classname>.
                            This line converts the reference to the generic
                            <classname>CAnalyzer</classname> base class into
                            a reference to the specialized <classname>CTclAnalyzer</classname>.
                        </para>
                    </callout>
                    <callout arearefs='simple.raw.size' >
                        <para>
                            Extracts the event size.
                        </para>
                    </callout>
                    <callout arearefs='simple.raw.setsize'>
                        <para>
                            Tells the analyzer how big the event is. Note that
                            the event size is in self including 16 bit entities.
                            That's why there's a scaling and why the word count
                            is subsequently deremented to give the number of
                            remaining words in the event.
                        </para>
                    </callout>
                    <callout arearefs='simple.raw.store'>
                        <para>
                            This loop saves the parameters in sequential
                            elements of the parameter array.
                        </para>
                    </callout>
                    <callout arearefs='simple.raw.return'>
                        <para>
                            Event processors return a <type>Bool_t</type>.
                            If the value returned is <literal>kfTRUE</literal>,
                            processing continues.  If <literal>kfFALSE</literal>
                            is returned, event processing is aborted (no more
                            pipeline elements are called) and the parameters
                            from this event are not submitted to the histogram.
                        </para>
                        <para>
                            A common error is to forget to return a value when
                            <literal>kfTRUE</literal> is intended.  In that
                            case, the return value is random (event by event) and the event processor
                            may appear to work but actually some fraction of the
                            events won't get histogrammed.
                        </para>
                    </callout>
                </calloutlist>
                <para>
                    Let's see what this looks like if we use Tree parameters.
                    The resulting file will be called  SimpleTree.cpp:
                </para>
                <example>
                    <title>SimpleTree.cpp - Event processor using tree parameters</title>
                    <programlisting>
#include "SimpleEvp.h"
#include &lt;stdint.h&gt;
#include &lt;TCLAnalyzer.h&gt;
#include &lt;TreeParameter.h&gt;                 <co id='simple.tree.includes' />


// Has a maximum of 10 parameters:

CTreeParameterArray Parameters("raw", 1024, 0.0, 1023.0, "arbitrary", 10, 0); <co id='simple.tree.array' />


Bool_t
SimpleEventProcessor::operator()(const Address_t pEvent, CEvent&amp; rEvent,
                                 CAnalyzer&amp; rAnalyzer, CBufferDecoder&amp; rDecoder)
{
  uint16_t* params   = reinterpret_cast&lt;uint16_t*&gt;(pEvent);
  CTclAnalyzer&amp; ana = reinterpret_cast&lt;CTclAnalyzer&amp;&gt;(rAnalyzer);
  uint32_t nWords = *params++;
  ana.SetEventSize(nWords*sizeof(uint16_t));

  nWords--;

  if (nWords &gt; 10) {                         <co id='simple.tree.sizelimit' />
    nWords = 10;
  }

  for (unsigned i = 0; i &lt; nWords; i++) {
    Parameters[i] = *params++;                  <co id='simple.tree.store' />
  }

  return kfTRUE;


}
                    </programlisting>
                </example>
                <calloutlist>
                    <callout arearefs='simple.tree.includes'>
                        <para>
                            There are a cluster of headers for the tree parameter
                            and tree variable subsystem.  These are all included
                            by the <filename>TreeParamter.h</filename> header
                            included here.
                        </para>
                    </callout>
                    <callout arearefs='simple.tree.array'>
                        <para>
                            This declaration creates an tree parameter array.
                            This is an array like object of 10 elements indexed
                            starting with 0.  The parameters will be named
                            <literal>raw.00</literal>, <literal>raw.01</literal>
                            ... <literal>raw.09</literal>.
                        </para>
                        <para>
                            The declaration specifies a suggested axis that goes
                            from <literal>0</literal> through <literal>1023</literal>
                            with 1024 bins, suitable for an integer in the range
                            of <literal>[0, 1024)</literal>.
                        </para>
                        <para>
                            The units are specified as <literal>arbitrary</literal>.
                        </para>
                        <para>
                            In the original versions of Tree parameter, event
                            processors would have to invoke the
                            <methodname>Reset</methodname> method on
                            tree parameters and arrays to bind them to their
                            underlying raw parameters before processing events.
                            When integrating tree parameters with SpecTcl, this
                            reset operation was moved into the SpecTcl framework.
                        </para>
                        <para>
                            You may still see code that invokes <methodname>Reset</methodname>
                            and this is harmless.
                        </para>
                    </callout>
                    <callout arearefs='simple.tree.sizelimit'>
                        <para>
                            Our declaration has only provided for up to 10 parameters.
                            Therefore if more than 10 parameters are present,
                            this code limits processing to the first
                            10.
                        </para>
                        <para>
                            In practice the fact that tree parameters are fixed
                            sized events is not a limitation because detector systems
                            tend to be fixed sized and, in any event, the parameters
                            must be named at some point.
                        </para>
                    </callout>
                    <callout arearefs='simple.tree.store'>
                        <para>
                            Stores the data into the tree parameter array.
                        </para>
                    </callout>
                </calloutlist>
            </section>
            <section>
                <title>
                    Setting up the event processing pipeline
                </title>
                <para>
                    Once the event processor has been written, SpecTcl must be
                    told to call an instance of it when events are available to be
                    processed.  This requires modifying the
                    <filename>MySpecTclApp.cpp</filename> file provided by the
                    skeleton:
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            The appropriate header file must be included so that
                            the class definition is available to
                            <filename>MySpecTclApp.cpp</filename>
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Sample code must be removed so that it does not
                            interfere with your application.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            An instance of your event processor must be
                            added to the event analysis pipeline.
                        </para>
                    </listitem>
                </itemizedlist>
                <para>
                    The first of thse steps, adding an <literal>#include</literal>
                    is pretty self explanatory;  In <filename>MySpecTclApp.cpp</filename>
                    locate the block of include directives at the top of the file.
                    Add one for your event processor.
                </para>
                <para>
                    This is shown for our simple event processor below:
                </para>
                <informalexample>
                    <programlisting>
#include &lt;config.h&gt;
#include "MySpecTclApp.h"
#include "EventProcessor.h"
#include "TCLAnalyzer.h"
#include &lt;Event.h&gt;
#include &lt;TreeParameter.h&gt;          // Add this if you use tree parameters.
#include "SimpleEvp.h"                    // Header for our event processor.
#ifdef HAVE_STD_NAMESPACE
using namespace std;

                    </programlisting>
                </informalexample>
                <para>
                    A large chunk of code in <filename>MySpecTclApp.cpp</filename>
                    represents an example.  These lines should be removed.
                    Delete the lines from the comment:
                    <literal>//  Local Class definitions:</literal> until the
                    comment block that describes
                    <methodname>CreateAnalysisPipeline</methodname>. 
                </para>
                <para>
                    This makes the code above look something like:
                </para>
                <informalexample>
                    <programlisting>

...
#include "SimpleEvp.h"
#ifdef HAVE_STD_NAMESPACE
using namespace std;
#endif


//  Function:
//    void CreateAnalysisPipeline(CAnalyzer&amp; rAnalyzer)
//  Operation Type:
//     Override
/*
...
                    </programlisting>
                </informalexample>
                <para>
                    Remove all code frrom the body of
                    <methodname>CreateAnalysisPipeline</methodname> as well.
                    Add a line to that body that looks like:
                </para>
                <informalexample>
                    <programlisting>
  RegisterEventProcessor(*(new SimpleEventProcessor), "MyUnpacker");

                    </programlisting>
                </informalexample>
                <para>
                    This adds an event processor to the back of the event
                    analysis pipeline.  The first parameter is a reference to
                    an object from a class derived from
                    <classname>CEventProcessor</classname>.   The second
                    parameter is a name you can assign to this processor.
                </para>
                <para>
                    If SpecTcl detects error while running code in your
                    event processor, it will include this name with your error
                    message.   Furthermore the SpecTcl API (see the
                    programmer's reference manual) provides API methods that
                    allow you to locate event processors by name so that you
                    can control the order of the pipeline if needed.
                </para>
                
            </section>
            <section>
                <title>Building your tailored SpecTcl</title>
                <para>
                    Building the tailored SpecTcl is an iterative process.
                    First the <filename>Makefile</filename> must be modified
                    to add any additional modules you've written (like your
                    event processor) to the build.  Next you iteratively attempt to
                    use <command>make</command> to build SpecTcl and fix errors
                    the compiler and linker point out to you.
                </para>
                <para>
                    In this section we'll point out the most likely bits and
                    pieces of the <filename>Makefile</filename> you will need
                    to modify.
                </para>
                <formalpara>
                    <title>The OBJECTS definition<literal></literal></title>
                    <para>
                        The <literal>OBJECTS</literal> symbol in the Makefile
                        should be a space separated list of the names of
                        object modules you want to produce.  Unless you want
                        to provide your own build rules, these should just be
                        the name of the CPP file with .o as the extension.
                    </para>
                </formalpara>
                <para>
                    If we choose to use the tree parameter event processor
                    in our build.  The <literal>OBJECTS</literal> definition
                    would look like:
                </para>
                <informalexample>
                    <programlisting>
OBJECTS=MySpecTclApp.o SimpleTree.o
                    </programlisting>
                </informalexample>
                <formalpara>
                    <title>Compilation switches</title>
                    <para>
                        Sometimes it's necessary to add compilation switches
                        to the build.  For example, you may need to specify
                        another include file directory to be searched.
                        The <literal>USERCXXFLAGS</literal> symbol in the
                        Makefile allows you to add to the compilation switches.
                    </para>
                </formalpara>
                <formalpara>
                    <title>Link/loader switches</title>
                    <para>
                        Similarly, the <literal>USERLDFLAGS</literal>
                        symbol allows you to add switches to the link command.
                    </para>
                </formalpara>
            </section>
        </section>
        <section>
            <title>Data sources</title>
            <para>
                The purpose of SpecTcl is to analyze data so no 'getting started'
                chapter would be complete without some discussion of data sources.
                The SpecTcl GUI
                (<link linkend='chap.gui' endterm='chap.gui.title' />)
                will say a bit more about data sources.  Here we
                introduce:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        The two types of data sources SpecTcl can analyze from.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        How to connect SpecTcl to a data source
                    </para>
                </listitem>
                <listitem>
                    <para>
                        How to control analysis of data from the source.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                SpecTcl can connect to two types of data sources:
            </para>
            <orderedlist>
                <listitem>
                    <para>
                        Files visible to the filesystem of the computer
                        in which SpecTcl runs.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Programs that send data to SpecTcl along a Unix pipeline.
                    </para>
                </listitem>
            </orderedlist>
            <para>
                Note that SpecTcl is data acquisition system neutral.  It therefore
                has no way to directly connect to an online data acquisition systems.
                To connect SpecTcl to a data acquisition system, you need to have
                a program that connects to that system and outputs data received
                from the system to its standard output.  Connecting that program
                as a pipe data source will give access to online data.
            </para>
            <para>
                NSCLDAQ provides a program; <filename>ringselector</filename>
                that can be used as a pipe data source for SpecTcl.
                <footnote>
                    <para>
                        Technically, <filename>ringtostdout</filename> could be
                        used as a pipe data source but <filename>ringselector</filename>
                        provides the mechanics to allow SpecTcl to sample the
                        data if it is not able to keep up with the online rate.
                    </para>
                </footnote>
            </para>
            <para>
                Tailoring SpecTcl to analyze data from systems other
                than NSCLDAQ is beyond the scope of this document.  It can and
                has been done for two non-NSCL systems that I know of
                (IUCF XSYS and Lucid from Univ. of Saskatchewan). 
            </para>
            <para>
                Three commands control data source selection and analysis from
                data sources.  Data source selection in SpecTcl is called
                attaching.
            </para>
            <para>
                The <command>attach</command> command:
            </para>
            <orderedlist>
                <listitem>
                    <para>
                        Stops any analysis in progress
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Disconnects SpecTcl from any data source it is currently
                        connected to.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Connects SpecTcl to the data source specified by the
                        <command>attach</command> command.
                    </para>
                </listitem>
            </orderedlist>
            <para>
                Note that <command>attach</command> does <emphasis>not</emphasis>
                start analyzing data from the event source. The <command>start</command>
                command starts analyzing data from a data source.  Data will be
                analyzed until one of the three conditions is true:
            </para>
            <orderedlist>
                <listitem>
                    <para>
                        An end file is detected on the data source.  For
                        pipe data sources this means the program on the other
                        end of the pipe has exited.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The <command>stop</command> command is issued, which
                        stops analyzing data from the data source (
                        <command>start</command> can restart analysis
                        ).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The <command>attach</command> is issued.
                    </para>
                </listitem>
            </orderedlist>
            <para>
                For details on the <command>attach</command> command, which
                can be rather complex, see the command reference.  Here are
                some simple examples however:
            </para>
            <example>
                <title>Sample attach commands</title>
                <synopsis>
                    <cmdsynopsis>
<command>attach <option>-file -format</option> ring  /projects/myexperiment/myevents/run-0010-00.evt</command>
                    </cmdsynopsis>
                    <cmdsynopsis>
<command>attach <option>-pipe -format</option> ring /usr/opt/daq/current/bin/ringselector --sample=PHYSICS_EVENT --non-blocking</command>
                    </cmdsynopsis>
                </synopsis>
            </example>
            <para>
                The first example attaches the file <filename>/projects/myexperiment/myevents/run-0010-00.evt</filename>
                as the data source. The file is from nscldaq-10.0 or later (ring buffer format).
            </para>
            <para>
                The second command attaches to the data acquisition system
                via  pipe data source (<filename>ringselector</filename>), the
                data acquisition system is, again, version 10.0 or higher as
                the format of the data is ringbuffer.
            </para>
            <para>
                Note that NSCLDAQ currently has two versions of the ring buffer
                DAQ system; 10.x and 11.x or higher.  If you attach to a file,
                or attach to an online system prior to the start of a run,
                SpecTcl can figure out which version you've attached automatically.
                If, however you attach to an online run in progress, prior
                to the <command>start</command> command you must use the
                <command>ringformat</command> to tell SpecTcl the NSCLDAQ version
                for example:
            </para>
            <informalexample>
                <synopsis>
                    <cmdsynopsis>
<command>ringformat 11.0</command>
                    </cmdsynopsis>
                </synopsis>
            </informalexample>
            <para>
                Says the data source provides data from nscldaq 11.0 or higher.
            </para>
        </section>
    </chapter>
    <chapter id='chap.filters'>
        <title id='chap.filters.title'>Using event filters</title>
        <para>
            Event filters are a SpecTcl object that can drastically improve performance
            if your analysis requires several passes over the data and/or
            progressively reduces the set of parameters and events you care about.
            Performance is improved by writing an event file that can usually
            be decoded much more efficiently than most raw event files.
        </para>
        <para>
            This chapter:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Describes exactly what a filter is.
                </para>
            </listitem>
            <listitem>
                <para>
                    Describes the <command>filter</command> command and how to
                    use it to create and manipulate filters.
                </para>
            </listitem>
            <listitem>
                <para>
                    Describes what you have to do to the event processing
                    pipeline to read/process filter files.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            A filter is a list of parameters, an output file and a gate.
            When a filter is specified and enabled (filters can be
            enabled or disabled), for every event that satisies the gate, the
            parameters specified by the filter are written to disk.  The
            output format is one which is self describing and easy to process
            back ito parameters.
        </para>
        <para>
            The <command>filter</command> command creates and manipulates filters.
            Making a filter usable is a multi step operation:
        </para>
        <orderedlist>
            <listitem>
                <para>
                    The filter must be created, specifying the gate that will
                    determine which events are output (note you can use a
                    <literal>True</literal> gate to output all events), and
                    the set of parametesr to be output.
                </para>
            </listitem>
            <listitem>
                <para>
                    The filter must be associated with an output file.  This
                    is the file to which the filter will write event data.
                </para>
            </listitem>
            <listitem>
                <para>
                    The filter must be enabled.
                </para>
            </listitem>
        </orderedlist>
        <para>
            Note that the filter does not respect run boundaries.  It's up to you
            or your  analysis script to disable a filter attach to a diferent
            file and re-enable as desired.  This allows the data from several
            runs to be collected into a filter if desired.  This is an intentional
            design choice.
        </para>
        <para>
            To create a filter:
        </para>
        <informalexample>
            <programlisting>
<command>filter</command> <option>-new</option> <replaceable>name gate parameters</replaceable>
            </programlisting>
        </informalexample>
        <variablelist>
            <varlistentry>
                <term><parameter>name</parameter></term>
                <listitem>
                    <para>
                        Is the name given to the filter.  In all subsequent
                        commands, this name must be used to select this filter.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><parameter>gate</parameter></term>
                <listitem>
                    <para>
                        Name of the gate that determines which events produce
                        output.  To output all events you can use a
                        <literal>True</literal> gate.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><parameter>parameters</parameter></term>
                <listitem>
                    <para>
                        This is a well formed Tcl list of the names of the
                        parameters to output to file for each event that
                        satisfies the <parameter>gate</parameter>.  See
                        <link linkend='chap.scripting' endterm='chap.scripting.title' />
                        for information about how to script SpecTcl so that you
                        don't have to type this in.  See
                        <link linkend='chap.gui' endterm='chap.gui.title' />
                        for a description of the SpecTcl default user interface
                        whih includes a GUI for defining and manipulating filters.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            Once the filter has been created it must be associated with an output
            file:
        </para>
        <informalexample>
            <programlisting>
<command>filter</command> <option>-file</option> <replaceable>filename filtername</replaceable>
            </programlisting>
        </informalexample>
        <para>
            <parameter>filename</parameter> is the file to which filter data will
            be written (any existing file is overwritten).  <parameter>filtername</parameter>
            is the name of the filter that will write that file.
        </para>
        <para>
            Once the filter is defined and connected with a file, enabling
            the filter will cause it to output events that satisfy its gate
            until it is disabled or SpecTcl exited:
        </para>
        <informalexample>
            <programlisting>
<command>filter</command> <option>-enable</option> <replaceable>filtername</replaceable>
<command>filter</command> <option>-disable</option> <replaceable>filtername</replaceable>
            </programlisting>
        </informalexample>
        <para>
            For a complete description of the <command>filter</command> command,
            see the command reference.
        </para>
    </chapter>
    <chapter id='chap.startup'>
        <title id='chap.startup.title'>SpecTcl's startup process </title>
        <para>
            As SpecTcl starts it uses several scripts to both steer its startup
            and to setup any Tcl commands and user interfaces desired by the
            user.   This chapter describes scripts that you can use to
            modify how SpecTcl starts and what it looks like once it has started.
        </para>
        <para>
            SpecTcl relies on two script families during initialization and startup.
            Each script family is a script with a specific name.  The script is
            searched for in a specific set of directories and <emphasis>all</emphasis>
            matching scripts are sourced.
        </para>
        <para>
            The directories searched are in order:
        </para>
        <variablelist>
            <varlistentry>
                <term><filename>$SpecTclHome/etc</filename></term>
                <listitem>
                    <para>
                        The <filename>etc</filename> subdirectory of the
                        SpecTcl installation directory.  Scripts here
                        are intended to be maintained by the installer andshould be
                        used to set system defaults and provide services that
                        are common to all users of SpecTcl system wide.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>The user's home directory</term>
                <listitem>
                    <para>
                        Scripts here should be used to provide definitions
                        and services common to all projects the user works on.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>Working directory</term>
                <listitem>
                    <para>
                        Scripts here should be usd to provide definitions and
                        services specific to the analysis that is run from
                        that directory.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            SpecTcl starts in two major phases; initialization and setup.  The
            initialization family of scripts is called
            <filename>SpecTclInit.tcl</filename>.  These scripts are invoked
            very early in SpecTcl's startup and ares used to define
            values that provide limits, hints and steering variables for
            SpecTcl's initialization and startup.
        </para>
        <para>
            The variables that can be set in this file are:
        </para>
        <variablelist>
            <varlistentry>
                <term><varname>DisplayType</varname></term>
                <listitem>
                    <para>
                        SpecTcl 5.0 and later support two visualization programs,
                        the original <application>Xamine</application> and the Root
                        based <application>Spectra</application>.  This variable
                        selects the visualizer that will be used:
                        <literal>spectra</literal> will start the Root based
                        Spectra
                        displayer while <literal>xamine</literal> will start the
                        traditional Xamine displayer
                    </para>
                </listitem>
            </varlistentry>

            <varlistentry>
                <term><varname>DisplayMegabytes</varname></term>
                <listitem>
                    <para>
                        The number of megabytes of display memory that will
                        be allocated to the shared memory region that holds
                        bulk spectrum data.  If this value results in a shared
                        memory region larger than one supported by the configuration
                        of Linux, you will get an invalid parameter message.
                    </para>
                    <para>
                        On linux, the maximum size a shared memory region
                        can have is configured by setting the
                        <literal>kernel.shmmax</literal> configuration parameter.
                        This can be done at boot time using the
                        <application>sysctl.conf</application> mechanisms.
                        If you administer your own linux system see
                        the manpage for <literal>sysctl.conf</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><varname>ParameterCount</varname></term>
                <listitem>
                    <para>
                        The <classname>CEvent</classname> array like object
                        that is passed to event processors is given an initial
                        size set by this value.   The object will expand as needed
                        to allow the parameter with the highest index to fit.
                        Internally, SpecTcl recycles old <classname>CEvent</classname>
                        objects so the initial value is not that important anymore.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><varname>EventListSize</varname></term>
                <listitem>
                    <para>
                        SpecTcl will let event processors unpack several events
                        before submitting them in a batch to the histogramming
                        classes.   This is intended to improve, somewhat the
                        cache hit rate.  This value determines the maximum
                        number of events SpeTcl will allow the event processor
                        pipeline to process before submitting them all to the
                        histogrammer.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><varname>TKConsoleHistory</varname></term>
                <listitem>
                    <para>
                        If your SpecTcl starts the TkCon command console,
                        this variable sets the number of commands TkCon
                        will retain in its command history.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><varname>TkConConsoleBufferSize</varname></term>
                <listitem>
                    <para>
                        If your SpecTcl starts the TkCon command console,
                        this variable sets the number of byes of scrollback
                        buffer that will be maintained.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            Once SpecTcl is fully initialized, it sources the
            <filename>SpecTclRC.tcl</filename> family of scripts.  This set of
            scripts can be used to define application specific commands, variables,
            parameters spectra as well as to provide a graphical user interface
            to make interacting with SpecTcl easier.  The skeleton
            comes with a <filename>SpecTclRC.tcl</filename>.  Feel free to use
            this as a starting point or to discard it.
        </para>
        <para>
            The skeleton <filename>SpecTclRC.tcl</filename> does the following:
        </para>
        <orderedlist>
            <listitem>
                <para>
                    Sets up a splash image that shows approximately how
                    far along the setup process the script has progressed.
                    The default splash image is the SpecTcl logo.  The splash
                    image can be changed by setting <varname>splashImage</varname>
                    in the <filename>SpecTclInit.tcl</filename> file.
                </para>
            </listitem>
            <listitem>
                <para>
                    Starts the base SpecTcl GUI which that lives in Tk's main
                    to level GUI.  This is just a bar of buttons.  This button
                    bar starts with buttons that clear all spectra and exit
                    SpecTcl.  You can pack additional buttons in the top level
                    widget or create your own top level widget GUI.
                </para>
            </listitem>
            <listitem>
                <para>
                    Provides some low level scripts that support writing Tcl
                    scripts that can be sourced into restore spectrum and gate
                    definitions for later runs of SpecTcl.  These are
                    described in the command reference guide.
                </para>
            </listitem>
            <listitem>
                <para>
                    Provides some low level scripts that support listing parameters,
                    spectra, gates and their applications in a more human
                    readable form.  Recall that SpecTcl's native parameters
                    produce output that's designed for processing by Tcl
                    scripts.  Note that the <command>More</command> proc is
                    also provided which can paginate the output of these
                    scripts.
                </para>
                <para>
                    These scripts are also documented in the command
                    reference guide.
                </para>
            </listitem>
            <listitem>
                <para>
                    Provides scripts that can copy simple cuts, contours
                    and bands to a different parameter set.   This
                    allows you to create a single gate that can then be copied
                    over and over again.
                </para>
                <para>
                    These scripts are documented in the command reference guide.
                </para>
            </listitem>
            <listitem>
                <para>
                    Starts the TkCon console.   TkCon has sophisticated command
                    editing capabilities.   The tclsh/wish interpreter run on
                    SpecTcl's stdin is not nearly as nice in that regard.
                    Note that if you don't need a console (you can do everything
                    you want in your GUI) you don't need to start this.
                </para>
                <para>
                    TkCon was written by Jeff Hobbs currently at ActiveState.
                    It has been modified for use with SpecTcl and is incorporated
                    under the rather loose terms of its <literal>Bourbon Ware</literal>
                    license.  The terms of that license were satisified at
                    the 13'th Tcl conference in Naperville,  in 2006.
                </para>
            </listitem>
            <listitem>
                <para>
                    Starts the SpecTcl default GUI.  If you have another GUI
                    you prefer by all means substitute it.  The SpecTcl default
                    GUI is described in this document at:
                    <link linkend='chap.gui' endterm='chap.gui.title' />
                </para>
            </listitem>
        </orderedlist>
    </chapter>
    <chapter id='chap.scripting'>
        <title id='chap.scripting.title'>Scripting with SpecTcl</title>
        <para>
            SpecTcl incorporates an extended version of the Tcl/Tk scripting
            language created originally by John Ousterhout.  Maintenance and
            development of that language migrated through Sun, Scriptics and
            Ajuba before settling into a community based Tcl-Core team
            mediated development model in 2000.  The Tk extension to Tcl,
            also incorporated into Tcl provides the ability to easily
            create graphical user interfaces.
        </para>
        <para>
            <ulink url='https://www.tcl.tk/man/tcl8.5/tutorial/tcltutorial.html' />
            is one good Tcl tutorial.
            <ulink url='http://www.tkdocs.com/tutorial/' /> provides a good
            Tk tutorial.
        </para>
        <para>
            Very likely  you're still reading this manual because you're a bit
            too impatient to wade  through all those tutorials.  The remainder
            of this chapter will:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Provide an accelerated introduction to the Tcl/Tk programming
                    language with pointers to more detailed reference material.
                </para>
            </listitem>
            <listitem>
                <para>
                    Provide a few simple examples to show how Tcl/Tk can be
                    used to provide graphical user interfaces on top of
                    SpecTcl (the usual reason for scripting).
                </para>
            </listitem>
            <listitem>
                <para>
                    Describe the mechanisms that allow you to make bridges
                    between the Tcl/Tk script world and your compiled
                    event processor code.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            Note that several research groups have already produced quite a lot
            of scripting on top of SpecTcl, both to provide user interfaces and
            to extend SpecTcl's features.  Before starting fresh, you might
            save yourself a lot of work by checking into what's out there.
        </para>
        <note>
            <title>Here Be Dragons</title>
            <para>
                Note that the NSCL supports SpecTcl and the Tcl scripts released
                along with it.  We cannot provide support for your scripts
                and add ons other than to help you understand enough about
                SpecTcl to move forward with your development work. 
            </para>
        </note>
        <section>
            <title>A quick introduction to Tcl/Tk</title>
            <para>
                This section will introduce you to the basic syntax and form
                of Tcl/Tk scripts.  Tcl is an extremely regular language.  Its
                regularity makes for a very shallow learning curve.  This
                shallow learning curve is one of the reasons it was adopted
                as the command language for SpecTcl.
            </para>
            <note>
                <title>SpecTcl is really NSCLSpecTcl</title>
                <para>
                    Throughout I've been calling this program SpecTcl. It's actual
                    name is <firstterm>NSCLSpecTcl</firstterm> to avoid
                    confusion within the Tcl communit with the SpecTcl interface
                    builder (
                    <ulink url='http://www.tcl.tk/software/spectcl/index.tml' />
                    ).  I'll continue to use the word SpecTcl as within the
                    nuclear physics  community SpecTcl is NSCLSpecTcl.
                </para>
            </note>
            <para>
                Once the language has been introduced, we'll take a quick tour
                through Tk describing its philosopohy and a few of the
                more common widgets.  Again there will be liberal reference pointers.
            </para>
            <section>
                <title>Tcl</title>
                <para>
                    The Tcl scripting language has very simple syntax.  There are,
                    in fact only 12 syntax rules for Tcl.  These are
                    commonly referred to as the <firstterm>Dodekalogue</firstterm>.
                    They are described here:
                    <ulink url='http://www.tcl.tk/man/tcl/TclCmd/Tcl.htm' />
                </para>
                <para>
                    In fact you can do significant work by knowing only some of these
                    (rephrased and reordered somewhat) words:
                </para>
                <orderedlist>
                    <listitem>
                        <para>
                            A Tcl command consists of a list of words.  Unless
                            quoting or a contiunation marker is used, a semicolon or newline
                            ends a Tcl command.
                        </para>
                        <para>
                            The Tcl line continuation marker is <literal>\</literal>
                            as the last character of the line.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Tcl commands have two phases of evaluation.  First
                            the Tcl interpreter performs indicated substitutions
                            on the command.  The first word of the resulting
                            command determines the operation. The remaining words
                            are passed to the command.
                        </para>
                        <para>
                            Note that commands return a result.  This is key
                            to the concept of substitution.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            The <literal>$</literal> indicates that what
                            follows is the name of a variable and that the
                            $ and variable name will be substituted with the
                            value of the variable.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            In a command text within square brackets
                            <literal>[ ]</literal> is considered a command.
                            That command is evaluated and the result of the
                            command substituted for it.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            If the first character of a word is a <literal>{</literal>
                            the word extends until the next <literal>}</literal>.
                            Substituion is turned off within brackes.
                        </para>
                        <para>
                            If the first character of a word is a <literal>"</literal>
                            the word extends until the next <literal>"</literal>.
                            Unlike quoting with braces, substitution is performed
                            within "".
                        </para>
                    </listitem>
                </orderedlist>
                <para>
                    A couple of points not mentioned in the syntax that are
                    core Tcl principles.  First <firstterm>everything</firstterm>
                    is a command.  Many programming languages have looping and
                    conditional constructs built in.  Tcl provides commands
                    that implement these.  Second everything has a string
                    representation (sometimes this is simplified to the acronym
                    EIAS - Everything Is A String).  This defines how type conversions
                    operate in Tcl as well as providing some regularity in
                    the management of dicts.
                </para>
                <formalpara>
                    <title>Variables</title>
                    <para>
                        The syntax hinted at the fact that Tcl has variables.  It
                        also has arrays.   Tcl arrays are, however indexed by
                        strings rather than integers.  Internally hashing is used
                        so that indexing is a constant time operation.
                    </para>
                </formalpara>

                <para>
                    Tcl has two additional data types that are supported via
                    commands;  These are lists and dicts.  A list is an ordered
                    set of words (A command is a well formatted Tcl list).
                    A dict is a set of key value pairs.
                </para>
                <para>
                    Tcl has support for object oriented programming via several
                    extensiona and, as of Tcl8.6 a native package called
                    <literal>TclOO</literal>.
                </para>
                <para>
                    The <command>set</command> command creates Tcl variables.
                    As noted, variables are accessed using <literal>$</literal>
                    substitution. The set command also returns the value of its
                    variable, and does not require the variable be given a new
                    value:
                </para>
                <informalexample>
                    <programlisting>
set a {this is a string}
set c $a
set d "[set c] with more stuff"
set first("Fox") Ron
                    </programlisting>
                </informalexample>
                <para>
                    In the example above, <varname>a</varname> has the value
                    <literal>this is a string</literal> as does <varname>c</varname>.
                    <varname>d</varname>, however has the value
                    <literal>this is a string with more stuff</literal>.
                    Finally <varname>first</varname> is an array and the
                    element indexed by the string <literal>Fox</literal> is
                    <literal>Ron</literal>.  
                </para>
                <para>
                    Note that in Tcl variables are created the first time they
                    are <command>set</command>.  There are no commands for
                    declaring variables (well that's a bit of a lie in some
                    circumstances but
                    ignore that for now).
                </para>
                <para>
                    Data manipulation commands include:
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            <command>string</command> which maniuplates text
                            strings:
                            <ulink url='http://www.tcl.tk/man/tcl8.5/TclCmd/string.htm' />
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <command><ulink url='http://www.tcl.tk/man/tcl8.5/TclCmd/list.htm'>list</ulink></command>,
                            <command><ulink url='http://www.tcl.tk/man/tcl8.5/TclCmd/lappend.htm'>lappend</ulink></command>,
                            <command><ulink url='http://www.tcl.tk/man/tcl8.5/TclCmd/lindex.htm'>lindex</ulink></command>,
                            <command><ulink url='http://www.tcl.tk/man/tcl8.5/TclCmd/lreplace.htm'></ulink>lreplace</command>,
                            <command><ulink url='http://www.tcl.tk/man/tcl8.5/TclCmd/llength.htm'>llength</ulink></command>
                            and
                            <command><ulink url='http://www.tcl.tk/man/tcl8.5/TclCmd/lsearch.htm'>lsearch</ulink></command>
                            are the most common list manipulation commands.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            The
                            <command><ulink url='http://www.tcl.tk/man/tcl8.5/TclCmd/dict.htm'>dict</ulink></command>
                            creates and maniuplates dicts.
                        </para>
                    </listitem>
                </itemizedlist>
                <para>
                    The <command>string</command> and <command>dict</command> commands
                    are examples of what Tclers call <firstterm>command ensembles</firstterm>.
                    These are commands that have a second word that is a subcommand
                    that determines what the command does.
                </para>
                <formalpara>
                    <title>Flow control</title>
                    <para>
                        As already described, Tcl implements flow control
                        via commands rather than as language structures.
                        Many flow control structures require a condition.
                        In order to ensure that the variables in conditions
                        are evaluated by the command rather than the interpreter's
                        first stage of evaluation, it's important to quote
                        these conditions in braces.  After introducing
                        the flow control commands I'll give an example that shows
                        why this is.
                    </para>
                </formalpara>
                <para>
                    Note also that the bodies of flow control commands are
                    scripts but, again <literal>{}</literal> quotation
                    is needed for all scripts that require more than one
                    word since each body is a single word of the command.
                    This may sound puzzling but actually looks quite natural
                    as we'll see in the examples.
                </para>
                <para>
                    Tcl provides the following flow control commands:
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            <command><ulink url='http://www.tcl.tk/man/tcl8.5/TclCmd/if.htm'>if</ulink></command>
                            provides the usual conditional.  The <command>if</command>
                            command can have several branches via the
                            <literal>elseif</literal> and <literal>else</literal>
                            keywords.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <command><ulink url='http://www.tcl.tk/man/tcl8.5/TclCmd/switch.htm'>switch</ulink></command>
                            Executes a single script from amongst several depending
                            on way a value matches simple expressions. 
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <command><ulink url='http://www.tcl.tk/man/tcl8.5/TclCmd/for.htm'>for</ulink></command>
                            provides for a loop that iterates in a manner very
                            similar to the C/C++ <command>for</command>
                            construct.  In many cases you may be used to using
                            a <command>for</command> loop the <command>foreach</command>
                            loop may be a more natural choice.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <command><ulink url='http://www.tcl.tk/man/tcl8.5/TclCmd/while.htm'>while</ulink></command>
                            provides for loops that are top tested.  A common Tcl
                            programming exercise is to implement a bottom tested
                            loop in pure Tcl (if you want to give that a try, see the
                            <command><ulink url='http://www.tcl.tk/man/tcl8.5/TclCmd/uplevel.htm'>uplevel</ulink></command>
                            command).
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <command><ulink url='http://www.tcl.tk/man/tcl8.5/TclCmd/foreach.htm'></ulink>foreach</command>
                            iterates over elements in a list.
                        </para>
                    </listitem>
                </itemizedlist>
                <para>
                    We have enough mechanics now that exmples can be relevant
                    to SpecTcl (though some may be toy examples).
                </para>
                <informalexample>
                    <programlisting>
set raw0Description [lindex [spectrum -list raw.00] 0]
set type [lindex $raw0Description 2]
if {$type == "1"}  {
   puts "1-d spectrum"
} elseif {$type == "2"} {
   puts "2-d spectrum"
} else {
   puts "Some other spectrum type: $type"
}
                    </programlisting>
                </informalexample>
                <para>
                    The first two lines of this example extract the spectrum
                    type code from the description of the spectrum named
                    <literal>raw.00</literal>.  The
                    <command><ulink url='http://www.tcl.tk/man/tcl8.5/TclCmd/puts.htm'>puts</ulink></command>
                    command outputs text, by default to standard output, so the
                    if bodies output mesages indicating if the spectrum is
                    a 1D, 2D or otherwise.  Note he use of variable substitution
                    in a quoted string in the <literal>else</literal> branch
                    of the if.
                </para>
                <para>
                    The same outcome can be expressed as a switch. Replace the
                    <command>if</command> with:
                </para>
                <informalexample>
                    <programlisting>
switch -exact $type {
    1 {
        puts "1-d spectrum"
    }
    2 {
        puts "2-d spectrum"
    }
    default {
        puts "Some other spectrum type: $type"
    }
}
                    </programlisting>
                </informalexample>
                <para>
                    Here's an example of a <command>for</command> loop
                    note that the
                    <command><ulink url='http://www.tcl.tk/man/tcl8.5/TclCmd/expr.htm'>expr</ulink></command>
                    command evaluates arbitrary arithmetical expressions (among
                    other things):
                    and
                    <command><ulink url='http://www.tcl.tk/man/tcl8.5/TclCmd/incr.htm'>incr</ulink></command>
                    increments a variable.
                </para>
                <informalexample>
                    <programlisting>
for {set i 0} {$i &lt; 10} {incr i} {
    puts "$i Squared is [expr {$i*$i}]}
}
                    </programlisting>
                </informalexample>
                <para>
                    Similarly the <command>while</command> loop:
                </para>
                <informalexample>
                    <programlisting>
set sq 0
set i  0
while {$sq &lt; 81} {
    set sq [expr {$i*$i}]
    puts "$i squared is $sq"
    incr i
}
                    </programlisting>
                </informalexample>
                <para>
                    I said that the condition clauses for all flow control command
                    should be braced.  The example above is a great example why this
                    is true. Suppose I'd written the <command>while</command> command
                    as:
                </para>
                <informalexample>
                    <programlisting>
set sq 0
while $sq &lt; 81 {
    ...
}
                    </programlisting>
                </informalexample>
                <para>
                    Tcl would have done its round of substitution before turning
                    control over to the <command>while</command> command.  This
                    would mean that the <command>while</command> command would get
                    rewritten to read:
                </para>
                <informalexample>
                    <programlisting>
while 0 &lt; 81 {
    ...
}
                    </programlisting>
                </informalexample>
                <para>
                    resulting in an infinite loop.
                </para>
                <informalexample>
                    <programlisting>
foreach spectrum [spectrum -list] {
    set name [lindex $spectrum 1]
    set type [lindex $spectrum 2]
    puts "$name  has a type of $type"
}
                    </programlisting>
                </informalexample>
                <para>
                    <command>foreach</command> is equivalent to the following]
                    awkward <command>for</command> loop:
                </para>
                <informalexample>
                    <programlisting>

set specs [spectrum -list]
for {set i 0} {$i &lt; [llength $specs]} {incr i} {
    set spectrum [lindex $specs $i]
    set name [lindex $spectrum 1]
    set type [lindex $spectrum 2]
    puts "$name  has a type of $type"
}
                    </programlisting>
                </informalexample>
                <para>
                    Whenever you find yourself using <command>lindex</command>
                    inside a <command>for</command> loop ask yourself
                    if a <command>foreach</command> loop might be simpler.
                </para>
                <para>
                    The last Tcl command I want to describe is the
                    <command><ulink url='http://www.tcl.tk/man/tcl8.5/TclCmd/proc.htm'>proc</ulink></command>
                    command.  <command>proc</command>, short for procedure
                    creates new Tcl commands.  Once created these commands look
                    and operate just like any other built in Tcl command.
                </para>
                <para>
                    Here's a simple example:
                </para>
                <informalexample>
                    <programlisting>
proc spectrumTypes spectra {
    foreach spectrum $spectra {
        set name [lindex $spectrum 1]
        set type [lindex $spectrum 2]
        puts "$name  has a type of $type"
    }
}
spectrumTypes [spectrum -list raw*]

                    </programlisting>
                </informalexample>
                <para>
                    The example first creates a new command
                    <command>spectrumTypes</command> with one parameter,
                    a list of spectrum descriptions.  The proc
                    outputs the names and types of each spectrum in the list.
                </para>
                <para>
                    The last line of the example uses this proc to output
                    the name and types of all spectra whose names start with
                    <literal>raw</literal>.
                </para>
                <para>
                    For a full list of Tcl (8.6) commands with links to their
                    reference documentation see:
                    <ulink url='http://www.tcl.tk/man/tcl8.6/TclCmd/contents.htm' />
                </para>
            </section>
            <section>
                <title>Tk</title>
                <para>
                    The Tk extension to Tcl provides the ability for
                    Tcl scripts to easily create graphical user interfaces.
                    GUI software in C/C++ is quite a chore in most
                    user interface frameworks that ranges from nightmarish
                    (Motif/Xt e.g.) to a pain (Qt e.g.).
                </para>
                <para>
                    Perhaps the best way to describe the value of Tk is
                    to show the following script.  You don't need SpecTcl
                    to run this.  You can use the <command>wish</command>
                    command to start a Tcl interpreter with Tk built in and paste
                    the script below into the command line:
                </para>
                <informalexample>
                    <programlisting>
ttk::button .b -text Exit -command exit
pack .b
                    </programlisting>
                </informalexample>
                <para>
                    This script should pop up an X window with a button labeled
                    <literal>Exit</literal>.  If you click on that button wish
                    should exit.
                </para>
                <para>
                    Simple as this script is, it illustrates several important
                    points about Tk:
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            Tk provides a set of commands (like <command>ttk::button</command>)
                            that create fairly high level components, or widgets
                            as they're called, from which user interfaces can
                            be composed.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Widgets have names.  Their names reflect their position
                            in a tree of parent/child widgets.  The name <literal>.b</literal>
                            means this widget is a child of the main window (<literal>.</literal>).
                            Periods are used as path separators when specifying a
                            widget's name.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Widgets have options. Collectively the current
                            values of all of a widget's options are called that
                            widget's configuration.  <option>-text</option> and
                            <option>-command</option> are two of the options
                            supported by the <command>ttk::button</command>
                            widget.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Actions can be attached to events handled by the
                            widget.  For example, obviously a button can be
                            pressed (clicked).  Options are provided for most
                            common widget events that allow you to specify
                            scripts to execute in response to those events.
                            In the example above, <option>-command</option>
                            specifies a script (the command <command>exit</command>)
                            to be executed when <literal>.b</literal> is
                            clicked.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            In addition to widget commands, Tk provides several
                            methods to layout widgets.  These are called.
                            <firstterm>geometry managers</firstterm>.  Tk
                            provides three of them:
                            <command>pack</command>, used in the example above,
                            <command>grid</command>, which generally provides
                            better layout control than pack and
                            <command>place</command> which gives exact
                            placement control along with all the joys and pains
                            that entails (you are responsible for re-layout in
                            response to resize events for example).
                        </para>
                        <para>
                            For a given <firstterm>container</firstterm>, you must stick with one geometry
                            manager.  
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Once the user interface is laid out, and the interpreter
                            has no more commands to execute (runs off the bottom
                            of the script), it enters an event loop.  The event
                            loop catches events that occur on the user interface
                            and dispatches them to the appropriate widgets.
                            Widgets then, if appropriate, dispatch events to
                            event handling scripts.
                        </para>
                        <para>
                            For more advanced applications the Tk
                            <command>bind</command> command allows you to specify
                            handlers for arbitrary events on widgets that may not
                            ordinarily handle them.  The <command>evetn</command>
                        </para>
                    </listitem>
                </itemizedlist>
                <para>
                    Tk provides two widget sets.  The classic widgets, those
                    Tk originally came from, have an appearance that mimics
                    Motif widgets.  They look the same regardless of the platform
                    on which they are run.  They look a bit clunky by modern
                    standarsd.
                </para>
                <para>
                    In 2007,
                    Joe English provided a new group of widgets originally
                    called <literal>Tile</literal> but now called
                    <literal>TTk</literal> which stands for themable Tk widgets.
                    These widgets have commands that start with <literal>ttk::</literal>.
                    ttk widgets determine the environment in which they
                    are running and adapt a display appearance that meets the
                    user interface guidelines of the underlying display system.
                    They do this automatically.
                </para>
            </section>
        </section>
        <section>
            <title>
                Some SpecTcl scripting examples.
            </title>
            <para>
                In this section we're going to build
                a simple, small bit of a user interface.  This GUI will:
            </para>
            <orderedlist>
                <listitem>
                    <para>
                        Provide a list of all spectra.  This list will
                        be udpated as new spectra are created/destroyed
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Provide a list of all gates.  This list too, will
                        be updated as new gates are created/deleted or modified.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Allow a set of spectra to be selected from the spectrum
                        list
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Allow a single gate to be selected from the gate list.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Allow the user to apply the selected gate to the list
                        of selected spectra.
                    </para>
                </listitem>
            </orderedlist>
            <para>
                We're going to do this the 'old fashioned way'.  In a modern
                Tcl/Tk program, we'd use one of the object oriented extensions
                or the built in TclOO package to encapsulate our user interface
                elements.  For this example we'll use raw Tcl/Tk so that we
                don't have to teach snit, incrTk or TclOO or any other
                Tcl/Tk extension.
            </para>
            <para>
                Along the way we're going to introduce the following widgets:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        <command>ttk::frame</command> A container widget that
                        allows us to layout children and then slap that
                        layout as a unit into another container.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <command>listbox</command> A widget that contains
                        a list of items.  We're going to use this to present
                        a list of the spectra currently defined in SpecTcl.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <command>ttk::combobox</command> a drop down menu widget
                        that allows you to select one item from a list.
                        We'll use this widget to let the user select one
                        of the gates.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <command>ttk::button</command> we'll use this to
                        allow the user to trigger the application of the gates.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <command>tk_messageBox</command> we'll use this to
                        display error and confirmation messages to the
                        user.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                This toy UI will be built into a single top level frame
                that's passed in to the creation proc.  The widgets of the
                UI will be pasted intot the top level frame using
                the <command>grid</command> geometry manager.  It will
                be up to the client to grid, pack or place the containing
                frame it passed us into the appropriate place of the larger
                user interface.  We'll give an example of a fragment
                from SpecTclRC.tcl that we can use to create the
                UI and put it in the top level GUI (button bar)
                produced by the default SpecTclRC.tcl
            </para>
            <para>
                This toy UI only shows a small fraction of the widgets and
                capabilities of Tk. See:
                <ulink url='http://www.tcl.tk/man/tcl8.6/TkCmd/contents.htm' />
                for a list of the Tk commands and links to
                associated reference material.
            </para>
            <para>
                Let's start off small.  We're going to use a ttk::combobox
                to allow the user to select a gate.  But how to we ensure
                the drop down menu of the combo box is up-to-date?
                ttk::combobox has an option <option>-postcommand</option>
                that allows us to attach a script to the event that pops up the
                menu.  The script runs before the menu is generated and, therefore
                can define the contents of the menu.   
            </para>
            <para>
                Have a look at the code below (elisis means that unrelated code
                has been omitted):
            </para>
            <example>
                <title>A gate selection combobox</title>
                <programlisting>
namespace eval ::MultiApply {
    variable listbox                    <co id='mapply.namespace' />
    variable selectedGate ""

}
...
##
# _FillGateList
#
#    Fills ::MultiApply::gates with the list of gaten names.
#
proc ::MultiApply::_FillGateList {widget} {
    set gates [list]
    foreach gate [gate -list] {
        lappend gates [lindex $gate 0]             <co  id='mapply.gatenames' />
    }
    $widget configure -values $gates               <co id='mapply.setgatelist' />
}
...
##
# GateComboBox
#   Create a combobox.  When posted, the combox box list will contain
#   The current list of gates.
#
# @param widget - name of the widget to create (this is not compound).
# @return widget - The widget requested.
#
proc ::MultiApply::GateComboBox {widget} {

    ttk::combobox $widget -values [list]  \
        -postcommand [list ::MultiApply::_FillGateList $widget] \  <co id='mapply.makecombo' />
        -textvariable ::MultiApply::selectedGate


    return $widget                           <co id='mapply.returnwidget' />
}

                </programlisting>
            </example>
            <para>
                The description of this bit of code will skip around a bit so
                try not to get seasick:
            </para>
            <calloutlist>
                <callout arearefs='mapply.namespace'>
                    <para>
                        This block of code creates a new Tcl
                        <firstterm>namespace</firstterm> and puts two
                        variables in it.    Namespaces are a mechanism to
                        encapsulate the names (procs and variables) of a package
                        so as to minimize the chances some other package will
                        generate name conflicts.
                    </para>
                    <para>
                        Namespaces can be nested. Fully qualified Tcl names
                        use the <literal>::</literal> characters to separate
                        the path to the variable or proc.  Thus we created
                        two variables whose fully qualified names
                        are <varname>::MultiApply::listbox</varname> and
                        <varname>::MultiApply::selectedGate</varname>.
                    </para>
                    <para>
                        procs can also live in namespaces.  Attempts to locate
                        commands for procs in a namespace are first searched in the
                        proc's namespace.   These variables will be used to
                        hold the widget name of the spectrum list box and the
                        gate currently selected by the gate combobox respectively.
                    </para>
                </callout>
                <callout arearefs='mapply.makecombo'>
                    <para>
                        This code creates the combobox from which the user
                        will select a gate. <option>-value</option> provides
                        the current set of values in he combobox.  This is empty
                        because <option>-postcommand</option> is used
                        to supply a script that will stock the values at the
                        time the combox list is pulled down.  This ensures
                        that the combobox always has the current set of gate
                        names when it's list of values is pulled down.
                    </para>
                    <para>
                        <option>-textvariable</option> specifies a variable in
                        which the combobox will maintain the current value of
                        the combobox.  This is either something the user types in
                        or something picked from the list that can be pulled down
                        in the combobox.  Note that this variable is in the
                        <literal>MultiApply</literal> namespace.
                    </para>
                    <para>
                        Note that the proc itself is also in the
                        <literal>MultiApply</literal> namespace.
                    </para>
                </callout>
                <callout arearefs='mapply.returnwidget'>
                    <para>
                        In order to make the <command>::MultiApply::GateComboBox</command>
                        look, as much as possible like a Tk widget creating command,
                        the widget passed in is returned to the caller.
                    </para>
                </callout>
                <callout arearefs='mapply.gatenames'>
                    <para>
                        Recall that the
                        <command>::MultiApply::_FillGateList</command> is the
                        sxcript run when the drop down is about to become visible.
                        This loop iterates through the set of gate definitions
                        making a list, <varname>gates</varname>, that only
                        contains the current gate names.
                    </para>
                </callout>
                <callout arearefs='mapply.setgatelist' >
                    <para>
                        Configuring the combobox's <option>-values</option>
                        option set the list of values (gate names) that will
                        be displayed in the pull down.  Note that
                        <command>gate  -list</command> is documented to return
                        the list of gates in alphabetial order of gate name.
                    </para>
                </callout>     
            </calloutlist>
            <para>
                Next let's look at how the spectrum selector is created and
                maintained.  In this case we need a widget that allows
                more than one spectrum to be selected.  The Tk
                listbox widget does that.   We'll also need a mechanism to
                maintain the contents of the list box as spectra are added
                and, potentially deleted.
            </para>
            <para>
                The mechanism we have for maintaining the spectrum list is
                the <option>-trace</option> option in the
                <command>spectrum</command> command.  This option allows
                a script to be called when spectra are added or deleted
                from SpecTcl's spectrum dictionary.
            </para>
            <para>
                Let's look at the code.
            </para>
            <example>
                <title>Spectrum selection listbox</title>
                <programlisting>
...
##
# _FillSpectrumListbox
#
#   - Delete all entries in the list box.
#   - Fill the list box with names of the spectra.
#
# @param l - list box.
# @param n - Name of spectrum added or deleted.
#
proc ::MultiApply::_FillSpectrumListbox {l name} {  <co id='mapply.spectrace' />
    $l delete 0 end                                 <co id='mapply.clearlbox' />
    foreach spectrum [spectrum -list] {
        $l insert end [lindex $spectrum 1]          <co id='mapply.addspecname' />
    }
}

...
##
# SpectrumListBox
#
# Create a list box and an associated ttk::scrollbar.
# The list box is then stocked with the existing
# spectra.  The spectrum -trace command is used
# to restock the list box when the set of spectra change
# either through creation or deletion.
#
#
# @param parent -  Name of desired widget
# @return parent.
proc ::MultiApply::SpectrumListBox {parent} {
    variable listbox                               <co id='mapply.variable' />

    # Create the UI elements and make the scroll bar work.

    ttk::frame $parent                               <co id='mapply.containerframe' />
    listbox    $parent.list  -yscrollcommand [list $parent.yscroll set] \
        -selectmode extended                         <co id='mapply.listbox' />
    ttk::scrollbar  $parent.scroll -command [$parent.list yview] \
        -orient vertical                             <co id='mapply.scrollbar' />

    set listbox $parent.list                         <co id='mapply.savelistbox' />

    # Stock the widget and arrange for it to get restocked:

    
    spectrum -trace add [list ::MultiApply::_FillSpectrumListbox $parent.list]
    spectrum -trace delete \                        <co id='mapply.spectrumtraces' />
        [list after idle [list ::MultiApply::_FillSpectrumListbox $parent.list]]
    _FillSpectrumListbox $parent.list junk          <co id='mapply.loadinitialspectra' />
    
    
    # Layout the widgets so that they also scale nicely and return $parent

    grid $parent.list $parent.scroll -sticky nsew   <co id='mapply.spechooserlayout' />
    grid rowconfigure $parent 0 -weight 1;          
    grid columnconfigure $parent 0 -weight 1;       <co id='mapply.spechooserweight' />
    grid columnconfigure $parent 1 -weight 0;       

    return $parent
}

                </programlisting>
            </example>
            <para>
                As before we're not going to cover this code in the order in which
                it appears. We'll start by explaining
                <command>::MultiApply::SpectrumListBox</command>  which creates
                the list box that will display and allow users to select
                the set of spectra a selected gate will be applied to.
            </para>
            <calloutlist>
                <callout arearefs='mapply.variable'>
                    <para>
                        Recall that in the previous example we created a namespace,
                        <literal>MultiApply</literal> and that one of the
                        variables we created in it was named <varname>listbox</varname>.
                        When the <command>variable</command> command is used within
                        a proc that lives in a namespace, as this one does,
                        the variable in the same namespace is made available to
                        the proc as if it were local.  This can also be used
                        instead of the older <command>global</command>
                        command.
                    </para>
                    <para>
                        The <varname>listbox</varname> variable is going to hold
                        the full path to the listbox widget that we are creating.
                        This is neede in order to make it available to the
                        proc that will later handle the actual application.
                    </para>
                </callout>
                <callout arearefs='mapply.containerframe'>
                    <para>
                        The number of spectra defined can be rather large.  Therefore
                        it's important to allow the user to access all spectrum
                        names even if there are more than can fit in the visible
                        area of the listbox.  A scrollbar is the natural
                        way to do this in GUIs.  Therefore we're gong to build
                        two widgets, a listbox and a vertical scroll bar.
                    </para>
                    <para>
                        The simplest way to ensure that we can layout these widgets
                        as we want to is to first build a frame and then build
                        and layout the widgets in that frame.  A frame is just
                        a container for other widgets. Frames can have their own
                        geometry management independent of the geometry management
                        of the rest of the application.
                    </para>
                    <para>
                        By passing a frame
                        back to the caller, the application can then put the
                        user interface element we create anywhere it wants as
                        a unit without knowing anything about its internal
                        construction.  <command>ttk::frame</command> creates
                        a frame that should have a natural appearance in the
                        platform in which the UI is running.
                    </para>
                </callout>
                <callout arearefs='mapply.listbox'>
                    <para>
                        This creates the list box that will hold the spectrum.
                        Listboxes have several selection models.  The
                        <option>-selectmode</option> option sets the
                        desired one.  In this case <literal>extended</literal>
                        provides the most natural selection model for a box
                        that can have multiple items selected.
                    </para>
                    <para>
                        The <option>-yscrollcommand</option> option may seem
                        a bit unsual.  Scroll bars and scrollable widgets
                        require a round trip interaction.  Just as the scrollbar
                        can tell its target widget what should be visible, the
                        target widget must tell the scroll bar how it should appear
                        (where the elevator should be in the groove and how big it
                        should be).
                    </para>
                    <para>
                        The <option>-yscrollcommand</option> provides a script
                        that is executed when the listbox changes what is visible.
                        Note that the script references a scrollbar,
                        <literal>$parent.scroll</literal> that we've not
                        created yet.  The <option>-yscrollcommand</option> when it
                        is executed will append two fractions that are the
                        fraction of the list at the top of its display and the
                        fraction that are at the bottom.
                    </para>
                </callout>
                <callout arearefs='mapply.scrollbar' >
                    <para>
                        This line creates a vertical scrollbar.  Two things
                        make this scrollbar vertical.  First the
                        <option>-orient</option> option means that the scrollbar
                        will be drawn up and down rather than side to side.
                        Second the <command>-command</command> script asks
                        the target widget to execute the
                        <command>yview</command> (instead of
                        <command>xview</command>).
                    </para>
                    <para>
                        The <option>-command</option> option provides a script
                        that's called in response to scrollbar manipulations.
                        The listbox's <command>yview</command> command controls
                        what set of list elements are visible in the
                        listbox.
                    </para>
                    <para>
                        Thus the listbox can control what the scrollbar looks like
                        since its <option>-yscrollcommand</option> executes the
                        scrollbar's <command>set</command> command.  Conversely
                        the scrollbar can control which list elements the listbox
                        displays because its <command>-command</command> script
                        invokes the listbox's <command>yview</command> command.
                    </para>
                    <para>
                        If we wanted to provide an X scrollbar we'd need it to
                        invoke the listbox's <command>xview</command> command
                        and to add a <option>-xscrollcommand</option> that
                        would invoke the x scrollbar's <command>set</command>
                        command.
                    </para>
                </callout>
                <callout arearefs='mapply.savelistbox'>
                    <para>
                        Once the list box is created its widget command is saved
                        int <varname>MultiApply::listbox</varname>.  Note again
                        that since we imported <varname>MultiApply::listbox</varname>
                        into the proc, we don't need to fully qualify its name.
                    </para>
                </callout>
                <callout arearefs ='mapply.spectrumtraces' >
                    <para>
                        In SpecTcl spectra can be created and deleted during
                        a run.  We want our spectrum list to be
                        maintained when the list of spectra is modified as
                        a result of creation and deletion.  The
                        SpecTcl <option>-trace</option> option on the
                        <command>Spectrum</command> command allows us to
                        associate a script with the creation or deletion of
                        a spectrum.  The script is called with the spectrum
                        affected passed in.  The script is called while the
                        spectrum exists.  This means after creation is complete
                        and before deletion is actually performed.
                    </para>
                    <para>
                        In our case, we just recreate the list box after each
                        creation and deletion for simplicity rather than attempting
                        to figure out what the creation or deletion means in terms
                        of updating the contents of the listbox in place.
                        The proc <function>::MultiApply::_FillSpectrumListbox</function>
                        accepts the list box as a parameter and the trace will
                        add to that the spectrum name as a parameter, which we'll
                        ignore.
                    </para>
                    <para>
                        The processing the deletion in this manner is problematic,
                        since the spectrum still exists at the time the trace fires.
                        We have two choices.  The first is to have a different proc
                        which looks at the spectrum name, finds it in the listbox
                        and removes it.  The second is to defer repopulation of the
                        listbox until the spectrum has been deleted.
                    </para>
                    <para>
                        The <command>after idle</command> command executes the script
                        that follows when the application event loop next has nothing
                        to do. SpecTcl won't return to the event loop until the
                        spectrum is completely deleted so using
                        <command>after idle</command> to schedule execution of
                        <function>::MultiApply::_FillSpectrumListbox</function>
                        from the event loop ensures that when it's called the
                        deleted spectrum is no longer in the SpecTcl spectrum
                        dictionary.
                    </para>
                </callout>
                <callout arearefs='mapply.loadinitialspectra'>
                    <para>
                        Since the trace proc ignores the spectrum parameter we
                        can use it directly to load the initial set of spectra
                        into the list box.  We just need to pass some dummy
                        spectrum name so that Tcl sees that we provided
                        the right number of parameters.
                    </para>
                    <para>
                        We could also have used the <literal>args</literal>
                        method in <function>::MultiApply::_FillSpectrumListbox</function>
                        so that we don't even have to provide that.
                        See
                        <ulink url='http://www.tcl.tk/man/tcl8.5/TclCmd/proc.htm'>
                            The proc manpage</ulink> for more information on
                        variable length parameter lists and defaulted parameters
                        (which are another way to go).
                    </para>
                </callout>
                <callout arearefs='mapply.spechooserlayout'>
                    <para>
                        Since the scrollbar is a vertical scrollbar,
                        <command>grid</command> is used to put the
                        listbox and the scrollbar side by side.  The
                        <option>-sticky</option> option is used to ensure the
                        widgets fully fill the cells they've been placed in.
                        If there were more rows of widgets that might horizontally
                        enlarge the scrollbar cell, we might want to lay them
                        out separately so that the scrollbar could come free on
                        the left (east) side:
                    </para>
                    <informalexample>
                        <programlisting>
grid $parent.list -row 0 -column 0 -sticky nsew;
grid $parent.scroll -row 0 -column 1 -sticky nsw
                        </programlisting>
                    </informalexample>
                </callout>
                <callout arearefs='mapply.spechooserweight'>
                    <para>
                        Making widgets resize appropriately in complex user
                        interfaces can be challenging.  Fortunately this user
                        interface isn't complex.  We want both the listbox
                        and the scrollbar to be able to vertically resize
                        and only the listbox should be able to take advantage
                        of additional horizontal space.
                    </para>
                    <para>
                        The <command>grid</command> command has this concept of
                        row (vertical scaling) and column (horizontal scaling)
                        weights.  Weights allow you to specify the proportion
                        of extra space each widget will get, or lose in a resize
                        operation.
                        See
                        <ulink url='http://www.tcl.tk/man/tcl8.5/TkCmd/grid.htm'>
                            The grid manpage
                        </ulink>
                        for more about this.
                    </para>
                    <para>
                        By setting the row weight to 1 we allow the widgets
                        in the row to resize vertically.  By setting the
                        weight of column 0 to 1 and column 1 to 0, we allow
                        the widget in column 0 (listbox) to resize horizontally
                        while fixing the horizontal size of the widget in column
                        1 (the scrollbar).
                    </para>
                </callout>
            </calloutlist>
            <para>
                Finally lets look at the implementation of
                <function>::MultiApply::_FillSpectrumListbox</function>:
            </para>
            <calloutlist>
                <callout arearefs='mapply.spectrace'>
                    <para>
                        Note that in addition to the listbox widget, the
                        proc is passed a spectrum name.  This name is appended
                        to the command specified by the
                        <command>spectrum -trace</command> command when the
                        trace is fired.  In fact we ignore this parameter.
                    </para>
                </callout>
                <callout arearefs='mapply.clearlbox' >
                    <para>
                        Since we're regenerating the entire contents of the listbox,
                        the first step is to delete all items from the listbox.
                    </para>
                </callout>
                <callout arearefs='mapply.addspecname' >
                    <para>
                        This loop extracts the name from each spectrum description
                        and adds it in the last position of the listbox.
                        The <command>spectrum -list</command> command is documented
                        to return the spectra listed in alphabetical order by
                        spectrum name.   Therefore the listbox will also be alphabetical
                        by spectrum name.
                    </para>
                </callout>
            </calloutlist>
            <para>
                We pretty much have everything we need.  Most of the hard work
                is done.  All we need to do is layou the spectrum chooser and
                gate chooser side by side and put a button underneath all that.
                We also need to write code for the button to execute when clicked:
            </para>
            <example>
                <title>Multiselect final layout and logic</title>
                <programlisting>

...

##
# _apply
#
#   Called to apply the gates:
#   - There must be at least one spectrum selected.
#   - A gate must be selected.
#   - Since the user can type into a combo box, the gate
#     must exist.
#   - Apply the selected gate to all selected spectra.
#
# @note ::MultiApply::listbox is the widget tha has the spectrum list.
# @note ::MultiApply::selectedGate has the name of the selected gate.
#
proc ::MultiApply::_apply {}  {
    variable selectedGate                     <co id='mapply.nsvariables' />
    variable listbox


    set spectrumIndices [$listbox curselection]  <co id='mapply.specselections' />

    # Check for the error listed above:          <co id='mapply.errorchecking' />

    if {[llength $spectrumIndices] == 0} {
        tk_messageBox -icon error -type ok -title "Need Spectrum" \
            -message {At least one spectrum must be selected}
        return
    }

    if {$selectedGate eq ""} {
        tk_messageBox -icon error -type ok -title "Need Gate" \
            -message {A gate must have beenselected}
        return
    }

    if {[llength [gate -list $selectedGate]] == 0} {
        tk_messageBox -icon error -type ok -title "Invalid Gate" \
            -message "There isn't a gate named $selectedGate"
        return
    }

    #  Build up a list of spectrum names:

    foreach item $spectrumIndices {
        lappend spectrumNames [$listbox get $item]     <co id='mapply.selectedspectrumlist' />
    }

    apply $selectedGate {*}$spectrumNames             <co id='mapply.applygate' />
}

...
##
# Selectors
#   Create a frame that has the spectrum selection on the left and
#   the gate combobox on the right.  gridding is done so that the
#   spectrum selector is the only one that can expand.
#
#  @param widget -widget to hold this (ttk::frame we create).
#  @return widget.
#
proc ::MultiApply::Selectors {widget} {
    ttk::frame $widget                              <co id='mapply.selectorframe' />

    set s [::MultiApply::SpectrumListBox $widget.s] <co id='mapply.selectorcreation' />
    set g [::MultiApply::GateComboBox    $widget.g]

    grid $s   -sticky nsew                          <co id='mapply.selectorlayout' />
    grid $g  -row 0 -column 1 -sticky ew

    grid rowconfigure    $widget 0 -weight 1
    grid columnconfigure $widget 0 -weight 1       <co id='mapply.selectorresize' />
    grid columnconfigure $widget 1 -weight 0

    return $widget
}


##
# MultiApply
#   Makes the full UI:
#     Selectors on top and an Apply Gate button on the bottom.
#     All that in a frame.
#
# @param widget - Top of the widget hierachy created ttk::frame.
# @return widget
#
proc ::MultiApply::MultiApply widget {
    ttk::frame $widget                                 <co id='mapply.topframe' />
    ::MultiApply::Selectors $widget.selectors          <co id='mapply.selectors' />
    ttk::button $widget.apply -text {Apply Gate} \
        -command [list ::MultiApply::_apply]           <co id='mapply.applybutton' />

    grid $widget.selectors -sticky nsew                <co id='mapply.toplayout' />
    grid $widget.apply     -sticky ns

    grid columnconfigure $widgxet 0 -weight 1
    grid rowconfigure    $widget 0 -weight 1          <co id='mapply.topresize' />
    grid rowconfigure    $widget 1 -weight 0

    return $widget
}

                </programlisting>
            </example>
            <para>
                Let's start with the two procs that glue together all the
                widgets and then conclude with the proc called to do the
                actual application.
            </para>
            <calloutlist>
                <callout arearefs='mapply.selectorframe'>
                    <para>
                        <function>::MultiApply::Selectors</function>  creates a
                        compound widget that consists of both the spectrum
                        chooser/scrollbar bundle and the gate selection
                        combobox.
                    </para>
                    <para>
                        These two objects will be placed in a frame which is
                        given the name passed in as a parameter and returned
                        if the proc executes successfully.
                    </para>
                </callout>
                <callout arearefs='mapply.selectorcreation' >
                    <para>
                        The two selectors get created as children of the frame.
                        While not always necessary, in general Tk is better behaved
                        if widgets that live an a container are descendents in the
                        widget tree of the container.
                    </para>
                </callout>
                <callout arearefs='mapply.selectorlayout'>
                    <para>
                        The layout  places the gate selector to the right of
                        the spectrum selector and, while the gate selector is
                        stuck to all four sides of its cell (the better to expand in x/y), 
                    </para>
                </callout>
                <callout arearefs='mapply.selectorresize'>
                    <para>
                        By now hopefully you have some familiarity with column
                        and row weights.  The weights given here allow the
                        widgets to expand in Y and the listbox only to expand
                        in X.  Since the gate chooser is unstuck from the top and
                        bottom it's not going to expand in Y but stay vertically
                        centered.
                    </para>
                </callout>
                <callout arearefs='mapply.topframe'>
                    <para>
                        <function>::MultiApply::MultiApply</function> creates
                        the entire user interface.  A frame is used to place the
                        composite widgets.  The frame is named as requested by
                        the <parameter>widget</parameter> parameter, which is
                        also returned to the caller.
                    </para>
                </callout>
                <callout arearefs='mapply.selectors'>
                    <para>
                        The frame that contains both of the selectors is created.
                    </para>
                </callout>
                <callout arearefs='mapply.applybutton'>
                    <para>
                        A button is created and labeled <literal>Apply Gate</literal>
                        (<option>-text</option> option).   The
                        <function>::MultiApply::_apply</function> proc specified
                        as the <option>-command</option> script so that it will
                        be called when the button is clicked.
                    </para>
                </callout>
                <callout arearefs='mapply.toplayout'>
                    <para>
                        This gridding places the selectors above the
                        button.  The button floats into the middle of the
                        horizontal extent but is stuck to the top and bottom.
                    </para>
                </callout>
                <callout arearefs='mapply.topresize'>
                    <para>
                        The row and column weights are set so that both rows
                        can expand in X but only the top row can expand in Y.
                        Since the button is unstuck from the X edges, it won't
                        expand at all.
                    </para>
                </callout>
            </calloutlist>
            <para>
                Let's look at <function>::MultiApply::_apply</function> which
                executes when the button is clicked.  This function has the
                actual logic.  As is not uncommon, the bulk of body of this
                proc is concerned with error checking, reporting and handling.
            </para>
            <calloutlist>
                <callout arearefs='mapply.nsvariables' >
                    <para>
                        These two lines import the namespace scoped variables.
                        Recall that <varname>selectedGate</varname> contains
                        the name of the gate that's been selected.   More precisely,
                        it contains the value of the text field of the gate
                        selection combo box. <varname>listbox</varname>
                        contains the name/command of the Spectrum selection
                        listbox.
                    </para>
                </callout>
                <callout arearefs='mapply.specselections' >
                    <para>
                        The <command>curselection</command> command of the
                        listbox widget returns a (possibly empty) list of the
                        indices of the items selected in the listbox.
                    </para>
                </callout>
                <callout arearefs='mapply.errorchecking'>
                    <para>
                        The long section of code below checks for and reports,
                        via a pop up dialog, the following error conditions:
                    </para>
                    <orderedlist>
                        <listitem>
                            <para>
                                At least one spectrum must be selected in the
                                spectrum listbox.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                A gate must have been specified (the textbox
                                in the combobox must not be empty).
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                The text in the combobox must be a gate that
                                exists.   Note that since the value of that
                                textbox can be typed in, it is possible to try
                                to apply a non-existent gate.  The same is not true
                                for spectra as the only spectra that can be chosen
                                are those in the spectrum listbox, which shows exactly
                                the set of spectra that are currently defined.
                            </para>
                        </listitem>
                    </orderedlist>
                </callout>
                <callout arearefs='mapply.selectedspectrumlist' >
                    <para>
                        This loop fetches the names of the selected spectra and
                        puts them in the list <varname>spectrumNames</varname>
                    </para>
                </callout>
                <callout arearefs='mapply.applygate'>
                    <para>
                        Applies the gate.  There's a bit of Tcl syntax that we've
                        not talked about in play here.  The <literal>{*}</literal>
                        or argument expansion operator (called by some the Polyphemus operator
                        because it looks like a single eye in a head), takes
                        a single command word that is a valid Tcl list and turns it
                        into one command word per list item.
                    </para>
                    <para>
                        Thus if there are two spectra selected;
                        <literal>spec1</literal> and <literal>spec2</literal>,
                        The command:
                    </para>
                    <programlisting>
apply somegate {*}{spec1 spec2}                       
                    </programlisting>
                    <para>
                        Becomes:
                    </para>
                    <programlisting>
apply somegate spec1 spec2
                    </programlisting>
                    <para>
                        The <command>apply </command> command does not accept a
                        list of spectra as a single parameter but the latter form
                        where each spectrum name is a single parameter.
                    </para>
                </callout>
            </calloutlist>
            <para>
                This completes the user interface.  If all of this code is in
                a file named <filename>multiapply.tcl</filename> you can add the
                following commnds to <filename>SpecTclRC.tcl</filename>
                to add it to the buttonbox (which may need to)
                be strecthed:
            </para>
            <informalexample>
                <programlisting>
source mulitapply.tcl
MultiApply::MultiApply .mapply
pack .mapply -fill both -expand 1
                </programlisting>
            </informalexample>
        </section>
        <section>
            <title>
                Connecting scripts and your event processors.
            </title>
            <para>
                In the previous section, we've seen Tcl scripting used to create
                a simple GUI for SpecTcl using Tk.  In this section we're going
                to explore how to connect Tcl Scripts with your compiled code
                (normally event processors).
            </para>
            <para>
                There are two approaches to linking SpecTcl C++ code and
                Tcl scripts: You can share data (variables) between Tcl and C++
                or you can add commands to SpecTcl/Tcl that you execute in your
                C++ code.  We are going to look at both approaches by lookint
                at the problem of providing a linear calibration that
                turns a raw parameter into a calibrated parameter.  We'll look at
                the following specific techniques:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        Obtaining the value of Tcl variables and/or linking them
                        to C/C++ variables.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The Treevariable subsystem.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Adding new compiled Tcl commands to the interpreter.
                    </para>
                </listitem>
            </itemizedlist>
            <section>
                <title>Using Tcl variables to communicate with C/C++ code</title>
                <para>
                    In our toy example, we need to provde and offset and a slope
                    to calibrate a single parameter.   This section will show
                    how to obtain the values of two variables named
                    <varname>slope</varname> and <varname>offset</varname>
                    defined in Tcl scripts at the C++ level.
                </para>
                <note>
                    <title>NOTE</title>
                    <para>
                        Before you think hard about extending and generalizing
                        this code for your own use, you might check out the
                        calibrated parameter SpecTcl plugin.
                    </para>
                </note>
                <para>
                    We're going to show two ways to do this.  First we'll
                    ask Tcl to return the value of the variables.  Second
                    we'll <firstterm>link</firstterm> the variables to
                    C++ variables.  The key to all of this are the
                    following classes:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><classname>SpecTcl</classname></term>
                        <listitem>
                            <para>
                                This class provides and application programming
                                interface (API) that provides access to
                                SpecTcl objects of interest.  For this
                                example, and the subsequent examples, we will
                                need this class's <methodname>getInterpreter</methodname>
                                method.
                            </para>
                            <para>
                                Note that <classname>SpecTcl</classname> is a
                                <firstterm>singleton</firstterm> object.
                                This means there can be only one.
                                The constructor for <classname>SpecTcl</classname>
                                is <literal>private</literal>.  To get access
                                to the single instance, you must use the
                                <methodname>getInstance</methodname> static
                                method of the class.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>CTCLInterpreter</classname></term>
                        <listitem>
                            <para>
                                SpecTcl (and NSCLDAQ) include a C++ wrapping
                                of much of the Tcl API.   This wrapping
                                is called Tcl++.  The
                                <classname>CTCLInterpreter</classname>,
                                is a wrapping of a <type>Tcl_Interp</type>,
                                or Tcl interpreter, object.
                            </para>
                            <para>
                                <classname>SpecTcl</classname>::<methodname>getInterpreter</methodname>
                                returns a pointer to a <classname>CTCLInterpreter</classname>
                                object.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>CTCLVariable</classname></term>
                        <listitem>
                            <para>
                                This class encapsulates a Tcl variable, or
                                array and provides services for accessing,
                                linking and, if derived, tracing the variable.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    See the reference guides for detailed information about these
                    classes.
                </para>
                <para>
                    Suppose we are writing a new event processor  that
                    will compute the calibrated parameter from the raw parameter.
                    We're going to have a class definition for that event processor
                    that looks like this:
                </para>
                <example>
                    <title>Calibration event processor</title>
                    <programlisting>
#ifndef CALIB_H
#define CALIB_H

#include &lt;EventProcessor.h&gt;
#include &lt;TreeParameter.h&gt;


class Calibrator : public CEventProcessor
{
private:
  CTreeParameter  m_raw;
  CTreeParameter  m_calibrated;
public:
  Calibrator();
  Bool_t operator()(const Address_t pEvent, CEvent&amp; rEvent,
                    CAnalyzer&amp; rAnalyzer, CBufferDecoder&amp; rDecoder);
private:
  double getSlope();                                      
  double getOffset();

};
#endif
                        
                    </programlisting>
                </example>
                <para>
                    If you've gone through the sections on writing event processors,
                    this should be nothing new.  We've added:
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            Two <classname>CTreeParameter</classname> member
                            variables.  <varname>m_raw</varname> will
                            is a tree parameter for the raw parameter.
                            <varname>m_calibrated</varname> is a tree
                            parameter for the calibrated parameter.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            We've added a construtor whose job it will be to
                            create the tree parameters properly.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            We added two private methods,
                            <methodname>getSlope</methodname> and
                            <methodname>getOffset</methodname> that will insulate
                            our event processing code from the mechanisms of
                            fetching the calibration slope and offset values.
                        </para>
                    </listitem>
                </itemizedlist>
                <para>
                    The constructor is pretty simple.  Assuming the raw parameter
                    is named <literal>raw</literal> and is from a 4K ADC e.g.
                    and the calibrated parameter is named
                    <literal>calibrated</literal> and represents energy in KeV
                    between 0 and 2,000;
                </para>
                <example>
                    <title>Calibrated parameter constructor</title>
                    <programlisting>
#include &lt;config.h&gt;
#include "Calib.h"
...
Calibrator::Calibrator() :
  m_raw("raw", 4096, 0.0, 4095.0, "arbitrary"),
  m_calibrated("calibrated", 4096, 0.0, 2000, "KeV")
{}

                    </programlisting>
                </example>
                <para>
                    Let's look at the event processor.  It will be registered in
                    the event processing pipeline after whatever does the
                    raw unpacking and produces the <literal>raw</literal>
                    parameter.  That means that our event processor
                    has access to the <literal>raw</literal> parameter
                    in the tree parameter rather than having to decode it again
                    from the data:
                </para>
                <example>
                    <title>Calibrated parameter computatino:</title>
                    <programlisting>
Bool_t
Calibrator::operator()(const Address_t pEvent, CEvent&amp; rEvent,
                    CAnalyzer&amp; rAnalyzer, CBufferDecoder&amp; rDecoder)
{
  if (m_raw.isValid()) {
    m_calibrated = getSlope() * m_raw + getOffset();
  }
  return kfTRUE;
}

                    </programlisting>
                </example>
                <para>
                    Pretty simple.  Note that we can only compute the calibrated
                    parameter if the raw parameter has a value for this event.
                    That's what the if statement checks.
                </para>
                <para>
                    Let's look at the <methodname>getSlope</methodname> method.
                </para>
                <example>
                    <title>Getting the slope from a Tcl variable:</title>
                    <programlisting>
#include &lt;SpecTcl.h&gt;
#include &lt;TCLInterpreter.h&gt;
#include &lt;TCLVariable.h&gt;
#include &lt;cstdlib&gt;
...
double
Calibrator::getSlope()
{
  SpecTcl* pApi            = SpecTcl::getInstance();  <co id='calibget.api' />
  CTCLInterpreter* pInterp = pApi->getInterpreter();  <co id='calibget.interp' />

  CTCLVariable slopeVar(pInterp, "slope", kfFALSE);   <co id='calibget.tclvar' />
  const char*  slopeString = slopeVar.Get();          <co id='calibget.varget' />
  double slope;

  if (slopeString) {
    slope = std::atof(slopeString);                  <co id='calibget.setval' />
  } else {
    slope = 1.0;
  }

  return slope;
}

                    </programlisting>
                </example>
                <para>
                    If you're not familiar with the classes being used some
                    of this might be a bit confusing, so let's pick it apart
                    step by step:
                </para>
                <calloutlist>
                    <callout arearefs='calibget.api'>
                        <para>
                            Gets a pointer to the SpecTcl API.  Recall that
                            the <classname>SpecTcl</classname> class implements
                            a singleton object.  For more on the Singleton
                            design pattern see e.g.:
                            <ulink url='https://msdn.microsoft.com/en-us/library/ee817670.aspx' />.
                        </para>
                        <para>
                            Singleton's don't have public constructors.  They
                            have a method (in our case <methodname>getInstance</methodname>)
                            that returns a poiner to the one allowed instance of
                            that class.
                        </para>
                    </callout>
                    <callout arearefs='calibget.interp'>
                        <para>
                            <methodname>getInterpreter()</methodname> returns a
                            pointer to the Tcl++ object that wraps the
                            interpreter that SpecTcl uses for command processing.
                            This is the interpreter in which the variables
                            we are interested in will be defined. Note that
                            applications can, and often do, instantiate more than
                            one interpreter so it's important to do this to get the
                            right one.
                        </para>
                    </callout>
                    <callout arearefs='calibget.tclvar'>
                        <para>
                            <classname>CTCLVariable</classname> wraps a variable
                            that lives in Tcl scripts.  Note that this constructor
                            provides an interpreter in which the variable is
                            defined.  The last parameter of the constructor is
                            a flag that indicates whether or not we want to trace
                            the variable as it changes.  Tracing is beyond the
                            scope of this manual.
                        </para>
                        <para>
                            Note that creating an object like this does not
                            ensure the variable exists, nor does it create
                            it if it does not.  This will be important to know
                            in the lines of code that follow.
                        </para>
                    </callout>
                    <callout arearefs='calibget.varget'>
                        <para>
                            The <methodname>Get</methodname> method returns the
                            string representation of the variable's value.
                            Recall that in Tcl all objects have a string
                            representation.  Not shown are a set of
                            flags that are passed to <methodname>Get</methodname>.
                            By default, these flags look only at global variables.
                            That's what we want.
                        </para>
                        <para>
                            Previously I said that the creation of an instance
                            of <classname>CTCLVariable</classname> does not
                            gaurantee the existence of that variable.  It may never
                            have been given a value.  If the variable has not
                            been given a value, then the return value from
                            <methodname>Get</methodname> is a null pointer.
                        </para>
                    </callout>
                    <callout arearefs='calibget.setval'>
                        <para>
                            If the return value from <methodname>Get</methodname>
                            was not a null pointer it is decoded as a
                            double.  This code assumes the string is a value
                            representation of a floating point value.  production
                            code might instead use <methodname>std::strtod</methodname>
                            which allows the caller to determine if the conversion
                            succeeded.
                        </para>
                        <para>
                            If the variable has not yet been set, the return
                            value from <methodname>Get</methodname> is null
                            and a default value of <literal>1.0</literal> is
                            returned.
                        </para>
                    </callout>
                </calloutlist>
                <para>
                    The code for offset is pretty much identical.  As an exercise,
                    create a method <methodname>getDouble</methodname> and
                    rewrite <methodname>getSlope</methodname> and
                    <methodname>getOffset</methodname> in terms of it.
                </para>
                <example>
                    <title>Getting the offset from a Tcl variable</title>
                    <programlisting>
double
Calibrator::getOffset()
{
  SpecTcl* pApi            = SpecTcl::getInstance();
  CTCLInterpreter* pInterp = pApi->getInterpreter();

  CTCLVariable offVar(pInterp, "offset", kfFALSE);
  const char*  offString = offVar.Get();
  double offset;

  if (offString) {
    offset = std::atof(offString);
  } else {
    offset = 0.0;
  }

  return slope;
}
                        
                    </programlisting>
                </example>
                <para>
                    The only difference from <methodname>getSlope</methodname>
                    is the name of the variable we care about and the default
                    value.
                </para>
                <para>
                    The code shown in these examples is perfectly fine.  It
                    will work.  It does, however require that for each event
                    with a <literal>raw</literal> parameter the
                    Tcl interpreter has to give us the variable values and
                    we need to convert those string values into doubles.
                    We can use <firstterm>Variable Linking</firstterm>
                    to speed this up.
                </para>
                <para>
                    Tcl allows us to associate a script variable with a
                    C/C++ variable.  When you do this, you specify the underlying
                    type of the variable and Tcl constrains values to valid
                    values for that type.  To access the value of a Tcl variable
                    that is linked, you just need to get the value of the
                    local C/C++ variable.
                </para>
                <para>
                    To make all of this work for use we'll:
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            Add member variables to the class for the slope
                            and offset.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Modify the constructor to link member variables to
                            the variable.  Note that links are always one-to-one.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Provide a class destructor to undo the link as
                            storing data to the variable after our class
                            is destroyed is likely to make a segfault happen.
                            Note that this is good practice though in an event
                            processor you probably could get away without it
                            as most event processors exist for the length of
                            the program's run.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Modify <methodname>getSlope</methodname> and
                            <methodname>getOffset</methodname> to return
                            the values of the linked variables.  While we
                            could reference those variables directly in the
                            <methodname>operator()</methodname>, we choose not
                            to so that the method of obtaining the variable
                            values is opaque to that method.
                        </para>
                    </listitem>
                </itemizedlist>
                <para>
                    Let's look at the changes to the header:
                </para>
                <example>
                    <title>Calibrator header with linked variables:</title>
                    <programlisting>
#ifndef CALIB_H
#define CALIB_H

#include &lt;EventProcessor.h&gt;
#include &lt;TreeParameter.h&gt;


class Calibrator : public CEventProcessor
{
private:
  CTreeParameter  m_raw;                   
  CTreeParameter  m_calibrated;            

  <emphasis role='bold'>double          m_slope;</emphasis>
  <emphasis role='bold'>double          m_offset;</emphasis>
public:
  Calibrator();
  <emphasis role='bold'>virtual ~Calibrator();</emphasis>
  Bool_t operator()(const Address_t pEvent, CEvent&amp; rEvent,
                    CAnalyzer&amp; rAnalyzer, CBufferDecoder&amp; rDecoder);
private:
  double getSlope();
  double getOffset();

};


#endif

                    </programlisting>
                </example>
                <para>
                    The three lines added to the header are emphasized above.
                </para>
                <para>
                    The constructor must be modified to link the variables
                    to the Tcl Variables.  Note that the code also ensures
                    there are initial values for the variables that make
                    sense:
                </para>
                <example>
                    <title>Constructor for linked variables</title>
                    <programlisting>
Calibrator::Calibrator() :
  m_raw("raw", 4096, 0.0, 4095.0, "arbitrary"),
  m_calibrated("calibrated", 4096, 0.0, 2000, "KeV")
{
  SpecTcl* pApi = SpecTcl::getInstance();
  CTCLInterpreter* pInterp = pApi->getInterpreter(); <co id='calib.linkinterp' />

  CTCLVariable slope(pInterp, "slope", kfFALSE);
  m_slope = 1.0;                                     <co id='calib.linkslopeset' />
  slope.Link(&amp;m_slope, TCL_LINK_DOUBLE);         <co id='calib.linkslopelink' />

  CTCLVariable offset(pInterp, "offset", kfFALSE);
  m_offset = 0.0;                                    <co id='calib.linkoffsettoo' />
  offset.Link(&amp;m_offset, TCL_LINK_DOUBLE);

}

                    </programlisting>
                </example>
                <calloutlist>
                    <callout arearefs='calib.linkinterp'>
                        <para>
                            This code should be familiar by now.  We use the
                            SpecTcl API singleton to get a pointer to the SpecTcl
                            command interpreter.
                        </para>
                    </callout>
                    <callout arearefs='calib.linkslopeset'>
                        <para>
                            When the variable is linked to a C/C++ variable it is
                            given the current value of that variable.  This
                            gives the slope a default value of <literal>1.0</literal>.
                        </para>
                    </callout>
                    <callout arearefs='calib.linkslopelink'>
                        <para>
                            This call links the slope variable to <varname>m_slope</varname>
                            forcing it to be a double.
                        </para>
                    </callout>
                    <callout arearefs='calib.linkoffsettoo' >
                        <para>
                            Similarly the offset is linked with the default
                            value of <literal>0.0</literal>
                        </para>
                    </callout>
                </calloutlist>
                <para>
                    If our event processor is destroyed, referencing the Tcl
                    variables <varname>slope</varname> and
                    <varname>offset</varname> will likely cause segmentation
                    faults.   We therefore need code to undo the link
                    at destruction time:
                </para>
                <example>
                    <title>Destructor for linked variable calibrator</title>
                    <programlisting>
Calibrator::~Calibrator()
{
  SpecTcl* pApi = SpecTcl::getInstance();
  CTCLInterpreter* pInterp = pApi->getInterpreter();

  CTCLVariable slope(pInterp, "slope", kfFALSE);
  slope.Unlink();

  CTCLVariable offset(pInterp, "offset", kfFALSE);
  offset.Unlink();

}
                    </programlisting>
                </example>
                <para>
                    Much of this code should be understandable.  The
                    <methodname>Unlink</methodname> removes any link the
                    variable may have with a C/C++ variable.
                </para>
                <para>
                    By using get <methodname>getSlope()</methodname> and
                    <methodname>getOffset()</methodname> methods, the
                    <methodname>operator()</methodname> method body is unchanged.
                    The two getters, however become significantly simpler:
                </para>
                <example>
                    <title>Getting slope and offset for linked variables</title>
                    <programlisting>
double
Calibrator::getSlope()
{

  return m_slope;
}

double
Calibrator::getOffset()
{

  return m_offset;
}

                    </programlisting>
                </example>
                <para>
                   No explanation is needed. 
                </para>
            </section>
            <section>
                <title>Using the Treevariable subsystem</title>
                <para>
                    In the previous section, we looked at how to get data from
                    a Tcl variable using the SpecTcl and Tcl++ APIs to both
                    SpecTcl and the Tcl interpreter.  We used values stored in
                    Tcl variables to compute a calibrated parameter.
                </para>
                <para>
                    In this section, we will introduce the <firstterm>treevariable</firstterm>
                    subsystem.  Daniel Bazin first designed and implemented this
                    system as an extension to SpecTcl.  Over time the code
                    migrated into a contributed subsystsem and now, is a fully
                    supported part of SpecTcl.  
                </para>
                <para>
                    The idea of tree variables is similar to that of tree parameters.
                    These object provide a hierachical namespace of variables.
                    Each tree parameter can be treated as if it were a double.
                    Tree parameters, in addition to having a value, have units of
                    measure.  A tree variable array class allows you to aggregate
                    several tree parameters in to a single object.
                </para>
                <para>
                    Tree parameters are implemented as C/C++ variables that are
                    linked to Tcl variables.    In addition to the C/C++
                    variable they have units of measure.
                </para>
                <para>
                    We will use tree variables to manage a set of calibration
                    parameters.  We'll assume we have a treeparameter array
                    of 16 elements that are called <literal>raw.0 ... raw.15</literal>.
                    Associated with these 16 parameters are two tree variables
                    of calibration constants, one, <literal>slopes</literal>
                    is a tree variable array of 16 sloops while the other,
                    <literal>offsets</literal> is a tree variable array of
                    calibration offsets.
                </para>
                <para>
                    Note that by adding a second level of indirection, as with
                    Tree parameters, more than one tree variable can be associated
                    with a single Tcl variable.   Thus the mapping of Tcl variables
                    to tree parameters is one to many.
                </para>
                <para>
                    Let's look at a header for the calibrator we've described
                    using tree parameters and tree variables.
                </para>
                <example>
                    <title>Header for calibrator using treevariables</title>
                    <programlisting>
#ifndef TREECALIB_H
#define TREECALIB_H
#include &lt;EventProcessor.h&gt;
#include &lt;TreeParameter.h&gt;

class TreeCalibrator : public CEventProcessor
{
private:
  CTreeParameterArray m_raw;
  CTreeParameterArray m_calibrated;
  CTreeVariableArray  m_slope;
  CTreeVariableArray  m_offset;

public:
  TreeCalibrator();
  Bool_t operator()(const Address_t pEvent, CEvent&amp; rEvent,
                    CAnalyzer&amp; rAnalyzer, CBufferDecoder&amp; rDecoder);

};

#endif

                    </programlisting>
                </example>
                <para>
                    In addition to tree parameter arrays with the raw and
                    calibrated parameters, we have tree variable arrays for
                    the calibration values.  The constructor must instantiate
                    these properly.  We're going to assume again, that the
                    raw parameters come from a 12 bit digitizer of some sort.
                </para>
                <para>
                    Here's the constructor:
                </para>
                <example>
                    <title>TreeCalibratorConstructor</title>
                    <programlisting>
^Cfox@charlie:~/test/sample$ cat TreeCalib.cpp
#include &lt;config.h&gt;
#include "TreeCalib.h"

TreeCalibrator::TreeCalibrator() :
  m_raw("raw", 12, 16, 0),
  m_calibrated("calibrated", 12, 16, 0),
  m_slope("slope", 1.0, "KeV/channel", 16, 0),
  m_offset("offset", 0.0, "KeV", 16, 0)
{}

                    </programlisting>
                </example>
                <para>
                    The form of the tree parameter constructor we are using
                    says that the parameters are 12 bits wide (go from
                    0 through 4095).  The tree variable array initializers
                    create 16 slopes initialized to 1.0 and 16 offsets initialized to 0.
                    The parameters will be calibrated in KeV.
                </para>
                <para>
                    Using Tree parameters and tree variables makes the
                    <methodname>operator()</methodname> trivial to write:
                </para>
                <example>
                    <title>TreeCalibrator::operator()</title>
                    <programlisting>
Bool_t
TreeCalibrator::operator()(const Address_t pEvent, CEvent&amp; rEvent,
                           CAnalyzer&amp; rAnalyzer, CBufferDecoder&amp; rDecoder)
{
  for (int i = 0; i &lt; 16; i++) {
    if (m_raw[i].isValid()) {
      m_calibrated[i] = m_raw[i] * m_slope[i] + m_offset[i];
    }
  }
  return kfTRUE;
}

                    </programlisting>
                </example>
                <para>
                    The really cool thing about tree parameters and tree variables
                    from the programmer's point of view is that they mimic ordinary
                    doubles and that arrays mimic ordinary arrays.
                </para>
            </section>
            <section>
                <title>Adding new compiled commands to Tcl</title>
                <para>
                    We'll continue to use our calibrated parameter as an example
                    for how to add commands to SpecTcl.  We've already seen
                    that using tree parameters and tree variables provides
                    a truly elegant solution.   
                </para>
                <para>
                    Going back to our example of a single calibrated parameters:
                    We're going to add a command
                    called <command>setcalib</command>.  <command>setcalib</command>
                    accepts two double parameters.  The first is the slope and
                    the second the calibration offset.
                </para>
                <para>
                    This example is a bit involved:
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            We need an event processor that stores slope and offset
                            and uses them to compute a calibrated parameter.
                            The event processor must also provide a mechanism
                            to set the slope and offset
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            We need a <classname>CTCLObjectProcessor</classname>
                            derived object.  <classname>CTCLObjectProcessor</classname>
                            is a class that wraps Tcl compiled application specific
                            commands.  All of SpecTcl's extensions to the Tcl
                            interpreter are implemented as classes derived from
                            <classname>CTCLObjectProcessor</classname>.
                        </para>
                        <para>
                            The class we design and implement must also have
                            a way to modify the slope and offset of the
                            event processor.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            We need to make the event processor and the
                            command known to SpecTcl and Tcl respectively.
                            Included in this are both modifications
                            to the <filename>MySpecTclApp.cpp</filename>
                            and <filename>Makefile</filename> files provided
                            by the skeleton.
                        </para>
                    </listitem>
                </itemizedlist>
                <section>
                    <title>The Event processor</title>
                    <para>
                        The header of the event processor look fairly normal:
                    </para>
                    <example>
                        <title>Event processor for command steered calibration</title>
                        <programlisting>
#ifndef CMDCALIBRATION_H
#define CMDCALIBRATION_H

#include &lt;EventProcessor.h&gt;
#include &lt;TreeParameter.h&gt;

class CmdCalibrator : public CEventProcessor
{
private:
  CTreeParameter m_raw;
  CTreeParameter m_calibrated;
  double         m_slope;
  double         m_offset;
public:
  CmdCalibrator();
  Bool_t operator()(Address_t pEvent, CEvent&amp; rEvent,
                    CAnalyzer&amp; rAnalyzer, CBufferDecoder&amp; rDecoder);

  void setSlope(double slope);
  void setOffset(double offset);
};


#endif

                        </programlisting>
                    </example>
                    <para>
                        The constructor, in addition to constructing the
                        tree parameters must initialize the sllope and offset
                        to reasonable default values:
                    </para>
                    <example>
                        <title>Constructor for command steered calibration event proc.</title>
                        <programlisting>
CmdCalibrator::CmdCalibrator() :
  m_raw("raw", 4096, 0.0, 4095.0, "arbitrary"),
  m_calibrated("calibrated", 4096, 0.0, "KeV"),
  m_slope(1.0),
  m_offset(0.0)
{}


                        </programlisting>
                    </example>
                    <para>
                        The remainder of the event processor is equally trivial:
                    </para>
                    <example>
                        <title>Command drive event processor implementation</title>
                        <programlisting>
Bool_t
CmdCalibrator::operator()(Address_t pEvent, CEvent&amp; rEvent,
                          CAnalyzer&amp; rAnalyzer, CBufferDecoder&amp; rDecoder)
{
  if (m_raw.isValid()) {
    m_calibrated = m_slope * m_raw + m_offset;
  }
}

void CmdCalibrator::setSlope(double slope) {
  m_slope = slope;
}
void CmdCalibrator::setOffset(double offset) {
  m_offset = offset;
};

                        </programlisting>
                    </example>
                </section>
                <section>
                    <title>The command processor</title>
                    <para>
                        <classname>CTCLObjectProcessor</classname> is the base
                        class for all Tcl++ command processors based on
                        <type>Tcl_Obj*</type> parameter lists.
                        <type>Tcl_Obj*</type> parameters are, however,
                        wrapped in <classname>CTCLObject</classname> objects which
                        can do most of the type conversions needed.
                    </para>
                    <para>
                        Our command processor will contain a CmdCalibration
                        event processor reference and will operate on the
                        slope and offset in that object.  This means that our
                        header will look something like this:
                    </para>
                    <example>
                        <title>setcalib command processor header:</title>
                        <programlisting>
#ifndef SETCALIBCOMMAND_H
#define SETCLIBCOMMAND_H

#include &lt;TCLObjectProcessor.h&gt;                      <co id='setcalib.procheader' />
class CmdCalibrator;                                       <co id='setcalib.forwarddef' />

class SetCalibCommand : public CTCLObjectProcessor         <co id='setcalib.classdef' />
{
private:
  CmdCalibrator&amp;   m_eventProcessor;                   <co id='setcalib.evpmember' />

public:
  SetCalibCommand(CTCLInterpreter&amp; interp, CmdCalibrator&amp; evp); <co id='setcalib.constructargs' />

  int operator()(CTCLInterpreter&amp; interp, std::vector&lt;CTCLObject&gt;&amp; objv); <co id='setcalib.cmdentryargs' />
};


#endif

                        </programlisting>
                    </example>
                    <calloutlist>
                        <callout arearefs='setcalib.procheader' >
                            <para>
                                All Tcl command processors that use Tcl++
                                should be derived from
                                the <classname>CTCLObjectProcessor</classname>
                                base class.  This header provides the definition
                                of that class needed by derived classes.
                            </para>
                        </callout>
                        <callout arearefs='setcalib.forwarddef'>
                            <para>
                                This is a forward, opaque definition of our
                                <classname>CmdCalibrator</classname> event processor.
                                We could also include the
                                <filename>CmdCalibration.h</filename> header.
                                We do not, however, need the compiler to know
                                the actual shape of the
                                <classname>CmdCalibrator</classname> class when
                                it is compiling the header as we're going to hold
                                a reference to the actual event processor object
                                rather than the object itself.
                            </para>
                            <para>
                                Stylistically and practically, if you can get
                                away with opaque forward definitions like this you should.
                                In addition to the slight increase in compilation
                                speed (the compiler doesn't have to include and compile
                                the header at this time), there are circular definition
                                problems that can be side stepped by using
                                opaque forward references.
                            </para>
                            <para>
                                For example, suppose I have a class A that holds
                                a reference to class B and class B holds a
                                 pointer to class A.  There's no way to use
                                 header includes to resolve the need to define
                                 A to B's and B to A's header.  Forward references
                                 such as the one shown above resolve this problem.
                            </para>
                        </callout>
                        <callout arearefs='setcalib.classdef'>
                            <para>
                                Our class, <classname>SetCalibCommand</classname>
                                is derived, as promised from
                                <classname>CTCObjectProcessor</classname>.
                            </para>
                        </callout>
                        <callout arearefs='setcalib.evpmember'>
                            <para>
                                This member declaration provides storage
                                for a refrence to the event processor we're
                                configuring.
                            </para>
                        </callout>
                        <callout arearefs='setcalib.constructargs' >
                            <para>
                                The construtor must store the reference to the
                                event processor.  As we'll see in the implementation,
                                the Tcl interpreter on which the command is going
                                to be registered must be passed to the
                                <classname>CTCLObjectProcessor</classname>
                                constructor.  Those two constraints determine
                                the argument signature for the constructor.
                            </para>
                            <para>
                                The command name is going to be hard coded
                                in the implementation's call to the
                                <command>CTCLObjectProcessotr</command> constructor.
                                Note that it's more usual to allow the
                                creator of the object to supply the command
                                name to the constructor as this allows the
                                application control over the command, and the
                                namespace it might live in.
                            </para>
                            <para>
                                We hard code the command name for simplicity.
                            </para>
                        </callout>
                        <callout arearefs='setcalib.cmdentryargs'>
                            <para>
                                The base class arranges for the virtual
                                method <methodname>operator()</methodname>
                                to be invoked when the command is executed.
                                That method is overriden by specific command
                                processors to provdee argument processing and
                                the logic of the command.
                            </para>
                            <para>
                                The <methodname>operator()</methodname> method is
                                passed a reference to the interpreter and
                                a reference to the vector of command words
                                encapsulated in <classname>CTCLObject</classname>
                                objects.  Note that the command words include
                                the command name word itself (<literal>objv[0]</literal>).
                            </para>
                        </callout>
                    </calloutlist>
                    <para>
                        Let's have a look at the constructor.  It's quite simple.
                        The base class constructor does all the work of registering
                        the command with Tcl and arranging for the
                        <methodname>operator()</methodname> to be called inside
                        a try/catch block when the command is executed:
                    </para>
                    <example>
                        <title>setcalib command constructor:</title>
                        <programlisting>
#include &lt;config.h&gt;

#include "SetCalibCommand.h"
#include "CmdCalibration.h"                <co id='setcalib.implincludes' />
#include &lt;TCLInterpreter.h&gt;
#include &lt;TCLObject.h&gt;

SetCalibCommand::SetCalibCommand(CTCLInterpreter&amp; interp, CmdCalibrator&amp; evp) :
  CTCLObjectProcessor(interp, "setcalib", true),  <co id='setcalib.bcconstruct' />
  m_eventProcessor(evp)                           <co id='setcalib.refconstruct' />
{}

                        </programlisting>
                    </example>
                    <calloutlist>
                        <callout arearefs='setcalib.implincludes'>
                            <para>
                                These headers are included to satisfy opaque
                                forward references in various headers.
                            </para>
                            <para>
                                We made an forward reference to
                                <classname>CmdCalibrator</classname>
                                in our header and the header for
                                <classname>CTCLObjectProcessor</classname>
                                makes opaque forward references to both
                                <classname>CTCLInterpreter</classname> and
                                <classname>CTCLObject</classname>.
                            </para>
                            <para>
                                We have code in this implementation that
                                needs to know the actual shape of these
                                classes.  You need to know the shape of a class
                                if you are going to invoke its methods or refer
                                to public data it may have.
                            </para>
                        </callout>
                        <callout arearefs='setcalib.bcconstruct'>
                            <para>
                                The base class constructor takes care of all
                                of the stuff needed to initialize this object
                                and, if requested, make it known to a
                                Tcl interpreter as a command.
                            </para>
                            <para>
                                The base class constructor we are using,
                                requires the interpreter, on which the object
                                will be registered as a command processor,
                                the verb that will activate the command and
                                a flag indicating whether or not you want the
                                object immediately registered.
                            </para>
                            <para>
                                It is possible to register a command processor
                                object on more than one interpreter, but that's
                                beyond the scope of this manual.  See the reference
                                material that covers Tcl++ for more information
                                about <classname>CTCLObjectProcessor</classname>
                                and the services it offers.
                            </para>
                        </callout>
                        <callout arearefs='setcalib.refconstruct'>
                            <para>
                                All member data that are references must be
                                constructed in class initializers.  This
                                line makes the event processor reference
                                we are  holding refer to the same one that
                                was passed in by reference to the constructor.
                            </para>
                        </callout>
                    </calloutlist>
                    <para>
                        Now we turn our attention to the implementation of the
                        command itself.  Command processors provide two things
                        back to the interpreter.  
                    </para>
                    <para>
                        First they must return an integer status to the
                        caller.  This can be one of <literal>TCL_OK</literal>
                        the command worked just fine. <literal>TCL_ERROR</literal>
                        means the command detected an error and failed.
                        Other return codes are used in command that provide
                        flow control: <literal>TCL_RETURN</literal> indicates
                        that the command requested a return from any proc the
                        command was invoked in.  <literal>TCL_BREAK</literal>
                        indicates the command wants the inner loop that called this
                        command to break out of the loop. <literal>TCL_CONTINUE</literal>
                        means that the command wants the inner loop that called this
                        command to skip the remainder of the loop body and
                        start the next loop iteration (if appropriate to the
                        loop condition).
                    </para>
                    <para>
                        Second, if desired, the command can have an interpreter
                        result.  Interpreter results are what will be substituted
                        for the command if it's used inside a<literal>[]</literal>
                        substitution.  The interpreter result is also what's used
                        as the error message in the event <literal>TCL_ERROR</literal>
                        is returned.  That's how we will use the interpreter
                        command value as we have nothing interesting to return
                        on success.
                    </para>
                    <para>
                        Here's a rough description of what our command will do:
                    </para>
                    <itemizedlist>
                        <listitem>
                            <para>
                                Verify the number of command words is three.
                                We need to have the command verb, the slope
                                and the offset.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                Extract the slope and offset from the
                                command words.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                Invoke the
                                <methodname>setSlope</methodname> and
                                <methodname>setOffset</methodname> methods of
                                the event processor to steer its subsequent
                                processing.
                            </para>
                        </listitem>
                    </itemizedlist>
                    <para>
                        Note that we're going to centralize event handling by
                        wrapping pretty much all of the code in a try catch block.
                    </para>
                    <example>
                        <title>setcalib Command processor implementation</title>
                        <programlisting>
SetCalibCommand::operator()(CTCLInterpreter&amp; interp, std::vector&lt;CTCLObject>&gt; objv)
{
  int status = TCL_OK;                 <co id='setcalib.statoptimism' />

  bindAll(interp, objv);               <co id='setcalib.bindcmdwords' />
  try {
    requireExactly(                    <co id='setcalib.requireexactly' />
        objv, 3,
        "setcalib needs only slope and offset params"
    );

    double slope  = objv[1];           <co id='setcalib.extractparams' />
    if (slope == 0.0) {
        throw "Slope equal to zero makes no sense";  <co id='setcalib.errortothrow' />
    }
    double offset = objv[2];

    m_eventProcessor.setSlope(slope);   <co id='setcalib.setparams' />
    m_eventProcessor.setOffset(offset);

  }
  catch (CException&amp; e) {
    interp.setResult(e.ReasonText());
    status = TCL_ERROR;
  }
  catch (std::exception&amp; e) {
    interp.setResult(e.what());
    status = TCL_ERROR;
  }                                     <co id='setcalib.exceptionhandling' />
  catch (std::string msg) {
    interp.setResult(msg);
    status = TCL_ERROR;
  }
  catch (const char* msg) {
    interp.setResult(msg);
    status = TCL_ERROR;
  }
  catch (...) {
    interp.setResult("Unexpected exception type caught executing setcalib");
    status = TCL_ERROR;
  }

  return status;                     <co id='setcalib.returncode' />

}
                            
                        </programlisting>
                    </example>
                <calloutlist>
                    <callout arearefs='setcalib.statoptimism' >
                        <para>
                            Our error handling strategy will be to wrap
                            the chunks of code that can detect errors in try/catch
                            blocks.  Those try/catch blocks will set the return
                            status to <literal>TCL_ERROR</literal>.
                        </para>
                        <para>
                            This initialization of <varname>status</varname>
                            ensures that if no error is detected, the return
                            code will be <literal>TCL_OK</literal> which indicates
                            success.
                        </para>
                    </callout>
                    <callout arearefs='setcalib.bindcmdwords'>
                        <para>
                            <classname>CTCLObject</classname> objects
                            can be bound or unbound to interpreters.  Some processing
                            of these objects can be done independent of an interpreter,
                            while the underlying API requires other calls to provide
                            an interpreter.  We're just going to bind all
                            command words to the interpreter executing the command
                            so that it's available if we use any services that
                            require an interpreter.
                        </para>
                        <para>
                            The base class,
                            <classname>CTCLObjectProcessor</classname> provides
                            a service method <methodname>bindAll</methodname>
                            that binds an interpreter to all elements of a vector
                            of <classname>CTCLObject</classname>s.
                        </para>
                    </callout>
                    <callout arearefs='setcalib.requireexactly'>
                        <para>
                            <classname>CTCLObjectProcessor</classname> provides
                            several utility methods for checking that your
                            command has been passed a valid number of parameters.
                            <methodname>requireExactly</methodname> throws
                            an <classname>std::string</classname> exception (the
                            value of the last parameter), if the size of
                            <varname>objv</varname> is not exactly what
                            is specified by the second parameter.
                        </para>
                        <para>
                            <methodname>requireAtLeast</methodname> and
                            <methodname>requireAtMost</methodname> are also
                            provided to handle cases where a command may have
                            a variable number of parameters.
                        </para>
                        <para>
                            Note as well that the command requires three parameters
                            because <varname>objv[0]</varname> is always the
                            command verb.
                        </para>
                    </callout>
                    <callout arearefs='setcalib.extractparams'>
                        <para>
                            <classname>CTCLObject</classname> provides type
                            conversion
                            operators that are capable of extracting the
                            various representations from the
                            <type>Tcl_Obj*</type> it wraps. In this case the
                            implicit type coniversion extracts the
                            double precision floating
                            point representation from that object.
                        </para>
                        <para>
                            If the required representation cannot be extracted
                            (e.g. the slope parameter might have the value
                            <literal>bad</literal>), a
                            <classname>CTCLException</classname> is thrown.
                            This exception type is derived from
                            <classname>CException</classname>.
                        </para>
                    </callout>
                    <callout arearefs='setcalib.errortothrow'>
                        <para>
                            Here we see how error detection and handling can
                            be turned into an exception throw.  Of course
                            a slope of zero maps all parameter values onto the offset
                            and is unreasonable.  The ability to do this error
                            checking is about the only advantage this approach
                            to calibration has.
                        </para>
                        <para>
                            Note that while we throw the exception here,
                            it's caught a bit lower down in the code
                            and turned into an error.
                        </para>
                    </callout>
                    <callout arearefs='setcalib.setparams'>
                        <para>
                            Once the calibration constants have been processed
                            successfully, we can set them in the event processor.
                            Having done so, on the next event, the new constants
                            will be used to produce the calibrated parameter.
                        </para>
                    </callout>
                    <callout arearefs='setcalib.exceptionhandling'>
                        <para>
                            This group of catches extracts an error message
                            from whatever exception was thrown and invokes
                            the <classname>CTCLInterpreter</classname>
                            <methodname>setResult</methodname> to set the
                            command result as well as setting the status
                            variable to <literal>TCL_ERROR</literal> so that
                            the interpreter knows an error occured.
                        </para>
                        <para>
                            Before continuing on, an important point of exception
                            handling is illustrated here.  The principle that
                            your <literal>catch</literal> blocks should catch
                            as generic a base class as possible.  Thus instead of
                            catching <classname>CTCLException</classname> we catch
                            the ultimate base class <classname>CException</classname>,
                            similarly we catch <classname>std::exception</classname>
                            the ultimate base class of C++ language exceptions.
                        </para>
                        <para>
                            The reason this is a good idea is that it insulates
                            us as much as possible from knowing the exact exception
                            types the code we use throws.  There are cases where
                            you must make an exception (no pun intended) to this rule.
                        </para>
                        <para>
                            Suppose you use an I/O package that throws a variety
                            of objects derived from <classname>iopkgexception</classname>.
                            Suppose that an attempt to read past end of file
                            results in a derived type <classname>eofexception</classname>
                            being thrown.  It can make sense to catch
                            <classname>eofexception</classname> prior to trying
                            to catch the generic <classname>iopkgexception</classname>
                            because you need to process an <classname>eofexception</classname>
                            differently than a generic error.
                        </para>
                        <para>
                            Note as well the final <literal>catch(...)</literal>
                            which catches unanticipated exception types and turns
                            them into a generic error message and a return code
                            of <literal>TCL_ERROR</literal>.
                        </para>
                    </callout>
                    <callout arearefs='setcalib.returncode'>
                        <para>
                            The final return code, <literal>TCL_OK</literal> if
                            no exception is caught, or <literal>TCL_ERROR</literal>
                            if one was. is returned to the interpreter.
                        </para>
                    </callout>
                </calloutlist>
                <section>
                    <title>Hooking it all together.</title>
                    <para>
                        To make all of this work we need to:
                    </para>
                    <orderedlist>
                        <listitem>
                            <para>
                                Ensure that MySpecTclApp.cpp includes the headers
                                for our event processor and our command processor.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                Instantiate and register our event processor
                                in the event procesing pipeline after the raw
                                event decoding has been done.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                Create an instance of our command processor
                                registered on the SpecTcl command interpreter and
                                given an instance of our event processor.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                Make additions to the Makefile so that our
                                event processor and our command processor
                                get built into SpecTcl.
                            </para>
                        </listitem>
                    </orderedlist>
                    <formalpara>
                        <title>Including headers</title>
                        <para>
                            Locate all of the <literal>#include</literal>
                            directives towards the top of
                            <filename>MySpecTclApp.h</filename>.  Inser the
                            following towards the bottom of those directives?
                        </para>
                    </formalpara>
                    <informalexample>
                        <programlisting>
#include "CmdCalibration.h"
#include "SetCalibCommand.h"
                        </programlisting>
                    </informalexample>
                    <formalpara>
                        <title>Instantiate and register the event processor</title>
                        <para>
                            We're going to statically create the event processor.
                            Registration will be done in the usual mannner
                            in <methodname>CreateAnalysisPipeline</methodname>.
                        </para>
                    </formalpara>
                    <para>
                        Just prior to <methodname>CreateAnalysisPipeline</methodname>
                        create an instance of the event processor.  With intervening
                        comments at the front of that method stripped out, this
                        will look like:
                    </para>
                    <informalexample>
                        <programlisting>
CmdCalibrator calibration;
void
CMySpecTclApp::CreateAnalysisPipeline(CAnalyzer&amp; rAnalyzer)
{
  RegisterEventProcessor(*(new SimpleEventProcessor), "Test");
  RegisterEventProcessor(calibration, "Calibrator");

}

                        </programlisting>
                    </informalexample>
                    <para>
                        We created this static instance of
                        <classname>CmdCalibrator</classname> so that
                        we can find it when we make our command processor
                    </para>
                    <formalpara>
                    <title>Creating and adding our command processor.</title>
                        <para>
                            <filename>MySpecTclApp.cpp</filename> has a
                            method; <methodname>AddCommands</methodname>.
                            That method is responsible for adding commands
                            to the base Tcl command set.
                        </para>
                    </formalpara>
                    <para>
                        Add a line that Creates an instance of our event
                        processor using the interpreter that's passed in
                        to that method.  Here's what it looks like after the
                        addition:
                    </para>
                    <informalexample>
                        <programlisting>
void
CMySpecTclApp::AddCommands(CTCLInterpreter&amp; rInterp)
{ CTclGrammerApp::AddCommands(rInterp);

  new SetCalibCommand(rInterp, calibration);
}
                        </programlisting>
                    </informalexample>
                    <para>
                        Note that you should <emphasis>never</emphasis>
                        remove the call to
                        <methodname>CTclGrammerApp::AddCommands</methodname>
                        at the top of this method.  That call adds SpecTcl's
                        command set.
                    </para>
                </section>
            </section>
        </section>
        </section>
    </chapter>
    <chapter id='chap.gui'>
        <title id='chap.gui.title'>Using the 'standard' SpecTcl GUI</title>
        <para>
            Up until now we've gotten through this manual with a single
            picture.  That's about to change.  The <filename>SpecTclRC.tcl</filename>
            as it comes from the skeleton includes a few lines that look like
            this:
        </para>
        <informalexample>
            <programlisting>
splash::progress $splash {Loading SpecTcl Tree Gui} 1

puts -nonewline "Starting treeparamgui..."
source $SpecTclHome/Script/SpecTclGui.tcl
puts " Done"

            </programlisting>
        </informalexample>
        <para>
            This loads SpecTcl's default graphical user interface.  In this chapter
            we will take a tour of that interface complete with pictures of the UI
            in progress.  Have a look at the figure below while we describe the
            highlights this tour will take.
        </para>
        <figure>
            <title>SpecTcl default graphical user interface (GUI)</title>
            <graphic format='PNG' fileref='gui1.png' />
        </figure>
        <para>
            Note that the GUI consists of a menu bar, several tabs, each of
            which select different pages within the GUI and a status bar
            at the bottom that provides information about the amount of
            free Display memory, and source of data being analyzed.
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    First we'll take a tour of the menu bar.  The menubar
                    provides access to operations that are frequently used but
                    don't necessarily have a place on any of the tab pages.
                </para>
            </listitem>
            <listitem>
                <para>
                    Next we'll look at the Spectra tab.  This tab allows you
                    to create spectra of various types, apply existing gates
                    to them and load/save files that contain the definitions.
                </para>
            </listitem>
            <listitem>
                <para>
                    The Parameters tab provides access to tree parameter
                    definitions. 
                </para>
            </listitem>
            <listitem>
                <para>
                    The Variables tab provides access to tree variable definitions
                    and values.
                </para>
            </listitem>
            <listitem>
                <para>
                    The gates tab allows you to create gates.  It is primarily used
                    to create compound gates as it is easier to enter the simple gates 
                    via the displayer.
                </para>
            </listitem>
            <listitem>
                <para>
                    Finally the Folders tab provides a comprehensive GUI that
                    allows you to create and manipulate
                    spectra, gates, variables and parameters (including
                    psuedo parameters).   The folders tabname comes from the
                    fact that the hierarchy of each object's name space
                    is represented as a tree view using folders to indicate
                    that you can drill down deeper into the hierarchy.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            The SpecTcl GUI supports saving the analysis definitions to file.
            Since you may forget to do this, or perhaps SpecTcl will crash
            before you have a chance to do this, after each change to the
            analysis conditions, SpeTcl's Gui will automatically save
            SpecTcl's analysis state to the file <filename>failsafe.tcl</filename>
            in the current working directory.
        </para>
        <section>
            <title>The Menubar and its contents</title>
            <para>
                Let's look at the menu bar one menu at a time:
            </para>
            <section>
                <title>The File menu</title>
                <para>
                    The file menu, as the name implies, provides the ability to
                    save and restore objects to and from the filesystem.
                </para>
                <formalpara>
                    <title><guimenu>File</guimenu><guimenuitem>Save...</guimenuitem></title>
                    <para>
                        Allows you to save all or part of the analysis setup to
                        file.  Note that the GUI maintains the most recent
                        analysis state in <filename>failsafe.tcl</filename>.
                        That file is updated after each change.  
                    </para>
                </formalpara>
                <para>
                    <guimenu>File</guimenu><guimenuitem>Save...</guimenuitem>
                    brings up the dialog below:
                </para>
                <figure>
                    <title>
                        The <guimenu>File</guimenu><guimenuitem>Save...</guimenuitem> dialog
                    </title>
                    <graphic format='PNG' fileref='savedialog.png' />
                </figure>
                <para>
                    The checkboxes allow you to select which objects are saved
                    to file.  The lower part of the dialog allows you to choose
                    the directory and name of the file.  Online help is provided
                    through the <guibutton>Help</guibutton> button.  Once
                    you've selected the items you want saved, and the file in which
                    to save them, you can click <guibutton>Ok</guibutton> to save
                    the file.  If you decide you don't want to save,
                    <guibutton>Cancel</guibutton> dismisses the dialog and does
                    nothing.
                </para>
                <formalpara>
                    <title><guimenu>File</guimenu><guimenuitem>Save TreeVariables...</guimenuitem></title>
                    <para>
                        Saves only the values and units of the tree variables.
                        This just brings up an ordinary file save dialog box
                        from which you can pick the directory and name of the
                        file.
                    </para>
                </formalpara>
                <formalpara>
                    <title><guimenu>File</guimenu><guimenuitem>Save Contents Of Spectra</guimenuitem></title>
                    <para>
                        This menu item allows you to save a file that has the
                        contents of one or more spectra.  This is a two step
                        process.  First you must select the spectra to save.
                        Second you must tell the GUI the directory/filename
                        in which to save the specstra.
                    </para>
                </formalpara>
                <para>
                    The spectrum chooser looks like this:
                </para>
                <figure>
                    <title>Choosing spectra to save to file</title>
                    <graphic format="PNG" fileref='savespectrumchooser.png' />
                </figure>
                <para>
                    On the left size the spectra not yet choosen are available
                    via their hierachical naming in a folder system.  The
                    spectra shwon are <literal>raw.00</literal>, <literal>raw.02</literal>
                    and so on.  The list on the right are the spectra that have
                    already been selected.
                </para>
                <para>
                    Once <guibutton>Ok</guibutton> is clicked the dialog is
                    dismissed an a file save dialog box appears instead to allow
                    you to select the directory an filename into which the
                    spectra will be saved.
                    The <command>swrite</command> commmand is used to write
                    the spectra in SpecTcl ASCII format.
                </para>
                <formalpara>
                    <title><guimenu>File</guimenu><guimenuitem>Load...</guimenuitem></title>
                    <para>
                        Brings up a file selection dialog.  The selected file
                        is assumed to contain a saved analysis state which is
                        loaded into SpecTcl.  Note that save files are Tcl scripts
                        so actually, this sources the script and reports errors.
                        After sourcing the script a <command>sbind -all</command>
                        is performed to attempt to put all spectra ito the
                        spectrum viewer shared memory.
                    </para>
                </formalpara>
                <formalpara>
                    <title><guimenu>File</guimenu><guimenuitem>Read Spectrum File...</guimenuitem></title>
                    <para>
                        Allows you to read a file that contains spectrum
                        data.  These are files written with <command>swrite</command>.
                        <guimenu>File</guimenu><guimenuitem>Save Contents of Spectra...</guimenuitem>
                        creates files readable by this menu entry.  The menu
                        command brings up the following dialog:
                    </para>
                </formalpara>
                <figure>
                    <title>Spectrum file selection dialog</title>
                    <graphic format='PNG' fileref='restorespectrumchoosr.png' />
                </figure>
                <para>
                    <command>sread</command> on which this menu option is based
                    has several ways to read in spectra.  These are reflected by
                    the checkbuttons at the bottom of the dialog box.  Here is
                    the meaning of these checkbuttons:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>Snapshot</literal></term>
                        <listitem>
                            <para>
                                If this is checked, the spectrum read is a snapshot
                                spectrum.  Snapshot spectra are spectra that are
                                never incremented.
                            </para>
                            <para>
                                If not checked, SpecTcl attempts to reconnect
                                the spectrum to the underlying parameters that
                                originally made it.  If all parameters are present,
                                the spectrum become live, incrementing based
                                on new event data as its read in.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>Replace existing spectra</literal></term>
                        <listitem>
                            <para>
                                Spectrum files contain the original names of the
                                spectrum.  If this checkbox is checked and there's
                                already a spectrum withthe specified name,
                                it is replaced.   If not, a new unique spectrum
                                name is created from the original by appending
                                an underscore and an integer (e.g.
                                <literal>raw.00</literal> might be given the name
                                <literal>raw.00_0</literal>).
                            </para>
                            <para>
                                This box is, in fact orthogonal to
                                <literal>Snapshot</literal> above.  A spectrum
                                can be replaced with a snapshot.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>Bind to display</literal></term>
                        <listitem>
                            <para>
                                If checked, once the spectrum has been read
                                in, its contents are relocated to the displayer
                                shared memory.  This makes it available
                                to the spectrum visualizer being used.
                                If not checked, the spectrum is still
                                loaded but is not visible to the displayer
                                until <command>sbind</command> is used to
                                bind it later.
                            </para>
                        </listitem>
                    </varlistentry>                    
                </variablelist>
                <formalpara>
                    <title><guimenu>File</guimenu><guimenuitem>Source Tcl Script...</guimenuitem></title>
                    <para>
                        Brings up a file selection dialog.  The selected file
                        is sourced in as a Tcl script.  Any error is reported
                        as a message box.
                    </para>
                </formalpara>
            </section>
            <section>
                <title>The Edit menu</title>
                <para>
                    Currently the <guimenu>Edit</guimenu> menu only has one
                    item:  <guimenuitem>Preferences...</guimenuitem>.  This allows
                    users to setup SpecTcl gui defaults and preferences.
                </para>
                <para>
                    The dialog below pops up:
                </para>
                <figure>
                    <title>SpecTcl Preferences dialog</title>
                    <graphic format='PNG' fileref='preferences.png' />
                </figure>
                <para>
                    The top part of the dialog allows you to set the default number
                    of bins on axes of 2-d spectra.   If <literal>Same as X</literal>
                    is checked, the the Y axis entry is disabled and the
                    value saved will be the same as for the X axis.  These defaults
                    apply to spectrum axes that are not on treeparameters as those
                    specify suggested default axis ranges and binning.
                </para>
                <para>
                    The second section allows you to describe a few parameters
                    relevant to the helpers used to pipe data from NSCLDAQ.
                    <literal>NSCL DAQ Root</literal> allows you to specify
                    where NSCLDAQ is stored.  This determines where the SpecTcl
                    GUI looks for pipe data sources appropriate to the DAQ system.
                    <literal>Default BufferSize</literal> is the size of data
                    source reads in bytes.  For NSCLDAQ earlier than version 10.0,
                    this must be the size of data blocks.  NSCLDAQ 10.0 and later
                    create more granular variable sized items.  This value can
                    affect I/O efficiency for those versions  of the system.
                </para>
                <para>
                    The preferences are stored in <filename>~/.SpecTclDefaults</filename>.
                </para>
            </section>
            <section>
                <title>The Data Source Menu</title>
                <para>
                    The <guimenu>Data Source</guimenu> menu provides commands that
                    manipulate data sources.  Note that unlike the
                    <command>attach</command> command used by itself, the
                    menu items that attach data sources also start analyzing
                    data from them.
                </para>
                <para>
                    Let's look at the commands <guimenu>Data Source</guimenu>
                    provides.
                </para>
                <formalpara>
                    <title><guimenu>Data Source</guimenu><guimenuitem>Online...</guimenuitem></title>
                    <para>
                        This menu item assumes that SpecTcl is running in a system
                        with NSCLDAQ.   The online attachment uses helper
                        processes that have been distributed with NSCLDAQ since
                        version 7.0.  Since we are not running any version older
                        than 10.0 at the NSCL I cannot gaurantee that older
                        versions will work.
                    </para>
                </formalpara>
                <para>
                    The dialog that prompts for online connection looks like this:
                </para>
                <figure>
                    <title>Prompt to connect SpecTcl online</title>
                    <graphic format='PNG' fileref='onlinechooser.png' />
                </figure>
                <para>
                    The host is the host that provides the data.  In
                    NSCLDAQ, all versions, it's the host in which the primary
                    data provider runs.  For simple experiments, this is the
                    host that runs the Readout program.  For more complex
                    experiments it will be the host that runs the end stage
                    event builder.
                </para>
                <para>
                    For NSCLDAQ versions 10.0 and newer the ring name is
                    the name of the ring buffer from which SpecTcl will
                    analyze data.  The final ring url will be constructed
                    from the host and the ring.
                </para>
                <para>
                    The buffer size in bytes.  For NSCLDAQ versions 10.x
                    and earlier the size only affects I/O efficiency (typically
                    bigger is better).  For versions prior to 10.x, the size
                    <emphasis>must</emphasis> match the blocking size of the
                    data (prior to nscldaq-10. data were shipped around in
                    homogeneous buffers).
                </para>
                <para>
                    The Data format radio button set selects the SpecTcl
                    buffer decoder:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>nscl</literal></term>
                        <listitem>
                            <para>
                                Actually represents data older than nscldaq-10.0.
                                It also requires a buffer size that is smaller
                                than 128Kbytes (65536 words).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>jumbo</literal></term>
                        <listitem>
                            <para>
                                Represents nscldaq data older than 10.0.
                                This is required for some MoNA data that needed
                                buffer sizes greater 128Kbytes.  The distinction
                                is that the buffer size requires more than 16
                                bits.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>ring10</literal></term>
                        <listitem>
                            <para>
                                Data from nscldaq 10.x  This is ringbuffer
                                data prior to the addition of body headers.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>ring11</literal></term>
                        <listitem>
                            <para>
                                Data from nscldaq 11.0 and later.  This is ringbuffer
                                data after the addition of body headers.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <note>
                    <title>Note</title>
                    <para>
                        If SpecTcl attaches while data taking is inactive,
                        it can and will determine the format of the data.  It's
                        not abnormal to attach SpecTcl to a run that's in progress
                        so it's always safer to provide the correct nscldaq version.
                    </para>
                </note>
                
                <formalpara>
                    <title><guimenu>Data Source</guimenu><guimenuitem>File</guimenuitem></title>
                    <para>
                        Provides a mechanism to create a file data source.
                        The format of data can be set just s it is for
                        online data sources.
                    </para>
                </formalpara>
                <para>
                    The dialog for choosing a file looks like this:
                </para>
                <figure>
                    <title>File data source choooser</title>
                    <graphic format='PNG' fileref='filechooser.png' />
                </figure>
                <para>
                    The top part of the dialog is just a file chooser that
                    allows you to select the event file.  The bottom part
                    a buffering size and format selector just like on the
                    dialog to select an online data source.
                </para>
                <formalpara>
                    <title><guimenu>Data Source</guimenu><guimenuitem>Pipe...</guimenuitem></title>
                    <para>
                        Allows you to attach an arbitrary program that emits
                        data on its standard output.  This is the general case
                        of a SpecTcl pipe data source.  One use might be to
                        use <literal>zcat</literal> to de-compress a gzipped
                        event file and analyze.
                    </para>
                </formalpara>
                <figure>
                    <title>Pipe data source dialog</title>
                    <graphic format='PNG' fileref='pipechooser.png' />
                </figure>
                <para>
                    The pipe dialog includes a file selector to select the
                    program to be run on the pipe.  An entry labeled
                    <literal>Parameters:</literal>  allows you to provide
                    command line parameters to program.  For example you can
                    use the file selector to select <filename>/usr/bin/zcat</filename>
                    and put the name of a compressed event file in the parameters
                    entry.
                </para>
                <para>
                    The remainder of the dialog provides buffersize and
                    format selection controls as in all of the other
                    data source selection dialogs.
                </para>
                <formalpara>
                    <title><guimenu>Data Source</guimenu><guimenuitem>List of Runs...</guimenuitem></title>
                    <para>
                        This option allows you to playback a sequence of run
                        files.   The  list of files to process are held in a
                        file that some experimental groups call a
                        <firstterm>Cluster file</firstterm> (presumably be
                        cause these files specify a cluster of runs to process).
                    </para>
                </formalpara>
                <para>
                    The <literal>clusterchooser</literal> dialog is shown below:
                </para>
                <figure>
                    <title>Cluster chooser dialog</title>
                    <graphic format='PNG' fileref='clusterchooser.png' />
                </figure>
                <para>
                    The dialog allows you to choose the cluster file.  This file
                    is a simple text file.  Each line of the file must be
                    the path to an event file.   The event files are analyzed
                    in the order specified by the cluster file.
                </para>
                <para>
                    Note that cluster files are one way to playback multi-segmented
                    event files, however recent versions of the SpecTclGUI script
                    recognize segmented runs when you select a file data source
                    and give you the option of playing back all of the segments
                    of the run rather than just the one selected.
                </para>
                <formalpara>
                    <title><guimenu>Data Source</guimenu><guimenuitem>Filter file</guimenuitem></title>
                    <para>
                        Specifies that you want to playback a filter file.
                        Since SpecTcl must be programmatically configured to
                        playback filter files, the first time you select this
                        option you'll be reminded of that and aksed to confirm
                        your version of SpecTcl can decode filter files.
                    </para>
                </formalpara>
                <para>
                    Once you confirm that you have a properly configured SpecTcl,
                    an ordinary file chooser dialog lets you select
                    the filter file you want to replay.  Filter files have a
                    format that is independent of data acquisition system and version.
                    Therefore there's no need to set a buffer size or a version
                    number as there is for the other data sources.
                </para>
                <formalpara>
                    <title><guimenu>Data Source</guimenu><guimenuitem>Detach</guimenuitem></title>
                    <para>
                        This menu item detaches SpecTcl from any currently attached source.
                        It actually does this by attaching SpecTcl to the
                        file <filename>/dev/null</filename>.   This file
                        always returns an end file condition when read.
                    </para>
                </formalpara>
            </section>
            <section>
                <title>The Filters menu</title>
                <para>
                    Filters are a mechanism to store some subset of data
                    into files that can be quickly decoded by SpecTcl at playback
                    time.  A filter is gate and a list of parameters.  When
                    the gate is true, all of the parameters in the filter are
                    written to file.  Thus filters allow you to select both
                    a subset of events as and a subset of parameters.
                </para>
                <para>
                    SpecTcl must be prepared to read back filter files.
                    The specifics of that are described in
                    <link linkend='chap.filteranalysis' endterm='chap.filteranalysis.title' />.
                    The <guimenu>Filters</guimenu> menu allows you to:
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            Create new filters
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Enable or disable existing filters (disabled filters
                            do not write data).
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Play back filter files (same as
                            <guimenu>Data Source</guimenu><guimenuitem>Filter File... </guimenuitem>).
                        </para>
                    </listitem>
                </itemizedlist>
                <para>
                    Let's look at the items on the <guimenu>Filters</guimenu> menu:
                </para>
                <formalpara>
                    <title><guimenu>Filters</guimenu><guimenuitem>Filter Wizard</guimenuitem></title>
                    <para>
                        The filter commands are somewhat complicated.  This menu
                        item provides a wizard that makes defining gates
                        simple. 
                    </para>
                </formalpara>
                <para>
                    The first step of the wizard prompts for a filter name.
                    All SpecTcl filters must have a unique name.
                </para>
                <figure>
                    <title>Filter wizard - setting the filter name</title>
                    <graphic format='PNG' fileref='filterwizrdname.png' />
                </figure>
                <para>
                    Note that the introductory page of the wizard als provides
                    an overview of the steps required to create a filter.  Choose
                    a new filter name, enter it in the text entry and
                    click <guibutton>Next</guibutton> to proceed to the
                    next step of the filter wizard:
                </para>
                <figure>
                    <title>Filter wizard - setting the filter gate.</title>
                    <graphic format='PNG' fileref='filterwizardgate.png' />
                </figure>
                <para>
                    The gate filter determines which events are written to the
                    filter file.  Only events that satisfy the gate will be
                    written.  Open the gates folder in the top of this page of the
                    wizard.  Browse the tree of gates until you find the one you want
                    and double-click it to select it.
                </para>
                <para>
                    The selected gate will be shown at the bottom of this wizard
                    page next to the <literal>Gate Chosen:</literal> label.
                    If you selected the wrong gate simply double-click the right
                    one to replace the chosen gate.
                </para>
                <para>
                    When you've selected the right gate, click <guibutton>Next</guibutton>
                    to move on to the next wizard screen.
                </para>
                <figure>
                    <title>Filter wizard - choosing parameters</title>
                    <graphic format='PNG' fileref='filterwizardparams.png' />
                </figure>
                <para>
                    Brows the parameter display and double click parameters to
                    add them to the list of parameters on the right.  If, by mistake
                    you add a parameter you don't want, double-click it to remove
                    it from the selected parameters list.
                </para>
                <para>
                    When the parameter list is what you want, click
                    <guibutton>Next</guibutton> to advance to the next, and last,
                    screen of the wizard:
                </para>
                <figure>
                    <title>Filter wizard - choosing the output file.</title>
                    <graphic format='PNG' fileref='filterwizardfile.png' />
                </figure>
                <para>
                    This wizard page allows you to choose a directory and name
                    for the filter output file.  This is the file into which
                    filtered data will be written.  You may also specify the
                    filter as <literal>Active</literal>.  Active filters
                    write data, inactive filters don't.
                </para>
                <para>
                    Complete the filter definition  by choosing a filter file
                    and deciding whether or not to activate the filter.
                    Click <guibutton>Finish</guibutton> to finish
                    defining the filter.
                </para>
                <formalpara>
                    <title><guimenu>Filters</guimenu><guimenuitem>Filter Enables...</guimenuitem></title>
                    <para>
                        A filter does not output data unless it is enabled.
                        The enable/disable state of filters  can be
                        manipulated in the dialog accessed through the
                        <guimenu>Filters</guimenu><guimenuitem>Filter Enables...</guimenuitem>
                    </para>
                </formalpara>
                <para>
                    This dialog is shown below:
                </para>
                <figure>
                    <title><guimenu>Filters</guimenu><guimenuitem>Filter Enables...</guimenuitem> dialog</title>
                    <graphic format='PNG' fileref='filterenables.png' />
                </figure>
                <para>
                    The dialog provides a checkbox next to each filter definition.
                    Check the box to enable the filter, uncheck to disable.
                    Once you've made your selections, click <guibutton>Ok</guibutton>
                    to make the appropriate changes.  The dialog provides not only
                    filter names, but the complete definition of each filter.
                </para>
                <formalpara>
                    <title><guimenu>Filters</guimenu><guimenuitem>Read Filter File...</guimenuitem></title>
                    <para>
                        This is identical to <guimenu>Data Source</guimenu><guimenuitem>Filter File...</guimenuitem>.
                        It allows you to attach the output of a filter as a data source.
                        Note that to successfullly do this your SpecTcl must
                        have been configured to decode data from
                        filter files.  See
                        <link linkend='chap.filteranalysis' endterm='chap.filteranalysis.title' />
                        for instructions.
                    </para>
                </formalpara>
            </section>
            <section>
                <title>The Spectra menu</title>
                <para>
                    This menu provides access to common operations on spectra.
                    These operations are also available in other parts of the
                    user interface.
                </para>
                <formalpara>
                    <title><guimenu>Spectra</guimenu><guimenuitem>Save Contents of Spectra...</guimenuitem></title>
                    <para>
                        This is identical to <guimenu>File</guimenu><guimenuitem>Save Contents of Spectra...</guimenuitem>.
                        The desired spectra are save in an ASCII file.  For
                        information about the format of this file, see
                        the programmer reference manual.  A description
                        of the user interface is available in the
                        section describing the <guimenu>File</guimenu>
                        menu.
                    </para>
                </formalpara>
                <formalpara>
                    <title><guimenu>Spectra</guimenu><guimenuitem>Read Spectrum File...</guimenuitem></title>
                    <para>
                        Identical to
                        <guimenu>File</guimenu><guimenuitem>Read Spectrum File...</guimenuitem>.
                        Spectra can be read in either as snapshots or connected
                        to the histogrammer where possible.  The spectra can
                        overwrite existing spectra or create new, uniquely named
                        spectra.  See the <guimenu>File</guimenu> menu documentation
                        section for details.
                    </para>
                </formalpara>
                <formalpara>
                    <title><guimenu>Spectra</guimenu><guimenuitem>Clear All</guimenuitem></title>
                    <para>
                        Clears the contents of all defined spectra.  Note that if
                        you have defined spectra that are not bound to the
                        displayer shared memory, those are also cleared.
                        By clearing a spectrum, we mean that all of the channels
                        in the spectrum are set to zero.
                    </para>
                </formalpara>
                <formalpara>
                    <title><guimenu>Spectra</guimenu><guimenuitem>Create...</guimenuitem></title>
                    <para>
                        Allows you to create spectra.  The operation of the
                        dialog this menu item creates will be described
                        completely in the
                        <link linkend='sec.folderui' endterm='sec.folderui.title' />.
                    </para>
                </formalpara>
                <para>
                    The Spectra tab  provides another method for creating spectra
                    which is superior for simple 1-D and 2-D spectra.  Other
                    spectra can be easily created with this page, as long as
                    some simple parameter naming conventions are observed.
                </para>
                <formalpara>
                    <title><guimenu>Spectra</guimenu><guimenuitem>Delete...</guimenuitem></title>
                    <para>
                        Allows you to delete a spectrum definition.
                        Once deleted the spectrum no longer exists.  
                    </para>
                </formalpara>
                <para>
                    The spectrum to be deleted is selected via a hierarchical
                    spectrum selection dialog.  See below
                </para>
                <figure id='fig.selectspectrum'>
                    <title id='fig.selectspectrum.title'>Spectrum Selection dialogt</title>
                    <graphic format='PNG' fileref='delspecdialog.png' />
                </figure>
                <para>
                    Navigate the folder hierarchy and double click the
                    spectra you want deleted (you may delete several at once).
                    If you accidentally choose the
                    wong spectrum, double click it in the Selected Spectra
                    listbox at the right of the dialog.   
                </para>
                <para>
                    Once the Selected Spectra list box contains the
                    spectra you want to destroy, click <guibutton>Ok</guibutton>
                    to delete the spectra.   You will be prompted to confirm
                    the deletion befor it actually is performed.  Use caution
                    as deleting a spectrum cannot be undone (other than by
                    redefining it).
                </para>
                <formalpara id='para.applygate'>
                    <title id='para.applygate.title'><guimenu>Spectra</guimenu><guimenuitem>Apply Gate...</guimenuitem></title>
                    <para>
                        Gates are conditions that are checked for each event.
                        Every spectrum has a gate applied to it (even if it's just
                        a true gate).  The spectrum is only incremented when an
                        event has satisfied the gate applied to the specturm and
                        the event has set values for the required parameters.
                    </para>
                </formalpara>
                <para>
                    This menu command allows you  to change the gate that
                    is applied to a set of spectra.  Note that the
                    Spectra tab has a control that does this easily for
                    single spectra.  The dialog used by the menu command
                    allows the same gate to be applied to several spectra.
                </para>
                <figure>
                    <title>Gate application dialog</title>
                    <graphic format='PNG' fileref='applygatedialog.png' />
                </figure>
                <para>
                    Using the spectra folder hierarchy, select the
                    spectra that will have a gate applied.  Using the
                    Gates folder hierearchy, chose the gate to apply.
                    If you selected an incorrect spectrum, you can remove
                    it from the Spectra: list box by double clicking it.
                    If  you chose the wrong gate, simply choose another.
                </para>
                <para>
                    When the gate and spectra have been properly chosen,
                    click <guibutton>Ok</guibutton> to apply the gate
                    to the designated spectra.
                </para>
            </section>
            <section>
                <title>The Gate menu</title>
                <para>
                    This menu allows you to manipulate gates and their definitions.
                    The commands int this menu are available elsewhere in the
                    UI, however there may be times when it is simpler to use this
                    menu than to switch notebook tabs to access that functionality.
                </para>
                <formalpara>
                    <title><guimenu>Gate</guimenu><guimenuitem>Create...</guimenuitem></title>
                    <para>
                        Brings up the gate editor and allows you to create any
                        type of gate.  Note that most simple gates can be
                        created more simply from the displayer.  Compound gates,
                        however can be created with this menu entry, in the folder
                        tab (same GUI mechanics) or in the Gates tab of the Gui
                        (different GUI mechanics).
                    </para>
                </formalpara>
                <para>
                    The GUI mechanics for this menu item will be described in
                    <link linkend='sec.folderui' endterm='sec.folderui.title' />
                    If you want to know another way to create gates from this UI
                    see
                    <link linkend='sec.gatespage' endterm='sec.gatespage.title' />.
                </para>
                <formalpara>
                    <title><guimenu>Gate</guimenu><guimenuitem>Apply...</guimenuitem></title>
                    <para>
                        Allows you to apply a gate to one or more spectra.
                        This operation is the same as
                        <guimenu>Spectra</guimenu><guimenuitem>Apply Gate...</guimenuitem>
                        See
                        <link linkend='para.applygate' endterm='para.applygate.title' />
                        for information about the UI mechanics required to
                        complete this operation.
                    </para>
                </formalpara>
                <formalpara>
                    <title><guimenu>Gate</guimenu><guimenuitem>Delete...</guimenuitem></title>
                    <para>
                        Allows you to select a set of gates to delete.  Note that
                        in order to make compound gate handling predicatable and
                        uniform as gates are deleted, deleted gates are actually
                        replaced with gates that are always <literal>False</literal>
                        rather than being totally deleted.
                    </para>
                </formalpara>
            <para>
                This command brings up the dialog below:
            </para>
            <figure>
                <title>Gate selection dialog</title>
                <graphic format='PNG' fileref='gateselection.png' />
            </figure>
            <para>
                Navigate the gate tree hierarchi, double clicking gates you want
                to delete.  If you select a gate you didn't intend to select,
                double click int in the selected gates list box.   When you are
                done, click <guibutton>Ok</guibutton>.  You will be ptrompted to
                confirm your selection.  If you do, the selected gates will
                be destroyed.
            </para>
            
        </section>
        </section>
        <section>
            <title>Using the Spectra page</title>
            <para>
                Let's look at the controls on the Spectra tab.  These controls
                are divided into several sections.   First let's look at the
                entire page.   Each of the subsequent sections will zoom in
                on the functionality of a section of the user interface.
            </para>
            <figure>
                <title>The Spectra tab.</title>
                <graphic format='PNG' fileref='spectracontrols.png' />
            </figure>
            <para>
                The bottom part of the user interface provides a filterable
                list of the spectra currently defined:
            </para>
            <figure>
                <title>The spectrum list</title>
                <graphic format='PNG' fileref='spectrumlist.png' />
            </figure>
            <para>
                The headings of the list box make the list fairly self
                explanatory.  There are, however several things you can do
                to control what you see:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        Below the spectrum list are several controls that
                        allow you to control the set of spectra that are displayed:
                    </para>
                    <para>
                        The <guibutton>Update Spectrum List</guibutton> button
                        reloads the set of spectra listed.  This can be necesary
                        if a script or definition file changes  spectrum definitions.
                    </para>
                    <para>
                        The <literal>Spectrum Mask</literal> text entry allows you
                        to specify a filter on the set of spectra displayed.
                        All glob characters can be used in the filter.
                        See <command>man 7 glob</command> for information about
                        glob wildcards.  The filter is applied dynamically as it
                        is modified.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        You can stretch or shrink the widths of the columns
                        by dragging the groove at the beginning or end of a column
                        heading  left or right as needed.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The display can be sorted in decreasing or increasing
                        order by any column.
                    </para>
                    <para>
                        Note that the <literal>Name</literal> column (at least initially)
                        as a white arrow in a black box at the right side of
                        the title.  This indicates the list is sorted by
                        name increasing as you go downward.  If you click that
                        arrow, the sort order reverses and the arrow flips
                        direction to inicated this.
                    </para>
                    <para>
                        If you click a column, the display is sorted by that column
                        and the arrow again indicates the sort direction.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Double clicking a spectrum from the list loads that
                        spectrum into the spectrum
                        definition and manipulation part of the
                        UI, which we will describe next:
                    </para>
                </listitem>
            </itemizedlist>
            <figure>
                <title>Spectrum definition and configuration</title>
                <graphic format='PNG' fileref='spectrumdefman.png' />
            </figure>
            <para>
                In the figure above, items not related to spectrum definition
                and manipulation have been smudged out.  We will look at those
                controls later.
            </para>
            <para>
                Using this section of the user interface you can:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        Create a new spectrum or replace an existing one
                        (<guibutton>Create/Replace</guibutton> button).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Delete an existing spectrum
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Duplicate an existing spectrum definitioubn.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Create spectrum that is defined the same as an existing one.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Perform, potentially dangerous, operations on all
                        spectra.
                    </para>
                </listitem>
            </itemizedlist>
            <formalpara>
                <title>Creating a new spectrum.</title>
                <para>
                    Briefly to create a new spectrum you select the type of
                    spectrum from the spectrum type box, Fill in the spectrum
                    definition (name and parameters) and click the
                    <guibutton>Create/Replace</guibutton> button.
                    You can also specify a data type by checking something other
                    than <literal>Long (32 bits)</literal> but with modern
                    computers there's seldom any reason to use smaller data types.
                </para>
            </formalpara>
            <para>
                Parameters are selected using the <guibutton>Parameter</guibutton>
                pulldown menubuttons (the second one will be enabled if the
                spectrum type, e.g. 2D, requries) the parameter tree is presented
                as a menu/submenu tree.  If any menu is too long scroll buttons
                are provided as well to allow you to scroll the visible set of
                menu items.
            </para>
            <para>
                If a selected parameter is a tree parameter, it will have
                recommended limits and binning.  If not, or if you want to
                change these values, type them in.
            </para>
            <para>
                Once the spetrum definition has been filled in, click
                <guibutton>Create/Replace</guibutton> to create the new spectrum.
                The new spectrum is, if it matches the filter, added to the
                spectrum list without the need for an
                <guibutton>Update</guibutton>
            </para>
            <para>
                As we'll see the <guibutton>Array</guibutton> checkbutton allows
                you to create several spectra simultaneously.
            </para>
            <formalpara>
                <title>Replacing an existing spectrum.</title>
                <para>
                    Replacing an existing spectrum is identical to creating a new
                    one except that the spectrum name is the name of a
                    previously existing spectrum.  You can also double click an
                    existing spectrum in spectrum list and change its definition,
                    since double clicking  a spectrum loads its spectrum definition.
                </para>
            </formalpara>
            <para>
                Prior to replacing existing spectra you'll have a chance to
                confirm this operation.
            </para>
            
            <formalpara>
                <title>Deleting a spectrum</title>
                <para>
                    To delete a spectrum, Double click it to load it into the
                    spectrum definition.  Click the <guibutton>Delete</guibutton>
                    button.  Warning - you are not prompted to confirm this
                    destructive operation.
                </para>
            </formalpara>
            <formalpara>
                <title>Duplicating a spectrum.</title>
                <para>
                    You can duplicate a spectrum by loading its definition
                    (Double click the spectrum in the spectrum list).
                    Once you've loaded the spectrum you want to duplicate,
                    click <guibutton>Duplicate</guibutton>.   The
                    new spectrum will be given a name like the old spectrum
                    name followed by <literal>_</literal> and a unique number.
                </para>
            </formalpara>
            <formalpara>
                <title>The very useful <guibutton>Array</guibutton> checkbutton.</title>
                <para>
                    Many experiments have detector systems that have several
                    nearly identical channels.  These channels can be represented
                    naturally as tree parameter arrays.  The array checkbutton
                    allows you to create a set of spectra (1D) from a tree parameter
                    array. 
                </para>
            </formalpara>
            <para>
                Simply enter a base name for the spectrum and choose one of the
                array elements as the parameter.  Be sure the
                <guibutton>Array</guibutton> checkbutton is selected.
                When you click <guibutton>Create/Replace</guibutton>,
                one spetrum will be made for each element of the array.  The
                name of each spectrum will be the basename followed by a
                <literal>.</literal> followed by the parameter index.
            </para>
            <formalpara>
                <title>The <guibutton>Clear</guibutton> button.</title>
                <para>
                    The <guibutton>Clear</guibutton> button clears the channels
                    of the spectrum that is loaded.  You can clear a
                    single spectrum by double clicking it in the spectrum
                    list and the clicking <guibutton>Clear</guibutton>.
                </para>
            </formalpara>
            <formalpara>
                <title>The very innocuous looking but dangerous <guibutton>all</guibutton> checkbutton</title>
                <para>
                    The <guibutton>All</guibutton> button extends the scope
                    of several operations to all currently defined spectra.
                    This can be very useful or very dangerous depending on the
                    operation performed:
                </para>
            </formalpara>
            <variablelist>
                <varlistentry>
                    <term><guibutton>Clear</guibutton></term>
                    <listitem>
                        <para>
                            All spectra are cleared.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><guibutton>Delete</guibutton></term>
                    <listitem>
                        <para>
                            Very dangerous!! All spectra are deleted.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><guibutton>Duplicate</guibutton></term>
                    <listitem>
                        <para>
                            All spectra are duplicated.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                Let's now look at the section of the Spectra tab below:
            </para>
            <figure>
                <title>Load/Save section of Spectra tab.</title>
                <graphic format='PNG' fileref='spectraload.png' />
            </figure>
            <para>
                This bit of the GUI allows you to save and restore the
                current analysis definitions/settings.
            </para>
            <para>
                The
                <guibutton>Save</guibutton> button saves
                the current settings to file.   It operates like the
                <guimenu>File</guimenu><guimenuitem>Save...</guimenuitem>
                menu command if you checked all categories.  Therefore the button
                only prompts for a file to which the settings will be written.
            </para>
            <para>
                Similarly the <guibutton>Load</guibutton> button prompts for
                a file to load (like the <guimenu>File</guimenu><guimenuitem>Load...</guimenuitem>
                menu command).  If the <guibutton>Cumulative</guibutton> checkbutton
                is checked, previous definitions are not deleted prior to reading
                the file. 
            </para>
            <para>
                The <guibutton>Failsafe</guibutton> checkbutton controls the
                writing of a <filename>failsafe.tcl</filename> file.  If
                checked, the GUI saves the current definitions after each modification
                to the analysis definitions.
            </para>
            <para>
                Finally let's look at the section of the page that controls
                the application of gates:
            </para>
            <figure>
                <title>Spectra gate applications</title>
                <graphic format='PNG' fileref='specgateapply.png' />
            </figure>
            <para>
                The dropdown menubutton (<guibutton>Gate</guibutton>) allows
                you to select a gate.  The name of the gate is loaded into
                the text entry box.  The <guibutton>Apply</guibutton> applies
                the gate to the currently selected spectrum. The
                <guibutton>Ungate</guibutton> removes that application (applies
                a <literal>True</literal> gate to the spectrum).  Note that both
                <guibutton>Apply</guibutton> and <guibutton>Ungate</guibutton>
                are modified by the state of the <guibutton>All</guibutton>
                check button.
            </para>
        </section>
        <section id='sec.parampage'>
            <title id='sec.parampage.title'>Using the Parameters page</title>
            <para>
                The <literal>Parameters</literal> tab lets you modify the
                definition of tree parameters.  Specifically, for existing
                tree parameters you can set new limits and units.  You
                may not set new values for the binning.
            </para>
            <para>
                The parameters page looks like this:
            </para>
            <figure>
                <title>Parameters page</title>
                <graphic format='PNG' fileref='parameterpage.png' />
            </figure>
            <para>
                At any time, exactly one line is active.  The line with its
                radio button checked.  The <guibutton>Parameter</guibutton>
                pulldown menu allows you to load a parameter into that line.
                The menu is organized to reflect the parameter hierarchy as a
                menu, sub-menu hierarchy.
            </para>
            <para>
                If you modify the name field to match an existing parameter,
                that parameter is loaded as well.  You can make as many modifications
                as you want to the low, high and units fields.   If you get hopelessly
                lost, simply click <guibutton>Load</guibutton> to reload the
                current definition of that parameter.  If you click
                <guibutton>Set</guibutton> the tree parameter definition
                will be modified.  If you click <guibutton>Change Spectra</guibutton>,
                any spectra that depend on that parameter will be redefined so
                that axes depending on that parameter have the new low and high
                limits.
            </para>
            <para>
                 The <guibutton>array</guibutton> checkbox affects the <guibutton>Set</guibutton> and
                 <guibutton>Change Spectra</guibutton> buttons. 
                 If it is checked, and the parameter on that line is a member
                 of a tree parameter array, all members of the array are modified
                 on a <guibutton>Set</guibutton> operation and all
                 spectra depending on all parameters in the array are modified.
                 If <guibutton>array</guibutton> is checked, the
                 <guibutton>Change Spectra</guibutton> button modifies all spectra
                 that depend on all paframeters in the tree parameter array
                 that contains that parameter.
            </para>
        </section>
        <section>
            <title>Using the variables page</title>
            <para>
                This page allows you to modify tree variable values and whole
                arrays of tree variables.  The mechanics of this
                page are pretty much the same as the parameters page, so
                see
                <link linkend='sec.parampage' endterm='sec.parampage.title' />
                for more.
            </para>
            <para>
                The page is shown below:
            </para>
            <figure>
                <title>The Variable page</title>
                <graphic format='PNG' fileref='variablepage.png' />
            </figure>
            <para>
                The differences between the parameter and variable page are:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        Since variables don't associate directly with spectra,
                        the lines don't have a button to change spectra.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        There are controls at the bottom of the page
                        that allow you to save and restore <emphasis>only</emphasis>
                        the tree variable values to and from file.
                    </para>
                </listitem>
            </itemizedlist>
        </section>
        <section id='sec.gatespage'>
            <title id='sec.gatespage.title'>Using the Gates page</title>
            <para>
                The gates page allows you to view, create, modify and delete
                gates.  To create or modify gates, you must know something about
                the SpecTcl <command>gate</command>  command.  If you do not,
                the <guimenu>Gate</guimenu><guimenuitem>Create...</guimenuitem>
                gate editor might be a better option.  Here's a screen shot
                of the Gates page:
            </para>
            <figure>
                <title>The Gates page</title>
                <graphic format='PNG' fileref='gatepage.png' />
            </figure>
            <para>
                The bottom part of the page works identically to the Spectra page.
                You can list spectra, you can sort by any column in either direction.
                Double clicking on a gate loads its definition into the top part
                of the page.  Filters and <guibutton>Update Gate List</guibutton>
                work in exactly the same way.
            </para>
            <para>
                Get definition/modification is a bit tricky though there is some
                help:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        The left entry is the gate name.  Either load it from
                        the list of existing gates (to modify) or type in the
                        name of a new gate.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The drop down menu button at the right allows you to
                        select the type of gate you are creating.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The entry to the right should contain the gate desciption
                        as it would appear on the <command>gate</command>
                        command but not surrounded by <literal>{}</literal>s.
                        For example to create a slice on parameter raw.01 from
                        123 to 456 that would read:
                        <literal>raw.01 {123 456}</literal> <emphasis>not</emphasis>
                        <literal>{raw.01 {123 456}}</literal>.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        If  you are building a compound gate, the
                        <guibutton>Gate Select</guibutton> drop down menu inserts
                        the name of the gate you choose from the menu at the
                        insertion point of the definition entry.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <guibutton>Clear Definition</guibutton> clears the right
                        entry field (the gate definition text).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The <guibutton>Create/Replace</guibutton> button creates
                        a new gate or replaces an existing gate if the gate name
                        matches an existing gate.  If you are replacing an existing
                        gate, no confirmation prompt is displayed, however.
                    </para>
                </listitem>
            </itemizedlist>
        </section>
        <section id='sec.folderui'>
            <title id='sec.folderui.title'>Using the folders tab.</title>
            <para>
                The folders tab attempts to condense the entire user interface
                into a single page.  It presents the spectra, parameters,
                tree variables and gates as a single tree of folders.
                Each folder and item within each folder has a
                <firstterm>context menu</firstterm> that pop up on a right click
                on the associated object.  The context menu provides operations
                that make sense on that object.
            </para>
            <para>
                As with the previous pages, we'll devote a subsection to
                descriptions of things that can be done on each of the
                top level folders and its contents.
            </para>
            <section>
                <title>Spectra folder</title>
                <para>
                    Let's look at the folder gui with the top level Spectra
                    folder and all subfolders opened:
                </para>
                <figure>
                    <title>Tree Gui Spectra folder</title>
                    <graphic format='PNG' fileref='folderspectra' />
                </figure>
                <para>
                    As we can see there are several objects that matter:
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            There's the top level <literal>Spectra</literal>
                            folder.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            There's a spectrum named <literal>calib</literal>
                            and a spectrum named <literal>Twod</literal>
                            right underneath the the top level folder.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            There's a subfolder named<literal>rQ</literal>
                            that contains an array of spectrum named
                            <literal>rQ.00</literal>, <literal>rQ.01</literal>...
                            <literal>rQ.09</literal>.
                        </para>
                    </listitem>
                </itemizedlist>
                <para>
                    Note that each spectrum can be opened as well.  Doing so
                    shows the parameters the spectrum depends on.  If this is
                    done for a 2-d spectrum, you see each parameter as an
                    axis definition.
                </para>
                <para>
                    Finally quite a bit of information is displayed about spectra
                    in this display.  From this display you can get at least as much
                    information as on the Spectra tab.
                </para>
                <para>
                    All manipulations are don via the context menus that
                    various object types have.  Let's look at those:
                </para>
                <section>
                    <title>Top level spectra folder context menu</title>
                    <para>
                        Right clicking the top level <literal>Spectra</literal>
                        folder gives a context menu with the following entries:
                        <variablelist>
                            <varlistentry>
                                <term><guimenuitem>New...</guimenuitem></term>
                                <listitem>
                                    <para>
                                        Allows you to create new spectra.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><guimenuitem>Refresh tree</guimenuitem></term>
                                <listitem>
                                    <para>
                                        Reloads the current definitions into the tree.
                                        This is required if changes are made
                                        either outside of the GUI or in other
                                        tabs of the GUI.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><guimenuitem>Clear All</guimenuitem></term>
                                <listitem>
                                    <para>
                                        Clears all of the spectra (contents).
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><guimenuitem>Help</guimenuitem></term>
                                <listitem>
                                    <para>
                                        The folder page has extensive online help.
                                        This brings up menu item brings up
                                        help on the things that can be done
                                        in the folderse Spectra tree.
                                    </para>
                                </listitem>
                            </varlistentry>
                        </variablelist>
                    </para>
                    <formalpara>
                        <title>New... Creating a new spectrum</title>
                        <para>
                            This brings up the top level spectrum editor:
                        </para>
                    </formalpara>
                    <figure>
                        <title>Top level spectrum editor</title>
                        <graphic format='PNG' fileref='spectrumedittop.png' />
                    </figure>
                    <para>
                        The actual form of the spectrum editor depends on the
                        type of spectrum being created.  You can enter the name
                        or specify you're making an array of spectra (just like
                        for the Spectra tab) here, but the main thing you need
                        to do is select the spectrum type from the drop down
                        menu at the upper left of the top level spectrum
                        editor.
                    </para>
                    <para>
                        The remainder of this section will go over the various
                        spectrum types and how to use the editors associated with
                        them.  Note that in some cases, because of the way
                        window managers work, you may need to resize an editor
                        to see all of it.  Note as well that all spectrum editors
                        have a <guibutton>Help</guibutton> button.  Finally
                        note that the spectrum editor is not a modal dialog.
                        That is the remainder of the GUI remains alive
                        while you are interacting with it.  The UI, however
                        only allows a single spectrum editor to be open
                        at any time.
                    </para>
                    <formalpara>
                        <title>1-d spectra</title>
                        <para>
                            The figure below shows the editor for a 1-d spectrum.
                        </para>
                    </formalpara>
                    <figure>
                        <title>1-d Spectrum Editor.</title>
                        <graphic format='PNG' fileref='spectrum1deditor.png' />
                    </figure>
                    <para>
                        1-d Spectra require you to select a single parameter.
                        You do this by double clicking that parameter in the
                        Parameters folder hierarchy at the left of the dialog.
                        Doing so fills in the parameter information box at the
                        right of the editor.  
                    </para>
                    <para>
                        If the parameter had suggested high/low/bin/units
                        information that is also loaded into the parameter
                        information box.  Note that you can edit the low/hig/bins
                        to set alternative axis limits and binning as desired.
                    </para>
                    <para>
                        You can apply an initial gate to the spectrum.  This is
                        done by browsing for the desired gate in the Gates
                        folder hierarchy to the left of the editor and double
                        clicking the desired gate.  The applied gate appears
                        to the right of the <literal>Gate</literal> label
                        at the top of the editor.
                    </para>
                    <para>
                        Naturally you may make mistakes.  If you choose the
                        wrong parameter, simply choose the right one and it,
                        and its recommended axis definition will replace the
                        parameter you selected.  If you chose the wrong gate
                        again, simply choose the right one and it will replace
                        the one you chose. Finally if you chose a gate and
                        decide that you actually don't want to gate the spectrum,
                        double click the gate name at the top of the editor
                        and you'll no longer be creating a gated spectrum.
                        If you chose the wrong spectrum type just pull down the
                        spectrum type menu again and choose the right type.
                    </para>
                    <para>
                        The mechanics of spetrum creation for all spectrum types
                        are very similar to this.  You choose the parameters
                        you need, you edit axis definitions and you optionally
                        select a gate.  When the spectrum is defined as
                        you desire, simply click <guibutton>Ok</guibutton> to
                        create and dismiss the dialog or <guibutton>Accept</guibutton>
                        to create the dialog but leave it open to define another
                        spectrum.  <guibutton>Cancel</guibutton> dismisses the
                        dialog doing nothing.  <guibutton>Help</guibutton>
                        as always brings up some help on this aspect of the
                        user interface.
                    </para>
                    <formalpara>
                        <title>2-d spectrum editor</title>
                        <para>
                            The 2-d spectrum editor is shown below. As the name
                            implies, 2d spectra represent a two dimensinoal grid.
                            One of the seleted parameters, the <firstterm>X parameter</firstterm>
                            is the X coordinate axis and the other the <firstterm>Y parameter</firstterm>
                            is the Y coordinate axis.
                            If the event has both parameters, and applied gate is
                            satisfied, the two parameters define an x/y point whose
                            bin is incremented.
                        </para>
                    </formalpara>
                    <figure>
                        <title>2-d spectrum editor</title>
                        <graphic format='PNG' fileref='spectrum2deditor.png' />
                    </figure>
                    <para>
                        The only difference between the 1-d and 2-d spectrum editors
                        is that you must choose two parameters, an X and a Y
                        parameter and optionally modify the axis definitions
                        of one or both of those axes.
                    </para>
                    <para>
                        Note that in the figure, the X parameter is highlighted.
                        This means that the next parameter you select from
                        the parameters folder will be the new X parameter.
                        Selecting a parameter automatically alternates the highlight.
                        Thus after selecting an X parameter the Y parameter is highlighted.
                        After selecting a Y parameter, the X parameter is highlighted.
                    </para>
                    <para>
                        This allows for a natural selection of first the X and then
                        the Y parameters of the histogram.  If you click on the
                        <literal>x Parameter</literal> or <literal>y Parameter</literal>
                        text that box will become the selected box and the next
                        selected parameter will be placed there.
                    </para>
                    <para>
                        All the editing operations described for a 1-d spectrum
                        apply with the addition that double clicking the name
                        of a parameter in a parameter box will remove it from
                        the box, making the parameter for that axis undefined.
                        Note as well that the assumption is that you won't plot
                        a parameter against itself so once you've selected a parameter
                        as either the X or Y parameter, it is removed from the
                        Parameters folder so that you can't accidently select
                        it again.
                    </para>
                    <para>
                        The spectrum editor requires you to fully describe the
                        spectrum.  If you attempt to click <guibutton>Ok</guibutton>
                        or <guibutton>Accept</guibutton> before defining
                        the minimal required information (spectrum name,
                        X and Y parameters) a dialog will pop up informing you
                        the spectrum is not yet fully defined.
                    </para>
                    <para>
                        While the <guibutton>Array</guibutton> checkbox is present,
                        you can only create arrays of 1-d spectra. An error
                        dialog reminding you of that fact pops up if the
                        array checkbox is selected when you click either
                        <guibutton>Ok</guibutton> or <guibutton>Accept</guibutton>.
                        Finally if a spectrum with this name already exists you
                        are asked to confirm the replacement of that spectrum
                        with your newly defined spectrum.
                    </para>
                    <formalpara>
                        <title>Gamma-1d spectrum editor</title>
                        <para>
                            A gamma-1d spectrum is a multiply incremented spectrum.
                            An arbitrary number of parameters can be put on a
                            common scale on the X axis. For each event that satisfies
                            the spectrum's gate, a channel incremented for each
                            parameter the spectrum depends on that has been given
                            a value.
                        </para>
                    </formalpara>
                    <para>
                        In addition to applying
                        a gate on gamma spectra, gamma spectra can have
                        <firstterm>folds</firstterm> set on them to explore
                        correlated, multi-gamma emisssions in a single event.
                    </para>
                    <para>
                        The gamma-1d spectrum editor looks like this:
                    </para>
                    <figure>
                        <title>Gamma-1d spectrum editor</title>
                        <graphic format='PNG' fileref='spectrumg1deditor.png' />
                    </figure>
                    <para>
                        The only difference between this editor and the
                        1-d spectrum editor is that the parameters for the axis
                        are shown in a list box and you can select as many of them
                        as desired.  Each parameter is selected by double clicking
                        it in the Parameters folder hierarchy. It is assumed that
                        you don't want a parameter to appear twice so each selected
                        parameter is removed from the parameters folder hierarchy.
                    </para>
                    <para>
                        If you accidently add a parameter you did not intend,
                        double click it in the <literal>Parameters</literal>
                        listbox and it will be removed, and added back to the
                        <literal>Parameters</literal> folder hierarchy.
                    </para>
                    <formalpara>
                        <title>Gamma-2d spectrum editor</title>
                        <para>
                            A Gamma-2d spectrum is a multiply incremeted 2-d spectrum.
                            it is incremented for all ordered pairs of parameters
                            used to define the spectrum.  Suppose, for exmaple
                            that parameters p1, p2, p3 have values and are parameters
                            in the spectrum.  Increments will occur for the coordinates
                            that correspond to (p1,p2), (p1, p3) and (p2, p3).
                        </para>
                    </formalpara>
                    <para>
                        Gamma-2d spectra therefore create blobs for each pair
                        of correlated gamma rays a reaction might produce.
                        Similarly Gamma-2d spectra can have folds applied to them
                        to spot additional corellated gammas that are in coincidence
                        with pairs.
                    </para>
                    <para>
                        Contours and bands that are accepted on a gamma 2d spectrum
                        are true if there is one or more pairs of parameters that
                        make the gate true.  In the increment example above,
                        a gamma countour would be true if any of the three
                        increments above would have fallen inside the gate.
                    </para>
                    <formalpara>
                        <title>Gamma 2-d x/y spectrum editor</title>
                        <para>
                            The gamma 2-d x/y spectrum, also called a
                            gamma deluxe spectrum is a multiply incremented
                            spectrum.  Unlike the gamma 2d spectrum, parameters
                            are assigned to an X or Y axis.  Increments occur for
                            all combinations of x/y parameters an event has defined.
                        </para>
                    </formalpara>
                    <para>
                        Suppose for example, an event has parameters p1, p2 defined
                        and these are on the X axis of a Gamma 2-d x/y spectrum.
                        Suppose similarly, parameters p3,p4 are defined and
                        on the y axis.  The following coordinates will be
                        incremented:
                        (p1, p3), (p1, p4), (p2, p3), (p2, p4).
                    </para>
                    <para>
                        The spectrum editor for this kind of spectrum looks like
                        this:
                    </para>
                    <figure>
                        <title>Gamma 2-d x/y spectrum editor</title>
                        <graphic format='PNG' fileref='spectrumg2dxyeditor.png' />
                    </figure>
                    <para>
                        Fill in the X parameter box by selecting (single click)
                        parameters from the parametr list and then clicking
                        the <guibutton>X-></guibutton> button to add parameters
                        one at a time to the X parameter list box.  Similarly
                        for Y parameters, click <guibutton>Y-></guibutton>
                        to add a parameter to the Y parameter list box.
                    </para>
                    <para>
                        Double clicking a parameter in a list box removes it from
                        the listbox.
                    </para>
                    <formalpara>
                        <title>Gamma summary spectra</title>
                        <para>
                            Gamma summary spectra are like summary spectra except
                            that each vertical channel column, instead of being a
                            1-d spectrum is a gamma spectrum.   The editor for that
                            type of spectrum looks like this:
                        </para>
                    </formalpara>
                    <figure>
                        <title>Gamma summary spectrum editor</title>
                        <graphic format='PNG' fileref='spectrumgsummaryeditor.png' />
                    </figure>
                    <para>
                        The idea of the editor is that you build up the parameters
                        on the x axis one column at a time.  Select channels by
                        double clicking them until you have the set of  parameters
                        you want in channel 0.  Then click <guibutton>Next Channel</guibutton> 
                        and select the channels for channel 1.  Continue this process
                        until all X axis channels are fully defined.
                    </para>
                    <formalpara>
                        <title>2-d sum spectrum</title>
                        <para>
                            You can think of a 2-d sum spectrum as the sum of
                            several 2-d spectra.  The spectrum is defined on
                            a set of ordered x/y parameter pairs.  Increments
                            are done for each defined pair.  Suppose, for example,
                            the spectrum is defined  with x parameters (p1, p2, p3)
                            and y parameters (p4, p5, p6).  Suppose an event defines
                            parameters p1, p2, p3, p4 and p6;  The channels defined
                            by the points (p1, p4) and (p3, p6) are incrmented.
                            The spectrum in this case is like the sum of spectra
                            defined on (p1, p4), (p2, p5), and (p3, p6).
                        </para>
                    </formalpara>
                    <para>
                        The editor looks like this:
                    </para>
                    <figure>
                        <title>2-d sum spectrum</title>
                        <graphic format='PNG' fileref='spectrum2dsumeditor.png' />
                    </figure>
                    <para>
                        You can select parameters either by selecting them one at
                        a time or, if you have a 2d spectrum whose parameters
                        you want to select for this spectrum you can select it:  
                    </para>
                    <itemizedlist>
                        <listitem>
                            <para>
                                Double clicking a 2d spectrum from the Spectra
                                folders adds the x and y parameters of that spectrum
                                to to the x and y parameter list of the
                                editor.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                Selecting a parameter from the parameter folder
                                (double clicking), adds it to the list box of
                                the paramters for the axis whose radio button
                                is selected and advances the radio button to the next
                                axis.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                If you double click a parameter
                                in one of the list boxes that has a
                                mate on the other axis, both parameters are
                                removed from the spectrum.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                If you double click a parameter in one of the
                                axis listboxes that does not have a corresponding
                                parameter in the other listbox, only that parameter
                                is removed..
                            </para>
                        </listitem>
                    </itemizedlist>
                    <formalpara>
                        <title>Summary spectrum editor.</title>
                        <para>
                            A summary spectrum is a 2-d spectrum whose vertical
                            columns are 1-d spectra.  Summary spectra provide
                            a simple way to look at the health of a highly segmented
                            array of parameters.
                        </para>
                    </formalpara>
                    <para>
                        Here's the editor for a summary spectrum:
                    </para>
                    <figure>
                        <title>Summary spectrum editor</title>
                        <graphic format='PNG' fileref='spectrumsummaryeditor.png' />
                    </figure>
                    <para>
                        Double click parameters to add them to the parameter list box.
                        Double clicking a parameter in the listbox, removes it.
                    </para>
                    <formalpara>
                        <title>Bitmask spectrum editor</title>
                        <para>
                            A bitmask spectrum is useful when you have parameters
                            that represent trigger masks.  A bitmask spectrum
                            assigns one channel per bit of the parameter value and
                            increments channels for each bit set in the
                            parameter.
                        </para>
                    </formalpara>
                    <para>
                        Suppose, for example, the parameter chosen for the
                        spetrum has the value <literal>0x237</literal>. Channels
                        0,1,2,4,5,9 wil be incremented.  One channel for each
                        bit set in the parameters
                        <footnote>
                            <para>
                                I think I got all the bit numbers right.  If
                                not let me know and I'll fix this bit.
                            </para>
                        </footnote>
                    </para>
                    <para>
                        Here's the editor:
                    </para>
                    <figure>
                        <title>Bit mask spectrum editor</title>
                        <graphic format='PNG' fileref='spctrum1deditor.png' />
                    </figure>
                    <para>
                        The appearance and the mechanics of this editor
                        are the same as for a 1-d spectrum.
                    </para>
                    <formalpara>
                        <title>Strip chart spectrum editor</title>
                        <para>
                            As the name implies a strip chart spectrum plots
                            the value of one parameter against another as it
                            increases (usually with time) or decreases.
                            A strip chart has a 'time axis' parameter that
                            is the x axis, and a value axis parameter.  The
                            time parameter selects a bin which the value parameter
                            is then added to.  
                        </para>
                    </formalpara>
                    <para>
                        Strip chart spectra feature a sliding X axis.  If the
                        time parameter goes out of the range of the X axis
                        (on either side) the X axis is redefined, and data in
                        the spectra are shifted accordingly.
                    </para>
                    <para>
                        The strip chart spectrum editor is shown below:
                    </para>
                    <figure>
                        <title>Strip chart Spectrum editor</title>
                        <graphic format='PNG' fileref='spectrumstripeditor.png' />
                    </figure>
                    <para>
                        You m ust select a time axis parameter and a value axis
                        paramter.  Note that the time axis parameter is highlighted
                        indicating the next selected parameter will be the time
                        axis parameter.  When you select a parameter the highlighted
                        axis will switch.  You can also click an axis to select it.
                    </para>
                    <para>
                        Loading the time axis will, if that is a tree parameter,
                        set an initial low/high/binning for the x axis although
                        that can change with time.  You can also edit those values.
                    </para>
                </section>
                
                <section>
                    <title>Spectrum context menu</title>
                    <para>
                        Right clicking on a spectrum brings up different
                        context menu:
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term><guimenuitem>Edit...</guimenuitem></term>
                            <listitem>
                                <para>
                                    Brings up the spectrum editor appropriate to
                                    the type of spectrum and preloads it with
                                    the current spectrum definition.
                                </para>
                                <para>
                                    You can use this to modify the definition
                                    of an existing spectrum or, by changing
                                    the spectrum name in the spectrum editor,
                                    use an existing spectrum definition as a
                                    starting point for a new spectrum
                                    definition.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><guimenuitem>Clear</guimenuitem></term>
                            <listitem>
                                <para>
                                    Clears only that spectrum.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><guimenuitem>Gate...</guimenuitem></term>
                            <listitem>
                                <para>
                                    Brings up the gate application dialog
                                    shown below.  Double click a gate
                                    to apply it to the spectrum and click
                                    <guibutton>Ok</guibutton> to confirm
                                    that application.  If you select the wrong
                                    gate, simply select the right one.
                                </para>
                                <figure>
                                    <title>Gate Application dialog</title>
                                    <graphic format='PNG' fileref='gateapplication.png' />
                                </figure>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><guimenuitem>Ungate</guimenuitem></term>
                            <listitem>
                                <para>
                                    Removes any gate applied to the spectrum.
                                    This is actually done by applying a True
                                    gate to the spectrum named
                                    <literal>-Ungated-</literal>.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><guimenuitem>Write...</guimenuitem></term>
                            <listitem>
                                <para>
                                    Brings up a file selection dialog box the
                                    contents of the 
                                    Spectrum on which the context menu was
                                    brought up will be written to file.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><guimenuitem>Delete..</guimenuitem></term>
                            <listitem>
                                <para>
                                    After prompting for confirmation (and
                                    getting it) deletes the spectrum on which
                                    the context menu was popped up.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><guimenuitem>Help...</guimenuitem></term>
                            <listitem>
                                <para>
                                    Displays help on the context menu entries.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </section>
            </section>
            <section>
                <title>Parameters folder</title>
                <para>
                    The parameters folder displays all parameters, whether they
                    have been defined as tree parameters or not.  Parameters that
                    are not tree parameters can be given limits, binning and units.
                    In addition, Pseudo parameters can be defined.
                </para>
                <para>
                    The context menu for the <literal>Parameters</literal> folder
                    contains the following menu entries:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><guimenuitem>Pseudo...</guimenuitem></term>
                        <listitem>
                            <para>
                                Allows you to define a new parameter that,
                                event by event, is computed from a tcl script.
                                See the SpecTcl <command>pseudo</command> command
                                for more information about pseudo parameters.
                            </para>
                            <para>
                                The pseudo parameter editor looks like this:
                            </para>
                            <figure>
                                <title>Psuedo parameter editor</title>
                                <graphic format='PNG' fileref='pseudoeditor.png' />
                            </figure>
                            <para>
                                In the top part you can fill in the charactersitics
                                of the new parameter.  Especially important is
                                the <literal>Depends on:</literal> entry box. That
                                should be a space separated list of the names of
                                the parameters required to compute the parameter.
                            </para>
                            <para>
                                The bottom text widget is where you put the
                                Tcl code needed to compute the parameter.
                                Note that each parameter name becomes the name
                                of a variable in the scope of that script.
                                In addition, for each parameter an
                                isValid variable is also created that is a boolean
                                which is true if the parameter has been given a value.
                            </para>
                            <para>
                                For example, if a pseudo is defined that depends
                                on <literal>par1</literal> and <literal>par2</literal>,
                                the body of the pseudo might be:
                            </para>
                            <informalexample>
                                <programlisting>
if {$par1isValid &amp;&amp; $par2isValid} {
    return [expr $par1 + $par2]
 } else {
     return -1
 }
                                </programlisting>

                            </informalexample>
                            <para>
                                Be very aware of the range of substitutions.
                                That is where the name being substituted for
                                ends in the absence of quotations. Specifically
                                a period ends the name that is substituted unless
                                the name is quoted.  So, for example, suppose
                                the case above depended on the variables
                                <literal>raw.par1</literal> and
                                <literal>raw.par2</literal>.  You would need
                                 to quote your variable names as shown below:
                            </para>
                            <informalexample>
                                <programlisting>
if {${raw.par1isValid} &amp;&amp; ${raw.par2isValid}} {
return [expr ${raw.par1} + ${raw.par2}]
} else {
 return -1
}
                                </programlisting>
                            </informalexample>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><guimenuitem>Refresh Tree</guimenuitem></term>
                        <listitem>
                            <para>
                                Updates the user interface's knowledge of the
                                objects SpecTcl knows about.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><guimenuitem>Help</guimenuitem></term>
                        <listitem>
                            <para>
                                Provides help on the context menu.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    Parameters themselves have a <guimenuitem>Psuedo...</guimenuitem>
                    and <guimenuitem>Help</guimenuitem> item as well as an
                    <guimenuitem>Edit...</guimenuitem> context menu item.
                    The Psueod item operates as for the folder's context menu.
                    The <guimenuitem>Edit...</guimenuitem> item brings up an
                    editor for parameter limits, binning and units:
                </para>
                <figure>
                    <title>Parameter editor</title>
                    <graphic format='PNG' fileref='parameditor.png' />
                </figure>
                <para>
                    This dialog should be pretty self explanatory.
                </para>
            </section>
            <section>
                <title>Variables folder</title>
                <para>
                    The variables folder allows you to view and manipulate
                    tree variables and tree arrays.  The context menu for top folder
                    just has <guimenuitem>Refresh Tree</guimenuitem> and
                    <guimenuitem>Help</guimenuitem> items.
                </para>
                <para>
                    Variables themselves don't have a context menu.  The only
                    think you can do with a variable is edit it.  Double clicking
                    a variable brings up an editor like this:
                </para>
                <figure>
                    <title>
                        Variable editor
                    </title>
                    <graphic format='PNG' fileref='vareditor.png' />
                </figure>
                <para>
                    The use of the variable editor should be fairly self evident.
                </para>
            </section>
            <section>
                <title>Gates folder</title>
                <para>
                    The gates folder allows you to list and manipulate gates.
                    Each gate has structure underneath it.  Opening the gate
                    shows the full definition of the gate.  Both the top level
                    gates folder and individual gates have context menus.
                </para>
                <para>
                    In addition to <guimenuitem>Refresh Tree</guimenuitem> and
                    <guimenuitem>Help</guimenuitem> menu, the top level folder's
                    context menu contains a <guimenu>New...</guimenu> item
                    which allows you to create a new gate.  This is mostly
                    useful for compound gates as simple gates can be entered
                    more easily in the viewers.
                </para>
                <para>
                    The context menu of gates themselves includes:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><guimenuitem>Edit...</guimenuitem></term>
                        <listitem>
                            <para>
                                Brings up the gate editor with all values
                                initialized to that of the gate that
                                brought up the context menu.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><guimenuitem>Apply To...</guimenuitem></term>
                        <listitem>
                            <para>
                                Brings up a dialog that allows you to select
                                one or more spectra to which the gate will be
                                applied.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><guimenuitem>Delete...</guimenuitem></term>
                        <listitem>
                            <para>
                                Allows you, after confirmation to delete the gate.
                                Note that deleted gates don't atually get deleted,
                                they get turned into false gates so that gates
                                that depend on them operate in a consistent manner.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    In addition to the context menus, double clicking on a gate
                    brings up a gate editor which allows you to modify the gate's
                    definition or to use it as a starting point for another gate.
                </para>
                <para>
                    Let's look at the
                    <link linkend='sec.gatecreator' endterm='sec.gatecreator.title' />
                    and then at the
                    <link linkend='sec.gateappdialog' endterm='sec.gateappdialog.title' />
                </para>
                <section id='sec.gatecreator'>
                    <title id='sec.gatecreator.title'>Gate creation/edit dialog</title>
                    <para>
                        As with the spectrum creation/edit dialog, the gate
                        creation and edit dialog's appearance depends on the
                        gate type.  In this section we'll go over how to interact
                        with the editor for all gate types.
                    </para>
                    <para>
                        When you want to create a gate, the gate editor first
                        looks like this:
                    </para>
                    <figure>
                        <title>Gate create/edit dialog</title>
                        <graphic format='PNG' fileref='gateeditorgeneric.png' />
                    </figure>
                    <para>
                        The only thing you can do with this dialog is set the
                        gate name, the gate type, cancel the operation, or
                        get online help.  Once you select the gate type. the
                        dialog will change appearance in accordance with the type
                        of gate you are creating.  If you are editing an existing
                        gate the gate type and dialog appearance are selected
                        from the gate being edited.
                    </para>
                    <formalpara>
                        <title>And gate editor</title>
                        <para>
                            And gates are compound gates that are true only if
                            all dependent gates are true. Note that dependent
                            gates may be other compound gates allowing for
                            the stepwise construction of arbitraty gate logic.
                        </para>
                    </formalpara>
                    <para>
                        The And gate editor is shwon below:
                    </para>
                    <figure id='fig.andeditor'>
                        <title id='fig.andeditor.title'>And gate editor</title>
                        <graphic format='PNG' fileref='andeditor.png' />
                    </figure>
                    <para>
                        Buid up the list of dependent gates by double clicking
                        on gates in the <literal>Gates</literal> folder to the
                        left of the dialog.  If you select a gate by mistake,
                        double click it in the
                        <literal>Dependent Gates</literal> list box
                        to remove it.
                    </para>
                    <formalpara>
                        <title>Or gate editor</title>
                        <para>
                            Or gates are compound gates which are true if at
                            least one of their dependent gates are true.
                            Note that again dependent gates can also be
                            compound gates allowing you to build up arbitrary
                            gate logic.   The appearance and mechanics of the
                            Or gate editor is identical to that of the
                            <link linkend='fig.andeditor' endterm='fig.andeditor.title' />
                        </para>
                    </formalpara>
                    <formalpara>
                        <title>Not gate editor</title>
                        <para>
                            Not gates are compound gates that have a single
                            dependent gate (which may itself be compound).
                            Then Not gate is true if its dependent gate is
                            False, and vica versa.  The Not gate shares the
                            same gate editor as the
                            <link linkend='fig.andeditor' endterm='fig.andeditor.title' />.
                            <guibutton>Ok</guibutton>, however only works if
                            a single gate is in the Dependent gates list box.
                            In the future, not gates will get its own gate editor,
                            one that makes it much clearer only one gate can
                            be selected.
                        </para>
                    </formalpara>
                    <!--  NOTE that the editors for :
                          -  2bands to a contour
                          -  Equal mask
                          -  Not mask
                          -  And mask
                          result in an error if selected.  Fill in documentation
                          about them here once that's fixed and we know what they
                          look like and how they work.
                    -->
                    <formalpara>
                        <title>Slice editor</title>
                        <para>
                            Slices represent a region of interest on a single
                            parameter.  Slices are primitive gates that can
                            be entered graphically in the viewers.  When entering
                            gates graphically it is important to note that
                            those gates are entered on the underlying parameter
                            not on the spectrum as sometimes people say.
                        </para>
                    </formalpara>
                    <para>
                        The slice editor is shown below.  Note that it reminds
                        you that you probably could enter gates like this more
                        easily graphically.
                    </para>
                    <figure id='fig.sliceeditor'>
                        <title id='fig.sliceeditor.title'>Slice gate editor</title>
                        <graphic format='PNG' fileref='sliceditor.png' />
                    </figure>
                    <para>
                        Use the <literal>Parameters</literal> folder to choose
                        which parameter the cut is on and set the low and high
                        limits of the cut at the bottom of the dialog. If you
                        selected the wrong parameter, just select the correct one
                        and the parameter will be replaced.
                    </para>
                    <formalpara>
                        <title>Gamma slice editor</title>
                        <para>
                            A gamma slice is a slice that depends on a number
                            of parameters.  Gamma  slices only have meaning
                            when applied to other gamma spectra.  In that case
                            they are treated as folds.  A gamma spectrum is
                            only incremented for parameters that do not make
                            the gate true.
                        </para>
                    </formalpara>
                    <para>
                        The gamma slice editor is identical to
                        <link linkend='fig.sliceeditor' endterm='fig.sliceeditor.title' />
                        except that an arbitrary number of parameters can be added to
                        the selected parameter list box.  If a gamma  1-D spectrum
                        has been created with the appropriate parameters, a gamma
                        gate can also be entered graphicall on the viewer.
                    </para>
                    <formalpara>
                        <title>Band gate editor</title>
                        <para>
                            A band is a gate that represents and open poly line
                            in the two dimensional space defined by a pair of
                            parameters.   Bands are true if an event defines
                            both parameters and results in a pointe below the
                            poly line.  If you want a band to be the space above
                            the poly line you can create a not gate from the
                            band.
                        </para>
                    </formalpara>
                    <para>
                        Bands can be easily entered by accepting its points on
                        a viewere by accepting points on a spectrum that is
                        defined on the parameters.  Again a reminder.  Gates are
                        defined on parameters regardless of the fact that for
                        convenience they may be drawn on spectra.
                    </para>
                    <para>
                        The band gate editor looks like this:
                    </para>
                    <figure id='fig.bandeditor'>
                        <title id='fig.bandeditor.title'>Band gate editor</title>
                        <graphic format='PNG' fileref='bandeditor.png' />
                    </figure>
                    <para>
                        In the parameters list box, the top parameter selected is
                        the X parameter and the bottom one, the Y parameter.
                        Select parameters fromt he folder hierarchy on the left
                        side of the GUI.  Selecting more than two parameters results
                        in the top one disappearing and the bottom one becoming
                        the X parameter.  You can also remove a parameter by
                        double clicking it in the list box.
                    </para>
                    <para>
                        The points of the gate can be entered in the next point
                        entry.  Points are floating point pairs whose values are
                        separated by whitespace.  The <keycap>Enter</keycap> key
                        adds the point, as does the <guibutton>Accept Point</guibutton>
                        button.  Points can be removed either by clicking
                        <guibutton>Delete Last</guibutton> which deletes the
                        last point and double cliking on the point to delete.
                    </para>
                    <formalpara>
                        <title>Contour gate editor</title>
                        <para>
                            Contoure gates are gates defined in the two dimensional
                            space defined by a pair of parameters.  Contours
                            are closed polylines.  The polyline is closed by
                            connecting its last pont to its first.  The gate is
                            true for events that define both of its parameter and
                            for which the point defined by the event is inside
                            the closed polyline.
                        </para>
                    </formalpara>
                    <para>
                        It is possible to draw all sorts of pathalogical figures.
                        SpecTcl has a consistent definition.  A point is considered
                        inside the gate if a line in any direction from the point extended to infinity
                        will cross an odd number of polyline edges.  A point is
                        outside if it crosses an even number of edges.
                    </para>
                    <para>
                        The interior of the gate shown below is shaded.
                    </para>
                    <figure>
                        <title>The interior of a pathalogical contoure gate</title>
                        <graphic format='PNG' fileref='contourinterior.png' />
                    </figure>
                    <para>
                        The contour editor is the same as the
                        <link linkend='fig.bandeditor' endterm='fig.bandeditor.title' />.
                        The only difference betweena band and a contour, after all is
                        that contours connect the last point to he first to form
                        a closed figure.
                    </para>
                    <formalpara>
                        <title>Gamma band and Gamma contour editor</title>
                        <para>
                            Gamma bands and contours are special gates
                            used to define folds on gamma spectra.  When applied
                            to a gamma spectrum, points are incremented only if their
                            paramters are not points that are inside the gate.
                            These gate share the
                            <link linkend='fig.bandeditor' endterm='fig.bandeditor.title' />.
                        </para>
                    </formalpara>
                </section>
                <section id='sec.gateappdialog'>
                    <title id='sec.gateappdialog.title'>Gate application dialog</title>
                    <para>
                        The gate application dialog allows you to apply a single
                        gate, the one that brought up the context menu, to
                        one or more spectra.  Recall that spectra only increment
                        for events in which their applied gate is true.
                    </para>
                    <para>
                        The dialog looks like this:
                    </para>
                    <figure>
                        <title>Gate Application Dialog</title>
                        <graphic format='PNG' fileref='gateapplicationdialog.png' />
                    </figure>
                    <para>
                        Select the spectra you want the gate applied to.  If you
                        accidentally select a spectrum you don't want the gate
                        applied to, double click it in the listbox to remove it.
                    </para>
                    <para>
                        Note that spectra selected are removed from the spectrum
                        tree as applying the same gate to a spectrum twice doesn't
                        hurt but is not really meaningful.
                    </para>
                </section>
            </section>
        </section>
    </chapter>
    <chapter id='chap.filteranalysis'>
        <title id ='chap.filteranalysis.title'>Analyzing filter files</title>
        <para>
            <link linkend='chap.filters' endterm='chap.filters.title'/>
            described filters, how to create them, and manipulate them to
            produce filtered data sets.  This chapter will describe how
            to analyze filtered data sets.  The scope of this chapter
            is limited to analyzing XDR formatted filters in SpecTcl.
        </para>
        <para>
            Filter data files are self-describing, but require a special
            buffer decoder and event processor to unpack them into
            parameters.  This chapter desribes:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    How to prepare your spectcl to analyze filtered event files.
                </para>
            </listitem>
            <listitem>
                <para>
                    The format of filtered event files.
                </para>
            </listitem>
        </itemizedlist>
        <section>
            <title>Preparing SpecTcl to analyze filtered event files.</title>
            <para>
                The steps required to prepare SpecTcl to read filtered event files
                are:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        Remove your event processors from the event analysis
                        pipeline.  When doing so, however, ensure that your
                        parameter definitions still exist.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Add a <classname>CFilterEventProcessor</classname>
                        at the front of the event analysis pipeline.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Rebuild your SpecTcl.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Use the <guimenu>Data Source</guimenu><guimenuitem>Filter File</guimenuitem>
                        to attach your SpecTcl to filtered event files.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                In our sample code, our event processors created tree parameters.
                We still need those parameters to provide slots for the filtered
                event data to put the unpacked data.  The simplest way
                to do this is to instantiate our event processors but just
                to not register them with the event analysis pipeline.
                See the sample <methodname>CreateAnalysisPipeline</methodname>
                below:
            </para>
            <example>
                <title>Removing our event processors from the analysis pipeline</title>
                <programlisting>
void 
CMySpecTclApp::CreateAnalysisPipeline(CAnalyzer&amp; rAnalyzer)  
{
  CEventProcessor* simple = new SimpleEventProcessor;  <co id='filtera.simple' />

  // Note calibration is static.                       <co id='filtera.calib' />

#ifdef ANALYZE_FILTERS                                 <co id='filtera.conditional' />

#else
  
  RegisterEventProcessor(*simple "Test");
  RegsisterEventProcessor(calibration, "Calibrator");
#endif
  
}  
                    
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='filtera.simple'>
                    <para>
                        Rather than instantiating the event processor as we
                        register it, instantiating it separately allows us to make
                        the instance, which defines tree parameters, but
                        to leave it out of the analysis pipeline.
                    </para>
                </callout>
                <callout arearefs='filtera.calib'>
                    <para>
                        It's been a few pages ago but recall that the
                        calbration computing event processor was
                        defined statically.  This will cause it to make the
                        tree parameters it needs.
                    </para>
                </callout>
                <callout arearefs='filtera.conditional'>
                    <para>
                        What we do here is use conditional compilation so that
                        we can compile  SpecTcl to either register the
                        filter event processor (next step) or our
                        event processors depending on the preprocessor
                        definition (or lack thereof) of <literal>ANALYZE_FILTERS</literal>.
                    </para>
                </callout>
            </calloutlist>
            <para>
                To add in the filter event processor we have to include its
                header and register an instance of it at the front of the
                event analysis pipeline:
            </para>
            <example>
                <title>Registering the filter event processor</title>
                <programlisting>
                    ...
#include "CmdCalibration.h"
#include "SetCalibCommand.h"
#include &lt;FilterEventProcessor.h&gt;
...

#ifdef ANALYZE_FILTERS
  RegisterEventProcessor(*(new CFilterEventProcessor), "FilterUnpacker");
#else
  ...
                </programlisting>
            </example>
            <para>
                Now to analyze filter files we just need to modify the
                <filename>Makefile</filename> definition of
                <literal>USERCXXFLAGS</literal>:
            </para>
            <example>
                <title>Defining <literal>ANALYZE_FILTERS</literal></title>
                <programlisting>
...
#  If you have any switches you need to add to the default c++ compilation rules,
#  add them to the defintion below:

USERCXXFLAGS=-DANALYZE_FILTERS
...
                </programlisting>
            </example>
            <para>
                Doing a <command>make clean SpecTcl</command> will now build
                SpecTcl to analyze filters.  commenting out that definition and
                again doing <command>make clean SpecTcl</command> will
                build a SpecTcl capable of reading raw event files again.
            </para>
        </section>
        <section>
            <title>The format of filtered event files.</title>
            <para>
                This section describes the format of filtered event files.
                It's more than a bit technical and can be skipped by anybody not
                planning to process event files outside of SpecTcl.
            </para>
            <para>
                The built in SpecTcl filter file format uses Xdr to ensure that
                filter files can be read on all systems, regardless of byte order.
                Most, if not all, unix-like systems provide an Xdr I/O library.
                See <command>man 3 xdr</command> for information about that
                library on your system.
            </para>
            <note>
                <title>Filter file formats are extensible</title>
                <para>
                    The filter file format is extensible and that is used
                    by the Root Filter format extension which writes
                    filter files as root ntuples.  Information about
                    how to extend filter file formats is given in the programming
                    guide.
                </para>
            </note>
            <para>
                Filter file formats are made up of two types of records. The
                record type is identified by a text string as the first
                item in each record.  The <literal>header</literal>
                record describes the parameters the filter file has.
                There will be only one of these and it must be the first record
                in the file.  The <literal>event</literal> record contains
                the data for a single event.  There will typically be many of these
                in the output file.
            </para>
            <section>
                <title>The <literal>header</literal> record</title>
                <para>
                    The first thing in a header is the string
                    <literal>header</literal>.  Furthermore, XDR filter files
                    must begin with a header record.
                </para>
                <para>
                    Following the <literal>header</literal> string, is an integer
                    that is the number of parameters in the filter file.
                </para>
                <para>
                    The next thing in a <literal>header</literal> record is
                    a sequence of strings.  The number of strings is the number
                    of parameters in the filter file.  Each string is a parameter
                    name.  
                </para>
                <para>
                    It is important to keep track of the order of those strings as
                    they represent the order of bits in the parameter present bit
                    mask in the <literal>event</literal> records (see below).
                    Note that SpecTcl, on reading the header does not create
                    parameters in this list that have not yet been defined.
                    Those parameters, when seen events, are discarded.
                </para>
            </section>
            <section>
                <title>The <literal>event</literal> record</title>
                <para>
                    The first thing in an event is the string <literal>event</literal>.
                    This indicates the record contains a description of a single event.
                </para>
                <para>
                    The record identification string is followed by a sequence of
                    integers.  These contain bit masks that describe which
                    parameters are present.  
                </para>
                <para>
                    As many unsigned bit masks will be present as rerquired to
                    provide one bit for each parameter.  Bits will be set in the
                    bit mask for each parameter that is defined in the event.
                    Bits are allocated from low order to high order, first mask
                    to last mask in the order of the parameter names in the
                    header record.  
                </para>
                <para>
                    For example, suppose there are two parameters <literal>a</literal>
                    and <literal>b</literal> that appear in that order in the
                    header parameter name list.  <literal>a</literal> will be
                    allocated the bottom, 1's, bit of the first (and only mask) and
                    <literal>b</literal> will be allocated the next, 2's bit in that
                    mask.
                </para>
                <para>
                    Following the bit masks are the parameter values as doubles.
                    The parameters are written in order of their names of in the
                    name list in the header, and only the parameters that have bits
                    set will be written.
                </para>
                <para>
                    Suppose, for example parameters <literal>a</literal>,
                    <literal>b</literal> and <literal>c</literal> are in the
                    filter and listed in that order in the parameter name list
                    in the header.  An event which gave a value only to
                    parameters <literal>a</literal> and <literal>c</literal>,
                    will have a bit mask of <literal>b101</literal>.  The bitmask
                    will then be followed first by the value of parameter 
                    <literal>a</literal> and then by the value of
                    parameter <literal>c</literal>.  Parameter <literal>b</literal>
                    is omitted since it's bit is not set in the mask.
                </para>
                <para>
                    For more information about this, see the following
                    source files in SpecTcl's <filename>Core</filename>
                    directory:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><filename>CXdrOutputStream.{cpp,h}</filename>, <filename>CXdrInputStream.{cpp,h}</filename></term>
                        <listitem>
                            <para>
                                Provides streaming operators (<literal>&lt;&lt;</literal>
                                and <literal>&gt;&gt;</literal>) that wrap
                                the library functions for doing I/O to XDR files.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><filename>CXdrFilterOutputStage.{cpp,h}</filename></term>
                        <listitem>
                            <para>
                                The output class used by the filter
                                system to write filter files in XDR format.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><filename>FilterBufferDecoder.{h,cpp}</filename></term>
                        <listitem>
                            <para>
                                The input class used by the filter system to
                                read filter files in XDR format.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </section>
        </section>
    </chapter>
</book>