<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                      "file:///usr/share/xml/docbook/schema/dtd/4.5/docbookx.dtd
"
>
<book>
    <bookinfo>
      <title>Batch SpecTcl (5.2 and later)</title>
      <author><firstname>Ron</firstname><surname>Fox</surname></author>
      <revhistory>
          <revision>
             <revnumber>1.0</revnumber>
             <date>July 23, 2019</date>
             <authorinitials>RF</authorinitials>
             <revremark>Original Release</revremark>
          </revision>
      </revhistory>
    </bookinfo>
    <chapter>
        <title>Introduction</title>
        <para>
            This manual describes the batchfeature of SpecTcl that was introduced
            in version 5.2.  Batch SpecTcl supports fully automated offline
            processing of event files.  When coupled with the external
            <application>mpispectcl</application> and
            <filename>mipspectcl</filename> packages, this offline processing
            can be performed in massively parallel clusters enabling
            performance that is only limmited I/O throughput.
        </para>
        <para>
            This document is organized as follows:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    The remainder of this chapter provides a brief introduction
                    to some of the concepts and limitations of batch SpecTcl.
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend="ch.serialbatch" endterm='ch.serialbatch.title' />
                    describes batch SpecTcl.  How to prepare to use it and
                    how to drive it.  Note that by itself, batch SpecTcl isn't
                    that interesting.  What it does do is provide a testbench
                    to ensure that you hvae the pieces you need to
                    run a parallel batch SpecTcl in a cluster environment.
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend="ch.mpitcl" endterm="ch.mpitcl.title" />
                    Describes a Tcl interpreter that is enhanced to support
                    simplified Message Passing Interface (MPI) communication.
                    This is foundational to the
                    <filename>mpispectcl</filename> package that is used
                    to implement parallel batch SpecTcl on top of both MPI
                    and the serial batch SpecTcl.
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ch.mpispectcl' endterm='ch.mpispectcl.title' />
                    Describes the Message Passing Interrace (MPI ) massively
                    parallel SpecTcl.  For compute intensive SpecTcl applications
                    you can get several orders of magnitude performance
                    improvement up to the I/O bandwidth of the system.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            Let's get a few concepts straight before we dive in.
            Batch SpecTcl is a purely non-interactive version of SpecTcl.
            Unlike the "normal" SpecTcl (we'll call that just SpecTcl from now on),
            it runs on a Tcl interpreter without the Tk Graphical user interface
            package installed.  Furthermore, once you begin analyzing data,
            the interpreter will be blocked from accepting future commands
            until that analysis is finished.
        </para>
        <para>
            As with SpecTcl, to use batch SpecTcl you'll need to define
            and register an analysis pipeline.  The same event processors you
            used in SpecTcl can be usedin batch SpecTcl, although they
            have to be setup differently.
        </para>
        <para>
            Since batch SpecTcl is not interactive, the assumption is that
            at some point you've figured out the set of parameters, spectra,
            gates and gate applications you need and saved them to some
            configuration file.  Prior to beginning analysis, you'll
            pull those definition into batch spectcl.
        </para>
        <para>
            Finally, since batch SpecTcl is non-interactive, you can't see
            the spectra it creates.   Therefore, after analyzing data,
            you need to write the spectra to file where they can be
            read into an interactive SpecTcl.
        </para>
        <para>
            In the next chapter we'll start to dive into how to get
            batch SpecTcl working for your code.  Note that
            since batch SpecTcl is purely serial, it's a good testbench for
            processing that will be used by MPI SpecTcl.
        </para>
    </chapter>
    <chapter id = "ch.serialbatch">
        <title id = "ch.serialbatch.title">Serial batch SpectTcl</title>
        <para>
            This chapter describes the batch SpecTcl.  It describes:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    How to incorporate batch SpecTcl into a raw Tcl interpreter
                    (e.g. tclsh).
                </para>
            </listitem>
            <listitem>
                <para>
                    The SpecTcl commands that batch SpecTcl
                    supports.  Note that this is a subset of the full set of
                    SpecTcl commands (e.g. the <command>attach</command> command
                    is not supported).
                </para>
            </listitem>
             <listitem>
                <para>
                    The objects in batch SpecTcl that drive the batch
                    analysis and the commands provided to accept them.
                    Note that this part of batch SpecTcl is deliberately
                    overkill to make the implementation of MPI SpecTcl simple.
                </para>
            </listitem>
            <listitem>
                <para>
                    How to create a loadable package that sets up the
                    batch SpecTcl event processing pipeline.
                </para>
            </listitem>
           
            <listitem>
                <para>
                    We'll look at a simple analysis script and explain how it works.
                    In that process, we'll also discuss multi-segmented
                    runs and how to analyze them.
                </para>
            </listitem>
        </itemizedlist>
        <section>
            <title>Incorporating batch SpecTcl in to a Tcl interpreter</title>
            <para>
                Batch SpecTcl provides a Tcl loadable package that can be
                installed in any Tcl (or Tk for that matter) interpreter.
                In order to do this you need to have a Tcl library path that
                includes the Tcl libraries in the
                version of SpecTcl you want to use (5.2-000 is
                the earliest ersion that supports batch SpecTcl).
            </para>
            <para>
                Here are two examples of how to do this assuming SpecTcl is installed
                in <filename>/usr/opt/spectcl/5.2-000</filename>:
            </para>
            <example>
                <title>Incorporating batch SpecTcl: Specifying the TCL Library on the command line:</title>
                <programlisting>
TCLLIBPATH=/usr/opt/spectcl/5.2-000/TclLibs tclsh
% package require spectcl
                </programlisting>
            </example>
            <example>
                <title>Incorporating batch SpecTcl: adding the Tcl library to the <varname>auto_path</varname></title>
                <programlisting>
tclsh
% lappend auto_path /usr/opt/spectcl/5.2-000/TclLibs
% package require spectcl
                </programlisting>
                <para>
                    The <literal>spectcl</literal> package contains the
                    library code needed to run batch SpecTcl.
                </para>
            </example>
        </section>
        <section>
            <title>Commands supported by batch SpecTcl</title>
            <para>
                In the previous section we've seen how to incorporate the
                Batch Spectcl library in a Tcl interpreter.  The
                <literal>spectcl</literal> package provides
                <emphasis>most</emphasis> of SpecTcl's commands.  Since batch
                SpecTcl is fully non-interactive, however, it does not
                make sense to provide all of SpecTcl's commands.
            </para>
            <para>
                Below is a list of the SpecTcl commands  Batch SpecTcl
                provides.  See the SpecTcl command reference for complete
                documentation of each command.
            </para>
            <variablelist>
                <varlistentry>
                    <term><command>parameter</command></term>
                    <listitem>
                        <para>
                            Allows you to define raw parameters and give
                            them slot numbers in the <classname>CEvent</classname>
                            object passed to elements of the event processing
                            pipeline.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>psuedo</command></term>
                    <listitem>
                        <para>
                            Provides support for creating computed paramters
                            at the Tcl script level.  While these are not
                            very performant in serial SpecTcls, in parallel
                            SpecTcl you can uses as many cores as you need
                            to get the performance up to the file read limit.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>spectrum</command></term>
                    <listitem>
                        <para>
                            Used to define and delete spectra as well
                            as to list the available spectra.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>clear</command></term>
                    <listitem>
                        <para>
                            Clears the contents one or more spectra.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>channel</command></term>
                    <listitem>
                        <para>
                            Support for getting or setting channel values
                            in a spectrum. We'll see how useful this is
                            in parallel SpecTcl later in this manual.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>swrite</command></term>
                    <listitem>
                        <para>
                            Writes spectra to file.  The result of a batch
                            SpecTcl run is a set of spectra.  The
                            <command>swrite</command> command is the
                            means you have to obtain those analysis products
                            after the analysis is run.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>sread</command></term>
                    <listitem>
                        <para>
                            Reads spectra from file.  This is not as useful
                            in batch SpecTcl but is supported.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>sbind</command>, <command>unbind</command></term>
                    <listitem>
                        <para>
                            These are effectively No-ops but are don't flag
                            errors.  They are provided in case your setup files
                            include e.g. <command>sbind -all</command> commands.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>gate</command></term>
                    <listitem>
                        <para>
                            Allows the creation, modification, deletion and listing
                            of conditions (gates) that can be applied to
                            spectra.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>apply</command></term>
                    <listitem>
                        <para>
                            Allows you to apply gates to spectra.  When a gate
                            is applied to a spectrum, events can only increment
                            that spectrum if the gate is satisfied by that
                            event.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>ungate</command></term>
                    <listitem>
                        <para>
                            Removes any condition on the increment of a spectrum.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>treeparameter</command></term>
                    <listitem>
                        <para>
                            Provides support for parameters with default ranges
                            and units.  Tree parameters are often specified in
                            configuration files.  
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>treevariable</command></term>
                    <listitem>
                        <para>
                            Provides support for Tcl variables that are
                            easily visible within compiled C code.  These variables
                            can also have units of measure.
                            <command>treevariable</command> commands often
                            are part of configuration files.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>fold</command></term>
                    <listitem>
                        <para>
                            This command can define folds on gamma spectra.
                            Folds are used in gamma spectroscopy.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>project</command></term>
                    <listitem>
                        <para>
                            provides support to create spectra that are
                            dynamic projections of 2-d spectra.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>fit</command></term>
                    <listitem>
                        <para>
                            Provides limited fitting support.  Note that
                            including the <literal>rootinterface</literal>
                            package provides the <command>rootexec</command>
                            command which provides access to root's fitting
                            capabilities and access to SpecTcl's spectra.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>integrate</command></term>
                    <listitem>
                        <para>
                            Supports integration of a region of interest in a
                            spectrum.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>version</command></term>
                    <listitem>
                        <para>
                            Returns the full SpecTcl version
                            (e.g. <literal>5.2-000</literal>).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>scontents</command></term>
                    <listitem>
                        <para>
                            Produces the contents of the non-zero channels
                            in a spectrum in either Tcl usable or JSON form.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>specstats</command></term>
                    <listitem>
                        <para>
                            Returns the under and overflow counters for
                            a spectrum.  By underflow and overflow, we mean
                            the number times an increment was attempted
                            off the left and right side of the a
                            spectrum respectively.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>pipeline</command></term>
                    <listitem>
                        <para>
                            Provides for dynamic manipulation of the
                            event processing pipeline.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>evbunpack</command></term>
                    <listitem>
                        <para>
                            Provides for constructing event processing pipelines
                            that work on event built data.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                Additional commands that are specific to batch SpecTcl are
                also defined.  These are described in th enext section.
            </para>
        </section>
        <section>
            <title>How Batch SpeTcl analyzes data</title>
            <para>
                In normal SpecTcl you don't usually have to worry about
                data analysis works.  You click buttons on a GUI or use
                menu items and poof SpecTcl is analyzing data.
                In normal SpecTcl, what's happening under the hood is a multi-step
                process:
            </para>
            <orderedlist>
                <listitem>
                    <para>
                        An <command>attach</command> command stops any
                        analysis in progress attaches SpecTcl to a new
                        data source (file or program on the end of a pipe).
                    </para>
                    
                </listitem>
                <listitem>
                    <para>
                        The <command>ringformat</command> command is used
                        to indicate if the data source is NSCLDAQ-10.x or
                        NSCLDAQ-11.x (we're not going to consider data from
                        NSCLDAQ-8.x or earlier).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The <command>start</command> command is used to
                        start analyzing data from the data source.
                    </para>
                </listitem>
            </orderedlist>
            <para>
                What this all does is select data sources, and buffer
                decoding objects as well as start a Tcl event loop based
                scheme for analyzing data while keeping the user interface
                alive to your interactions.
            </para>
            <para>
                Batch SpecTcl does not need to keep the user interface alive
                and has been written with NSCLDAQ-11.x data in mind (though
                a suitably sophisticated programmer can override that).
            </para>
            <para>
                Batch SpecTcl provides an analysis scheme were data are taken
                from some data getting object and passed to some data distributing
                object.   In practice, the data getting object
                gets data from file while the data distributing object
                sends that data into the normal SpecTcl analysis objects.
            </para>
            <para>
                To analyze data you must issue commands to select the
                data getter and the data distributor and then ask the
                program to analyze data.  While this may seem overly complex,
                when we discuss parallel SpecTcl, we'll see how this allows us to
                extend batch SpecTcl into an MPI application simply by
                adding additional data getters and distributors as well
                as a fancier script to drive the analysis.
            </para>
            <para>
                The <command>filesource</command>  command specifies that the
                data getter the analysis will use gets data from a file.
                This command takes one mandatory parameter and an optional
                parameter.  The mandatory parameter is the name of the file
                the getter takes data from.  The optional one is the size in
                bytes of reads done from that file.  When you run parallel
                SpecTcl, this block size can have an impact on when you go
                I/O limited.  The default block size is <literal>8192</literal>.
            </para>
            <para>
                Here are some examples of the <command>filesource</command> command.
            </para>
            <example>
                <title>Using the <command>filesource</command> command</title>
                <programlisting>
filesource /mnt/evtdata/e00000/run6/run-0006-00.evt
filesource /mnt/evtdata/e00000/run6/run-0006-00.evt   [expr 1024*1024]
                </programlisting>
            </example>
            <para>
                In the first example, data will be gotten from the run 6 event
                file in the evtdata area for some experiment using the default
                block size of <literal>8192</literal>.  In the second example,
                The same file is read but with a block size of 1 Mbytes
                (1024*1024).
            </para>
            <para>
                The analysis data distributor is selected using the
                <command>analysissink</command> command. It takes no parameters.
            </para>
            <para>
                Once the getter and distributor are selected, you can begin
                analysis via the <command>analyze</command> command.
                This command will not return until the getter has indicated
                there's no more data available from its data source.
                Once that has happened, you're certainly free to analyze
                another run by using the <command>filesource</command>
                command to specify another file (for example you could analyze
                a segmented run in a loop over all the event files in the run).
            </para>
            <para>
                Extending the <command>filesource</command> example above,
                here's how you would analyze the singly segmented run 6
                with a blocksize of 1Mbytes
            </para>
            <example>
                <title>Analyzing a run</title>
                <programlisting>
filesource /mnt/evtdata/e00000/run6/run6-0006-00.evt
analysissyink
analyze
                </programlisting>
            </example>
        </section>
        <section>
            <title>Creating a loadable package for the event analysis pipeline</title>
            <para>
                In the previous section, wwe learned how to start batch SpecTcl
                analyzing data.  If you've worked with SpecTcl in any depth, however
                you should be wondering how to setup the event analysis pipeline.
                In this section we'll describe how to do that.
            </para>
            <para>
                As a pre-requisite, you'll need to have the sources to the
                event processors you use available.  They  can stay where
                they normally live in your normal SpecTcl build tree.
            </para>
            <para>
                What we're going to do is create a compiled Tcl loadable
                package that you can incorporate in to the Tcl interpreter
                that's already incorporated the <filename>spectcl</filename>
                package.
            </para>
            <para>
                Here's the procedure we'll describes:
            </para>
            <orderedlist>
                <listitem>
                    <para>
                        Get the batch SpecTcl loadable package skeleton
                        from the SpecTcl distribution.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Modify the package initialization code in the
                        skeleton to instantiate event processors and
                        setup the analysis pipeline.  This process
                        should be familiar to SpecTcl programmers though the
                        skeleton is much simpler.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Modify the Makefile in the skeleton to include
                        the sources needed (e.g. event processors and
                        supporting code).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Build the loadable object.
                    </para>
                </listitem>
            </orderedlist>
            <para>
                We'll also show how to incorporate your loadable package into
                tcl and to check that the pipeline you thought you set up is
                the pipeline you actually set up.
            </para>
            <para>
                To start with, obtain the batch SpecTcl skeleton. This consists
                of the files in the BatchSkel directory of the Skeleton
                installation tree. Put these files in an empty directory.
                For example;  Suppose SpecTcl is installed in
                <filename>/usr/opt/spectcl/5.2-000</filename>, 
            </para>
            <example>
                <title>Obtaining the batch SpecTcl skeleton</title>
                <programlisting>
mkdir batch
cd batch
cp /usr/opt/spectcl/5.2-000/BatchSkel/* .
                </programlisting>
            </example>
            <para>
                The skeleton consists of several files; <filename>Makefile</filename>
                and <filename>Skeleton.cpp</filename> are the files you
                will need to edit.  <filename>CPipelineMaker.{h,cpp}</filename>
                are base class files that we need but should not edit.
            </para>
            <para>
                In editing <filename>Skeleton.cpp</filename>, you need to
                consider three things:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        The actual event processing pipeline you are going
                        to create.  Note that unlike SpecTcl, all pipeline
                        elements (event processors) must have names.  Futhrmore
                        to take advantage of regular SpecTcl's 5.1 capability
                        for dynamically built event processingn pipelines you
                        should get in the habit of providing an event processor
                        name when registering 
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The Name and version of the package you are creating
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The name of the shared object the Makefile will create.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                To setup the event processing pipeline you'll need to
                provide <literal>#include</literal> directives to pull in
                the headers for your event processors.  Don't specify absolute
                paths, take care of that in the Makefile.  
            </para>
            <para>
                Here's an example
            </para>
            <example>
                <title>Including event processor headers</title>
                <programlisting>
                    ...
//  Here you should include your headers for your event processors.

#include &lt;CAENUnpack.h&gt;
                    ...
                </programlisting>
            </example>
            <para>
                The command shown is in the skeleton to indicate where to
                put these <literal>#include</literal> directives.
            </para>
            <para>
                Next, locate the class <classname>MyPiplineMaker</classname>,
                Create and register the event processor(s) you need
                 in the order you want them called.  For example
            </para>
            <example>
                <title>Registering your event processing pipeline</title>
                <programlisting>
                    ...
class MyPipelineMaker : public CPipelineMaker
{
public:
    void operator()() {
        // Here instantiate and use RegisterEventProcessor to
        // setup the event processing pipeline.

      RegisterEventProcessor(*(new CAENUnpack), "CAEN");

    }
};
            ...

                </programlisting>
            </example>
            <para>
                You can register event processors for inclusion in dynamic
                pipelines.  See the SpecTcl programming and programming
                reference manuals for a description of that process.
            </para>
            <para>
                The name and version of the Tcl package are defined in
                the static file level variables
                <varname>PKG_NAME</varname> and <varname>VERSION</varname>
                respectively:
            </para>
            <example>
                <title>Setting the package name and version</title>
                <programlisting>
                    ...
// This file will create a Tcl loadable package, those have versions and
// names... set the version and name here:  Below are sample names.
// If you keep this you'll load your package by
//
//   lappend auto_path $directory_that_has_what_this_builds
//   package require MyPipeline

static const char* VERSION="1.0";
static const char* PKG_NAME="MyPipeline";
                    ...
                </programlisting>
            </example>
            <para>
                You don't need to modify these usually but you can if you prefer.
                The Skeleton sets the version to 1.0 and the package name to
                <literal>MyPipeline</literal>.
            </para>
            <para>
                The Skeleton <filename>Makefile</filename>, by default,
                creates the library <filename>libMyPipelineMaker.so</filename>.
                If you change the name of the library, you need to change the
                name of the package initialization function.  The initialization
                function must have C language bindings and must have name
                that is derived as follows: Starting with the library filename,
                remove the <literal>lib</literal> and <literal>.so</literal>
                In what remains capitalize the first letter and make all other
                letters lower case, append <literal>_Init</literal>. So if you
                have a library named <literal>libBatchPipeline.so</literal> the
                initialization function will be <literal>Batchpipline_Init</literal>.
            </para>
            <para>
                Below shows the initialization function signature in
                the <filename>Skeleton.cpp</filename>
            </para>
            <example>
                <title>Initialization entry point</title>
                <programlisting>
                    ...
/**
 * This entry is called when the package is loaded.
 *  The name of this entry is derived from the shared library name as follows:
 *  -  Remove the leading lib kill the trailing .so
 *  -  Set the first letter to uppercase and all others to lower case.
 *  -  Append _Init.
 *
 *  So, for example, if the library is named libMyPipelineMaker.so
 *  this entry must be called Mypiplinemaker_Init
 *  If you chose a different library name, you must adjust the function
 *  name below.
 */
extern "C" {                              // Tcl n eeds C bindings.
    int Mypipelinemaker_Init(Tcl_Interp* pRawInterpreter)
    {
                    ...
                </programlisting>
            </example>
            <para>
                Unless you want to define additional Tcl commands you normally
                don't have to modify the Skeleton's initialization
                function.
            </para>
            <para>
                Now let's look at the Makefile.  As with standard SpecTcl's
                skeleton Makefile, you  should not need to modify  much more
                than the top pieces of the file. 
            </para>
            <para>
                Let's look at that file:
            </para>
            <example>
                <title>Batch SpecTcl Makefile</title>
                <programlisting>
#  Makefile that you can use to build pipeline maker packages.
#
#
#   What this will produce is a shared library
#   and a Tcl package index file that allows you to load
#   the shared library via packgae require
#   assuming the the library and its pkg_Index.tcl
#   file are in auto_path.
#

INSTDIR=/usr/opt/spectcl/5.2-000        <co id='make.version' />
INCDIR=/usr/opt/spectcl/5.2-000/include

# Add any directories in which sources might live here
# Use this rather than copying your event processors
# into this directory e.g.

VPATH=.                               <co id= 'make.srcdirs' />

#  Add the sources you need built here.

SOURCES=Skeleton.cpp                 <co id='make.sources' />

#
#  Add any compilation flags you need here:
#
MYCXXFLAGS=                       <co id='make.cxxflags' />

#
#  Add any link flags you need here:
#

MYLDFLAGS=                      <co id='cxxldflags' />

##
#  Name of the .so we're buiding note the init
#  function has to track this;  the name here
#  is the one in the skeleton

MYPACKAGELIB=libMyPipelineMaker.so   <co id='make.libname' />

#  If specific objects have dependencies, put them here
#  No need to put in the compilation rule.
#  e.g.
#    Skeleton.o: Skeleton.cpp MyUnpacker.h       <co id='make.deps' />

                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='make.version'>
                    <para>
                        These two lines of the file specify the SpecTcl version
                        you are using.  They are used to compute compilation
                        and link switches that are defined in the chunk of the
                        file you don't need to edit.  If you switch to another
                        version of SpecTcl, simplly change the version numbers
                         in the paths here to reflect the new SpecTcl version
                         you are using.
                    </para>
                </callout>
                <callout arearefs='make.srcdirs'>
                    <para>
                        It's tempting to copy event processor source files
                        from your standard SpecTcl to here.  Don't do it. If you
                        do I pretty much gaurantee that at some point you'll
                        forget to copy a changed file in one direction or the other.
                        The <literal>VPATH</literal> Makefile variable
                        describes to Make the directories in which to search for
                        dependencies.  Just add the directory(ies) in which your
                        event processor sources are located to the definition
                        of <literal>VPATH</literal>.  Path elemnts are either
                        space or <literal>:</literal> separated.
                    </para>
                </callout>
                <callout arearefs='make.sources'>
                    <para>
                        Provide the names of the sources you want compiled
                        into your shared object.  Note that you don't need to
                        specify paths of these sources if they  live in directories
                        that are specified in <literal>VPATH</literal>.  For example,
                        if <literal>VPATH=. ..</literal> use
                        <literal>SOURCES=Skeleton.cpp MyEvprocessor.cpp</literal>
                        <emphasis>NOT</emphasis>
                        <literal>SOURCES=Skeleton.cpp ../MyEveprocessor.cpp</literal>.
                    </para>
                    <para>
                        Note as well that in this line, unlike the Makefile for
                        SpecTcl, you're specifying the sources (.cpp) not objects (.o).
                    </para>
                </callout>
                <callout arearefs='make.cxxflags'>
                    <para>
                        Specify any compilation flags you need to build code here.
                        For example if an event processor and its header live in
                        <literal>..</literal>, you'll need e.g.
                        <literal>MYCXXFLAGS=-I..</literal>
                    </para>
                </callout>
                <callout arearefs='cxxldflags'>
                    <para>
                        Specify the ld flags you need.  For example, if your event
                        processors are in  a library named
                        <filename>libMyEventProcessors.a</filename> that's
                        located in <filename>..</filename>, you might have:
                        <literal>MYLDFLAGS=-L.. -lMyEventProcessors</literal>
                    </para>
                    <para>
                        Note that Tcl rquires lodable packages to be self contained.
                        By that I mean that once loaded, along with the
                        shared objects it was linked to, there can be no
                        undefined symbols.  If there are, tcl will segfault
                        when you try to load the object.  You may also see errors
                        in the last stage of the Makefile when the
                        <filename>pkgIndex.tcl</filename> file is created.
                    </para>
                </callout>
            </calloutlist>
            <para>
                Once you've edited everything, use <command>make</command>
                to build the shared object and package index.
            </para>
        </section>
        <section>
            <title>A simple analysis script.</title>
            <para>
                BatchSpecTcl needs to be driven by a script.  The script must:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        Load the spectcl package.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Load the user's Tcl package that sets up the anlaysis
                        pipeline
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Specify the data getter and distributor.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Start Analysis
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Save the results.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                The sample script below assumes that TCLLIBPATH includes
                the SpecTcl TclLibs directory and the directory in which your
                <literal>MyPipeline</literal> package is stored.  We further assume
                that an interactive SpecTcl has saved its configuration
                in <filename>defs.tcl</filename>.  This definition file
                normally contains the spectrum and gate definitions,
                gate applications and changed tree parameter and tree variable
                settings.
            </para>
            <example>
                <title>Smaple batch SpecTcl script.</title>
                <programlisting>
package require spectcl             <co id='batch.requirebase' />
package require MyPipeline          <co id='batch.requirepipe' />
source defs.tcl                     <co id='batch.defs' />

filesource run-0003-00.evt          <co id ='batch.getter' />
analysissink                        <co id='batch.distributor' />
puts "analyzing..."
analyze                             <co id='batch.analyze' />
puts "done"

set f [open spectra.dat w]
foreach spectrum [spectrum -list] {
   set name [lindex $spectrum 1]     <co id='batch.save' />
   swrite -format ascii $f $name
}
close $f
puts "Spectra written to spectra.dat"
                    
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='batch.requirebase'>
                    <para>
                        Requires the SpecTcl batch package.  This script
                        requires that TCLLIBPATH includes the
                        <filename>TclLibs</filename> directory of a SpecTcl
                        installation with version greater than or equal to
                        <literal>5.2-000</literal>.
                    </para>
                </callout>
                <callout arearefs='batch.requirepipe'>
                    <para>
                        <literal>MyhPipeline</literal> is the name of the
                        package created by the Skeleton, unless you change
                        it.  This line loads that package which, at initialization,
                        sets up the analysis pipeline that produces parameters
                        from raw events.
                    </para>
                </callout>
                <callout arearefs='batch.defs'>
                    <para>
                        Sources the file that contains the spectrum, gate,
                        gate application definitions and other information
                        that determines what's done with the parameters
                        produced for each event.
                    </para>
                </callout>
                <callout arearefs='batch.getter'>
                    <para>
                        Specifies data will be gotten from file.
                        The file we read will be run-0003-00.evt in the
                        current working directory.  This might be a single run
                        event file.
                    </para>
                </callout>
                <callout arearefs='batch.distributor'>
                    <para>
                        The main analysis loop will take data read from the
                        getter and distribute them to the SpecTcl analysis
                        subsystem.
                    </para>
                </callout>
                <callout arearefs='batch.analyze'>
                    <para>
                        Analyzes the entire file.
                    </para>
                </callout>
                <callout arearefs='batch.save'>
                    <para>
                        This chunk of code opens the file
                        <filename>specta.dat</filename>, loops over all spectrum
                        definitions and writes the spectra that have been
                        accumulated to that file.  Using interactive SpecTcl
                        you can read this file using a similar loop:
                    </para>
                    <example>
                        <title>Reading a file with several spectra:</title>
                        <programlisting>
set f [open spectra.dat r]
while {![eof $f]} {
    catch {sread -format ascii -nosnapshot -replace $f}
}
close $f
                        </programlisting>
                    </example>
                    <para>
                        The <command>catch</command> command is used because
                        att the end of the file, there may be an empty line which
                        won't let the end file condition be discovered until
                        after an attempt is made to read a spectrum that is not
                        there.
                    </para>
                </callout>

            </calloutlist>
            <para>
                You can certainly modify the analysis so that it
                analyzes more than one file or even more than one run.
                Suppose the current directory contains several runs and the
                order in which the file segments whithin each run is
                processed is unimportant.  To analyze all segments of
                runs 1 through 10, the following could be done (after
                the packages and definitions have been loaded):
            </para>
            <example>
                <title>Reading several multi segmented runs:</title>
                <programlisting>
                    ...
analysissink
for {set run 1} {$run &lt;= 10} {incr run} {
    clear -all
    set namePattern [format run-%04d-*.evt $run]
    set files [glob $namePattern]
    puts "Analyzing run $run"
    foreach file $files {
        filesource $file
        analyze
        puts "Analyzed segment $file"
    }
    puts done
    set  f [open run-$run.spec]
    for spectrum [spectcrum -list] {
        set name [lindex $spectrum 1]
        swrite -format ascii $name $f
    }
    close $f
    puts "Wrote spectra to run-$run.spec"
    
}
                </programlisting>
            </example>
            <para>
                By now this script should be understandable.  Note how prior to
                analyzing the event files for each run, the spectra are cleared.
                Note as well that spectra for each run are written in a file that
                has the run number it its name.
            </para>
            <para>
                Note that the segments in a run will be analyzed out of order.
                Furthermore a simple
                <literal>set files [lsort [glob $namePattern]]</literal> will only
                work if there are less than 100 segments in the run as the file
                run-0001-100.evt sorts alphabetically prior to run-0001-002.evt
            </para>
            <para>
                Here's a Tcl fragment that provides a proc that sorts the list
                of run segments for a run in segment order.
            </para>
            <example>
                <title>Ordering run segments by segment number</title>
                <programlisting>
proc compare {file1 file2} {
    scan $file1 run-%04d-%02d.evt run seg1
    scan $file2 run-%04d-%02d.evt run seg2
    
    if {$seg1 &lt; $seg2} {return -1}
    if {$seg1 &gt; $seg2} {return 1}
    return 0
}
proc sortRun {filelist} {
    return [lsort  -increasing -command compare $filelist]
}

                </programlisting>
            </example>
            <para>
                This uses the ability of the <command>lsort</command>
                command to accept a command that defines the collation order
                of the list it's sorting.
            </para>
        </section>
    </chapter>
    <chapter id='ch.mpitcl'>
        <title id='ch.mpitcl.title'>MPITcl - an enhanced Tcl interpreter</title>
        <para>
            MPITcl provides a Tcl friendly interface to the Message Passing
            Interface (MPI) library for parallel sequential computing.
            MPI is a commonly used library for parallel computing.  MPITcl
            is not part of SpecTcl proper, rather it is a separate package.
            It serves as the basis for parallel batch SpecTcl.
        </para>
        <para>
            MPItcl is an extended Tcl interpreter with additions that support
            Tcl scripts as MPI programs.
        </para>
        <para>
            In this chapter we will:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Introduce some of the concepts behind MPI.
                </para>
            </listitem>
            <listitem>
                <para>
                    Describe how MPI concepts are realized in MPITcl
                </para>
            </listitem>
            <listitem>
                <para>
                    Describe the MPITcl command ensemble that supports
                    MPITcl.
                </para>
            </listitem>
            <listitem>
                <para>
                    Show how to run MPITcl and provide a very simple
                    script that shows how it can be used.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            Note that whle you can <literal>package require Tk</literal> in an
            MPITcl script, this will fail in most cluster computing environments
            as they are intended for batch computing.  Finally, refer to the
            reference section for a full discussion of the MPITcl command ensemble.
        </para>
        <section>
            <title>MPI Concepts</title>
            <para>
                MPI programs consist of a single program.  Several copies of this
                single program are run across several cores which may, in turn
                be distributed across several  network nodes.
            </para>
            <para>
                A Message passing MPI allows copies of the program to exchange
                messages that consist of well defined data types.  MPI further
                supports dividing the computation into distinct intercommunicating
                groups.  Furthermore, messages have tags assocciated with them
                that can describe the type of information in the message.
            </para>
            <para>
                Each instance of a program in an MPI application has one or more
                <firstterm>ranks</firstterm>.  A program instance's rank is just
                an integer numbered from zero to the size of the group.
                A program can inquire as to its rank within all groups it
                belongs to.
            </para>
            <para>
                Communication within a group is handled via group's
                <firstterm>communicator</firstterm>.  A special communicator
                is predefined <literal>MPI_COMM_WORLD</literal> that
                communicates with all the program instances in an application.
            </para>
        </section>
        <section>
            <title>How MPI Concepts map to MPITcl</title>
            <para>
                Communication in MPI can be very complex.  The aim of MPITcl
                is to simplify this communcation and make it friendly to the
                sorts of things a Tcl script might think of doing in a parallel
                computation.  These simplifications:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        Remove the concept of grouping program instances
                        other than the world group.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Since in Tcl everything has a string representation,
                        all data are exchanged via the MPI_CHAR data type.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The computation is logically thought of as the
                        rank 0 script, which runs an interpreter capable of
                        accepting commands or sourcing script files and
                        all other ranks which just process messages.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Program instances can send scripts to other ranks
                        in the computation.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Program instances can send Tcl data to other ranks
                        in the computation.  Program instances can establish
                        handlers for Tcl data.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Several tag values are predefined to know how to dispatch
                        messages received.
                    </para>
                </listitem>
            </itemizedlist>
        </section>
        <section>
            <title>The mpi::mpi command ensemble.</title>
            <para>
                The MPITcl interpreter adds a command ensemble;
                <command>mpi::mpi</command>.  See the reference material
                for full information about each subcommand.
                This has the following subcommands:
            </para>
            <variablelist>
                <varlistentry>
                    <term><command>size</command></term>
                    <listitem>
                        <para>
                            Returns the number of mpitcl program instances
                            in the program.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>rank</command></term>
                    <listitem>
                        <para>
                            Returns the rank of the program within the
                            <literal>MPI_COMM_WORLD</literal> communicator.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>execute</command></term>
                    <listitem>
                        <para>
                            Executes a command in process.  The process is
                            either specified by rank or
                            <literal>others</literal> may be specified to
                            execute the command in all other processes but the
                            sender.  <literal>all</literal> can be specified
                            to execute the script in all processes including this
                            one.  No communication is done to execute the
                            command in this process.
                        </para>
                        <para>
                            For rank 0 to execute a command sent to it by
                            another rank, it must be running the notifier and
                            be in the event loop (e.g. by <command>vwait</command>).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>send</command></term>
                    <listitem>
                        <para>
                            Sends data to another process. <literal>all</literal>
                            and <literal>others</literal> can be used here as well
                            to specify several receivers.  
                        </para>
                        <para>
                            For all program instances to be able to receive
                            data requires that they have established a data handler
                            command (see <command>handle</command>).  Additionally,
                            for rank 0 to receive data, it must be running the
                            notifier and be in the event loop (e.g. via
                            <command>vwait</command>).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>handle</command></term>
                    <listitem>
                        <para>
                            Specifies a script to handle data sent to the process
                            via <command>send</command>.  The sender's rank and
                            the data are appended to the command prior to execution.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>stopnotifier</command></term>
                    <listitem>
                        <para>
                            The notifier is a thread that runs in the rank 0
                            process.  It's purpose is to monitor for MPI
                            messages and queue them as events to the main thread's
                            interpreter where they can be executed when the
                            event loop is entered via, for example,
                            <command>vwait</command>.
                        </para>
                        <para>
                            If compiled code wants to do message exchange it
                            can be important to stop the notifier thread to
                            prevent events from being queues that the main
                            thread will be handling.
                        </para>
                        <para>
                            This command, which is only legal in rank 0 stops
                            the notifier thread.  This is done by sending a
                            message with a special tag.  The probe loop the
                            notifier is executing, recognizesthis tag, absorbs
                            the message and exits.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>startnotifier</command></term>
                    <listitem>
                        <para>
                            Starts the notifier if it is stopped.
                            If the notifier is already running, this has undefined
                            results.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </section>
        <section>
            <title>Running MPITcl (NSCL/FRIB specific)</title>
            <para>
                At the NSCL, the MPITcl shell is located in
                /usr/opt/miptcl/bin/mpitcl.  It is normally run under the
                <command>mpirun</command> command.  Usually it is
                run within a batch job submission script that specifies the
                resources the application needs and provides stdin redirection to
                a script that contains the application.
            </para>
            <para>
                For example, the following command runs 4 processes in the
                MPItcl application and specifies the application script
                myapp.tcl
            </para>
            <example>
                <title>Running MPITcl</title>
                <programlisting>
mpirun -np 4 /usr/opt/mpitcl/bin/mpitcl &lt;myapp.tcl
                </programlisting>
            </example>
            <para>
                Let's look at a toy application.  In
                <link linkend='ch.mpispectcl' endterm='ch.mpispectcl.title' />
                We'll look at MPI batch SpecTcl, a more interesting application
                that runs under MPITcl.  Remember that the script executes
                in rank 0. It therefore must tell all other ranks what to do.
            </para>
            <example>
                <title>Toy MPITcl application</title>
                <programlisting>
                    
                    
puts "There are [mpi::mpi size] proceses in the application."   <co id='mpi.size' />
mpi::mpi execute others {puts "Hello from worker [mpi::mpi rank]"} <co id='mpi.exec' />

# Note that the notifier starts out running so this can work:

mpi::mpi execute others {
    proc ReturnData {rank data} {
      mpi::mpi send 0 $data
    }                                                <co id='mpi.otherhandle' />
    mpi::mpi handle  ReturnData
}

proc receiveData {rank data} {
    puts "Received data from $rank: $data" 
    incr ::expecting -1
}
mpi::mpi handle receiveData                       <co id='mpi.rank0handle' />

set expecting [mpi::mpi size]                     <co id='mpi.repliesexpected' />
incr expecting -1                                

mpi::mpi send others [list 1 2 3 4]              <co id='mpi.send' />
while {$expecting > 0} {
 vwait expecting
}

mpi::mpi stopnotifier                          <co id='mpi.stop' />
mpi::mpi execute all exit


                </programlisting>
            </example>
            <para>
                Remember that this script runs in rank 0
            </para>
            <calloutlist>
                <callout arearefs='mpi.size'>
                    <para>
                        Reports the number of processes in the computation.
                        If, for example this was run from
                        <command>mpirun -np 4 ...</command> this would report
                        <literal>4</literal>
                    </para>
                </callout>
                <callout arearefs='mpi.exec'>
                    <para>
                        Requests all but rank 0 output its rank to stdout.
                        Note that the output may not be in any order and
                        may not even be in coherent lines because the
                        outputs are all done in parallel in the various
                        non rank 0 processes.
                    </para>
                </callout>
                <callout arearefs='mpi.otherhandle'>
                    <para>
                        In all processes besides rank 0, a proc named
                        <literal>ReturnData</literal> is defined and set up
                        to handle any data sent to that process.  The proc
                        sends the data it receives to the rank 0 process.
                    </para>
                </callout>
                <callout arearefs='mpi.rank0handle'>
                    <para>
                        In rank 0, however a data handler is established that
                        outputs where the data came from and the contents of
                        the data.  The <varname>expecting</varname>
                        global variable is decremented after each call.
                        If this variable is <command>vwait</command>ed on,
                        the <command>vwait</command> will conclude when the
                        handler is called.
                    </para>
                </callout>
                <callout arearefs='mpi.repliesexpected'>
                    <para>
                        For a send to others, this computes the number of
                        times we expect the <literal>receiveData</literal> handler
                        tob e called.  Once for each process in the application
                        except rank 0.
                    </para>
                </callout>
                <callout arearefs='mpi.send'>
                    <para>
                        Sends a list of data to all other ranks and
                        vwaits until all other ranks have responded by
                        echoing back their data.  Each echo back will
                        result in <literal>receiveData</literal> being called,
                        which ends the <command>vwait</command>.  The loop
                        runs until there are no more replies to wait for.
                    </para>
                </callout>
                <callout arearefs='mpi.stop'>
                    <para>
                        Prior to exiting the application the notifier thread must
                        be exited. The <command>mpi::mpi execute all exit</command>
                        is the preferred way to exit the MPI application.  A simple
                        <command>exit</command> won't do because mpirun will
                        wait until all processes in the application have exited.
                    </para>
                </callout>
            </calloutlist>
            <para>
                Hopefully this toy application gives you an idea about how
                the typical patterns used in an MPITcl application.  
            </para>
        </section>
    </chapter>
    <chapter id='ch.mpispectcl'>
        <title id='ch.mpispectcl.title'>MPISpecTcl - Massively parallel SpecTcl.</title>
        <para>
            Massively parallel SpecTcl uses the MPITcl package, batch SpecTcl
            and additional getters and distributor establishing commands
            to support running a massively parallel SpecTcl analysis on a cluster.
            The computing models that are supported all involve running the
            full analysis pipeline, raw data to histograms in parallel and
            collecting the resulting histograms when all workers are done.
        </para>
        <para>
            In this chapter we will:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Describe the <literal>mpispectcl</literal> package and
                    its contents.
                </para>
            </listitem>
            <listitem>
                <para>
                    Describe two methods by which SpecTcl can be run in parallel
                    using these tools.
                </para>
            </listitem>
            <listitem>
                <para>
                    Provide a sample detailed script that supports one of those models.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            Again, please refer to the reference pages in the appendix for
            full reference information.
        </para>
        <section>
            <title>The <literal>mpispectcl</literal> package</title>
            <para>
                The mpispectcl package provides an additional getter an distributor
                for SpecTcl as well as commands that allow you to set these
                up for the analyzer.
            </para>
            <para>
                The additional distributor, MPIDistributor, supports distributing
                data to a set of MPI clients using a 'pull' protocol.
                In a pull protocol, each client requests its next block of data
                from the distributor.  When no more data is available, the
                distributor, indicates that to all clients on their next
                data requests until all clients have been told there's no more
                data.  The command that sets this distributor up is
                <command>mpisink</command>
            </para>
            <para>
                The additional data getter, MPIDataGetter is a data getter that
                gets data from an MPIDistributor.  The command that sets this
                data getter up is <command>mpisink</command>
            </para>
        </section>
        <section>
            <title>Parallel models for SpecTcl</title>
            <para>
                This section will consider two parallel models for SpecTcl.
                In both models, the worker processes analyze work items
                sent by the rank 0 process and, at the end of analysis,
                are queried for their spectra.
            </para>
            <para>
                The model we will consider in the next chapter uses work units that are a
                single block of complete ring items.  In that model, the rank
                0 process has a file data getter, and an mpidistributor while all
                other processes have an mpi data getter and an analyzer distributor.
            </para>
            <para>
                Each block of data is distributed to the next requestor.  Each
                process that is not rank 0 is given the entire configuration
                file and independently histograms.  When analysis is completed,
                spectra are gathered from the non rank 0 workers and summed into the
                rank 0 process from which they can be written.
            </para>
            <para>
                This model should scale linearly until I/O limitations bottleneck
                the computation.  Note that included in the I/O limitations are
                file read performance and communication costs between the
                workers and the rank 0 process.  This process is, most often,
                suitable.  We'll call this model
                <emphasis>serial I/O parallel computation</emphasis>
            </para>
            <para>
                If the files to be analyzed are scattered across multiple
                servers, parallel I/O can be performed.  This model
                <emphasis>Parallel I/O parallel computation</emphasis> can be
                implemented without using the additional getter/distributors in
                the <literal>mpispectcl</literal> package.  It should scale up
                to the aggregate I/O bandwidth.
            </para>
            <para>
                In this second model, all non rank 0 processes are independent
                batch Spectcls with the exception that the rank 0 process
                feeds each of them a set of files to analyze.
            </para>
            <para>
                Since traffic shaping is important, each worker might be given
                a set of files that are on one server.  The files are serially
                analyzed by each non rank 0 process and, when each process is done,
                it notifies the rank 0 process which collects the spectra from
                that process summing it into the spectra it has.   When all workers
                are done, the rank 0 process can save spectra.
            </para>
            <para>
                This model has more limited application as it requires data to
                be distributed in some manner on the network.  It is possible
                and relatively simple to implement.
            </para>
        </section>
        <section>
            <title>Serial reader parallel worker example.</title>
            <para>
                In this chapter we'll work our way along a sample
                MPITcl/SpecTcl application that implements the serial reader
                parallel worker model.  The example will just read a single
                event file, but we've already described how to extend this
                to multiple files or run segments.
            </para>
            <para>
                To review, workers, non rank 0, will run an mpi data getter and
                an analysis data distributor.  Rank 0, the reader, will run
                a file getter and and mpi distributor.
            </para>
            <para>
                We'll look at the script in logical chunks.  Note that in the
                NSCL to run this, the TCL Library path must include
                the SpecTcl library path, /usr/opt/mpitcl/TclLibs and the
                directory in which your batch SpecTcl loadable package lives.
            </para>
            <example>
                <title>Package and definition loads</title>
                <programlisting>
mpi::mpi execute all {
    package require spectcl
    package require mpispectcl
    package require MyPipeline
    source defs.tcl
}

                </programlisting>
            </example>
            <para>
                All ranks must have loaded the packages and the analysis definitions
                (<filename>defs.tcl</filename>).
            </para>
            <example>
                <title>Setting up sources and distirbutors</title>
                <programlisting>
mpi::mpi execute others {
    mpisource
    analysissink
}


filesource run-0003-00.evt
mpisink
                </programlisting>
            </example>
            <para>
                The execute others ensures the non rank 0 processes have an mpi source
                and analyze that data.  Since the rank 0 process is running this
                script, the next two lines ensure that rank 0 takes data from
                file and distributes it via MPI.
            </para>
            <para>
                Note that for parallel jobs, the maximum I/O throughput is a
                function of the blocksize.  You may want to chart it for your
                application so that you can use an optimal rather than the default
                block size.
            </para>
            <example>
                <title>Analyze the file in parallel:</title>
                <programlisting>
mpi::mpi stopnotifier

mpi::mpi execute others analyze
analyze

                </programlisting>
            </example>
            <para>
                The wrinkle here is that the mpi distributor needs to have
                full control over all MPI messaging.  Therefore the notifier
                is stopped during analysis to ensure no MPI messages get queued
                to the rank 0 event loop rather than received by the mpi distributor.
                The execute and analyze commands get analysis running in the workers
                and data transmission running in rank 0.
            </para>
            <example>
                <title>Getting and saving the results.</title>
                <programlisting>
mpi::mpi startnotifier;         # Run the interpreter event pump again.

clear -all;                     # only needed if multiple runs are analyzed.

set l [spectrum -list]
set f [open spectra.dat w]

foreach spectrum $l {
    set name [lindex $spectrum 1]
    getSpectrumFromWorkers $name
    swrite -format ascii $f $name
    flush $f
}

close $f


                </programlisting>
            </example>
            <para>
                For data exchange to rank 0 we need the event notifier running.
                This code is pretty simple, For each defined spectrum,
                <literal>getSpectrumFromWorkers</literal> is called to sum
                in the data from each worker into a spectrum,  that spectrum
                is then written to file.  When all spectra have been
                received, the the file is closed.
            </para>
            <para>
                We've pushed the magic of fetching spectra off into a pair
                of procs.  One of them initiates data transfer and waits,
                the other handles incoming data.  Let's have a look at them.
            </para>
            <example>
                <title>Initiating spectrum data collection and waiting for all the workers to report.</title>
                <programlisting>
proc getSpectrumFromWorkers name {
    mpi::mpi handle [list addData $name]
    set ::expected [mpi::mpi size]
    incr ::expected -1;         # Number of workers.



    set script "mpi::mpi send 0 "
    append script "\["
    append script "scontents $name]"
    mpi::mpi execute others $script
    while {$::expected > 0} {
        vwait ::expected
    }

}

                </programlisting>
            </example>
            <para>
                This follows the pattern described in the example in
                the MPITcl chapter.  We're going to send a command to the
                workers to give us the results of scontents on a specific spectrum.
                Our data handler, <literal>addData</literal> will sum the
                data from one worker and decrement <literal>::expected</literal>
                the loop on <command>vwait </command> waits for all data before
                returning.
            </para>
            <para>
                One wrinkle needs to be pointed out.  We need the spectrum
                name substituted by our interpreter but the scontents command
                to be substituted by the target interpreters.  The only
                way I could figure out how to do that was by incrementally building
                up the script passed to the ohters.
            </para>
            <para>
                  Note also that <literal>addData</literal> is passed the spectrum
                  name by us.
            </para>
            <para>
                Let's have a look at the <literal>addData</literal> proc.
                It's called from the event loop whenever we have data from
                a worker:
            </para>
            <example>
                <title>Receiving data from a worker:</title>
                <programlisting>
proc addData {name src data} {
    foreach datum $data {
        set value [lindex $datum end]; #   This is assumed an integer.
        set coords [lrange $datum 0 end-1]
        set current [channel -get $name $coords]

        incr current $value
        channel -set $name $coords $current
    }
    incr ::expected -1;         #  one fewer workers to expect.

}

                </programlisting>
            </example>
            <para>
                This is pretty simple, the scontents data is a list of
                pairs (1d spectra) or triplets (2d spectcra). The last element
                is the channel value while the previous elements are channel
                coordinates.
            </para>
            <para>
                The value and coordinates are split out of the each element and
                the
                <command>channel -get</command> and <command>channel -set</command>
                commands are used to add the channel values to the appropriate
                channel coordinates.  Note that once all elements of the
                scontents list are processed, <literal>::expected</literal>
                is decremented which releases <literal>getSpectrumFromWorkers</literal>
                from its <literal>vwait</literal>.
            </para>
            <para>
                Finall we exit:
            </para>
            <example>
                <title>Exiting parallel SpecTcl</title>
                <programlisting>
mpi::mpi stopnotifier;     
mpi::mpi execute others exit
exit

                </programlisting>
            </example>
            <para>
                Note again that MPITcl can segfault if asked toexit while the notifier
                thread is still running. Therefore it's stopped before asking
                the non rank 0 processes to exit and exiting ourselves.
            </para>
        </section>
        
    </chapter>
    <appendix>
        <title>Reference (man) pages</title>
        <para>
            This appendix provides reference material for batch SpecTcl,
            MPITcl and MPISpecTcl
        </para>
        <section>
            <title>Batch SpecTcl</title>
            <para>
                This section provides reference pages for the commands unique
                to batch SpecTcl and the classes you might want to know
                about if you are exending batch SpecTcl.
            </para>
            <refentry>
                <refmeta>
                    <refentrytitle>analysissink</refentrytitle>
                    <manvolnum>1batchSpectcl</manvolnum>
                </refmeta>
                <refnamediv>
                    <refname>analysissink</refname>
                    <refpurpose>Establish a data distributor to the anlaysis pipeline</refpurpose>
                </refnamediv>
                <refsynopsisdiv>
                    <cmdsynopsis>
<command>analysissink</command>
                    </cmdsynopsis>
                    
                </refsynopsisdiv>
                <refsect1>
                    <title>DESCRIPTION</title>
                    <para>
                        Sets the data distributor to an analysis sink.  Regardless
                        of where the data comes from, it will be passed on to the
                        analysis pipeline for histogramming.
                    </para>
                </refsect1>
            
            </refentry>
            <refentry>
                <refmeta>
                    <refentrytitle>analyze</refentrytitle>
                    <manvolnum>1batchSpecTcl</manvolnum>
                </refmeta>
                <refnamediv>
                    <refname>analyze</refname>
                    <refpurpose>Begin analysis.</refpurpose>
                </refnamediv>
                <refsynopsisdiv>
                    <cmdsynopsis>
<command>analyze</command>
                    </cmdsynopsis>
                </refsynopsisdiv>
                <refsect1>
                    <title>DESCRIPTION</title>
                    <para>
                        Begin analysis of data from the data getter sending
                        the resulting data blocks to the data distributor.
                        It is an error to request analysis without having set
                        both a getter and a setter.
                    </para>
                    <para>
                        Behavior when this command is issued after an event
                        source has already been exhausted is not defined and
                        depends on the implementation of that source.
                    </para>
                </refsect1>
            
            </refentry>
            <refentry>
                <refmeta>
                    <refentrytitle>filesource</refentrytitle>
                    <manvolnum>1batchSpecTcl</manvolnum>
                </refmeta>
                <refnamediv>
                    <refname>filesource</refname>
                    <refpurpose>Establish a data getter from a file.</refpurpose>
                </refnamediv>
                <refsynopsisdiv>
                    <cmdsynopsis>
<command>filesource <replaceable>filename ?blocksize-in-bytes?</replaceable></command>
                    </cmdsynopsis>
                </refsynopsisdiv>
                <refsect1>
                    <title>DESCRIPTION</title>
                    <para>
                        Establishes a data getter that reads data from the file
                        <parameter>filename</parameter>  If specified the
                        <parameter>blocksize-in-bytes</parameter> specifies
                        the size of each read done from the data file.  If
                        not provided a default value is used. Note that
                        the block size must be large enough to hold at least
                        one ring item entirely.
                    </para>
                </refsect1>
            
            </refentry>
            <refentry>
                <refmeta>
                    <refentrytitle>CDataGetter</refentrytitle>
                    <manvolnum>3batchSpecTcl</manvolnum>
                </refmeta>
                <refnamediv>
                    <refname>CDataGetter</refname>
                    <refpurpose>Base class for data getters.</refpurpose>
                </refnamediv>
                <refsynopsisdiv>
                    <synopsis>
#include &lt;CDataGetter.h&gt;

class CDataGetter
{
public:
    virtual ~CDataGetter() {}               
    virtual std::pair&lt;size_t, void*&gt; read() = 0;  
    virtual void free(std::pair&lt;size_t, void*&gt;&amp; data) =0; 
};

                    </synopsis>
                </refsynopsisdiv>
                <refsect1>
                    <title>DESCRIPTION</title>
                    <para>
                        This class is documented in case you want to add additional
                        data sources to batch SpecTcl.  The <classname>CDataGetter</classname>
                        class is the base class for such objects.  Concrete
                        subclasses must implement two methods;
                        <methodname>read</methodname> and <methodname>free</methodname>.
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term>
                                <methodsynopsis>
                                    <modifier>virtual</modifier>
                                    <type>std::pair&lt;size_t, void*&gt; </type>
                                    <methodname>read</methodname>
                                    <void />
                                    <modifier></modifier>
                                </methodsynopsis>
                            </term>
                            <listitem>
                                <para>
                                    This is expected to read another chunk of data
                                    from the data source.  The return value is
                                    a pair that provides the amount of data
                                    read (in bytes) and a pointer to that data.
                                    The data may be dynamically or statically
                                    allocated.  The current version of the
                                    SpecTcl Batch analyzer will only have one
                                    block of data <firstterm>active</firstterm> at
                                    a time, that is <methodname>free</methodname>
                                    will be called prior to the next invocation
                                    of <methodname>read</methodname>
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <methodsynopsis>
                                    <modifier>virtual </modifier>
                                    <type>void </type>
                                    <methodname>free</methodname>
                                    <methodparam>
                                        <type>std::pair&lt;size_t, void*&gt;&amp; </type>
                                        <parameter>data</parameter>
                                    </methodparam>
                                    <modifier></modifier>
                                </methodsynopsis>
                            </term>
                            <listitem>
                                <para>
                                    Called when the analyzer is done with a block
                                    of data.  If the data was dynamically allocated,
                                    this method should free it.  The
                                    parameter is a reference to the result of
                                    the most recent call to <methodname>read</methodname>.
                                    Only one block of data will be in analysis
                                    in this SpecTcl at a time.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </refsect1>
                
            </refentry>
            <refentry>
                <refmeta>
                    <refentrytitle>CDataDistributor</refentrytitle>
                    <manvolnum>3batchSpecTcl</manvolnum>
                </refmeta>
                <refnamediv>
                    <refname>CDataDistributor</refname>
                    <refpurpose>Data Distribution base class.</refpurpose>
                </refnamediv>
                <refsynopsisdiv>
                    <synopsis>
#include &lt;CDataDistributor&gt;
class CDataDistributor
{
public:
    virtual ~CDataDistributor() {}
    virtual void handleData(std::pair&lt;size_t, void*&gt;&amp; info) = 0;
};


                    </synopsis>
                </refsynopsisdiv>
                <refsect1>
                    <title>DESCRIPTION</title>
                    <para>
                        This  class is documented in case you want to
                        write additional methods to dispose of data that has
                        been gotten from a batch SpecTcl data source.
                        Concrete subclasses must implement a single method;
                        <methodname>handleData</methodname> which takes, as a
                        parameter, a pair gotten from the data getter's
                        <methodname>read</methodname> method.  This pair contains
                        the size and pointer to the block of data to handle.
                        When this method returns, there must be no further need
                        to reference that storage (it can be freed if desired).
                    </para>
                </refsect1>
            
            </refentry>
        </section>
        
    </appendix>
</book>

