<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                      "file:///usr/share/xml/docbook/schema/dtd/4.5/docbookx.dtd
"
>
<book>
    <bookinfo>
      <title>SpecTcl CAEN-DPP analysis</title>
      <author><firstname>Ron</firstname><surname>Fox</surname></author>
      <revhistory>
          <revision>
             <revnumber>1.0</revnumber>
             <date>December 26, 2019</date>
             <authorinitials>RF</authorinitials>
             <revremark>Original Release</revremark>
          </revision>
      </revhistory>
    </bookinfo>
    <chapter>
        <title>Introduction</title>
        <para>
            In collaboration with Lousiana State University, CAEN has developed
            support for the CAEN xx725 and CAEN xx730 digitizers running digital
            pulse processing (DPP) firmware for Pulse Height Analysis (PHA) and
            Pulse Shape Discrimination (PSD).  This document describes developments
            within NSCLSpecTcl that provide support to unpack data from these
            digitizers with minimal programming onthe part of the user.
            The features documented in this manual are first deployed in SpecTcl
            version 5.4-000
        </para>
        <para>
            This document is organized in the following chapters:
        </para>
        <itemizedlist>
            <listitem>
               <para>
                  <link linkend='ch.background' endterm='ch.background.title' />
                    provides background information needed to understand the
                    remainder
                    of the document. 
               </para>
            </listitem>
            <listitem>
               <para>
                  <link linkend='ch.description' endterm='ch.description.title' /> 
               </para>
            </listitem>
            <listitem>
               <para>
                  <link linkend='app.reference' endterm='app.reference.title'/>
                  Provides manpage style reference information for the classes
                  that implement the software in a top-down order.
               </para>
            </listitem>
        </itemizedlist>
    </chapter>
    <chapter id='ch.background'>
        <title id='ch.background.title'>Background information</title>
        <para>
            CAEN DPP Digitizers emit a series of hits.  The hits from each
            digitizer are time ordered.  Due to buffering, however, the hits
            from a crate full of digitizers cannot be readout and emitted in time
            order.  
        </para>
        <para>
            The NSCL event builder can then weave together hits across modules and
            build events made up of hits that live within a coincidence window.
            The event builder determines the outermost packaging of events
            and, therefore must be used, even if only a single channel is used,
            in order to create events that are compatible with the unpacking
            software described in this manual.
        </para>
        <para>
            The hit formats used in the Readout Support for CAEN DPP digitizers,
            don't tag the hit type (DPP-PSD or DPP-PHA) it is, therefore,
            the responsibility of the programmer tailoring the unpacking of
            data from CAEN-DPP digitizers to know the  DPP firmware
            loaded into each digitizer and their source ids.
        </para>
    </chapter>
    <chapter id='ch.description'>
        <title id='ch.description.title'>Description of the software</title>
        <para>
            This chapter will provide a tutorial introduction to the use of
            the software provided in SpecTcl to unpack DPP-PSD and DPP-PHA
            digitizers.  It's important to note that we only support
            CAEN xx730   (500MHz) and CAEN xx725 (250MHz) digitizers.
            Full reference material describing the classes discussed in this
            chapter are available in
            <link linkend='app.reference' endterm='app.reference.title' />.
        </para>
        <para>
            This chapter assumes that you are familiar with:
        </para>
        <itemizedlist>
            <listitem>
               <para>
                  SpecTcl concepts, specifically event processors and the event
                  processing pipeline.
               </para>
            </listitem>
            <listitem>
               <para>
                  C++ Programming concepts.   That  you understand classes and
                  objects, how to derive new classes from old classes and
                  how to instantiate objects that are instances of classes.
               </para>
            </listitem>
        </itemizedlist>
        <para>
            This chapter will run through two examples that show how to
            decode data from a hypothetical setup with three digitizers;
        </para>
        <itemizedlist>
            <listitem>
               <para>
                  A DPP-PHA XX730 (500MHz) digitizer with source id 1.
               </para>
            </listitem>
            <listitem>
               <para>
                  A DPP-PSD XX730 (500MHz) digitizer with source id 2.  In order
                  to apply the CFD fine time correction to the digitizer
                  timestamp, it is necessary to know the digitizer frequency.
                  It is also important to know the values of bits 10 and 11
                  of the digitizer's CFD settings register as these affect
                  the time interval over which the CFD interpolates a fine time.
                  In this case, we will assumem that the value of both of these
                  bits is 0 (interpolate between adjacent samples).  See the
                  reference information for the CAENParameterMap classes
                  for a description of what to do if you have non-zero values
                  for these bits.
               </para>
            </listitem>
            <listitem>
               <para>
                  A DPP-PSD XX725 (250MHz) digitizer with source id 3.  We'll
                  assume again that bits 10 and 11 of the CFD settings register
                  are both zero.
               </para>
            </listitem>
        </itemizedlist>
        <para>
            The process of writing code to unpack CAEN Digitizer data is as
            follows:
        </para>
        <itemizedlist>
            <listitem>
               <para>
                  Assign parameter names  to each channel of each digitizer.
               </para>
            </listitem>
            <listitem>
               <para>
                  Define a class derived from <classname>CAENEventProcessor</classname>.
               </para>
            </listitem>
            <listitem>
               <para>
                  In your event processor's constructor register parameter mapping
                  object for each digitizer.
               </para>
            </listitem>
            <listitem>
               <para>
                  Instantiate your event processor in  your
                  <filename>MySpecTclApp.cpp</filename> file and
                  add it to the event processing pipeline in your implementation
                  of its <methodname>CreateAnalysisPipeline</methodname>
                  method.
               </para>
            </listitem>
        </itemizedlist>
        <para>
            In the remainder of this chapter we'll go through these operations
            step by step.  We'll show how to assign uniform parameter names
            (a tree parameter array) to a digitizer as well as how to
            define a map that isn't uniform (where you need to define the
            parameter names for each parameter from each channel you care about).
        </para>
        <para>
            Before thinking about how to assign parameter names to module channels,
            it's important to know the set of parameters we can decode from
            each module.  The set of parameters differs from
            DPP-PHA and DPP-PSD.
        </para>
        <variablelist>
            <title>Parameters produced by DPP-PHA channels</title>
            <varlistentry>
               <term>Time Tag</term>
               <listitem>
                   <para>
                    This is the raw trigger time for the hit.  The PHA module
                    is not capable of running a CFD trigger and therefore does not
                    have a fine time correction.  This time will be converted
                    by the readout program to nanoseconds
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>Energy</term>
               <listitem>
                   <para>
                    The pulse height from the digital pulse processing
                    algorithm.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>Extras 1</term>
               <listitem>
                   <para>
                    If programmed to produce an extras1, this will contain
                    its' value
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>Extras 2</term>
               <listitem>
                   <para>
                    If programmed to produce two extras, this will contain
                    the value of extras2.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>Fine time</term>
               <listitem>
                   <para>
                    If the extras2 word has been programmed to contain the
                    RC-CR2 time interpolation, a fine time stamp with resolution
                    much higher than the digitization frequency can be computed
                    and stored.
                   </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <variablelist>
            <title>Parameters produced by DPP-PSD channels</title>
            <varlistentry>
               <term>Short Gate charge</term>
               <listitem>
                   <para>
                    The baseline subtracted integration of the part of the pulse
                    in the short gate.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>Long Gate charge</term>
               <listitem>
                   <para>
                    The baseline subtracted integration of the part of the pulse
                    in the long gate.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>baseline</term>
               <listitem>
                   <para>
                    The computation of the pulse baseline
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>Trigger time</term>
               <listitem>
                   <para>
                    The trigger coarse time, with the CFD interpolated fine time
                    folded into it, in nanoseconds.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>Pile up flag</term>
               <listitem>
                   <para>
                    This is given the value 20 if there is a pile up and 40 if
                    there was not one.  This allows you to histogram the parameter
                    giving two separated narrow peaks on which gates can be
                    set (e.g. to only increment a histoigram with no pileup).
                   </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            The sections that follow will include code fragments from the
            complete example that is installed in
            <filename>$SpecTclHome/share/examples/caendpp</filename>.  Note
            that to get that example to compile, you'll need to adjust the
            definition of <literal>INSTDIR</literal> in the Makefile.
        </para>
        <section>
            <title>Assigning parameters</title>
            <para>
                There are four classes that allow us to assign parameters to
                channels from a module (source id).  
                These are:
            </para>
            <variablelist>
                <varlistentry>
                   <term><classname>CAENPHArrayMapper</classname></term>
                   <listitem>
                       <para>
                        Allows you to provide the basename of a tree parameter
                        array for each parameter type in a PHA module.
                        There will be an array with
                        elements numbered 0 through 15 for the channels.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><classname>CAENPHAParameterMapper</classname></term>
                   <listitem>
                       <para>
                        Allows you to provide a vector of individual names
                        for each parameter for each channel of a PHA module.
                        This also supports
                        omitting decoding parameters from unused channels.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><classname>CAENPSDArryaMapper</classname></term>
                   <listitem>
                       <para>
                        Allows you to provide the basename of a tree parameter
                        array for each parameter type in a PSD module.
                        There will be an array with elements numbered
                        0-15 for the channels.  You can also control how, or if
                        the CFD fine time is added into the coarse time.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><classname>CAENPSDParameterMapper</classname></term>
                   <listitem>
                       <para>
                        Allows you to provide a vector of indivudal names for
                        each parameter for each channel of a PSD module.
                        This supports omitting the decode of unused channels and
                        describing how to combine any CFD fine time with the
                        coarse time tag.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                These are all derived from
                the common base class <classname>CAENParameterMap</classname>.
                The interface of this class provides a virtual method;
                <methodname>assignParameters</methodname> which takes hits
                from the module it is responsible for and assigns values to
                SpecTcl tree parameters as defined by the specific
                subclasses above.
            </para>
            <para>
                With this in mind let's assign parameters to each of our three
                hypothetical modules.  We'll assign uniform array basenames to
                source ids 1 and 2 (DPP-PHA and 500MHz DPP-PSD modules).  We'll
                define individual parameters for the first few even channels of
                source id 3 (the 250MHz DPP-PSD module).
            </para>
            <para>
                The base names we'll use for the DPP-PHA will be:
            </para>
            <variablelist>
                <title>DPP-PHA basenames (for source id 1)</title>
                <varlistentry>
                   <term>pha.time</term>
                   <listitem>
                       <para>
                         For the trigger time tags.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>pha.energy</term>
                   <listitem>
                       <para>
                        For the energy
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>extras 1</term>
                   <listitem>
                       <para>
                        We're going to ignore this word.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>pha.extras2</term>
                   <listitem>
                       <para>
                        The raw extras 2 word. Note that we're going to assume
                        that this has been programmed to contain the
                        RC-CR2 interpolated time in its lower 16 bits.
                        The parameter, by itself is pretty useless, to
                        get the top 16 bits you'll need to create a second
                        event processor to pull those bits out and assign
                        them to some other set of parameters.
                        This technique will be demontrated in
                        <link linkend='sec.computing' endterm='sec.computing.title' />
                        below.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>pha.finetime</term>
                   <listitem>
                       <para>
                        Will contain the high resolution time computed from
                        the time tag (pha.time) and bottom 16 bits of the
                        extras2 word.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                For the 500MHz DPP-PSD module (source id 2 we'll use the
                following parameter basenames)/
            </para>
            <variablelist>
                <title>DPP-PHA 500MHz basenames (source id 2)</title>
                <varlistentry>
                   <term>psd1.shortQ</term>
                   <listitem>
                       <para>
                        Charge integration of the short gate.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>psd1.longQ</term>
                   <listitem>
                       <para>
                        Charge integration of the long gate.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>psd1.baseline</term>
                   <listitem>
                       <para>
                        Baseline computation.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>psd1.time</term>
                   <listitem>
                       <para>
                        Full time (trigger tag with CFD interpolation)
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>psd.pileup</term>
                   <listitem>
                       <para>
                        Pileup flag.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                For source id 3, the 250MHz DPP-PSD module, let's assume that
                channel 0 and 2 are a start and stop detector package for time of
                flight (yes I know I should have put those in the 500MHz digitizer
                but this is just a programming example). Let's further assume that
                rather than needing to do pulse shape discrimnation, we've just
                set the long gate to give us a current integrated energy.l
                Let's assume that
                all other channels are unused and don't need to have parameters
                assigned to them. We'll assign parameters as follows:
            </para>
            <variablelist>
                <title>DPP-PSD 250MHz  module (source id 3)</title>
                <varlistentry>
                   <term>start.time</term>
                   <listitem>
                       <para>
                        Channel 0 time (start time.)
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>start.E</term>
                   <listitem>
                       <para>
                        Channel 0 long gate charge integration.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>start.baseline</term>
                   <listitem>
                       <para>
                        channel 0 baseline computation.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>start.pileup</term>
                   <listitem>
                       <para>
                        channel 0  pileup flag.
                       </para>
                    </listitem>
                </varlistentry>
                
                <varlistentry>
                   <term>stop.time</term>
                   <listitem>
                       <para>
                        Channel 2 time (stop time)
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>stop.E</term>
                   <listitem>
                       <para>
                        Channel 2 long gate charge integration.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>stop.baseline</term>
                   <listitem>
                       <para>
                        Channel 2 baseline computation.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>stop.pileup</term>
                   <listitem>
                       <para>
                        Channel 2 pileup flag.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </section>
        <section>
            <title>Define our event processor class</title>
            <para>
                The <classname>CAENEventProcessor</classname> class provides
                a base class for analyzing event built data that includes
                data from CAENDPP digitizers.  By itself, it can't do anything
                useful.  It expects you to derive a new class from it and
                provide that class with set of parameter maps that describe
                the parameters assigned to the channels of each digitizer.
            </para>
            <para>
                The definition of this class is shown below:
            </para>
            <example>
                <title>DPPEventProcessor.h</title>
                <programlisting>
#ifndef DPPEVENTPROCESSOR_H
#define DPPEVENTPROCESSOR_H                 <co id='dppheader.guard' />

#include &lt;CAENEventProcessor.h&gt;       <co id='dppheader.basedef' />

class MyDPPEventProcessor : public CAENEventProcessor  <co id='dppheader.derive' />
{
public:
  MyDPPEventProcessor();                    <co id='dppheader.constructor' />
};

#endif
                   
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='dppheader.guard' >
                    <para>
                        This construct and the #endif at the bottom of the
                        file should be used in all header files.  It allows the
                        header to be included more than once (which can happen
                        inadvertently) without triggering compiler complaints
                        about multiple definitions.   Therefore it is known
                        as an <firstterm>include gauard</firstterm>
                    </para>
                    <para>
                        In order to prevent collision with preprocessor names
                        used to guard other headers, by convention the
                        preprocessor name checked and defined is usually
                        derived from the header file name; in this case
                        <filename>DPPEventProcessor.h</filename>.
                    </para>
                </callout>
                <callout arearefs='dppheader.basedef' >
                    <para>
                        Defines a  new class
                        <classname>MyDPPEventProcessor</classname>
                        derived from the base class
                        <classname>CAENEventProcessor</classname>.  This
                        allows us to specify the set of parameter maps the
                        base class will use when assigning parameters from
                        event fragments.
                    </para>
                </callout>
                <callout arearefs='dppheader.constructor' >
                    <para>
                        We need to implement a constructor.  It is in the
                        constructor that we'll create parameter maps and
                        hand them to the base class for its use.
                        This is the only job we really have to get raw
                        parameters decoded.
                    </para>
                </callout>
            </calloutlist>
        </section>
        <section>
            <title>Registering Marameter Mappings</title>
            <para>
                In this section we'll, present code that describes the
                parameter mappings we developed and informs the
                <classname>CAENEventProcessor</classname> base class
                of <classname>MyDPPEventProcessor</classname> of them.
                This is done by createing a parameter mapping object
                for each module and passing it to the
                <classname>CAAENEventProcessor::</classname><methodname>addParameterMap</methodname>
                method. 
            </para>
            <para>
                Here's the code to do that.
            </para>
            <example>
                <title>DPPEventProcessor.cpp</title>
                <programlisting>
#include "DPPEventProcessor.h"      <co id='dppimp.include' />
#include &lt;CAENParameterMap.h&gt; <co id='dppimp.mapperinc' />
#include &lt;vector&gt;             <co id='dppimp.mapperaddinc' />
#include &lt;string&gt;

MyDPPEventProcessor::MyDPPEventProcessor()   <co id='dppimp.constructor' />
{
  addParameterMap(1, new CAENPHAArrayMapper(  <co id='dppimp.src1' />
     "pha.time", "pha.energy", nullptr, "pha.extra2", "pha.finetime
  ), 2);
  addParameterMap(2, new CAENPSDArrayMapper(   <co id='dppimp.src2' />
     "psd1.time" ,"psd1.shortQ", "psd1.longQ", "psd1.baseline", "psd1.pileup"),
     2
  );
  std::vector&lt;std::string&gt; src3times={"start.time", "", "stop.time"}; <co id='dppimp.src3params' />
  std::vector&lt;std::string&gt; src3charge={"start.E", "", "stop.E"};
  std::vector&lt;std::string&gt; src3bl={"start.baseline", "", "stop.baseline"};
  std::vector&lt;std::string&gt; src3pup={"start.pileup","", "stop.pileup"};
  std::vector&lt;std::string&gt; src3unused;
  addParameterMap(3, new CAENPSDParameterMapper(    <co id='dppimp.src3' />
      src3charge, src3unused, src3bl, src3times, src3pup),
      4
  );
}
                   
                </programlisting>
            </example>
            <para>
                Lets' look at this constructor implementation step by step so
                we can understand what's going on and, in the process gain some
                understanding of both the
                <classname>CAENEventProcessor</classname> class and the parameter
                mapper classes.
            </para>
            <calloutlist>
                <callout arearefs='dppimp.include' >
                    <para>
                        As usual we need to include the class definition
                        in order to implement it.
                    </para>
                </callout>
                <callout arearefs='dppimp.mapperinc' >
                    <para>
                        Including this header brings in the definitions
                        for four parameter mapping classes so we can
                        make instances of them to register with the
                        <classname>CAENEventProcessor</classname> base
                        class.
                    </para>
                </callout>
                <callout arearefs='dppimp.mapperaddinc' >
                    <para>
                        These headers include class definitions we'll need
                        when creating the channel by channel parameter name
                        definitions needed by
                        <classname>CAENPSDParameterMapper</classname>.
                    </para>
                </callout>
                <callout arearefs='dppimp.constructor' >
                    <para>
                        Begins the implementation of our event processor's
                        constructor.  This is where we're going to add
                        parameter definitions to the base class.  Note that
                        our case is simple enough we can do everything in line
                        and the constructor is understandable.  For larger
                        systems it may be wise to break the implementation
                        down into method calls where each method
                        defines the parameter mapping for some part of the
                        system. 
                    </para>
                </callout>
                <callout arearefs='dppimp.src1' >
                    <para>
                        This creates and registers the parameter mapper
                        for source id 1.  It does this using a call to the
                        base class's
                        <methodname>addParameterMap</methodname> method.
                        This method takes two mandatory parameters and one
                        optional parameter.
                    </para>
                    <para>
                        The first parameter is the source id for which the
                        map is being registered.  If a fragment from a data source
                        without a map is encountered in an event, it will be
                        ignored by the event processor.  This allows you to mix
                        CAEN digitizers with other modules (as long as the timestamps
                        are synchronized an in nanoseconds).
                    </para>
                    <para>
                        The second parameter is a pointer to a
                        <classname>CAENParameterMap</classname>. Remember this
                        is the base class for all of the parameter map classes.
                        The <methodname>addParameterMap</methodname> method
                        expects this to be a dynamically created object.
                        Normally, event processors live for the life time
                        of the program, however if you have an application that
                        dynamically creates/destroys event processors (e.g. to
                        make use of the dynamic pipeline manager), this is important
                        as when a <classname>CAENEventProcessor</classname>
                        is destroyed, it will <literal>delete</literal>
                        all registered parameter mapper objects.
                    </para>
                    <para>
                        The mapper we register is a <classname>CAENPHAArrayMapper</classname>.
                        As you can see it is dynamically created. Its parameters
                        are, in order, the time tag, energy, extras1 and extras2
                        parameter base names.   16 element tree parameter
                        arrays are created for each of these.
                    </para>
                    <para>
                        Note that we pass a <literal>nullptr</literal> as
                        the basename for the extras1 parameter.  If you pass
                        a null pointer for a parameter basename, the
                        array parameter mappers will simply not assign those
                        parts of a hit to SpecTcl parameters.
                    </para>
                    <para>
                        The last parameter is the range, in nanoseconds over
                        which the fine time is interpolated.  For our
                        500MHz digitizer, this is 2s/sample.  For DPP-PHA
                        digitizers, since the interpolation is always
                        between adjacent samples, this should always be the
                        sample timing.
                    </para>
                </callout>
                <callout arearefs='dppimp.src2' >
                    <para>
                        Registers the parameter map for source id 2, our
                        500MHz DPP-PSD module.  This should be readily
                        undertansdable from the discussion of the registration
                        for source id 1 above.
                    </para>
                    <para>
                        Note that for PSD parameter maps, if the CFD time is
                        included in the extras word, the final parameter (which defaults to 0)
                        is the number of nanoseconds across which the CFD
                        time interpolation is performed.  Normally, this is
                        just the number of nanoseconds per sample.  However
                        CFD parameters can be set to interpolate between multiple samples
                        as well, in which case, again, that affects this parameter
                        (I think).
                    </para>
                    <para>
                        If the CFD is not selected, then you can omit this parameter.
                        Since the default is zero, and in part of the computation
                        of the fine time the extras word bit field
                        that normally contains the CFD fine time is multiplied
                        by this value this will result in no CFD fine time interpolation.
                    </para>
                </callout>
                <callout arearefs='dppimp.src3params' >
                    <para>
                        In this section, we prepare vectors that contain
                        parameter names that will be passed to the
                        <classname>CAENPSDParameterMapper</classname> constructor.
                        The principle is the same for
                        <classname>CAENPHAParameterMapper</classname>.  Each
                        parameter must have a vector of parameter name strings.
                        If the vector is fewer than 16 elements long, the remaining
                        channels are ignored.  If a parameter name is an
                        empty string, that channel is ignored.  This is
                        why there are empty
                        strings for channel 1, and an empty array (which will
                        be used for the short gate charge integration).
                    </para>
                </callout>
                <callout arearefs='dppimp.src3' >
                    <para>
                        This adds the parameter map for source 3, our
                        250MHz DPP-PSD digitizer.  Note that we've specified
                        the interpolation time of the CFD to be 4ns.
                    </para>
                </callout>
            </calloutlist>
            <para>
                As you can see setting up the parameter mappings is an easy, although for
                larger setups potentially tedious task.  Once those mappings are
                set up, however, the base class event processing code takes care
                of everything else to get us raw parameters.  Note that to do
                a real Time of flight we'll need to get differences between the
                start and stop detector times.  We'll show how to do this in
                the section
                <link linkend='sec.computing' endterm='sec.computing.title' />.
            </para>
        </section>
        <section>
            <title>Adding the event processor to the pipeline and build</title>
            <para>
                We have a class definition and we have a class implementation.
                What we need to tie all this into SpecTcl is to create an instance
                of our event processor class and put it into the SpecTcl
                event processing pipeline.  We also need to build our class into
                our tailored version of SpecTcl.
            </para>
            <para>
                Assuming you've pulled down a Skeleton for SpecTcl in the same
                directory as your event processor class; We need to edit
                the skeleton application (<filename>MySpecTclApp.cpp</filename>)
                as follows:
            </para>
            <example>
                <title>Changes to <filename>MySpecTclApp.cpp</filename></title>
                <programlisting>
#include &lt;config.h&gt;
#include "MySpecTclApp.h"
#include "EventProcessor.h"
#include "TCLAnalyzer.h"
#include &lt;Event.h&gt;
#include &lt;TreeParameter.h&gt;
#include "DPPEventProcessor.h"                <co id='skel.addheader' />
                    ...
void
CMySpecTclApp::CreateAnalysisPipeline(CAnalyzer&amp; rAnalyzer)
{
  RegisterEventProcessor(*(new MyDPPEventProcessor), "CAEN_DPP"); <co id='skel.register' />


}
                    
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='skel.addheader' >
                    <para>
                        We must make our skeleton source aware of the class
                        definition for our event processor.
                    </para>
                </callout>
                <callout arearefs='skel.addheader' >
                    <para>
                        This line instantiates a new instance of our
                        event processing class and registers it in the
                        event processing pipeline as an event processor
                        named <literal>CAEN_DPP</literal>.  
                    </para>
                </callout>
            </calloutlist>
            <para>
                Finally we need to edit the skeleton's <filename>Makefile</filename>.
                The support libraries have been incorporated into the SpecTcl
                core library so all that's really needed is to ensure that
                our event processor class implementation is built into
                our tailored SpecTcl.  This is done by adding the
                <filename>DPPEventProcessor.o</filename> to the definition
                of the <literal>OBJECTS</literal> macro in the
                Makefile.
            </para>
            <example>
                <title>Changes to the SpecTcl Makefile</title>
                <programlisting>
                    ...
OBJECTS=MySpecTclApp.o DPPEventProcessor.o
                    ...
                </programlisting>
            </example>
        </section>
        <section id='sec.computing'>
            <title id='sec.computing.title'>But I need to compute time differences!!!</title>
            <para>
                The example we worked through in the previous sections
                of this chapter got us raw parameter unpacking.  However,
                we've got a pair of raw parameters; <literal>start.time</literal>
                and <literal>stop.time</literal> that represent the start and
                stop times of a time of flight measurement.  This
                section shows how to compute the time of flight parameter
                which we'll call <literal>TOF</literal>.
            </para>
            <para>
                In this section, we are going to make use of two SpecTcl
                features, one of which is well known and one not so well
                known/understood:
            </para>
            <itemizedlist>
                <listitem>
                   <para>
                      SpecTcl supports a logical pipline of event processors.
                      Each event processor has access not only to the raw event,
                      but to the parameters that have been produced by prior
                      stages of the pipeline.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      If you create two tree parameter objects that have the
                      same name, they wil map to the same underlying SpecTcl
                      parameter.  Since the <classname>CAENEventProcessor</classname>
                      creates tree parameters, this allows us to easily access
                      the start and stop times it creates.
                   </para>
                </listitem>
            </itemizedlist>
            <para>
                Here are the steps we must take:
            </para>
            <itemizedlist>
                <listitem>
                   <para>
                      Create a new event processor definition that has
                      start and stop time tree parameter member variables,
                      as well as a TOF tree parameter member for the results
                      of our computation.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Implement the constructor of this event processor to
                      initialize the tree parameter members to have the same
                      names (<literal>start.time</literal> and <literal>stop.tim</literal>)
                      as the parameter names we assigned in the event
                      processor that produces raw parameters.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Implement the function call operator; <methodname>operator()</methodname>
                      to perform the time difference for events where both the
                      start and stop times have been assigned values.
                   </para>
                </listitem>
            </itemizedlist>
            <para>
                Note that the techniques described in this section can be
                expanded to perform an wide variety of computations on
                extracted parameters, for example the parameter in the top
                16 bits of the extras2 word could be extracted into a new
                parameter or calibrated energies could be computed and so on.
            </para>
            <section>
                <title>
                    Defining an event processor class to compute TOF
                </title>
                <para>
                    Here's the class definition for our TOF event processor:
                </para>
                <example>
                    <title>TOF Event processor definition; <filename>TOFEventProcessor.h</filename></title>
                    <programlisting>
#ifndef TOFEVENTPROCESSOR_H
#define TOFEVENTPROCESSOR_H
#include &lt;EventProcessor.h&gt;      <co id='tofdef.evpinc' />
#include &lt;TreeParameter.h&gt;       <co id='tofdef.tpinc'  />

class TOFEventProcessor :  public CEventProcessor   <co id='tof.classdef' />
{
private:
  CTreeParameter m_start;              
  CTreeParameter m_stop;               <co id='tofdef.members' />
  CTreeParameter m_tof;
public:
  TOFEventProcessor();                 <co id='tofdef.constructor' />
  Bool_t operator()(                   <co id='tofdef.fcall' />
    Address_t pEvent, CEvent&amp; rEvent, CAnalyzer&amp; a, CBufferDecoder&amp; d
  );

};


#endif

                    </programlisting>
                </example>
                <calloutlist>
                    <callout arearefs='tofdef.evpinc' >
                        <para>
                            We're writing an event processor.  This means
                            deriving a class from <classname>CEventProcessor</classname>.
                            Doing that requires including
                            <filename>EventProcessor.h</filename> that
                            defines this base class and its interfaces.
                        </para>
                    </callout>
                    <callout arearefs='tofdef.tpinc' >
                        <para>
                            Our event processor will include member data
                            that are <classname>CTreeParameter</classname>
                            objects.  The <filename>TreeParameter.h</filename>
                            header defines the tree parameter, tree parameter array,
                            tree variable and tree variable array classes.
                        </para>
                    </callout>
                    <callout arearefs='tof.classdef' >
                        <para>
                            This line starts  our class definition. Our event
                            processor class is named <classname>TOFEventProcessor</classname>
                            and, as all event processors must, derives from
                            the <classname>CEventProcessor</classname>
                            base class.
                        </para>
                    </callout>
                    <callout arearefs='tofdef.constructor' >
                        <para>
                            We need to implement a constructor to construct the
                            <classname>CTreeParameter</classname> member data
                            of our class with the correct parameter names.
                        </para>
                    </callout>
                    <callout arearefs='tofdef.fcall' >
                        <para>
                            The event processor's function call operator
                            (<methodname>operator()</methodname>) is called for each
                            event.  We must implement this to compute
                            event by event time differences into
                            <varname>m_tof</varname>
                        </para>
                    </callout>
                </calloutlist>
            </section>
            <section>
                <title>Implementing <classname>TOFEventProcessor</classname>
                (<filename>TOFEventProcessor.cpp</filename></title>
                <example>
                    <title>TOFEventProcessor.cpp</title>
                    <programlisting>
#include "TOFEventProcessor.h" 


TOFEventProcessor::TOFEventProcessor() :
  m_start("start.time",  "ns"),
  m_stop("stop.time", "ns"),            <co id='tofimp.init' />
  m_tof("TOF",  "ns")
{}

Bool_t
TOFEventProcessor::operator()(
     Address_t pEvent, CEvent&amp; rEvent, CAnalyzer&amp; a, CBufferDecoder&amp; d
)
{
  if (m_start.isValid() &amp;&amp; m_stop.isValid()) {  <co id='tofimp.valid' />
    m_tof = m_stop - m_start;                           <co id='tofimp.tof' />
  }
  return kfTRUE;                                        <co id='tofimp.retval' />
}

                    </programlisting>

                </example>
                <calloutlist>
                    <callout arearefs='tofimp.init' >
                        <para>
                            These three lines initialize the tree parameter
                            member variables.  THe first two have the same
                            names as the time parameters in the time of flight
                            start and stop digitizer channels.  The third
                            represents a new parameter that we will fill in
                            from our TOF computation.
                        </para>
                    </callout>
                    <callout arearefs='tofimp.valid' >
                        <para>
                            Assigning a value to a tree parameter makes that
                            parameter valid.  This condition protects against
                            computing time differences if one or both of the
                            start/stop times were not in the event.  Whenever you
                            perform computations that depend on SpecTcl parameters,
                            you should ensure the dependent parameters are valid.
                        </para>
                        <para>
                            If a SpecTcl parameter value is fetched prior to being
                            assigned, it will raise an exception and that will
                            abort the processing of that event.
                        </para>
                    </callout>
                    <callout arearefs='tofimp.tof' >
                        <para>
                            Among other things, tree parameter objects can be
                            treated as if they were <literal>double</literal>
                            variables in the sense that you can compute with them
                            and assign them values.  This line computes
                            the TOF and assigns it to the time of flight parameter.
                        </para>
                    </callout>
                    <callout arearefs='tofimp.retval' >
                        <para>
                            Event processing pipeline elements must return a value.
                            The value <literal>kfTRUE</literal> indicates that
                            SpecTcl should continue processing this event.  If
                            an event processing method returns <literal>kfFALSE</literal>,
                            any subsequent elements of the pipeline are not run
                            and the event is not histogrammed.
                        </para>
                        <para>
                            A common error is not to include this return value.
                            This results in random events being discarded.
                        </para>
                    </callout>
                </calloutlist>
            </section>
            <section>
                <title>Adding the TOF computation to our SpecTcl</title>
                <para>
                    We need to make a couple of additions to
                    <filename>MySpecTclApp.cpp</filename> that, if you
                    followed the previous sections, should be familiar:
                </para>
                <example>
                    <title>TOF modifications to <filename>MySpecTclApp.cpp</filename></title>
                    <programlisting>
    ...
#include "DPPEventProcessor.h"
#include "TOFEventProcessor.h"                  // Added line
    ...

void
CMySpecTclApp::CreateAnalysisPipeline(CAnalyzer&amp; rAnalyzer)
{
  RegisterEventProcessor(*(new MyDPPEventProcessor), "CAEN_DPP");
  RegisterEventProcessor(*(new TOFEventProcessor), "TOF_COMPUTATION"); //added line

}
    
                    </programlisting>
                </example>
                <para>
                    Similarly we need to add TOFEventProcessor.o to the
                    <literal>OBJECTS</literal> definition in Makefile:
                </para>
                <example>
                    <title>Adding TOFEventProcessor to the SpecTcl Build</title>
                    <programlisting>
OBJECTS=MySpecTclApp.o DPPEventProcessor.o TOFEventProcessor.o
                    </programlisting>
                </example>
            </section>
        </section>
    </chapter>
    <appendix id='app.reference'>
        <title id='app.reference.title'>Reference pages</title>
        <para>
            This appendix provides reference material for the classes
            that support the CAEN DPP unpacking subsystem.  Rather than
            providing these pages in alphabetical order, they will be provided
            in the order you are likely to need them (if at all).  It's very
            possible that you will not need to use most of theses man pages,
            however they are provided for completeness.
        </para>
        <refentry>
           <refmeta>
              <refentrytitle>CAENEventProcessor</refentrytitle>
              <manvolnum>3caendpp</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CAENEventProcessor</refname>
              <refpurpose>Process event built data containing CAEN DPP hits.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CAENEventProcessor.h&gt;
class CAENEventProcessor : public CEventProcessor
{
public:
    CAENEventProcessor();
    virtual ~CAENEventProcessor();

    virtual Bool_t operator()(
        const Address_t pEvent,
        CEvent&amp; rEvent,
        CAnalyzer&amp; rAnalyzer,
        CBufferDecoder&amp; rDecoder
    );

protected:
    void addParameterMap(int sid, CAENParameterMap* map, int mult=1);
};

                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    This class is a base class for event processors that
                    can decode event built data that includes hits from
                    CAEN-DPP digitizers.  This class must be subclassed
                    and the constructor for the subclass defines the
                    destination parameters for each channel of each module
                    by instantiating <classname>CAENParameterMap</classname>
                    subclasses and making them known to the object by
                    invoking
                    <methodname>addParameterMap</methodname> to
                    make a correspondence between the map instance and
                    a module's source id.
                  </para>
                  <para>
                    Note that <methodname>addParameterMap</methodname>
                    includes an optional <parameter>mult</parameter> parameter.
                    This parameter must be supplied for DPP-PSD digitizers.
                    It controls how the CFD bits in the extras word are folded
                    into the time parameter.  
                  </para>
                  <para>
                    Similarly, if you want a sensible
                    fine time out of the DPP-PHA digitizer via its RC-CR2
                    interpolation this value must be supplied and must be the
                    time between digitizer samples in ns; e.g.
                    2 for a xx730 (500MHz) DPP-PHA module and 4 for a xx725
                    (250MHz) DPP-PHA module.  The RC-CR2 interpolation always
                    interpolates between adjacent samples.
                  </para>
                  <para>
                    The DPP-PSD CFD divides the time between interpolation samples
                    into 1024 time buckets. The <parameter>mult</parameter>
                    parameter must be this interpolation interval in
                    nano-seconds.  If the CFD is not used to get a fine time,
                    <parameter>mult</parameter> should be zero.
                  </para>
                  <para>
                    In most cases, the <parameter>mult</parameter> parameter
                    should be the digitizer sampling interval;
                    <literal>2</literal> for 500MHz digitizers or
                    <literal>4</literal> for 250MHz digitizers.
                    It is possible, however to lengthen the interpolation
                    interval by setting bits 10:11 of the CFD control register.
                    This is useful for very steep zero crossings since the interpolation
                    precision drops as the zero crossing gets steep.
                  </para>
                  <para>
                    The table below describes the value of <parameter>mult</parameter>
                    to use for the combinations of these two bits:
                  </para>
                  <table>
                    <title>Value of <parameter>mult</parameter></title>
                    <tgroup cols='3' align='left' colsep='2' rowsep='1'>
                        <thead>
                            <row>
                                <entry>Bits 10:11 value</entry>
                                <entry>Mult for 250MHz digitizer (725)</entry>
                                <entry>Mult for 500Mhz digitizer (750)</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>00</entry><entry>4</entry><entry>2</entry>
                            </row>
                            <row>
                                <entry>01</entry><entry>16</entry><entry>8</entry>
                            </row>
                            <row>
                                <entry>10</entry><entry>24</entry><entry>12</entry>
                            </row>
                            <row>
                                <entry>11</entry><entry>32</entry><entry>16</entry>
                            </row>
                        </tbody>
                    </tgroup>
                  </table>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CAENParameterMap</refentrytitle>
              <manvolnum>3caendpp</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CAENParameterMap</refname>
              <refpurpose>Describe parameter mapping classes.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CAENParameterMap.h&gt;

class CAENParameterMap
{
public:
    virtual ~CAENParameterMap() {}

    virtual void assignParameters(const CAENModuleHits&amp; module) = 0;
};

//////////////////////////// PHA Maps   //////////////////

class CAENPHAMapper : public CAENParameterMap
{
public:
    virtual void assignParameters(const CAENModuleHits&amp; module) {}
};

class CAENPHAArrayMapper : public CAENPHAMapper
{
public:
    CAENPHAArrayMapper(
        const char* time, const char* energy,
        const char* extra1, const char* extra2, const char* finetime
    );
    virtual void assignParameters(const CAENModuleHits&amp; module);
};
class CAENPHAParameterMapper : public CAENPHAMapper
{
public:
    CAENPHAParameterMapper(
        const std::vector&lt;std::string&gt;&amp; times,
        const std::vector&lt;std::string&gt;&amp; energies,
        const std::vector&lt;std::string&gt;&amp; extras1,
        const std::vector&lt;std::string&gt;&amp; extras2,
        const std::vector&lt;std::string&gt;&amp; finetimes
    );

    virtual void assignParameters(const CAENModuleHits&amp; module);
};
//////////////////////// PSD MAPS //////////////////////////////////


class CAENPSDMapper : public CAENParameterMap
{
public:
    virtual void assignParameters(const CAENModuleHits&amp; module) {}
};

class CAENPSDArrayMapper : public CAENPSDMapper
{
public:
    CAENPSDArrayMapper(
        const char* time, const char* shortGate, const char* longGate,
        const char* baseline,
        const char* pur = 0     // Default is not defined.
    );

    virtual void assignParameters(const CAENModuleHits&amp; module);
};

class CAENPSDParameterMapper : public CAENPSDMapper
{
public:
    CAENPSDParameterMapper(
        const std::vector&lt;std::string&gt;&amp; shortGates,
        const std::vector&lt;std::string&gt;&amp; longGates,
        const std::vector&lt;std::string&gt;&amp; baselines,
        const std::vector&lt;std::string&gt;&amp; times,
        const std::vector&lt;std::string&gt;&amp; pur
    );

    virtual void assignParameters(const CAENModuleHits&amp; module);
};



                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    The classes described on this page all
                    derive from <classname>CAENParameterMap</classname>
                    and exist to provide mappings between channels of a single
                    CAEN-DPP module and parameters the
                    <classname>CAENEventProcessor</classname> will assign
                    values to for raw parameters from those channels.
                  </para>
                  <para>
                    There are two main subclasses in this class hierarchy.
                    The <classname>CAENPHAMapper</classname> subtree of
                    classes maps parameters for modules with DPP-PHA firmware
                    while the <classname>CAENPSDMapper</classname> does the
                    same for parameters for modules with DPP-PSD firmware.
                  </para>
                  <para>
                    Each of these classes, in turn, has two subclasses.
                    One to create simple tree parameter arrays from basenames
                    for each parameter type and another that allows full control
                    over the parameter names for each channel and each raw
                    parameter of the digitizer.
                  </para>
                  <para>
                    The remainder of this section describes the constructors
                    of each of these four leaf classes, as the only involvement
                    you'll typically need to have at the application level is to
                    construct these and register them with a class
                    derived from <classname>CAENEventProcessor</classname>.
                  </para>
                  <para>
                    Objects from these classes collaborate with some scheme
                    to create hit objects from CAEN data.  Typically, this is
                    a <classname>CAENEventProcessor</classname> derived event
                    processor.   That object will create container of hits for
                    each module and call:
                  </para>
                  <methodsynopsis>
                     <type>virtual void </type>
                     <methodname>assignParameters</methodname>
                     <methodparam>
                         <type>const CAENModuleHits&amp; </type>
                         <parameter>module</parameter>
                     </methodparam>
                  </methodsynopsis>
                  <para>
                    for the appropriate parameter mapper. Note that for PSD
                    and PHA
                    modules, the individual hits already know how to fold
                    their respective interpolations into the time tag to produce
                    a high precision time.
                    time.
                  </para>
                <refsect2>
                    <title>CAENPHAArrayMapper</title>
                    <para>
                        This class's construtor manufactures tree parameter
                        arrays with 16 elements, on array for each raw parameter
                        the digitizer can produce and one element in each array
                        per channel.
                    </para>
                    <para>
                        The constructor looks like this:
                    </para>
                    <constructorsynopsis>
                        <methodname>CAENPHAArrayMapper</methodname>
                        <methodparam>
                            <type>const char* </type><parameter>time</parameter>
                        </methodparam>
                        <methodparam>
                            <type>const char* </type><parameter>energy</parameter>
                        </methodparam>
                        <methodparam>
                            <type>const char* </type><parameter>extra1</parameter>
                            
                        </methodparam>
                        <methodparam>
                            <type> const char* </type><parameter>extra2</parameter>
                            
                        </methodparam>
                        <methodparam>
                            <type>const char*</type><parameter>finetimes</parameter>
                        </methodparam>
                    </constructorsynopsis>
                    <para>
                        Each parameter is the base name of one of the possible
                        raw parameters the digitizer can produce.
                        If you supply a <literal>nullptr</literal> instead of
                        a pointer to a C string, that parameter is not assigned
                        any parameter.
                    </para>
                    <para>
                        Note that the time parameters will be expressed in
                        units of nanoseconds when unpacked.
                    </para>
                </refsect2>
                <refsect2>
                    <title>
                        CAENPHAParameterMapper
                    </title>
                    <constructorsynopsis>
                        <methodname>CAENPHAParameterMapper</methodname>
                        <methodparam>
                            <type>const std::vector&lt;std::string&gt;&amp; </type><parameter>times</parameter>
                            
                        </methodparam>
                        <methodparam>
                            <type>const std::vector&lt;std::string&gt;&amp; </type><parameter>energies</parameter>
                            
                        </methodparam>
                        <methodparam>
                            <type>const std::vector&lt;std::string&gt;&amp; </type><parameter>extras1</parameter>
                            
                        </methodparam>
                        <methodparam>
                            <type>const std::vector&lt;std::string&gt;&amp; </type><parameter>extras2</parameter>
                            
                        </methodparam>
                        <methodparam>
                            <type>
                                const std::vector&lt;std::string&gt;&amp;
                            </type><parameter>finetimes</parameter>
                        </methodparam>
                    </constructorsynopsis>
                    <para>
                        This class provides complete control over all parameter
                        names from all  channnels.  Each
                        parameter is a vector of at most 16 strings.
                        The strings represent the parameter names for that
                        type of parameter for each channel of the digitizer.
                        Trailing unused channels may be omitted and an empty string
                        (<literal>""</literal>) can be used to indicate
                        a channel is unused.
                    </para>
                </refsect2>
                <refsect2>
                    <title>CAENPSDParameterMapper</title>
                    <para>
                        Very similar to <classname>CAENPHAParameterMapper</classname>,
                        however the parameters are base names for the tree
                        parameters into which DPP-PSD modules raw parameters
                        will be unpacked:
                    </para>
                    <constructorsynopsis>
                        <methodname>CAENPSDArrayMapper</methodname>
                        <methodparam>
                            <type>const char* </type><parameter>time</parameter>
                        </methodparam>
                        <methodparam>
                            <type>const char* </type><parameter>shortGate</parameter>
                        </methodparam>
                        <methodparam>
                            <type> const char* </type><parameter>longGate</parameter>
                        </methodparam>
                        <methodparam>
                            <type>const char* </type><parameter>baseline</parameter>
                        </methodparam>
                        <methodparam>
                            <type>const char* </type><parameter>pur</parameter>
                            <initializer>0</initializer>
                        </methodparam>
                    </constructorsynopsis>
                    <para>
                        Note that the time parameters unpacked are the high
                        resolution times that are computed from the time tag and
                        the CFD correction.  If, you want the coarse time only,
                        ensure that the PSD hits passed to this object have
                        a CFD multiplier value of 0.
                    </para>
                    <para>
                        If you want both the coarse time and the fine time,
                        derive from this class a class that constructs a tree
                        parameter array for the coarse time.  In that class implement
                        the <methodname>assignParameters</methodname> method
                        to first invoke the base class <methodname>assignParameters</methodname>
                        method and then to iterate over the hits that have been
                        passed in, extracting the channel number and time tag from
                        each hit via its <methodname>getChannel</methodname>
                        and <methodname>getTimeTag</methodname> methods and
                        set the appropriate element of your tree parameter array.
                    </para>
                </refsect2>
                <refsect2>
                    <title>
                        <classname>CAENPSDParameterMapper</classname>
                    </title>
                    <para>
                        By a method similar to the <classname>CAENPHAParameterMapper</classname>,
                        instances of this class allow you detailed control over
                        all parameter names:
                    </para>
                    <constructorsynopsis>
                        <methodname>CAENPSDParameterMapper</methodname>
                        <methodparam>
                            <type>const std::vector&lt;std::string&gt;&amp;</type>
                            <parameter> shortGates</parameter>
                        </methodparam>
                        <methodparam>
                            <type>const std::vector&lt;std::string&gt;&amp; </type>
                            <parameter>longGates</parameter>
                        </methodparam>
                        <methodparam>
                            <type>const std::vector&lt;std::string&gt;&amp; </type>
                            <parameter>baselines</parameter>
                        </methodparam>
                        <methodparam>
                            <type>const std::vector&lt;std::string&gt;&amp; </type>
                            <parameter>times</parameter>
                        </methodparam>
                        <methodparam>
                            <type>const std::vector&lt;std::string&gt;&amp;</type>
                            <parameter> pur</parameter>
                        </methodparam>
                    </constructorsynopsis>
                    <para>
                        As with <classname>CAENPHAPasrameterMapper</classname>,
                        if a vector's slot has an empty string for a value,
                        that channel will not be assigned a parameter.  If the
                        vector has fewer than 16 elements, the remaining
                        channels will not be assigned a value.  The intent is
                        to support sparsely populated modules.
                    </para>
                </refsect2>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CAENParser</refentrytitle>
              <manvolnum>3caendpp</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CAENParser</refname>
              <refpurpose>Parse event built data into CAENHit objects</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CAENParser.h&gt;

class CAENParser
{
public:
    CAENParser();
    void operator()(void* pEventBody);
    void clear();
    const std::vector&lt;CAENModuleHits*&gt;&amp; getHitModules() const;
    void addModule(int sid, CAENHit::HitType type, int multiplier=0);
};

                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    This class process an event of event built data into a set
                    of CAEN hits.  After construction, and before being handed
                    any events, <methodname>addModule</methodname> must be
                    called for each module in use to establish its source id,
                    its module type (DPP-PSD or DPP-PHA) and, and the fine time
                    interpolation interval (<parameter>multiplier</parameter>)
                    in nanoseconds.
                  </para>
                  <para>
                    Once properly set up the flow is to pass an event
                    to the instance via the function call operation, then
                    fetch the decoded hits out of the parser using
                    <methodname>getHitModules</methodname>.  Once the hits
                    are processed, the parser must be readied for the next
                    event by invoking <methodname>clear</methodname>.
                  </para>
                  <para>
                    One application programming use case for this class is
                    to use it to decode events outside of the SpecTcl
                    environment, e.g. when building Root trees from
                    CAEN DPP event data.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>void </type>
                           <methodname>operator</methodname>
                           <methodparam>
                               <type>void* </type><parameter>pEventBody</parameter>
                           </methodparam>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Given the body of an event, parses the fragments
                            of the CAEN DPP modules into hits which can be
                            retreived using <methodname>getHitModules</methodname>.
                           </para>
                           <para>
                            Given an object that is derived from
                            the NSCLDAQ class
                            <classname>CRingItem</classname>, you can
                            use that object's
                            <methodname>getBodyPointer</methodname> to get
                            the pointer that must be passed to this method.
                           </para>
                           <para>
                            Given a pinter to a <type>RingItem</type> struct,
                            (defined in <filename>DataFormat.h</filename>),
                            if the field <structfield>s_body.u_noBodyHeader.s_mbz</structfield>
                            is either <literal>0</literal> (NSCLDAQ 11) or
                            <literal>sizeof(uint32_t)</literal> (NSCLDAQ 12 or later),
                            The pointer to pass is given by the field
                            <structfield>s_body.u_noBodyHeader.s_body</structfield>.
                            Otherwise it's given by
                            <structfield>s_body>u_hasBodyHeader.s_body</structfield>.
                            Note, as well, that the NSCLDAQ support for CAEN-DPP readout
                            always produces a body header for a
                            <literal>PHYSICS_EVENT</literal> ring item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>void </type>
                           <methodname>clear</methodname>
                           <void />
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Prepares an instance for the next event by
                            clearing the hits it has parsed and stored from
                            the previous event (it is harmless to call this
                            when there are no hits).
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>const std::vector&lt;CAENModuleHits*&gt;&amp; </type>
                           <methodname>getHitModules</methodname>
                           <void />
                           <modifier>const</modifier>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns a const reference to the hits parsed from
                            the most recent event.  See the reference for
                            <classname>CAENModuleHits</classname> for information
                            about what you get back.
                           </para>
                           <para>
                            As the return value is actually a reference to the
                            hits stored inside the instance, it is
                            <literal>const</literal> so that you are not
                            allowed to modify the vector's contents.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>void </type>
                           <methodname>addModule</methodname>
                           <methodparam>
                               <type>int </type><parameter>sid</parameter>
                           </methodparam>
                           <methodparam>
                               <type>CAENHit::HitType </type><parameter>type</parameter>
                           </methodparam>
                           <methodparam>
                               <type>int </type><parameter>multiplier</parameter>
                               <initializer>0</initializer>
                           </methodparam>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            After constructing an instance, the parser must be
                            told which source ids to pay attention to and how
                            to construct hits for each hit from a source id.
                            This method allows that information to be stored
                            in the parser.  
                           </para>
                           <para>
                            <parameter>sid</parameter> is the source id of a module
                            that is being described.  Recall that in the
                            CAEN-DPP support for NSCLDAQ, each module must be
                            given an event builder source id.
                           </para>
                           <para>
                            <parameter>type</parameter> is the type of modules
                            represented by that source id.  The
                            <filename>CAENHit.h</filename> header describes
                            the legal values for this as
                            <literal>CAENHit::PSD</literal> and
                            <literal>CAENHit::PHA</literal> with obvious meanings.
                           </para>
                           <para>
                            <parameter>multiplier</parameter> need only be
                            provided for <literal>CAENHit::PSD</literal>
                            modules for which the CFD will be integrated into
                            a high precision time value.  This value represents
                            the range in time over which the CFD interpolates in
                            nanoseconds.  The <classname>CAENEventProcessor</classname>
                            reference page provides a table that describes
                            the value to use for this parameter to get
                            correct fine times.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CAENModuleHits</refentrytitle>
              <manvolnum>3caendpp</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CAENModuleHits</refname>
              <refpurpose>Container for hits from a CAEN DPP module</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CAENModuleHits.h*&gt;

class CAENHit;

class CAENModuleHits {
public:
    CAENModuleHits(int sid=0);
    CAENModuleHits(const CAENModuleHits&amp; rhs);
    CAENModuleHits&amp; operator=(const CAENModuleHits&amp; rhs);

    void clear();
    void addHit(CAENHit* pHit);
    const std::vector&lt;CAENHit*&gt;&amp; getHits() const;
    int getSourceId() const;

};
                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    <classname>CAENModuleHits</classname> instances
                    are containers for the hits from a single CAEN DPP module.
                    While not required by the software, the firmware in these
                    modules requires that the hits are homogeneous in type
                    (PSD or PHA only).  
                  </para>
                  <para>
                    The object provides copy construction
                    and assignment however these must both be used with care
                    since it is the hit creator that is responsible for
                    managing hit storage; if the hits are dynamically created,
                    understanding when deletion is possible can be difficult
                    if there are many instances of the container.
                    It's safest only to make copies (via copy construction
                    or assignment) for very short lived objects, e.g. for
                    pass by value to functions/methods or or a block local
                    variable that is destroyed after the block is exited.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term>
                        <constructorsynopsis>
                            <methodname>CAENModuleHits</methodname>
                            <methodparam>
                                <type>int </type><parameter>sid</parameter>
                                <initializer>0</initializer>
                            </methodparam>
                        </constructorsynopsis>
                       </term>
                       <listitem>
                           <para>
                            The constructor requires a the source id
                            (<parameter>sid</parameter>) of
                            the module it will hold hits for.  The
                            main purpose of instances of this class is to
                            hold the hits that are associated with one module
                            and carry that association.
                           </para>
                           <para>
                            This allows some  parser, such as
                            <classname>CAENParser</classname> to produce
                            hits for modules and pass those hits on to
                            other code in a self-descriptive manner.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>void </type>
                           <methodname>clear</methodname>
                           <void />
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Clears the vector of hits encapsulated by
                            this instance of the class. Note, as we will
                            reiterate in the description of
                            <methodname>addHit</methodname>, storage management
                            of the hits themselves is the responsibility of
                            the object that creates those hits.
                           </para>
                           <para>
                            Normally at the time this method is called, it is
                            appropriate to destroy the hits themselves if they
                            were dynamically allocated. 
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>void </type>
                           <methodname>addHit</methodname>
                           <methodparam>
                               <type>CAENHit* </type><parameter>pHit</parameter>
                           </methodparam>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Associates a hit with the module represented by
                            this instance.  It is the caller's responsibility
                            to ensure the hit is of the correct type for the
                            firmware loaded in that module.  The caller
                            is also responsible for owning and managing
                            the storage associated with this hit. 
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>const std::vector&lt;CAENHit*&gt;&amp; </type>
                           <methodname>getHits</methodname>
                           <void />
                           <modifier>const</modifier>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns a const reference to the vector of hits
                            that have been added to this instance since the
                            last time <methodname>clear</methodname> was
                            called.  The reference refers to storage that is
                            internal to the object.  Therefore the reference
                            is const and the vector cannot be modified nor
                            should the hits within the vector be modified.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>int </type>
                           <methodname>getSourceId</methodname>
                           <void />
                           <modifier>const</modifier>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns the source id used to construct this
                            instance. 
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>               
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CAENHit</refentrytitle>
              <manvolnum>3caendpp</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CAENHit</refname>
              <refpurpose>CAEN-DPP hit classes.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CAENHit.h&gt;

class CAENHit {
public:
    typedef enum _HitType {PSD, PHA} HitType;

public:
    CAENHit(HitType type);
    HitType  getType() const;
    uint64_t getTimeTag() const;
    uint32_t getChannel() const;
    const std::vector&lt;uint16_t&gt;&amp; trace1() const;
    const std::vector&lt;uint16_t&gt;&amp; trace2() const;

public:
    virtual void unpack(void* pData) = 0;
};


class CAENPHAHit : public CAENHit
{
public:
    CAENPHAHit(int multiplier);

    uint16_t getEnergy() const;
    uint16_t getExtra1() const;
    uint32_t getExtra2() const;

    virtual void unpack(void* pData) ;
};


class CAENPSDHit : public CAENHit
{

public:
    CAENPSDHit(int cfdMultiplier);

    uint16_t getShortCharge() const;
    uint16_t getLongCharge()  const;
    uint16_t getBaseline()    const;
    uint16_t getPURFlag()     const;
    uint16_t getCFDTime()     const;
    double   getTime()        const;

    virtual void unpack(void* pData);
};

                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    This class hierarchy provides a hit type independent
                    mechanism to unpack hit data into the parameters a hit
                    contains.  The caller is responsible for knowing what
                    type of  hit (PSD or PHA) a fragment contains, instantiating
                    that hit and then asking that hit to unpack the data
                    from that hit via the <methodname>unpack</methodname>
                    virtual method.
                  </para>
                  <para>
                    This method must be handed a pointer to the body of the
                    ring item inside the fragment that is being processed.
                    Event built data, which the NSCLDAQ support for CAEN-DPP
                    modules produces, consists of a series of fragments.  Each
                    fragment has a header and a body. The body of each fragment
                    is the original ring item that contained the fragment
                    before it was built into the event.  It is the body
                    of <emphasis>this</emphasis> ring item that must
                    be handed to the <methodname>unpack</methodname>
                    methods as the <parameter>pData</parameter> parameter.
                  </para>
                  <para>
                    Having discussed the <methodname>unpack</methodname>
                    virtual method and its expectations here, we will
                    omit discussion of that method from the sections
                    that follow that describe each class in this class hierarchy.
                  </para>
                <refsect2>
                    <title>CAENHit</title>
                    <para>
                        This class is the base class of the hierachy.  It provides
                        storage and accessors for the data that are common to all
                        hit types. It also provides a utility to unpack and
                        access any traces acquired by the module.
                    </para>
                    <para>
                        The pure virtual <methodname>unpack</methodname> method
                        described in detail in <literal>DESCRIPTION</literal> above
                        must be implemented by concrete subclasses to unpack the
                        data in hit types for which they're responsible.
                    </para>
                    <para>
                        The <classname>CAENHit</classname> class supports the
                        following methods:
                    </para>
                    <variablelist>
                        <varlistentry>
                           <term>
                            <constructorsynopsis>
                                <methodname>CAENHit</methodname>
                                <methodparam>
                                    <type>HitType </type><parameter>type</parameter>
                                </methodparam>
                            </constructorsynopsis>
                           </term>
                           <listitem>
                               <para>
                                The constructor stores the hit type.  This
                                can be used by consumers of hits to do the appropriate
                                dynamic casts to gain a concrete hit type from
                                a generic hit pointer or reference.
                               </para>
                               <para>
                                The <parameter>type</parameter> parameter must be
                                one of
                                <literal>CAENHit::PHA</literal> for modules with
                                DPP-PHA firmware or <literal>CAENHit::PSD</literal>
                                for moduls with DPP-PSD firmware.  At present,
                                there is no NSCLDAQ/SpecTcl support for DPP-CI
                                firmware. In any event, the DPP-PSD firmware can
                                be used to do charge integration with a suitably
                                long long gate.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>HitType  </type>
                               <methodname>getType</methodname>
                               <void />
                               <modifier>const</modifier>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns the hit type used to construct this
                                instance. This will be the value of the
                                <parameter>type</parameter> parameter passed to
                                our constructor.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>uint64_t </type>
                               <methodname>getTimeTag</methodname>
                               <void />
                               <modifier>const</modifier>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns the hit's trigger time tag as it is
                                recorded by NSCLDAQ.  This value has been
                                handled 32 bit timstamp wraps and
                                calibrated the time tag to nanoseconds.
                                Note that users of DPP-PSD modules that want the
                                trigger time combined with the CFD zero crossing interpolation
                                for high resolution time should use those hits
                                <methodname>getTime</methodname> method not this
                                method.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>uint32_t </type>
                               <methodname>getChannel</methodname>
                               <void />
                               <modifier>const</modifier>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns the channel within the module
                                in which this hit occured. 
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>const std::vector&lt;uint16_t&gt;&amp; </type>
                               <methodname>trace1</methodname>
                               <void />
                               <modifier>const</modifier>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns a reference to the vector into which the
                                first of two possible recorded analog traces can
                                be stored.  If no first trace was stored,
                                the <methodname>size</methodname> method of the
                                vector will give a size of <literal>0</literal>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>const std::vector&lt;uint16_t&gt;&amp; </type>
                               <methodname>trace2</methodname>
                               <void />
                               <modifier>const</modifier>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns a reference to the vector into which the
                                second of two possible recorded analog traces
                                can be stored.  If no second trace was stored
                                the <methodname>size</methodname> method of the
                                vector will return <literal>0</literal>.
                               </para>
                            </listitem>
                        </varlistentry>
                            
                    </variablelist>
                </refsect2>
                <refsect2>
                    <title>CAENPHAHit</title>
                    <para>
                        The unpack method for <classname>CAENPHAHit</classname>
                        unpacks the raw parameters and, if present, traces from
                        a DPP-PHA hit.  The trigger time is made available via
                        the base class method
                        <methodname>getTimeTag</methodname>.
                        If you have programmed the extras2 word to include the
                        RC-CR2 interpolated fine time you can call
                        <parameter>getTime</parameter> to return the trigger
                        time with that interpolation rolled in.
                    </para>
                    <para>
                        The following methods are specific to
                        <classname>CAENPHAHit</classname>:
                    </para>
                    <variablelist>
                        <varlistentry>
                           <term>
                            <constructorsynopsis>
                                <methodname>CAENPHAHit</methodname>
                                <methodparam>
                                    <type>int</type><parameter>mult</parameter>
                                </methodparam>
                            </constructorsynopsis>
                           </term>
                           <listitem>
                               <para>
                                The <parameter>mult</parameter> parameter should
                                be the number of nanoseconds in the interval
                                within  which the RC-CR2 interpolation interpolates
                                the trigger time.  This must be the sampling time
                                e.g. <literal>2</literal> for 500MHz digitizers
                                and <literal>4</literal> for 250MHz digitizers.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>uint16_t </type>
                               <methodname>getEnergy</methodname>
                               <void />
                               <modifier>const</modifier>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns energy for the event computed by the
                                DPP-PHA firmware for the hit's trace.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>uint16_t </type>
                               <methodname>getExtra1</methodname>
                               <void />
                               <modifier>const</modifier>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                If an extra1 word was selected in the digitizer
                                setup, this returns the value of that word.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>uint32_t </type>
                               <methodname>getExtra2 </methodname>
                               <void />
                               <modifier>const</modifier>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                If an extras 2 word was selected in the digitizer
                                setup, this returns the value of that word for
                                this hit.
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </refsect2>
                <refsect2>
                    <title>CAENPSDHit</title>
                    <para>
                        The <methodname>unpack</methodname> method of this
                        class unpacks the parameters of a DPP-PSD digitizer.
                        Access methods specific to this class allow access
                        to both the raw parameters and the high resolution
                        time computed from the time tag and the CFD interpolation
                        if that's used.
                    </para>
                    <para>
                        The class provides the following constructor and
                        data access methods:
                    </para>
                    <variablelist>
                        <varlistentry>
                           <term>
                            <constructorsynopsis>
                                <methodname>CAENPSDHit</methodname>
                                <methodparam>
                                    <type>int </type><parameter>cfdMultiplier</parameter>
                                </methodparam>
                            </constructorsynopsis>
                           </term>
                           <listitem>
                               <para>
                                The <parameter>cfdMultiplier</parameter> parameter
                                provides the number of nanoseconds over which the
                                CFD interpolates the fine time.  See
                                the table of values in the reference page for
                                <classname>CAENEventProcessor</classname> for
                                the values this should take.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>uint16_t </type>
                               <methodname>getShortCharge</methodname>
                               <void />
                               <modifier> const</modifier>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns the short gate charge computed by
                                the DPP-PSD firmware.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>uint16_t </type>
                               <methodname>getLongCharge</methodname>
                               <void />
                               <modifier> const</modifier>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns the charge in the long gate computed
                                by the DPP-PSD firmware.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>
                                uint16_t 
                               </type>
                               <methodname>getBaseline</methodname>
                               <void />
                               <modifier>const</modifier>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns the signal baseline computed by the
                                DPP-PSD firmware.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>uint16_t </type>
                               <methodname>getPURFlag</methodname>
                               <void />
                               <modifier>const</modifier>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Gets the value of the pile up rejection
                                flag.  
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>uint16_t </type>
                               <methodname>getCFDTime</methodname>
                               <void />
                               <modifier>const</modifier>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns the bottom 10 bits of the extras
                                word which are assumed to have the CFD interpolation
                                value.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>double   </type>
                               <methodname>getTime</methodname>
                               <void />
                               <modifier>const</modifier>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Computes the fine time from the coarse time tag
                                and the extras word which is assumed to have
                                the CFD interpolation in its bottom 10 bits.
                                This requires a correct value for the CFD
                                multiplier at construction time.
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </refsect2>
            </refsect1>

        </refentry>
    </appendix>
</book>
