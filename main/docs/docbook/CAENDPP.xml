<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                      "file:///usr/share/xml/docbook/schema/dtd/4.5/docbookx.dtd
"
>
<book>
    <bookinfo>
      <title>SpecTcl CAEN-DPP analysis</title>
      <author><firstname>Ron</firstname><surname>Fox</surname></author>
      <revhistory>
          <revision>
             <revnumber>1.0</revnumber>
             <date>December 26, 2019</date>
             <authorinitials>RF</authorinitials>
             <revremark>Original Release</revremark>
          </revision>
      </revhistory>
    </bookinfo>
    <chapter>
        <title>Introduction</title>
        <para>
            In collaboration with Lousiana State University, CAEN has developed
            support for the CAEN xx725 and CAEN xx730 digitizers running digital
            pulse processing (DPP) firmware for Pulse Height Analysis (PHA) and
            Pulse Shape Discrimination (PSD).  This document describes developments
            within NSCLSpecTcl that provide support to unpack data from these
            digitizers with minimal programming onthe part of the user.
            The features documented in this manual are first deployed in SpecTcl
            version 5.4-000
        </para>
        <para>
            This document is organized in the following chapters:
        </para>
        <itemizedlist>
            <listitem>
               <para>
                  <link linkend='ch.background' endterm='ch.background.title' />
                    provides background information needed to understand the
                    remainder
                    of the document. 
               </para>
            </listitem>
            <listitem>
               <para>
                  <link linkend='ch.description' endterm='ch.description.title' /> 
               </para>
            </listitem>
            <listitem>
               <para>
                  <link linkend='app.reference' endterm='app.reference.title'/>
                  Provides manpage style reference information for the classes
                  that implement the software in a top-down order.
               </para>
            </listitem>
        </itemizedlist>
    </chapter>
    <chapter id='ch.background'>
        <title id='ch.background.title'>Background information</title>
        <para>
            CAEN DPP Digitizers emit a series of hits.  The hits from each
            digitizer are time ordered.  Due to buffering, however, the hits
            from a crate full of digitizers cannot be readout and emitted in time
            order.  
        </para>
        <para>
            The NSCL event builder can then weave together hits across modules and
            build events made up of hits that live within a coincidence window.
            The event builder determines the outermost packaging of events
            and, therefore must be used, even if only a single channel is used,
            in order to create events that are compatible with the unpacking
            software described in this manual.
        </para>
        <para>
            The hit formats used in the Readout Support for CAEN DPP digitizers,
            don't tag the hit type (DPP-PSD or DPP-PHA) it is, therefore,
            the responsibility of the programmer tailoring the unpacking of
            data from CAEN-DPP digitizers to know the  DPP firmware
            loaded into each digitizer and their source ids.
        </para>
    </chapter>
    <chapter id='ch.description'>
        <title id='ch.description.title'>Description of the software</title>
        <para>
            This chapter will provide a tutorial introduction to the use of
            the software provided in SpecTcl to unpack DPP-PSD and DPP-PHA
            digitizers.  It's important to note that we only support
            CAEN xx730   (500MHz) and CAEN xx725 (250MHz) digitizers.
            Full reference material describing the classes discussed in this
            chapter are available in
            <link linkend='app.reference' endterm='app.reference.title' />.
        </para>
        <para>
            This chapter assumes that you are familiar with:
        </para>
        <itemizedlist>
            <listitem>
               <para>
                  SpecTcl concepts, specifically event processors and the event
                  processing pipeline.
               </para>
            </listitem>
            <listitem>
               <para>
                  C++ Programming concepts.   That  you understand classes and
                  objects, how to derive new classes from old classes and
                  how to instantiate objects that are instances of classes.
               </para>
            </listitem>
        </itemizedlist>
        <para>
            This chapter will run through two examples that show how to
            decode data from a hypothetical setup with three digitizers;
        </para>
        <itemizedlist>
            <listitem>
               <para>
                  A DPP-PHA digitizer with source id 1. Note that for decoding
                  DPP-PHA digitizer data it is not necessary to know the
                  frequency of the digitizer.
               </para>
            </listitem>
            <listitem>
               <para>
                  A DPP-PSD XX730 (500MHz) digitizer with source id 2.  In order
                  to apply the CFD fine time correction to the digitizer
                  timestamp, it is necessary to know the digitizer frequency.
                  It is also important to know the values of bits 10 and 11
                  of the digitizer's CFD settings register as these affect
                  the time interval over which the CFD interpolates a fine time.
                  In this case, we will assumem that the value of both of these
                  bits is 0 (interpolate between adjacent samples).  See the
                  reference information for the CAENParameterMap classes
                  for a description of what to do if you have non-zero values
                  for these bits.
               </para>
            </listitem>
            <listitem>
               <para>
                  A DPP-PSD XX725 (250MHz) digitizer with source id 3.  We'll
                  assume again that bits 10 and 11 of the CFD settings register
                  are both zero.
               </para>
            </listitem>
        </itemizedlist>
        <para>
            The process of writing code to unpack CAEN Digitizer data is as
            follows:
        </para>
        <itemizedlist>
            <listitem>
               <para>
                  Assign parameter names  to each channel of each digitizer.
               </para>
            </listitem>
            <listitem>
               <para>
                  Define a class derived from <classname>CAENEventProcessor</classname>.
               </para>
            </listitem>
            <listitem>
               <para>
                  In your event processor's constructor register parameter mapping
                  object for each digitizer.
               </para>
            </listitem>
            <listitem>
               <para>
                  Instantiate your event processor in  your
                  <filename>MySpecTclApp.cpp</filename> file and
                  add it to the event processing pipeline in your implementation
                  of its <methodname>CreateAnalysisPipeline</methodname>
                  method.
               </para>
            </listitem>
        </itemizedlist>
        <para>
            In the remainder of this chapter we'll go through these operations
            step by step.  We'll show how to assign uniform parameter names
            (a tree parameter array) to a digitizer as well as how to
            define a map that isn't uniform (where you need to define the
            parameter names for each parameter from each channel you care about).
        </para>
        <para>
            Before thinking about how to assign parameter names to module channels,
            it's important to know the set of parameters we can decode from
            each module.  The set of parameters differs from
            DPP-PHA and DPP-PSD.
        </para>
        <variablelist>
            <title>Parameters produced by DPP-PHA channels</title>
            <varlistentry>
               <term>Time Tag</term>
               <listitem>
                   <para>
                    This is the raw trigger time for the hit.  The PHA module
                    is not capable of running a CFD trigger and therefore does not
                    have a fine time correction.  This time will be converted
                    by the readout program to nanoseconds
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>Energy</term>
               <listitem>
                   <para>
                    The pulse height from the digital pulse processing
                    algorithm.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>Extras 1</term>
               <listitem>
                   <para>
                    If programmed to produce an extras1, this will contain
                    its' value
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>Extras 2</term>
               <listitem>
                   <para>
                    If programmed to produce two extras, this will contain
                    the value of extras2.
                   </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <variablelist>
            <title>Parameters produced by DPP-PSD channels</title>
            <varlistentry>
               <term>Short Gate charge</term>
               <listitem>
                   <para>
                    The baseline subtracted integration of the part of the pulse
                    in the short gate.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>Long Gate charge</term>
               <listitem>
                   <para>
                    The baseline subtracted integration of the part of the pulse
                    in the long gate.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>baseline</term>
               <listitem>
                   <para>
                    The computation of the pulse baseline
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>Trigger time</term>
               <listitem>
                   <para>
                    The trigger coarse time, with the CFD interpolated fine time
                    folded into it, in nanoseconds.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>Pile up flag</term>
               <listitem>
                   <para>
                    This is given the value 20 if there is a pile up and 40 if
                    there was not one.  This allows you to histogram the parameter
                    giving two separated narrow peaks on which gates can be
                    set (e.g. to only increment a histoigram with no pileup).
                   </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            The sections that follow will include code fragments from the
            complete example that is installed in
            <filename>$SpecTclHome/share/examples/caendpp</filename>.  Note
            that to get that example to compile, you'll need to adjust the
            definition of <literal>INSTDIR</literal> in the Makefile.
        </para>
        <section>
            <title>Assigning parameters</title>
            <para>
                There are four classes that allow us to assign parameters to
                channels from a module (source id).  
                These are:
            </para>
            <variablelist>
                <varlistentry>
                   <term><classname>CAENPHArrayMapper</classname></term>
                   <listitem>
                       <para>
                        Allows you to provide the basename of a tree parameter
                        array for each parameter type in a PHA module.
                        There will be an array with
                        elements numbered 0 through 15 for the channels.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><classname>CAENPHAParameterMapper</classname></term>
                   <listitem>
                       <para>
                        Allows you to provide a vector of individual names
                        for each parameter for each channel of a PHA module.
                        This also supports
                        omitting decoding parameters from unused channels.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><classname>CAENPSDArryaMapper</classname></term>
                   <listitem>
                       <para>
                        Allows you to provide the basename of a tree parameter
                        array for each parameter type in a PSD module.
                        There will be an array with elements numbered
                        0-15 for the channels.  You can also control how, or if
                        the CFD fine time is added into the coarse time.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><classname>CAENPSDParameterMapper</classname></term>
                   <listitem>
                       <para>
                        Allows you to provide a vector of indivudal names for
                        each parameter for each channel of a PSD module.
                        This supports omitting the decode of unused channels and
                        describing how to combine any CFD fine time with the
                        coarse time tag.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                These are all derived from
                the common base class <classname>CAENParameterMap</classname>.
                The interface of this class provides a virtual method;
                <methodname>assignParameters</methodname> which takes hits
                from the module it is responsible for and assigns values to
                SpecTcl tree parameters as defined by the specific
                subclasses above.
            </para>
            <para>
                With this in mind let's assign parameters to each of our three
                hypothetical modules.  We'll assign uniform array basenames to
                source ids 1 and 2 (DPP-PHA and 500MHz DPP-PSD modules).  We'll
                define individual parameters for the first few even channels of
                source id 3 (the 250MHz DPP-PSD module).
            </para>
            <para>
                The base names we'll use for the DPP-PHA will be:
            </para>
            <variablelist>
                <title>DPP-PHA basenames (for source id 1)</title>
                <varlistentry>
                   <term>pha.time</term>
                   <listitem>
                       <para>
                         For the trigger time tags.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>pha.energy</term>
                   <listitem>
                       <para>
                        For the energy
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>extras 1</term>
                   <listitem>
                       <para>
                        We're going to ignore this word.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>pha.missedtrigs</term>
                   <listitem>
                       <para>
                        Assuming the extras 2 word  has been programmed to enable
                        recording of the missed triggers count.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                For the 500MHz DPP-PSD module (source id 2 we'll use the
                following parameter basenames)/
            </para>
            <variablelist>
                <title>DPP-PHA 500MHz basenames (source id 2)</title>
                <varlistentry>
                   <term>psd1.shortQ</term>
                   <listitem>
                       <para>
                        Charge integration of the short gate.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>psd1.longQ</term>
                   <listitem>
                       <para>
                        Charge integration of the long gate.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>psd1.baseline</term>
                   <listitem>
                       <para>
                        Baseline computation.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>psd1.time</term>
                   <listitem>
                       <para>
                        Full time (trigger tag with CFD interpolation)
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>psd.pileup</term>
                   <listitem>
                       <para>
                        Pileup flag.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                For source id 3, the 250MHz DPP-PSD module, let's assume that
                channel 0 and 2 are a start and stop detector package for time of
                flight (yes I know I should have put those in the 500MHz digitizer
                but this is just a programming example). Let's further assume that
                rather than needing to do pulse shape discrimnation, we've just
                set the long gate to give us a current integrated energy.l
                Let's assume that
                all other channels are unused and don't need to have parameters
                assigned to them. We'll assign parameters as follows:
            </para>
            <variablelist>
                <title>DPP-PSD 250MHz  module (source id 3)</title>
                <varlistentry>
                   <term>start.time</term>
                   <listitem>
                       <para>
                        Channel 0 time (start time.)
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>start.E</term>
                   <listitem>
                       <para>
                        Channel 0 long gate charge integration.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>start.baseline</term>
                   <listitem>
                       <para>
                        channel 0 baseline computation.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>start.pileup</term>
                   <listitem>
                       <para>
                        channel 0  pileup flag.
                       </para>
                    </listitem>
                </varlistentry>
                
                <varlistentry>
                   <term>stop.time</term>
                   <listitem>
                       <para>
                        Channel 2 time (stop time)
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>stop.E</term>
                   <listitem>
                       <para>
                        Channel 2 long gate charge integration.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>stop.baseline</term>
                   <listitem>
                       <para>
                        Channel 2 baseline computation.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>stop.pileup</term>
                   <listitem>
                       <para>
                        Channel 2 pileup flag.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </section>
        <section>
            <title>Define our event processor class</title>
            <para>
                The <classname>CAENEventProcessor</classname> class provides
                a base class for analyzing event built data that includes
                data from CAENDPP digitizers.  By itself, it can't do anything
                useful.  It expects you to derive a new class from it and
                provide that class with set of parameter maps that describe
                the parameters assigned to the channels of each digitizer.
            </para>
            <para>
                The definition of this class is shown below:
            </para>
            <example>
                <title>DPPEventProcessor.h</title>
                <programlisting>
#ifndef DPPEVENTPROCESSOR_H
#define DPPEVENTPROCESSOR_H                 <co id='dppheader.guard' />

#include &lt;CAENEventProcessor.h&gt;       <co id='dppheader.basedef' />

class MyDPPEventProcessor : public CAENEventProcessor  <co id='dppheader.derive' />
{
public:
  MyDPPEventProcessor();                    <co id='dppheader.constructor' />
};

#endif
                   
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='dppheader.guard' >
                    <para>
                        This construct and the #endif at the bottom of the
                        file should be used in all header files.  It allows the
                        header to be included more than once (which can happen
                        inadvertently) without triggering compiler complaints
                        about multiple definitions.   Therefore it is known
                        as an <firstterm>include gauard</firstterm>
                    </para>
                    <para>
                        In order to prevent collision with preprocessor names
                        used to guard other headers, by convention the
                        preprocessor name checked and defined is usually
                        derived from the header file name; in this case
                        <filename>DPPEventProcessor.h</filename>.
                    </para>
                </callout>
                <callout arearefs='dppheader.basedef' >
                    <para>
                        Defines a  new class
                        <classname>MyDPPEventProcessor</classname>
                        derived from the base class
                        <classname>CAENEventProcessor</classname>.  This
                        allows us to specify the set of parameter maps the
                        base class will use when assigning parameters from
                        event fragments.
                    </para>
                </callout>
                <callout arearefs='dppheader.constructor' >
                    <para>
                        We need to implement a constructor.  It is in the
                        constructor that we'll create parameter maps and
                        hand them to the base class for its use.
                        This is the only job we really have to get raw
                        parameters decoded.
                    </para>
                </callout>
            </calloutlist>
        </section>
        <section>
            <title>Registering Marameter Mappings</title>
            <para>
                In this section we'll, present code that describes the
                parameter mappings we developed and informs the
                <classname>CAENEventProcessor</classname> base class
                of <classname>MyDPPEventProcessor</classname> of them.
                This is done by createing a parameter mapping object
                for each module and passing it to the
                <classname>CAAENEventProcessor::</classname><methodname>addParameterMap</methodname>
                method. 
            </para>
            <para>
                Here's the code to do that.
            </para>
            <example>
                <title>DPPEventProcessor.cpp</title>
                <programlisting>
#include "DPPEventProcessor.h"      <co id='dppimp.include' />
#include &lt;CAENParameterMap.h&gt; <co id='dppimp.mapperinc' />
#include &lt;vector&gt;             <co id='dppimp.mapperaddinc' />
#include &lt;string&gt;

MyDPPEventProcessor::MyDPPEventProcessor()   <co id='dppimp.constructor' />
{
  addParameterMap(1, new CAENPHAArrayMapper(  <co id='dppimp.src1' />
     "pha.time", "pha.energy", nullptr, "pha.missedtrigs"
  ));
  addParameterMap(2, new CAENPSDArrayMapper(   <co id='dppimp.src2' />
     "psd1.time" ,"psd1.shortQ", "psd1.longQ", "psd1.baseline", "psd1.pileup"),
     2
  );
  std::vector&lt;std::string&gt; src3times={"start.time", "", "stop.time"}; <co id='dppimp.src3params' />
  std::vector&lt;std::string&gt; src3charge={"start.E", "", "stop.E"};
  std::vector&lt;std::string&gt; src3bl={"start.baseline", "", "stop.baseline"};
  std::vector&lt;std::string&gt; src3pup={"start.pileup","", "stop.pileup"};
  std::vector&lt;std::string&gt; src3unused;
  addParameterMap(3, new CAENPSDParameterMapper(    <co id='dppimp.src3' />
      src3charge, src3unused, src3bl, src3times, src3pup),
      4
  );
}
                   
                </programlisting>
            </example>
            <para>
                Lets' look at this constructor implementation step by step so
                we can understand what's going on and, in the process gain some
                understanding of both the
                <classname>CAENEventProcessor</classname> class and the parameter
                mapper classes.
            </para>
            <calloutlist>
                <callout arearefs='dppimp.include' >
                    <para>
                        As usual we need to include the class definition
                        in order to implement it.
                    </para>
                </callout>
                <callout arearefs='dppimp.mapperinc' >
                    <para>
                        Including this header brings in the definitions
                        for four parameter mapping classes so we can
                        make instances of them to register with the
                        <classname>CAENEventProcessor</classname> base
                        class.
                    </para>
                </callout>
                <callout arearefs='dppimp.mapperaddinc' >
                    <para>
                        These headers include class definitions we'll need
                        when creating the channel by channel parameter name
                        definitions needed by
                        <classname>CAENPSDParameterMapper</classname>.
                    </para>
                </callout>
                <callout arearefs='dppimp.constructor' >
                    <para>
                        Begins the implementation of our event processor's
                        constructor.  This is where we're going to add
                        parameter definitions to the base class.  Note that
                        our case is simple enough we can do everything in line
                        and the constructor is understandable.  For larger
                        systems it may be wise to break the implementation
                        down into method calls where each method
                        defines the parameter mapping for some part of the
                        system. 
                    </para>
                </callout>
                <callout arearefs='dppimp.src1' >
                    <para>
                        This creates and registers the parameter mapper
                        for source id 1.  It does this using a call to the
                        base class's
                        <methodname>addParameterMap</methodname> method.
                        This method takes two mandatory parameters and one
                        optional parameter which we'll discuss when we
                        look at the registration of the PSD parameter maps.
                    </para>
                    <para>
                        The first parameter is the source id for which the
                        map is being registered.  If a fragment from a data source
                        without a map is encountered in an event, it will be
                        ignored by the event processor.  This allows you to mix
                        CAEN digitizers with other modules (as long as the timestamps
                        are synchronized an in nanoseconds).
                    </para>
                    <para>
                        The second parameter is a pointer to a
                        <classname>CAENParameterMap</classname>. Remember this
                        is the base class for all of the parameter map classes.
                        The <methodname>addParameterMap</methodname> method
                        expects this to be a dynamically created object.
                        Normally, event processors live for the life time
                        of the program, however if you have an application that
                        dynamically creates/destroys event processors (e.g. to
                        make use of the dynamic pipeline manager), this is important
                        as when a <classname>CAENEventProcessor</classname>
                        is destroyed, it will <literal>delete</literal>
                        all registered parameter mapper objects.
                    </para>
                    <para>
                        The mapper we register is a <classname>CAENPHAArrayMapper</classname>.
                        As you can see it is dynamically created. Its parameters
                        are, in order, the time tag, energy, extras1 and extras2
                        parameter base names.   16 element tree parameter
                        arrays are created for each of these.
                    </para>
                    <para>
                        Note that we pass a <literal>nullptr</literal> as
                        the basename for the extras1 parameter.  If you pass
                        a null pointer for a parameter basename, the
                        array parameter mappers will simply not assign those
                        parts of a hit to SpecTcl parameters.
                    </para>
                </callout>
                <callout arearefs='dppimp.src2' >
                    <para>
                        Registers the parameter map for source id 2, our
                        500MHz DPP-PSD module.  This should be readily
                        undertansdable from the discussion of the registration
                        for source id 1 above.
                    </para>
                    <para>
                        Note that for PSD parameter maps, if the CFD time is
                        included in the extras word, the final parameter (which defaults to 0)
                        is the number of nanoseconds across which the CFD
                        time interpolation is performed.  Normally, this is
                        just the number of nanoseconds per sample.  However
                        CFD parameters can be set to interpolate between multiple samples
                        as well, in which case, again, that affects this parameter
                        (I think).
                    </para>
                    <para>
                        If the CFD is not selected, then you can omit this parameter.
                        Since the default is zero, and in part of the computation
                        of the fine time the extras word bit field
                        that normally contains the CFD fine time is multiplied
                        by this value this will result in no CFD fine time interpolation.
                    </para>
                </callout>
                <callout arearefs='dppimp.src3params' >
                    <para>
                        In this section, we prepare vectors that contain
                        parameter names that will be passed to the
                        <classname>CAENPSDParameterMapper</classname> constructor.
                        The principle is the same for
                        <classname>CAENPHAParameterMapper</classname>.  Each
                        parameter must have a vector of parameter name strings.
                        If the vector is fewer than 16 elements long, the remaining
                        channels are ignored.  If a parameter name is an
                        empty string, that channel is ignored.  This is
                        why there are empty
                        strings for channel 1, and an empty array (which will
                        be used for the short gate charge integration).
                    </para>
                </callout>
                <callout arearefs='dppimp.src3' >
                    <para>
                        This adds the parameter map for source 3, our
                        250MHz DPP-PSD digitizer.  Note that we've specified
                        the interpolation time of the CFD to be 4ns.
                    </para>
                </callout>
            </calloutlist>
            <para>
                As you can see setting up the parameter mappings is an easy, although for
                larger setups potentially tedious task.  Once those mappings are
                set up, however, the base class event processing code takes care
                of everything else to get us raw parameters.  Note that to do
                a real Time of flight we'll need to get differences between the
                start and stop detector times.  We'll show how to do this in
                the section
                <link linkend='sec.computing' endterm='sec.computing.title' />.
            </para>
        </section>
        <section>
            <title>Adding the event processor to the pipeline and build</title>
            <para>
                We have a class definition and we have a class implementation.
                What we need to tie all this into SpecTcl is to create an instance
                of our event processor class and put it into the SpecTcl
                event processing pipeline.  We also need to build our class into
                our tailored version of SpecTcl.
            </para>
            <para>
                Assuming you've pulled down a Skeleton for SpecTcl in the same
                directory as your event processor class; We need to edit
                the skeleton application (<filename>MySpecTclApp.cpp</filename>)
                as follows:
            </para>
            <example>
                <title>Changes to <filename>MySpecTclApp.cpp</filename></title>
                <programlisting>
#include &lt;config.h&gt;
#include "MySpecTclApp.h"
#include "EventProcessor.h"
#include "TCLAnalyzer.h"
#include &lt;Event.h&gt;
#include &lt;TreeParameter.h&gt;
#include "DPPEventProcessor.h"                <co id='skel.addheader' />
                    ...
void
CMySpecTclApp::CreateAnalysisPipeline(CAnalyzer&amp; rAnalyzer)
{
  RegisterEventProcessor(*(new MyDPPEventProcessor), "CAEN_DPP"); <co id='skel.register' />


}
                    
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='skel.addheader' >
                    <para>
                        We must make our skeleton source aware of the class
                        definition for our event processor.
                    </para>
                </callout>
                <callout arearefs='skel.addheader' >
                    <para>
                        This line instantiates a new instance of our
                        event processing class and registers it in the
                        event processing pipeline as an event processor
                        named <literal>CAEN_DPP</literal>.  
                    </para>
                </callout>
            </calloutlist>
            <para>
                Finally we need to edit the skeleton's <filename>Makefile</filename>.
                The support libraries have been incorporated into the SpecTcl
                core library so all that's really needed is to ensure that
                our event processor class implementation is built into
                our tailored SpecTcl.  This is done by adding the
                <filename>DPPEventProcessor.o</filename> to the definition
                of the <literal>OBJECTS</literal> macro in the
                Makefile.
            </para>
            <example>
                <title>Changes to the SpecTcl Makefile</title>
                <programlisting>
                    ...
OBJECTS=MySpecTclApp.o DPPEventProcessor.o
                    ...
                </programlisting>
            </example>
        </section>
        <section id='sec.computing'>
            <title id='sec.computing.title'>But I need to compute time differences!!!</title>
            <para>
                The example we worked through in the previous sections
                of this chapter got us raw parameter unpacking.  However,
                we've got a pair of raw parameters; <literal>start.time</literal>
                and <literal>stop.time</literal> that represent the start and
                stop times of a time of flight measurement.  This
                section shows how to compute the time of flight parameter
                which we'll call <literal>TOF</literal>.
            </para>
            <para>
                In this section, we are going to make use of two SpecTcl
                features, one of which is well known and one not so well
                known/understood:
            </para>
            <itemizedlist>
                <listitem>
                   <para>
                      SpecTcl supports a logical pipline of event processors.
                      Each event processor has access not only to the raw event,
                      but to the parameters that have been produced by prior
                      stages of the pipeline.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      If you create two tree parameter objects that have the
                      same name, they wil map to the same underlying SpecTcl
                      parameter.  Since the <classname>CAENEventProcessor</classname>
                      creates tree parameters, this allows us to easily access
                      the start and stop times it creates.
                   </para>
                </listitem>
            </itemizedlist>
            <para>
                Here are the steps we must take:
            </para>
            <itemizedlist>
                <listitem>
                   <para>
                      Create a new event processor definition that has
                      start and stop time tree parameter member variables,
                      as well as a TOF tree parameter member for the results
                      of our computation.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Implement the constructor of this event processor to
                      initialize the tree parameter members to have the same
                      names (<literal>start.time</literal> and <literal>stop.tim</literal>)
                      as the parameter names we assigned in the event
                      processor that produces raw parameters.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Implement the function call operator; <methodname>operator()</methodname>
                      to perform the time difference for events where both the
                      start and stop times have been assigned values.
                   </para>
                </listitem>
            </itemizedlist>
            <section>
                <title>
                    Defining an event processor class to compute TOF
                </title>
                <para>
                    Here's the class definition for our TOF event processor:
                </para>
                <example>
                    <title>TOF Event processor definition; <filename>TOFEventProcessor.h</filename></title>
                    <programlisting>
#ifndef TOFEVENTPROCESSOR_H
#define TOFEVENTPROCESSOR_H
#include &lt;EventProcessor.h&gt;      <co id='tofdef.evpinc' />
#include &lt;TreeParameter.h&gt;       <co id='tofdef.tpinc'  />

class TOFEventProcessor :  public CEventProcessor   <co id='tof.classdef' />
{
private:
  CTreeParameter m_start;              
  CTreeParameter m_stop;               <co id='tofdef.members' />
  CTreeParameter m_tof;
public:
  TOFEventProcessor();                 <co id='tofdef.constructor' />
  Bool_t operator()(                   <co id='tofdef.fcall' />
    Address_t pEvent, CEvent&amp; rEvent, CAnalyzer&amp; a, CBufferDecoder&amp; d
  );

};


#endif

                    </programlisting>
                </example>
                <calloutlist>
                    <callout arearefs='tofdef.evpinc' >
                        <para>
                            We're writing an event processor.  This means
                            deriving a class from <classname>CEventProcessor</classname>.
                            Doing that requires including
                            <filename>EventProcessor.h</filename> that
                            defines this base class and its interfaces.
                        </para>
                    </callout>
                    <callout arearefs='tofdef.tpinc' >
                        <para>
                            Our event processor will include member data
                            that are <classname>CTreeParameter</classname>
                            objects.  The <filename>TreeParameter.h</filename>
                            header defines the tree parameter, tree parameter array,
                            tree variable and tree variable array classes.
                        </para>
                    </callout>
                    <callout arearefs='tof.classdef' >
                        <para>
                            This line starts  our class definition. Our event
                            processor class is named <classname>TOFEventProcessor</classname>
                            and, as all event processors must, derives from
                            the <classname>CEventProcessor</classname>
                            base class.
                        </para>
                    </callout>
                    <callout arearefs='tofdef.constructor' >
                        <para>
                            We need to implement a constructor to construct the
                            <classname>CTreeParameter</classname> member data
                            of our class with the correct parameter names.
                        </para>
                    </callout>
                    <callout arearefs='tofdef.fcall' >
                        <para>
                            The event processor's function call operator
                            (<methodname>operator()</methodname>) is called for each
                            event.  We must implement this to compute
                            event by event time differences into
                            <varname>m_tof</varname>
                        </para>
                    </callout>
                </calloutlist>
            </section>
            <section>
                <title>Implementing <classname>TOFEventProcessor</classname>
                (<filename>TOFEventProcessor.cpp</filename></title>
                <example>
                    <title>TOFEventProcessor.cpp</title>
                    <programlisting>
#include "TOFEventProcessor.h" 


TOFEventProcessor::TOFEventProcessor() :
  m_start("start.time",  "ns"),
  m_stop("stop.time", "ns"),            <co id='tofimp.init' />
  m_tof("TOF",  "ns")
{}

Bool_t
TOFEventProcessor::operator()(
     Address_t pEvent, CEvent&amp; rEvent, CAnalyzer&amp; a, CBufferDecoder&amp; d
)
{
  if (m_start.isValid() &amp;&amp; m_stop.isValid()) {  <co id='tofimp.valid' />
    m_tof = m_stop - m_start;                           <co id='tofimp.tof' />
  }
  return kfTRUE;                                        <co id='tofimp.retval' />
}

                    </programlisting>

                </example>
                <calloutlist>
                    <callout arearefs='tofimp.init' >
                        <para>
                            These three lines initialize the tree parameter
                            member variables.  THe first two have the same
                            names as the time parameters in the time of flight
                            start and stop digitizer channels.  The third
                            represents a new parameter that we will fill in
                            from our TOF computation.
                        </para>
                    </callout>
                    <callout arearefs='tofimp.valid' >
                        <para>
                            Assigning a value to a tree parameter makes that
                            parameter valid.  This condition protects against
                            computing time differences if one or both of the
                            start/stop times were not in the event.  Whenever you
                            perform computations that depend on SpecTcl parameters,
                            you should ensure the dependent parameters are valid.
                        </para>
                        <para>
                            If a SpecTcl parameter value is fetched prior to being
                            assigned, it will raise an exception and that will
                            abort the processing of that event.
                        </para>
                    </callout>
                    <callout arearefs='tofimp.tof' >
                        <para>
                            Among other things, tree parameter objects can be
                            treated as if they were <literal>double</literal>
                            variables in the sense that you can compute with them
                            and assign them values.  This line computes
                            the TOF and assigns it to the time of flight parameter.
                        </para>
                    </callout>
                    <callout arearefs='tofimp.retval' >
                        <para>
                            Event processing pipeline elements must return a value.
                            The value <literal>kfTRUE</literal> indicates that
                            SpecTcl should continue processing this event.  If
                            an event processing method returns <literal>kfFALSE</literal>,
                            any subsequent elements of the pipeline are not run
                            and the event is not histogrammed.
                        </para>
                        <para>
                            A common error is not to include this return value.
                            This results in random events being discarded.
                        </para>
                    </callout>
                </calloutlist>
            </section>
            <section>
                <title>Adding the TOF computation to our SpecTcl</title>
                <para>
                    We need to make a couple of additions to
                    <filename>MySpecTclApp.cpp</filename> that, if you
                    followed the previous sections, should be familiar:
                </para>
                <example>
                    <title>TOF modifications to <filename>MySpecTclApp.cpp</filename></title>
                    <programlisting>
    ...
#include "DPPEventProcessor.h"
#include "TOFEventProcessor.h"                  // Added line
    ...

void
CMySpecTclApp::CreateAnalysisPipeline(CAnalyzer&amp; rAnalyzer)
{
  RegisterEventProcessor(*(new MyDPPEventProcessor), "CAEN_DPP");
  RegisterEventProcessor(*(new TOFEventProcessor), "TOF_COMPUTATION"); //added line

}
    
                    </programlisting>
                </example>
                <para>
                    Similarly we need to add TOFEventProcessor.o to the
                    <literal>OBJECTS</literal> definition in Makefile:
                </para>
                <example>
                    <title>Adding TOFEventProcessor to the SpecTcl Build</title>
                    <programlisting>
OBJECTS=MySpecTclApp.o DPPEventProcessor.o TOFEventProcessor.o
                    </programlisting>
                </example>
            </section>
        </section>
    </chapter>
    <appendix id='app.reference'>
        <title id='app.reference.title'>Reference pages</title>
        <para>
            This appendix provides reference material for the classes
            that support the CAEN DPP unpacking subsystem.  Rather than
            providing these pages in alphabetical order, they will be provided
            in the order you are likely to need them (if at all).  It's very
            possible that you will not need to use most of theses man pages,
            however they are provided for completeness.
        </para>
        <refentry>
           <refmeta>
              <refentrytitle>CAENEventProcessor</refentrytitle>
              <manvolnum>3caendpp</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CAENEventProcessor</refname>
              <refpurpose>Process event built data containing CAEN DPP hits.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CAENEventProcessor.h&gt;
class CAENEventProcessor : public CEventProcessor
{
public:
    CAENEventProcessor();
    virtual ~CAENEventProcessor();

    virtual Bool_t operator()(
        const Address_t pEvent,
        CEvent&amp; rEvent,
        CAnalyzer&amp; rAnalyzer,
        CBufferDecoder&amp; rDecoder
    );

protected:
    void addParameterMap(int sid, CAENParameterMap* map, int mult=1);
};

                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    This class is a base class for event processors that
                    can decode event built data that includes hits from
                    CAEN-DPP digitizers.  This class must be subclassed
                    and the constructor for the subclass defines the
                    destination parameters for each channel of each module
                    by instantiating <classname>CAENParameterMap</classname>
                    subclasses and making them known to the object by
                    invoking
                    <methodname>addParameterMap</methodname> to
                    make a correspondence between the map instance and
                    a module's source id.
                  </para>
                  <para>
                    Note that <methodname>addParameterMap</methodname>
                    includes an optional <parameter>mult</parameter> parameter.
                    This parameter must be supplied for DPP-PSD digitizers.
                    It controls how the CFD bits in the extras word are folded
                    into the time parameter.
                  </para>
                  <para>
                    The DPP-PSD CFD divides the time between interpolation samples
                    into 1024 time buckets. The <parameter>mult</parameter>
                    parameter must be this interpolation interval in
                    nano-seconds.  If the CFD is not used to get a fine time,
                    <parameter>mult</parameter> should be zero.
                  </para>
                  <para>
                    In most cases, the <parameter>mult</parameter> parameter
                    should be the digitizer sampling interval;
                    <literal>2</literal> for 500MHz digitizers or
                    <literal>4</literal> for 250MHz digitizers.
                    It is possible, however to lengthen the interpolation
                    interval by setting bits 10:11 of the CFD control register.
                    This is useful for very steep zero crossings since the interpolation
                    precision drops as the zero crossing gets steep.
                  </para>
                  <para>
                    The table below describes the value of <parameter>mult</parameter>
                    to use for the combinations of these two bits:
                  </para>
                  <table>
                    <title>Value of <parameter>mult</parameter></title>
                    <tgroup cols='3' align='left' colsep='2' rowsep='1'>
                        <thead>
                            <row>
                                <entry>Bits 10:11 value</entry>
                                <entry>Mult for 250MHz digitizer (725)</entry>
                                <entry>Mult for 500Mhz digitizer (750)</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>00</entry><entry>4</entry><entry>2</entry>
                            </row>
                            <row>
                                <entry>01</entry><entry>16</entry><entry>8</entry>
                            </row>
                            <row>
                                <entry>10</entry><entry>24</entry><entry>12</entry>
                            </row>
                            <row>
                                <entry>11</entry><entry>32</entry><entry>16</entry>
                            </row>
                        </tbody>
                    </tgroup>
                  </table>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CAENParameterMap</refentrytitle>
              <manvolnum>3caendpp</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CAENParameterMap</refname>
              <refpurpose>Describe parameter mapping classes.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CAENParameterMap.h&gt;

class CAENParameterMap
{
public:
    virtual ~CAENParameterMap() {}

    virtual void assignParameters(const CAENModuleHits&amp; module) = 0;
};

//////////////////////////// PHA Maps   //////////////////

class CAENPHAMapper : public CAENParameterMap
{
public:
    virtual void assignParameters(const CAENModuleHits&amp; module) {}
};

class CAENPHAArrayMapper : public CAENPHAMapper
{
public:
    CAENPHAArrayMapper(
        const char* time, const char* energy,
        const char* extra1, const char* extra2
    );
    virtual void assignParameters(const CAENModuleHits&amp; module);
};
class CAENPHAParameterMapper : public CAENPHAMapper
{
public:
    CAENPHAParameterMapper(
        const std::vector&lt;std::string&gt;&amp; times,
        const std::vector&lt;std::string&gt;&amp; energies,
        const std::vector&lt;std::string&gt;&amp; extras1,
        const std::vector&lt;std::string&gt;&amp; extras2
    );

    virtual void assignParameters(const CAENModuleHits&amp; module);
};
//////////////////////// PSD MAPS //////////////////////////////////


class CAENPSDMapper : public CAENParameterMap
{
public:
    virtual void assignParameters(const CAENModuleHits&amp; module) {}
};

class CAENPSDArrayMapper : public CAENPSDMapper
{
public:
    CAENPSDArrayMapper(
        const char* time, const char* shortGate, const char* longGate,
        const char* baseline,
        const char* pur = 0     // Default is not defined.
    );

    virtual void assignParameters(const CAENModuleHits&amp; module);
};

class CAENPSDParameterMapper : public CAENPSDMapper
{
public:
    CAENPSDParameterMapper(
        const std::vector&lt;std::string&gt;&amp; shortGates,
        const std::vector&lt;std::string&gt;&amp; longGates,
        const std::vector&lt;std::string&gt;&amp; baselines,
        const std::vector&lt;std::string&gt;&amp; times,
        const std::vector&lt;std::string&gt;&amp; pur
    );

    virtual void assignParameters(const CAENModuleHits&amp; module);
};



                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    The classes described on this page all
                    derive from <classname>CAENParameterMap</classname>
                    and exist to provide mappings between channels of a single
                    CAEN-DPP module and parameters the
                    <classname>CAENEventProcessor</classname> will assign
                    values to for raw parameters from those channels.
                  </para>
                  <para>
                    There are two main subclasses in this class hierarchy.
                    The <classname>CAENPHAMapper</classname> subtree of
                    classes maps parameters for modules with DPP-PHA firmware
                    while the <classname>CAENPSDMapper</classname> does the
                    same for parameters for modules with DPP-PSD firmware.
                  </para>
                  <para>
                    Each of these classes, in turn, has two subclasses.
                    One to create simple tree parameter arrays from basenames
                    for each parameter type and another that allows full control
                    over the parameter names for each channel and each raw
                    parameter of the digitizer.
                  </para>
                  <para>
                    The remainder of this section describes the constructors
                    of each of these four leaf classes, as the only involvement
                    you'll typically need to have at the application level is to
                    construct these and register them with a class
                    derived from <classname>CAENEventProcessor</classname>.
                  </para>
                <refsect2>
                    <title>CAENPHAArrayMapper</title>
                    <para>
                        This class's construtor manufactures tree parameter
                        arrays with 16 elements, on array for each raw parameter
                        the digitizer can produce and one element in each array
                        per channel.
                    </para>
                    <para>
                        The constructor looks like this:
                    </para>
                    <constructorsynopsis>
                        <methodname>CAENPHAArrayMapper</methodname>
                        <methodparam>
                            <type>const char* </type><parameter>time</parameter>
                        </methodparam>
                        <methodparam>
                            <type>const char* </type><parameter>energy</parameter>
                        </methodparam>
                        <methodparam>
                            <type>const char* </type><parameter>extra1</parameter>
                            
                        </methodparam>
                        <methodparam>
                            <type> const char* </type><parameter>extra2</parameter>
                            
                        </methodparam>
                    </constructorsynopsis>
                    <para>
                        Each parameter is the base name of one of the possible
                        raw parameters the digitizer can produce.
                        If you supply a <literal>nullptr</literal> instead of
                        a pointer to a C string, that parameter is not assigned
                        any parameter.
                    </para>
                    <para>
                        Note that the time parameter will be expressed in
                        units of nanoseconds when unpacked.
                    </para>
                </refsect2>
                <refsect2>
                    <title>
                        CAENPHAParameterMapper
                    </title>
                    <constructorsynopsis>
                        <methodname>CAENPHAParameterMapper</methodname>
                        <methodparam>
                            <type>const std::vector&lt;std::string&gt;&amp; </type><parameter>times</parameter>
                            
                        </methodparam>
                        <methodparam>
                            <type>const std::vector&lt;std::string&gt;&amp; </type><parameter>energies</parameter>
                            
                        </methodparam>
                        <methodparam>
                            <type>const std::vector&lt;std::string&gt;&amp; </type><parameter>extras1</parameter>
                            
                        </methodparam>
                        <methodparam>
                            <type>const std::vector&lt;std::string&gt;&amp; </type><parameter>extras2</parameter>
                            
                        </methodparam>
                    </constructorsynopsis>
                    <para>
                        This class provides complete control over all parameter
                        names from all  channnels.  Each
                        parameter is a vector of at most 16 strings.
                        The strings represent the parameter names for that
                        type of parameter for each channel of the digitizer.
                        Trailing unused channels may be omitted and an empty string
                        (<literal>""</literal>) can be used to indicate
                        a channel is unused.
                    </para>
                </refsect2>
            </refsect1>
        </refentry>
    </appendix>
</book>
