<?xml version="1.0" encoding="UTF-8"?>


<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                      "file:///usr/share/xml/docbook/schema/dtd/4.5/docbookx.dtd
"
>
<book>
    <bookinfo>
      <title>mpiSpecTcl.</title>
      <author><firstname>Ron</firstname><surname>Fox</surname></author>
      <revhistory>
          <revision>
             <revnumber>1.0</revnumber>
             <date>August 10, 2018 and following</date>
             <authorinitials>RF</authorinitials>
             <revremark>Original Release</revremark>
          </revision>
      </revhistory>
    </bookinfo>
    <chapter>
        <title>Quick Start</title>
        <para>
            This chapter is intended to get you up and running with XXUSBSpecTcl and 
            custom configured SpecTcl's that don't extend the SpecTcl command set.
            I'll describe:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    What mp;iSpecTcl is.
                </para>
            </listitem>
            <listitem>
                <para>
                    How to know if your version of SpecTcl supports MPI Parallelism
                </para>
            </listitem>
            <listitem>
                <para>
                    Environment variables you will need to set to run MPI mpiSpecTcl
                </para>
            </listitem>
            <listitem>
                <para>
                    How to run mpiSpecTcl with parallel event processing pipelines
                </para>
            </listitem>
            <listitem>
                <para>
                    Debugging mpiSpecTcl tailored code.
                </para>
            </listitem>
        </itemizedlist>
        <section>
            <title>What is mpiSpecTcl</title>
            <para>
                mpiSpecTcl can be used with SpecTcl version 7.0 or later.  It supports
                scalable performance by parallelizing the event processing pipeline.
                When you run mpiSpecTcl, events from the data source are distributed
                between one or more <firstterm>worker processes</firstterm>. Each of these
                processes passes events through its copy of the event processing pipeline and
                sends the parameters it produces to another process running the event sink
                pipline (histogramer).
            </para>
            <para>
                Since in many nuclear science experminents, each event can be analyzed independently 
                of all other events, running more than one worker process will scale up the rate at which
                events can be processed until data transfer limits this scaling.
            </para>
            <para>
                For a more detailed description of how mpiSpecTcl works, see:
                <link linkend='chap.howitworks' endterm='chap.howitworks.title' />
            </para>
        </section>
        <section>
            <title>Checking for support of MPI parallelism.</title>
            <para>
                Support for MPI parallelism in SpecTcl is an option selectable when SpecTcl is built and
                installed.  You can see if MPI parallelism is enabled by looking at the <literal>VERSION</literal>
                file that is installed in the top level directory of the SpecTcl installtion (the INSTDIR directory
                in your tailored Makefile).
            </para>
            <para>
                Below are the first two lines of this file for SpecTcl built with MPI support:
            </para>
            <example id='ex.version'>
                <title id='ex.version.title'>VERSION file for SpecTcls with MPI support</title>
                <programlisting>
Version:  SpecTcl-7.0-000 build on RonDell Thu 06 Jun 2024 01:48:15 PM EDT by ron MPI Enabled
Compiled with /usr/opt/mpi/openmpi-4.0.1/bin/mpicxx and /usr/opt/mpi/openmpi-4.0.1/bin/mpicc               
                </programlisting>
            </example>
            <para>
                Towards the end of the first line you can see the text <literal>MPI Enabled</literal>.
                This indicates the installed SpecTcl was built with MPI support enabled.  
                If MPI support was disabled, this will read <literal>MPI Disabled</literal>.
            </para>
            <para>
                THe second line shows the compiler command used to build SpecTcl.
                Building software with MPI requires specific include directories and link libraries
                to be added to the compiler and linker flags.  For convenience, MPI distributions such
                as OpenMPI and MPICH provide compiler drivers that define these flags for the user.
                Note that <literal>mpicxx</literal> is the MPI C++ compiler and <literal>mpicc</literal>
                the MPI C compiler.  Mostly, take not of the path to the compiler.
                That will be needed both when you run SpecTcl in parallel mode and you may also
                need to define an environment variable to use SpecTcl in parallel mode.
            </para>
        </section>
        <section>
            <title>Environment variables you will need</title>
            <para>
                In <link linkend='ex.version' endterm='ex.version.title' />, if the compilation commands
                have directory paths on them you will probably need to tell OpenMPI where to find its
                runtime.  This is done by setting the environment variable <literal>OPAL_PREFIX</literal>
                to the top level of the OpenMPI installation.  In the example, this is
                <filename>/usr/opt/mpi/openmpi-4.0.1</filename>.  For example:
                <informalexample>
                    <programlisting>
OPAL_PREFIX=/usr/opt/mpi/openmpi-4.0.1
export OPAL_PREFIX
                    </programlisting>
                </informalexample>
            </para>
        </section>
        <section>
            <title>Running mpiSpecTcl in parallel mode</title>
            <para>
                Running an MPI application requires using the <literal>mpirun</literal> command.  
                The mpirun command allows you to, among other things, specify the number of processes
                that should be started in the application. mpirun then sets up the MPI communication
                infrastructure and starts the processes in a way that the MPI API knows how to communicate.
            </para>
            <para>
                If you had to set the <literal>OPAL_PREFIX</literal> environment variable, you can use
                it.  Here's a sample invocation of the mpirun command that starts 5 processes for the
                SpecTcl that you built in the current working directory:
            </para>
            <example>
                <title>mpirun exmaple</title>
                <programlisting>
$OPAL_PREFIX/bin/mpirun -n 5 SpecTcl
                </programlisting>
            </example>
            <para>
                the value given to the <option>-n</option> option specifies the number of processes mpirun
                should start.  As will be described more completely in 
                <link linkend='chap.howitworks' endterm='chap.howitworks.title' />, you must use at least 3 processes.
                Two processes are non-worker processes, the remaining processes are workers that run the event processing
                pipeline in parallel on events.  The number actual value of <option>-n</option> that makes sense,
                depdends on the computational complexity of your event processing pipeline. 
            </para>
            <para>
                If you use this simple invocation of the miprun command your processes will all run
                in the computer that runs the <command>mpirun</command> command. In that case,
                a value for <option>-n</option> larger than the number of cores in that system
                makes no sense.  More complex invocations of <command>mpirun</command> are possible and
                can allow the application to spread across more than one system.  This is complicated for
                the containerized environment and beyond the scope of this document.
            </para>
        </section>
        <section>
            <title>Debugging mpiSpecTcl</title>
            <para>
                It is a sad fact of life that you will need to find errors in your software.
                In a parallel process, print statements can be confusing as they may step on 
                top of each other.   There are a couple of tricks you can use.
            </para>
            <para>
                If you just run your SpecTcl (not mpirun it), it will run fully serially.  You can
                use output and even gdb to ferret out the bugs.  If your event processing pipeline
                truly has no historical knowledge of prior events, finding and fixing the bugs with
                SpecTcl run serially, should, normally, be sufficient.  
            </para>
            <para>
                If your event processing
                pipeline requires knowledge of prior events, you will, most likely
                need to run mpiSpecTcl either serially or with <option>n 3</option>. 3 processes
                ensures that there is one worker process which, therefore gets all events.  This worker process
                runs in pipeline parallelism with the SpecTcl code that takes the parameters unpacked from events and
                histograms them so you might get some modest speed-up.
            </para>
            <para>
                A second technique you can use is to use <command>mpirun</command> in a way that binds a 
                separate terminal window (e.g. xterm) so that the output from each process is separated
                from all other processes.  You can also use this technique to run gdb in all processes.
            </para>
            <para>
                The example below shows two invocations of <command>mpirun</command>  THe first one
                just runs SpecTcl with a separate <command>xterm</command> window for each process.
                The second command does the same thing but runs  each of the SpecTcl processes under the 
                control of <command>gdb</command>
            </para>
            <example>
                <title>Xterm per process and gdb per process</title>
                <programlisting>
$OPAL_PREFIX/bin/mpirun -n 5 xterm -e SpecTcl      #Each process has a terminal
$OPAL_PREFIX/bin/mpirun -n 5 xterm -e gdb SpecTcl  #Each process under gdb in its terminal
                </programlisting>
            </example>
            <para>
                The point is that the <option>-e</option> to the <command>xterm</command> commande
                means that the remainder of the command should be run inside the xterm.  In the first case,
                that's just SpecTcl, in the second that's gdb being told to control SpecTcl.
            </para>
            <para>
                Under <command>mpirun</command> using the technique above to run the processes under the
                control of gdb, in general you'll want to know which processes are workers and set breakpoints in 
                one or more of them.   You can do this for open MPI via the gdb command 
                <command>show environment OMPI_COMM_WORLD_RANK</command>. For MPICH, 
                <command>show environment PMI_RANK</command> should be used instead.
                The value of this environment variabl can be thought of as a process number or 
                <firstterm>rank</firstterm> used to
                identify the function of a given process.  Workers have a rank of 2 or higher.
                Rank 0 is the base process which runs the interactive Tcl interpreter and distributes
                events to workers.  Rank 1 is the event sink pipeline (histogramer) and also starts any
                displayer (e.g. Xamine or CutiePie).
            </para>
        </section>
    </chapter>
    <chapter>
        <title>Porting custom commands</title>
        <para>
            One of the strengths of SpecTcl and the Tcl scripting language it uses is its extensibility.
            Complex tailored SpecTcl programs have used this to extend the Tcl interpreter, adding
            commands of their own to the base Tcl/Tk core and SpecTcl extensions to that core.
            When SpecTcl is running as an MPI program, only one of the processes has an interactive
            interpreter.  Therefore, your custom commands must be wrapped in appropriate classes
            that will relay your command to the rest of the program from the interactive interpreter process.
            For more about this, see <link linkend='chap.howitworks' endterm='chap.howitworks.title' />
        </para>
        <para>
            This chapter will introduce two classes which:
        </para>
        <itemizedlist>
            <listitem><para>
                Know when SpecTcl is running as an MPI application and when it is running serially.
            </para></listitem>
            <listitem><para>
                When SpecTcl is running serially simply pass control of to an encapsulated commands.
            </para></listitem>
            <listitem><para>
                When SpecTcl is running as an MPI application, either causes the wrapped command to 
                be executed in all other processes or in all processes, depending on the wrapper
                class chosen.
            </para></listitem>
            <listitem><para>
                In MPI application mode, collects the statuses and the results from all of the
                processes executing the command and does something <emphasis>sensible</emphasis>.
                (I'll define sensible as well).
            </para></listitem>
        </itemizedlist>
        <para>
            I will also describe how your code can recognize if the application is running
            serially or as an MPI application and how to know, in the latter case, the role of the
            process it is executing in.
        </para>
        <para>
            The techniques I will describe have been used withn the SpecTcl command extensions
            and examples will be drawn from that code.
        </para>
        <section>
            <title>The command wrapper classes</title>
            <para>
                In order to function in the MPI application environment, your commands must be
                wrapped in one of two classes: <classname>CMPITclCommand</classname> defined in
                <filename>CMPITclCommand.h</filename> or <classname>CMPITclCommandAll</classname>
                defined in <filename>CMPITclCommandAll.h</filename>
            </para>
            <para>
               Your command must still be created in <filename>MySpecTclApp.cpp</filename>'s 
               <methodname>AddCommand</methodname> method.  The procedure is to first create an instanced of your
               command then to wrap that instanced in the class you chose.
            </para>
            <para>
                In most cases you won't need your command to run in the interactive interpreter process.
                Again, see <link linkend='chap.howitworks' endterm='chap.howitworks.title' />.  If that is
                the case you should wrap your command in <classname>CMPITclCommand</classname>.  If, on the other hand,
                you need your command to run in the main interpreter, wrap it in <classname>CMPITclCommandAll</classname>
            </para>
            <para>
                The example below is the <classname>CMySpecTclApp</classname>::<methodname>AddCommands</methodname> from 
                CCUSBSpecTcl, howing how the <command>parammap</command> is wrapped in 
                <classname>CMPITclCommand</classname>.  The procedures is identical for
                <classname>CMPITclCommandAll</classname> as its constructor has the same argument
                signature as <classname>CMPITclCommand</classname>'s constructor.
            </para>
            <example>
                <title>Wrapping a command in <classname>CMPITclCommand</classname></title>
                <programlisting>
#include "MPITclCommand.h"

...

void 
CMySpecTclApp::AddCommands(CTCLInterpreter&amp; rInterp)  
{ 
  CTclGrammerApp::AddCommands(rInterp);         <co id='ex.wrapcmd.base' />
  CParamMapCommand::create(rInterp);            <co id='ex.wrapcmd.createwrapped' />
  auto pParamMap = CParamMapCommand::getInstance(); <co id='ex.wrapcmd.getwrapped' />
  new CMPITclCommand(rInterp, "parammap", pParamMap); <co id='ex.wrapcmd.wrap' />
}  
                </programlisting>
            </example>
            <para>
                This example is made a bit more complicated than most of your commands will be because
                CCUSB has a static creation method to create and store the instance of the command and
                another static method to retrieve a pointer to that method. For a detailed description
                of the sample code, see below where the numbers in the list correspond to numbered
                callouts in the code itself.
            </para>
            <calloutlist>
                <callout arearefs='ex.wrapcmd.base'>
                    <para>
                        As usual, <classname>TclGrammerApp</classname>::<methodname>AddCommands</methodname> is 
                        called to define the standard SpecTcl commands (like e.g. <command>spectrum</command>).
                    </para>
                </callout>
                <callout arearefs='ex.wrapcmd.createwrapped'>
                    <para>
                        This creates the <command>parammap</command> command handler and stores a
                        pointer to is instance.  Note that it's just fine to register the command with
                        the interpreter.   The wrapper will override that registration.
                    </para>
                </callout>
                <callout arearefs='ex.wrapcmd.getwrapped'>
                    <para>
                        Retrieves a pointer to the command processor instance.  The
                        processor instance must have been implemented as a class derived
                        eventually from <classname>CTCLObjectProcessor</classname>.  For classes
                        derived from the older, obsolete <classname>CTCLProcessor</classname>, see 
                        <link linkend='sec.wrapoldcmds' endterm='sec.wrapoldcmds.title' /> for some simple
                        techniques to convert those to <classname>CTCLObjectProcessor</classname>
                        processors.
                    </para>
                </callout>
                <callout arearefs='ex.wrapcmd.wrap'>
                    <para>
                        This is the magic that does the actual wrapping. The constructor for both
                        <classname>CMPITclCommand.h</classname>
                        takes three  parameters:
                        <itemizedlist>
                            <listitem><para>
                                A reference to the <classname>CTCLInterpreter</classname> on which the
                                command is defined.   This was passed in as <varname>rIterp</varname>
                                to <methodname>AddCommands</methodname>
                            </para></listitem>
                            <listitem><para>
                                The command name under which the wrapped command shoulid be invoked.
                                Normally this shoulid be the same command name used to create your
                                wrapped command.  In this case it is <literal>parammap</literal>
                            </para></listitem>
                            <listitem><para>
                                The wrapped command itself, a pointer to an object from a class
                                derived from <classname>CTCLObjectProcessor</classname>.
                            </para></listitem>
                        </itemizedlist>
                    </para>
                </callout>
            </calloutlist>
            <para>
                The <command>pman</command> SpecTcl core command processor uses  an interesting trick that allows you
                to leave the initialization code in <filename>MySpecTclApp.cpp</filename> unmodified.
                It also is wrapped in a <classname>CMPITclCommandAll</classname>.
            </para>
            <para>
                The original command processor class, <classname>CPipelineCommand</classname> is renamed to 
                <classname>CPipelineCommandActual</classname>.  This just a simple global string replace for the
                 most part.  A new class named <classname>CPipelineCommand</classname> derived, in this case,
                 from <classname>CMPITclCommandAll</classname> with the same constructor signature as
                 <classname>CPipelineCommandActual</classname> which constructs that actual command processor and wraps it.
                 This method is suitable when the wrapped command processor is not exporting any services to the external code.
            </para>
            <para>
                The example below shows excerpts from the header <filename>CPipelineCommand.h</filename>.
            </para>
            <example>
                <title>Transparently wrapping commands by renaming the actual processor</title>
                <programlisting>
#include &lt;PITclCommandAll.h&gt;
#include &lt;TCLObjectProcessor.h&gt;

...
class CPipelineCommandActual : public CTCLObjectProcess  <co id='ex.autowrap.actualdecl' />
or
{
...
public:

    CPipelineCommandActual(CTCLInterpreter&amp; interp);
    int operator()(
        CTCLInterpreter&amp; interp, 
        std::vector&lt;CTCLObject&gt;&amp;; objv
    );

...
};

class CPipelineCommand : public CMPITclCommandAll {  <co id='ex.autowrap.wrapperdecl' />
public:
    CPipelineCommand(CTCLInterpreter&amp; rInterp) ;
    ~CPipelineCommand() {}
};

                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='ex.autowrap.actualdecl' >
                <para>
                    Here we see the renamed original class. Note that in the implementation you will want
                    to replace <replaceable>OriginalClassName</replaceable><literal>::</literal> with
                    <replaceable>OriginalClassName</replaceable><literal>Actual::</literal>
                </para>
                </callout>
                <callout arearefs='ex.autowrap.wrapperdecl'>
                    <para>
                        Here is the definition of the replacement for the original class.
                    </para>
                </callout>
            </calloutlist>
            <para>
                where the implementation of <classname>CPipelineCommand</classname>, CPipelineCommand.cpp
                is now:
            </para>
            <example>
                <title>Implementing the replacement class </title>
                <programlisting>
CPipelineCommand::CPipelineCommand(CTCLInterpreter&amp; rInterp) : <co id='ex.autowrap.constructorimpl' />
  CMPITclCommandAll(rInterp, "pman", new CPipelineCommandActual(rInterp)) {}
                </programlisting>
            </example>
            <para> 
                Doing this allows your wrapped command to be constructed in exactly the same way the
                original command was.  If you have to wrap a lot of commands this can be conceptually simpler.
            </para>
            <calloutlist>
                <callout arearefs='ex.autowrap.constructorimpl'>
                    <para>
                        Here you can see how we implement the constructor of the wrapper class
                        so that it wraps the actual class.
                    </para>
                </callout>
            </calloutlist>
        </section>
        <section>
            <title>Knowing the execution evironment</title>
            <para>
                Your commands may need to know if you are running as an MPI application and, if so,
                the sort of process you are.  mpiSpecTcl has three types of functionally distinct processes:
                The Root process runs the interactive Tcl interpreter (and therefore any GUI), the
                Event sink pipeline process and workers, which run the event processing pipline you write.
                The organization of the MPI application is described in greater detail in 
                <link linkend='chap.howitworks' endterm='chap.howitworks.title' />.
            </para>
            <para>
                There is only one Root and one Event sink pipeline process.  There are as many Worker processes
                as you implicitly specify in the <command>mpirun</command> command.  User command
                extensions generally affect the operation of the event processing pipeline and, therefore
                when running MPI should onhly actually do something in worker processes.
            </para>
            <para>
                In MPI processes are grouped together in <firstterm>communicators</firstterm>.  Each 
                process is assigned an unsigned integer number called a <firstterm>rank</firstterm> within
                each communicator to which it belongs.  WHen an MPI application starts, an initial 
                communicator called the <firstterm>world communicator</firstterm> is created by the
                MPI run-time and processes are assigned a rank within the world communicator.
                It is the world communicator rank that mpiSpecTcl uses to assign roles to each process.
            </para>
            <para>
                The header <filename>Globals.h</filename> defines three preprocessor constants:
            </para>
            <variablelist>
                <varlistentry>
                    <term><literal>MPI_ROOT_RANK</literal></term>
                    <listitem>
                        <para>
                            The rank of the root process.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>MPI_EVENT_SINK_RANK</literal></term>
                    <listitem>
                        <para>
                            The rnak of the event sink pipline process.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>MPI_FIRST_WORKER_RANK</literal></term>
                    <listitem>
                        <para>
                            The smallest rank assigned to a worker process.  All workers will
                            have world communicator ranks that are this or larger.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                The header <filename>TclPump.h</filename> provides a pair of functions:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>bool</type> <function>isMpiApp</function><literal>()</literal></term>
                    <listitem>
                        <para>
                            Returns <literal>true</literal> if SpecTcl is running as an MPI application.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>int</type> <function>myRank</function> <literal>()</literal></term>
                    <listitem>
                        <para>
                            Returns the rank of the process in the current communicator.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                Here is sample code for a command processor that only executes in worker processes
                when the SpecTcl is an mpi application but executes as well if SpecTcl is run serially.
            </para>
            <example>
                <title>Running commands only in workers</title>
                <programlisting>
#include &lt;TclPump.h&gt;
...
int SomCommandProcessor::operator()(
    CTCLInterpreter&amp; interp, std::vector&lt;CTCLObject&gt;& objv
) {
    if (isMpiApp() && (myRank() < MPI_FIRST_WORKER_RANK)) {
        return TCL_OK;
    }
    // The actual stuff the command does...


}
                </programlisting>
            </example>
        </section>
        <section id='sec.wrapoldcmds'>
            <title id='sec.wrapoldcmds.title'>Wrapping old argc, argv commands.</title>
            <para>
                Commands written for today's SpecTcl <emphasis>should</emphasis> be writtena
                as classes derived from <classname>CTCLObjectProcessor</classname>.  The MPI
                wrapper classes are <emphasis>only</emphasis> able to wrap that sort of class.
                
            </para>
            <para>
                However, originally SpecTcl only had a 
                <classname>CTCLProcessor</classname> base class for writing commands and,
                naturally, there may still be commands out there derived from
                <classname>CTCLProcessor</classname>.  This section describes how to
                convert <classname>CTCLProcessor</classname> derived classes into
                <classname>CTCLObjectProcesssor</classname> derived classes so they can be wrapped
                in e.g. <classname>CMPITclCommand</classname>
            </para>
            <para>
                Several SpecTcl commands were still <classname>CTCLProcessor</classname> derived
                and this chapter provides lessons learned porting those.
            </para>
            <para>
                Before staring let's look at the differences between the signatures for
                <methodname>operator()</methodname> for the two classes.
                For <classname>CTCLProcessor</classname>, <methodname>operator()</methodname>
                looks like this:
            </para>
            <funcsynopsis>
                <funcprototype>
                    <funcdef>int <function>operator()</function></funcdef>
                    <paramdef>
                        <parameter>CTCLINterpreter&amp; interp</parameter>
                        <parameter>CTCLResult&amp; result</parameter>
                        <parameter>int argc</parameter>
                        <parameter>char** argv</parameter>
                    </paramdef>
                </funcprototype>
            </funcsynopsis>
            <para>
                Where <parameter>argc</parameter> is the number of words in the command,
                <parameter>argv</parameter> are pointers to the verb text,
                and <parameter>result</parameter> is the result object for the result that will
                be returned by the command.
            </para>
            <para>
                On the other hand, for <classname>CTCLObjectProcesor</classname>, 
                <methodname>operator()</methodname> looks like this:
            </para>
            <funcsynopsis>
                <funcprototype>
                    <funcdef>int <function>operator()</function></funcdef>
                    <paramdef>
                        <parameter>CTCLINterpreter&amp; interp</parameter>
                        <parameter>std::vector&lt;CTCLObject&gt;&amp; objv</parameter>
                    </paramdef>
                </funcprototype>
            </funcsynopsis>
            <para>
                WHere <parameter>objv</parameter>
                are the command words and the result should be set via 
                <literal>interp.setResult</literal> which has a few different overloads.
            </para>
            <para>
                In addition to the relatively simple problem of changing the inheritance, porting
                requires deciding how to handle the parameterization of <methodname>operator()</methodname>
                where access to the command words may be sprinkled throughout the code. 
            </para>
            <para>
                The SpecTcl <command>spectrum</command> is an example of a command that had been
                derived from <classname>CTCLProcessor</classname> but had to be ported to be derived
                from <classname>CTCLObjectProcessor</classname> in order to be wrapped in 
                <classname>CMPITclCommandAll</classname>.
            </para>
            <para>
                The <command>spectrum</command> is a command ensemble.  Each of the options
                <option>-new</option>, <option>-list</option>, <option>-delete</option> and 
                <option>-trace</option> can be thought
                of as a subcommand (if none of these options is present the command internally defaults to
                <option>-new</option>).  In SpecTcl, such ensembles typically execute each subcommand in 
                another method with <methodname>operator()</methodname> mostly just dispatching to the appropriate 
                subcommand method.
            </para>
            <para>
                First lests look at a fragment of the header (<filename>SpectrumCommand.h</filename>).
            </para>
            <example>
                <title>Porting <classname>CTCLProcessor</classname> to 
                    <classname>CTCLObjectProcessor</classname> <filename>SpectrumCommand.h</filename>
                </title>
                <programlisting>
...
class CSpectrumCommand  : public CTCLPackagedObjectProcessor       
{
...
public:  
  virtual   int operator() (CTCLInterpreter&amp; rInterpreter, 
			    std::vector&lt;CTCLObject&gt;&amp; objv)  ;
  Int_t New (CTCLInterpreter&amp; rInterpreter, 
	     int nArgs, const char* pArgs[])  ;
  Int_t List (CTCLInterpreter&amp; rInterp, 
	      int nArgs, const char* Args[]);
  Int_t Delete (CTCLInterpreter&amp; rInterp,
		int nArgs, const char* pArgs[])  ;
  Int_t Trace  (CTCLInterpreter&amp; rInterp, 
		int nArgs, const char* pArgs[]);
...
};
...
                </programlisting>
            </example>
            <para>
                This example shows that the <methodname>operator()</methodname> method will marshall
                the <parameter>objv</parameter> array into an argc/argv and pass that to the 
                subcommand processors.  The only modifications needed to the subcommand processors
                then become removing the <parameter>result</parameter> from their signatures and
                figuring out how, then, to handle returning results.
            </para>
            <para>
                The next example shows a fragment of code from <methodname>operator()</methodname>
                that recreates argc and argv from <parameter>objv</parameter>
            </para>
            <example>
                <title>
                    Porting <classname>CTCLProcessor</classname> to <classname>CTCLObjectProcessor</classname>
                    Marshalling arguments.
                </title>
                <programlisting>
int 
CSpectrumCommand::operator()(CTCLInterpreter&amp; rInterpreter, std::vector&lt;CTCLObject&gt;&amp; objv)
{

  std::vector&lt;std::string&gt; words;
  std::vector&lt;const char*&gt; pWords;

  // Due to lifetimes and how c_str behaves we need two loops not one:

  for (auto&amp; word : objv) {
    words.push_back(std::string(word));
  }
  for (int i =0; i &lt; words.size(); i++) {
    pWords.push_back(words[i].c_str());
  }
  int nArgs = words.size();
  auto pArgs = pWords.data();
...
}
                </programlisting>
            </example>
            <para>
                First <parameter>objv</parameter> is converted into a vector of std::string. Next, 
                this is used to produce a vector of const char*.  This has to be done in two loops
                due to lifetime issues.  Finally, nArgs (argc if you prefer) is just the  size of either
                of those vectors and pArgs (argv if you prefer) is just the data in the vector of 
                const char*s.
            </para>
            <para>
                Each subcommand processor new needs to figure out how to deal with the "missing" 
                result parameter and, instead use the interpreter's <methodname>setResult</methodname>
                to set the result.  It's simplest to note that std::string has most of the methods that
                <classname>CTCLResult</classname> has for building up contents.
                Let's look at the <methodname>Usage</methodname> for the spectrum command.  It appends a 
                summary of the syntax of the <command>spectrum</command> to the contents of result.
                Originally, the result object was passed by reference to this method:
            </para>
            <example>
                <title>Porting <classname>CTCLProcessor</classname> to <classname>CTCLObjectProcessor</classname>
                    substituting std::string for the result
                </title>
                <programlisting>
void 
CSpectrumCommand::Usage(CTCLInterpreter& rInterp, const char* prefix)
{
  std::string rResult = rInterp.GetResultString();
  if (prefix) rResult += prefix;
  rResult += "Usage: \n";
  rResult += "  spectrum [-new] name type { parameters... } {axisdefs... [datatype]y\n";
  rResult += "  spectrum -list ?-byid? ?-showgate? [pattern]\n";
  rResult += "  spectrum -list pattern\n";
  rResult += "  spectrum -list -id ?-showgate? id\n";
  rResult += "  spectrum -delete name1 [name2...]\n";
  rResult += "  spectrum -delete -id id1 [id2...]\n";
  rResult += "  spectrum -delete -all\n";
  rResult += "  spectrum -trace add ?script?\n";
  rResult += "  spectrum -trace delete ?script?\n";
  rResult += "    In the above, an axsidef has one of the following formats:\n";
  rResult += "         n           - n is the Log(2) the number of channels\n";
  rResult += "         {low hi n}  - Full definition where:\n";
  rResult += "                       low  - Parameter value represented by channel 0\n";
  rResult += "                       hi   - Parameter value represented by channel n-1\n";
  rResult += "                       n    - Number of channels on the axis.\n";
  rResult += "\n  The spectrum command creates and deletes spectra as well\n";
  rResult += "  as listing their properties.";
  rResult += " The -trace switch allows the creation, inspection and removal\n";
  rResult += " of traces on adding and deleting spectra\n";
  rInterp.setResult(rResult);
  }
                </programlisting>
            </example>
            <para>
                This technique can be used directly in command or subcommand processors:
                create a local std::string named the same as the original result parameter,
                and just prior to the <literal>return</literal> statement, invoked
                the <methodname>setResult</methodname> method of the interpreter object to
                set the command's result.  One of the overloads of 
                <classname>CTCLInterpreter</classname>::<methodname>setResult</methodname> sets the result
                from an std::string object.
            </para>
        </section>
    </chapter>
    <chapter id='chap.howitworks'>
        <title id='chap.howitworks.title'>How mpiSpecTcl works in parallel mode.</title>
        <para>
        </para>
    </chapter>
    <appendix>
        <title>mpiSpecTcl class references</title>
        <para>
        </para>
    </appendix>
</book>