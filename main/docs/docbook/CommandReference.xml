<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                      "file:///usr/share/xml/docbook/schema/dtd/4.5/docbookx.dtd
"
>
<book>
    <bookinfo>
      <title>SpecTcl Command Reference.</title>
      <author><firstname>Ron</firstname><surname>Fox</surname></author>
      <revhistory>
          <revision>
             <revnumber>1.0</revnumber>
             <date>June 2, 2017 and following</date>
             <authorinitials>RF</authorinitials>
             <revremark>Original Release</revremark>
          </revision>
      </revhistory>
    </bookinfo>

<chapter>
    <title>Introduction</title>
    <para>
        This document provides command reference information for SpecTcl
        beginning with Version 5.0.  The reference material is provided
        in a format similiar to Unix Manpages. 
    </para>
</chapter>
<reference>
    <title>SpecTcl Commands</title>

<!--  Apply Command -->

<refentry id='ref.applycommand'>
    <refmeta>
        <refentrytitle id='ref.applycommand.title'>apply</refentrytitle>
        <manvolnum>1SpecTcl</manvolnum>
    </refmeta>
    
    <refnamediv>
        <refname>apply</refname>
        <refpurpose>Show which gates are applied to which spectra</refpurpose>
    </refnamediv>
    
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
apply <replaceable>gatename spectrum1 ?spectrum2...?</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
apply <option>-list</option>  ?<replaceable>pattern</replaceable>
            </command>
        </cmdsynopsis>
    </refsynopsisdiv>
    
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The <command>apply</command> command applies a gate to one or more
            spectra or, if given the <option>-list</option> option lists spectra
            and the gates applied to them.
        </para>
        <para>
            Application of a gate requires at least two command parameters.
            The first is the name of a gate.  The remaining parametrs are the names
            of spectra to which that gate will be applied.  Once a gate has been
            applied to a spectrum it can only be incremented for events
            that satisfy the gate.
        </para>
        <para>
            The <option>-list</option> option can accept an optional pattern
            parameter.  The pattern parameter accepts glob wild card characters.
            If not provided, <literal>*</literal> is used.
        </para>
    </refsect1>
    
    <refsect1>
        <title>OPTIONS</title>
        <variablelist>
            <varlistentry>
                <term><option>-list</option></term>
                <listitem>
                    <para>
                        Instead of applying a gate to one or more spectra, the
                        presence of this option lists the spectra and the
                        gates applied to them.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title>OUTPUT</title>
        <para>
            A successful <command>apply</command> command
            only produces meaningful output if the <option>-list</option> option
            is used.  In that case, the output is a
            list with a two element sublist for each defined spectrum that
            matches the pattern parameter (recall that if no pattern is provided,
            the patternd defaults to <literal>*</literal> which matches
            everything).
            The first element of that list is the name of the spectrum. The second
            element of the list is a four element list containing in order:
            The name of the applied gate, the gate id, the gate type code and
            the gate definition string.  The contents of the gate definition
            string vary depending on the gate type.
        </para>
    </refsect1>
    <refsect1>
        <title>EXAMPLES</title>
        <example>
            <title>Applying a gate to a single spectrum</title>
            <cmdsynopsis><command>
apply neutrons pid
            </command></cmdsynopsis>
        </example>
        <para>
            The example above applies the gate named <literal>neutrons</literal>
            to the single spectrum named <literal>pid</literal>
        </para>
        <example>
            <title>Applying a gate to several spectra</title>
            <cmdsynopsis><command>
apply alphas energy1 energy2 energy3 energy4
            </command></cmdsynopsis>
        </example>
        <para>
            Applies the gate named <literal>alpha</literal> to four spectra
            named:
            <literal>energy1</literal>,
            <literal>energy2</literal>,
            <literal>energy3</literal> and<literal>energy4</literal>.
        </para>
        <example>
            <title>Listing gates applied to all spectra</title>
            <cmdsynopsis><command>
apply -list
            </command></cmdsynopsis>
        </example>
        <para>
            Results in a list with a two element sublist for each defined spectrum.
            The first element of that list is the name of the spectrum. The second
            element of the list is a four element list containing in order:
            The name of the applied gate, the gate id, the gate type code and
            the gate definition string.  The contents of the gate definition
            string vary depending on the gate type.
        </para>
        <para>
            Suppose the <literal>neutrons</literal> and <literal>alphas</literal>
            gates are both slices.  The output might look something like:
        </para>
        <informalexample>
            <programlisting>
{pid {neutrons 0 s {time {1700.00 1800.00}}}}
{energy1 {alphas 1 s {pid {1200.00 1350.00}}}}
{energy2 {alphas 1 s {pid {1200.00 1350.00}}}}
{energy3 {alphas 1 s {pid {1200.00 1350.00}}}}
{energy4 {alphas 1 s {pid {1200.00 1350.00}}}}
            </programlisting>
        </informalexample>
        <para>
            Note that all spectra have an applied gate.  The gate may, however be
            a <literal>T</literal> gate, which is always satisfied.  For example:
        </para>
        <informalexample>
            <programlisting>
... {ungated-spectrum {-TRUE= 0 T {}}} ...
            </programlisting>
        </informalexample>
        <example>
            <title>Using a filter to list gate applications</title>
            <cmdsynopsis>
                <command>
apply -list e*                    
                </command>
            </cmdsynopsis>
        </example>
        <para>
            For the spectra and application of the previous example, this will
            return:
        </para>
        <informalexample>
             <programlisting>
{energy1 {alphas 1 s {pid {1200.00 1350.00}}}}
{energy2 {alphas 1 s {pid {1200.00 1350.00}}}}
{energy3 {alphas 1 s {pid {1200.00 1350.00}}}}
{energy4 {alphas 1 s {pid {1200.00 1350.00}}}}
            </programlisting>           
        </informalexample>
    </refsect1>
    
    <refsect1>
        <title>SEE ALSO</title>
        <itemizedlist>
            <listitem>
                <para>
                    <link linkend='ref.gatecommand' endterm='ref.gatecommand.title' />
                </para>
            </listitem>
        </itemizedlist>
    </refsect1>
</refentry>

<!--   attach command reference -->
<refentry id='ref.attachcommand'>
    <refmeta>
        <refentrytitle id='ref.attachcommand.title'>attach</refentrytitle>
        <manvolnum>1SpecTcl</manvolnum>
    </refmeta>
    
    <refnamediv>
        <refname>attach</refname>
        <refpurpose>Connect SpecTcl to a data source</refpurpose>
    </refnamediv>
    
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
attach <replaceable>?options? ?sourcetype? connection...</replaceable>
            </command>
        </cmdsynopsis>
    </refsynopsisdiv>
    
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <command>attach</command> connects SpecTcl to a data source.
            If SpecTcl is already connected to a data source, the previous
            data source is first disconnected.
            Once connected to a data source the <command>start</command>
            and <command>stop</command> commands control when data
            is analyzed from that source.
        </para>
        <para>
            There are fundamentally two types of data sources; files and programs
            connected to SpecTcl by a pipe.  The source type is a required
            parameter on the <command>attach</command> command.  Other options
            control SpecTcl's understanding about the data format and how to
            process it.
        </para>
        <para>
            The data source type determines the format of the connection parameters.
        </para>
    </refsect1>
    
    <refsect1>
        <title>OPTIONS</title>
        <para>
            The <command>attach</command> command must have exactly one data
            source option, which determines how the connection parameter(s) are
            processed.  This can be one of:
        </para>
        <variablelist>
            <varlistentry>
                <term><option>-file</option></term>
                <listitem>
                    <para>
                        Data comes from a file.  The connection consists of a
                        single parameter that is the path to the file in the
                        filesystem.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-pipe</option></term>
                <listitem>
                    <para>
                        Data comes from a program.  The program is started using
                        the connection words as command and arguments.  Any
                        number of connection words are allowed but they must,
                        of course, make sense to the program.
                    </para>
                    <para>
                        Programs attached in this way have their stdout connected
                        to a pipe from which SpecTcl reads data.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-list</option></term>
                <listitem>
                    <para>
                        Not actually a data source type, this
                        provides information about the currently attached
                        data source.  If this is provided all other options
                        are ignored.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            The remaining options can be used in any combination:
        </para>
        <variablelist>
            <varlistentry>
                <term><option>-size</option></term>
                <listitem>
                    <para>
                        The number of bytes SpecTcl will read from the data source
                        at any given time.  For some data source formats, this
                        is important (see <option>-format</option> below), for
                        others this just says something about the I/O efficiency
                        of SpecTcl
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-format</option> <replaceable>format-value</replaceable></term>
                <listitem>
                    <para>
                        Specifies the format of the data being analyzed.
                        SpecTcl comes with a set of formats it knows about.
                        This set of formats can be extended as well, however
                        that process is not in the scope of this manual.
                    </para>
                    <para>
                        The value of the <option>-format</option> flag can
                        say something about how strictly the value of
                        <option>-size</option> must be.  Specifically, if
                        you are anlyzing data from a format that uses fixed sized
                        buffering, the <option>-size</option> parameter must
                        match the buffer size.
                    </para>
                    <para>
                        The built in format values are:
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term><literal>nscl</literal></term>
                            <listitem>
                                <para>
                                    This is the 'traditional' nscl daq format
                                    for NSCLDAQ data from versions 8.0 and earlier.
                                </para>
                                <para>
                                    At this time this is only useful for
                                    legacy data.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>jumbo</literal></term>
                            <listitem>
                                <para>
                                    A specialized version of
                                    <literal>nscl</literal> that allowed for
                                    buffer sizes larger than 128Kbytes.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>filter</literal></term>
                            <listitem>
                                <para>
                                    The file is an XDR Filter file.  SpecTcl
                                    must be properly prepared to analyze filter
                                    data.  See the User Guide for more
                                    information.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>ring</literal></term>
                            <listitem>
                                <para>
                                    Data is from nscldaq 10.0 and later, ring
                                    buffer data.  Note that the
                                    <command>ringformat</command> command
                                    may be required to specify the ring buffer
                                    format prior to starting analysis.
                                </para>
                                <para>
                                    If a ring buffer event file is seen from
                                    its very beginning, SpecTcl can and will
                                    automatically determine the ring buffer
                                    format.   If, as is often the case
                                    in online analyais, the data source
                                    connects to the middle of a run, the
                                    <command>ringformat</command> command
                                    must correctly specify the ring format  prior
                                    to issuing the <command>start</command>
                                    command.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </listitem>
            </varlistentry>
            
        </variablelist>
    </refsect1>
    <refsect1>
        <title>OUTPUT</title>
        <para>
            Only the <option>-list</option> produces anything.  If the data
            source is a pipe data source, the words that were used to invoke
            the program are returned.   If the source is a file data source,
            the return value will be <literal>File: </literal><replaceable>file-name</replaceable>.
        </para>
    </refsect1>
    <refsect1>
        <title>EXAMPLES</title>
        <example>
            <title>Attaching to a data file for nscldaq-11:</title>
            <cmdsynopsis><command>
attach -format ring -file /user/fox/stagearea/complete/run-0001-00.evt
            </command></cmdsynopsis>
        </example>
        <para>
            The command above attaches the ring buffer file:
            <filename>/user/fox/stagearea/complete/run-0001-00.evt</filename>
            the <command>start</command> command is needed to start
            analyzing data.  Since this is segment 0 of a file data source,
            by definition SpecTcl will haves sufficient information to
            determine the ring item format.
        </para>
        <example>
            <title>Attaching to the online system via a pipe data source</title>
        <cmdsynopsis><command>
attach -format ring -pipe /usr/opt/daq/current/bin/ringselector --non-blocking --sample=PHYSICS_EVENT  tcp://spdaq20.nscl.msu.edu/e01234
        </command></cmdsynopsis>
        </example>
        <para>
            Uses the <application>ringselector</application> program supplied with
            NSCLDAQ to attach SpecTcl to the online system.  <application>ringselector</application>
            accepts data from a ring buffer and outputs it to stdout making it suitable
            for use as a pipe data source.   The switches use ensure that
            analysis by SpecTcl cannot bottle neck the dataflow.
        </para>
        <para>
            In this case, it's advisable to issue a <command>ringformat</command>
            command prior to intiating analysis.
        </para>
        <example>
            <title>Attaching to a compressed datafile:</title>
            <cmdsynopsis><command>
attach -format ring -pipe zcat /user/fox/stagearea/compressed/run0.gz
            </command></cmdsynopsis>
        </example>
        <para>
            This examples hows that pipe data sources can productively be
            somethingo ther than just connectors to the online system.
            In this case a gzipped event file is analyzed without requiring
            the file exist in uncompressed form.
        </para>
    </refsect1>
    
    <refsect1>
        <title>SEE ALSO</title>
        <itemizedlist>
            <listitem>
                <para>
                    <link linkend='ref.startcommand' endterm='ref.startcommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.stopcommand' endterm='ref.stopcommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.ringformatcommand' endterm='ref.ringformatcommand.title' />
                </para>
            </listitem>
        </itemizedlist>
    </refsect1>
</refentry>
<refentry id='ref.sbindcommand'>
    <refmeta>
        <refentrytitle id='ref.sbindcommand.title'>sbind</refentrytitle>
        <manvolnum>1SpecTcl</manvolnum>
    </refmeta>
    
    <refnamediv>
        <refname>sbind</refname>
        <refpurpose>Store spectrum channels in display share memory</refpurpose>
    </refnamediv>
    
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
sbind -all
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
sbind <replaceable>spectrum-name1 ?spectrum-name2...?</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
sbind -list <replaceable>?pattern</replaceable>
            </command>
        </cmdsynopsis>
    </refsynopsisdiv>
    
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            SpecTcl maintains bulk spectrum storage and abbreviated metadata in
            a shared memory region.  This allows for high performance data
            transfer between it and displayer programs. The <command>sbind</command>
            command, short for <firstterm>spectrum bind</firstterm> binds spectra
            into this shared memory region.   It can also provide information
            about the spectra bound to the shared memory region.
        </para>
    </refsect1>
    
    <refsect1>
        <title>OPTIONS</title>
        <variablelist>
            <varlistentry>
                <term><option>-all</option></term>
                <listitem>
                    <para>
                        Binds all known spectra into the shared memory.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-list</option></term>
                <listitem>
                    <para>
                        Lists spectrum bindings.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title>OUTPUT</title>
        <para>
            Only the <option>-list</option> option produces any useful value.
            The command then produces a list of Tcl Triplets.  Each triplet contains,
            in order; the spectrum id, the spectrum name and the binding slot number.
        </para>
    </refsect1>
    <refsect1>
        <title>EXAMPLES</title>
        <example>
            <title>Binding all spectra to display memory</title>
            <cmdsynopsis>
                <command>
sbind -all
                </command>
            </cmdsynopsis>
        </example>
        <example>
            <title>Binding a list of spectra to the displayer</title>
            <cmdsynopsis><command>
sbind  raw.00 raw.01 raw.02
            </command></cmdsynopsis>
        </example>
        <example>
            <title>
                Listing the bindings of spectra that match a pattern
            </title>
            <cmdsynopsis><command>
sbind -list raw*
            </command></cmdsynopsis>
        </example>
        <para>
            The output of this might be something like:
        </para>
        <informalexample>
            <programlisting>
{1 raw.00 1} {2 raw.00 2} ... {9 raw.09 9}
            </programlisting>
        </informalexample>
    </refsect1>
    
    <refsect1>
        <title>SEE ALSO</title>
        <itemizedlist>
            <listitem>
                <para>
                    <link linkend='ref.spectrumcommand' endterm='ref.spectrumcommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.unbindcommand' endterm='ref.unbindcommand.title' />
                </para>
            </listitem>
        </itemizedlist>   
    </refsect1>
</refentry>
<refentry id='ref.fitcommand'>
    <refmeta>
        <refentrytitle id='ref.fitcommand.title'>fit</refentrytitle>
        <manvolnum>1SpecTcl</manvolnum>
    </refmeta>
    
    <refnamediv>
        <refname>fit</refname>
        <refpurpose>1-d Spectrum fitting computation</refpurpose>
    </refnamediv>
    
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
fit create fitname spectrumname low high type
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
fit update <replaceable>?pattern?</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
fit delete name
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
fit list <replaceable>?pattern?</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
fit proc name
            </command>
        </cmdsynopsis>
    </refsynopsisdiv>
    
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
             The <command>fit</command> command is a command ensemble that
             creates and maniuplates fits of spectrum data.  At present, SpecTcl
             only has builtin support for gaussian fits on a constant background
             and linear fits.
             The programming guide describes how to add fit types to this subsystem
             in a seamless manner.
        </para>
        <para>
            The fit command allows you to specify a region of interest to be
            fit and update the fit parameters based on current data.  A unique
            feature of the fit command is that it can return the definition
            of a Tcl proc that can be used to compute the fit value at
            any point.
        </para>
    </refsect1>
    
    <refsect1>
        <title>SUBCOMMANDS</title>
        <para>
            The <command>fit</command> command is a command ensemble.  This
            means that what the command does depends on a keyword immediately
            following the <command>fit</command> command word.  The sections
            that follow will describe the subcommands <command>fit</command>
            understands.
        </para>
        <refsect2>
            <title>create</title>
            <cmdsynopsis>
              <command>
fit create fitname spectrumname low high type
              </command>
          </cmdsynopsis>
           <para>
                Creates a new fit.  <parameter>fitname</parameter> is the name
                that will be given to the fit.  Each fit has a name that must
                be unique.  It is an error to create a fit with a fit name that
                already exists.
            </para>
            <para>
                Fits are performed on 1D spectra.  <parameter>spectrumname</parameter>
                must be the name of a spectrum that has a single, X axis.
            </para>
            <para>
                <parameter>low</parameter> and <parameter>high</parameter> are
                the channel numbers of the area of interest the fit covers.
                These must be raw channel numbers.  
            </para>
            <para>
                <parameter>type</parameter> is the type of the fit.
                The builtin types are <literal>gaussian</literal>, which performs
                a gaussian fit with a constant background term and
                <literal>linear</literal>.   See
                the Programming Guide for information about how to add
                additional fit types to the system.
            </para>
            <para>
                This command returns the name of the fit as its result.
            </para>
        </refsect2>
        <refsect2>
            <title>update</title>
            <cmdsynopsis>
                <command>
fit update <replaceable>?pattern?</replaceable>
                </command>
            </cmdsynopsis>
            <para>
                Recomputes fit parameters for all fits that match the optional
                glob <parameter>pattern</parameter>.  If the
                <parameter>pattern</parameter> is not supplied it defaults to
                <literal>*</literal> matching all fits. 
            </para>
            <para>
                If the Xamine displayer is used, the fitline displayed on the
                spectrum is updated.  Note that with the Root based Spectra
                displayer it is more normal to use Root's native fitting
                subsystem.
            </para>
            <para>
                This subcommand produces no useful output.
            </para>        
        </refsect2>
        <refsect2>
            <title>delete</title>
            <cmdsynopsis>
                <command>
fit delete name
                </command>
            </cmdsynopsis>
            <para>
                Deletes the fit <parameter>name</parameter>.  All resources
                associated with that fit are released.
            </para>
        </refsect2>
        <refsect2>
            <title>list</title>
            <cmdsynopsis>
                <command>
    fit list <replaceable>?pattern?</replaceable>
                </command>
            </cmdsynopsis>
            <para>
                Lists the fits that match the optional glob
                <parameter>pattern</parameter>.  If <parameter>pattern</parameter>
                is not provided on the command line, it defaults to
                <literal>*</literal> which matches all fits.
            </para>
            <para>
                This command returns a (possibly empty) list of fit descriptions.
                Each fit description is itself a 5 element list containing:
            </para>
            <orderedlist>
                <listitem>
                    <para>
                        The name of the fit
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The name of the spectrum the fit is defined on
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The type of the fit (e.g. <literal>gaussian</literal>).
                        Note that SpecTcl defines both
                        <literal>gaussian</literal>  which is a gaussian function
                        on a constant background and a <literal>linear</literal>
                        fit types
                    </para>
                </listitem>
                <listitem>
                    <para>
                        A two element list that is the area of interest over
                        which the fit was performed.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        A property list that describes the fit parameters.
                        A property list is a list of two item sublists.
                        Each item contains a keyword and a value
                        (the keyword is element 0). The parameters returned by
                        each fit will depend on its fit type as each fit type
                        will have a different set of variable parameters. For
                        example, the gaussian fit has a "centroid" parameter,
                        a linear fit might have a "slope" parameter.
                        See the section
                        "Parameters of supported fits" below for the parameters
                        of fits that are a standard part of SpecTcl. for others
                        either list them and look at the fit property list or
                        consult with the author of the fit. Note that all fits
                        should produce a property named <literal>chisquare</literal>
                        that is the chi-square measure of the goodness of the fit.
                    </para>
                </listitem>
            </orderedlist>
            <refsect3>
                <title>Parameters of supported fit types:</title>
                <formalpara>
                    <title>Gaussian fits</title>
                    <para>
                        See the full functional form of the gaussian below.
                        <variablelist>
                            <varlistentry>
                                <term><literal>baseline</literal></term>
                                <listitem>
                                    <para>
                                        The constant background the gaussian
                                        sits on.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><literal>height</literal></term>
                                <listitem>
                                    <para>
                                        The scaling parameter of the gaussian.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><literal>centroid</literal></term>
                                <listitem>
                                    <para>
                                        The position of the peak.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><literal>sigma</literal></term>
                                <listitem>
                                    <para>
                                        The variance of the peak.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><literal>chisquare</literal></term>
                                <listitem>
                                    <para>
                                        The goodness of fit.
                                    </para>
                                </listitem>
                            </varlistentry>
                        </variablelist>
                    </para>
                </formalpara>
                <para>
                    Using the above parameterization, the functional form of
                    a gaussian fit is:
                </para>
                <informalexample>
                    <literallayout>
 y = baseline + height * exp(-0.5*((x-centroid)/sigma)**2)
                    </literallayout>
                </informalexample>
                <formalpara>
                    <title>
                        Linear fits
                    </title>
                    <para>
                        The following parameters are defined for linear fits:
                        <variablelist>
                            <varlistentry>
                                <term><literal>offset</literal></term>
                                <listitem>
                                    <para>
                                        The Y intercept of the fit line
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><literal>slope</literal></term>
                                <listitem>
                                    <para>
                                        Slope of the fit line.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><literal>chisquare</literal></term>
                                <listitem>
                                    <para>
                                        The goodness of fit measure.
                                    </para>
                                </listitem>
                            </varlistentry>
                        </variablelist>
                    </para>
                </formalpara>
                <para>
                    The form of the linear fit is, of course:
                </para>
                <informalexample>
                    <literallayout>
 y  = offset + slope*x
                    </literallayout>
                </informalexample>
            </refsect3>
        </refsect2>
        <refsect2>
            <title>proc</title>
            <cmdsynopsis>
                <command>
fit proc name
                </command>
            </cmdsynopsis>
            <para>
                Returns the text of a Tcl proc that can evaluate the fit line
                <emphasis>as it is defined at the time of this command</emphasis>
                (the proc does not reflect later <command>update</command> operations).
                The proc can be used to evaluate the fit at any point although
                evaluation outside the area of interest may be meaningless.
            </para>
            <para>
                The fit proc will be named <literal>fitline</literal> and will
                take one parameter, the channel number at which the fit should
                be evaluated.
            </para>
        </refsect2>
    </refsect1>
    
    <refsect1>
        <title>EXAMPLES</title>
        <example>
            <title>Using the <literal>proc</literal> subcommand</title>
            <programlisting>
foreach fit [fit list] {
  set name [lindex $fit 0]
  eval     [fit proc $name]
  rename fitline $name
}
            </programlisting>
        </example>
        <para>
            The example above uses the <command>fit proc</command> command to
            get a proc text for each defined fit.  The <command>eval</command>
            command is then used to create the actual fit proc for Tcl.  The
            <command>rename</command> command then renames the proc, which is
            always called <literal>fitline</literal> to the name of the fit
            so that procs don't step on each other's name.
        </para>
    </refsect1>
</refentry>
<refentry id='ref.foldcommand'>
    <refmeta>
        <refentrytitle id='ref.foldcommand.title'>fold</refentrytitle>
        <manvolnum>1SpecTcl</manvolnum>
    </refmeta>
    
    <refnamediv>
        <refname>fold</refname>
        <refpurpose>Apply a gamma gate as a fold</refpurpose>
    </refnamediv>
    
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
fold -apply <replaceable>ggate-name spectrum1 ?spectrum2 ...?</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
fold -list <replaceable>?pattern?</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
fold -remove <replaceable>spectrum</replaceable>
            </command>
        </cmdsynopsis>
    </refsynopsisdiv>
    
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Folds are a simple mechanism to unravel complex gamma spectra into
            coincident sets of peaks. Whenver a fold is applied to a gamma
            spectrum, if the gate on that spectrum allows the gamma spetrum to
            be incremented, the fold controls the way in which the gamma specrum
            is incremented.
        </para>
        <para>
            Without a fold, a gamma 1d spectrum is incremented once for each
            parameter in the spectrum. A gamma 2d spectrum is incremented once
            for each parameter pair in the spectrum. This provides a means to
            aggregate all of the gamma ray detectors in an experiment into a
            single spectrum.
        </para>
        <para>
            With a fold, each parameter (for a gamma slice) or parameter pair
            (for a gamma band or contour) is checked against the gate. Whenever
            a parameter or pair of parameters satisfies the gate, the spectrum
            is incremented for all other parameters (1D) or parameter pairs
            (2D) that make up the spectrum. The effect is to remove the peak
            around which the gate was drawn and leave only the peaks that occur
            in coincidence with that peak (note that a bump in a 2-d spectrum
            already represents a gamma-gamma coincidence allowing 4-fold
            coincidence spectra to be produced by looking for bumps in a 2-d
            spectrum on which a gamma contour e.g. has been applied).                        
        </para>
    </refsect1>
    
    <refsect1>
        <title>OPTIONS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
fold -apply <replaceable>ggate-name spectrum1 ?spectrum2 ...?</replaceable>
                        </command>
                    </cmdsynopsis>                   
                </term>
                <listitem>
                    <para>
                        Applies the fold <parameter>ggate-name</parameter>
                        to the spectra that follow.  <parameter>ggate-name</parameter>
                        must be a gamma gate and the spectra named must be
                        gamma spectra.
                    </para>
                    <para>
                        Once applied, the gamma spectrum will only be incremented
                        if the parameter(s) don't satisfy the gate, effectively
                        removing the region described by the fold but requiring
                        a coincidence with a gamma in the region described by the
                        fold.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
fold -list <replaceable>?pattern?</replaceable>
                        </command>
                    </cmdsynopsis>                    
                </term>
                <listitem>
                    <para>
                        Lists the set of spectra with folds that match the
                        optional pattern. If the pattern is not supplied, it is
                        taken to be * which matchs all spectra. The result of
                        the fold -list command is a list of spectra with folds.
                        Each list element is, itself a two element list
                        consisting of, in order, the spectrum name and the name
                        of the gate that is used to produce the folded spectrum.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
fold -remove <replaceable>spectrum</replaceable>
                        </command>
                    </cmdsynopsis>                    
                </term>
                <listitem>
                    <para>
                        Removes any fold that is applied to <parameter>spectrum</parameter>
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>

    </refsect1>
    
    <refsect1>
        <title>SEE ALSO</title>
        <itemizedlist>
            <listitem>
                <para>
                    <link linkend='ref.gatecommand' endterm='ref.gatecommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.applycommand' endterm='ref.applycommand.title' />
                </para>
            </listitem>
        </itemizedlist>
    </refsect1>
</refentry>
<refentry id='ref.channelcommand'>
    <refmeta>
        <refentrytitle id='ref.channelcommand.title'>channel</refentrytitle>
        <manvolnum>1SpecTcl</manvolnum>
    </refmeta>
    
    <refnamediv>
        <refname>channel</refname>
        <refpurpose>Access spectrum channels</refpurpose>
    </refnamediv>
    
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
channel -get <replaceable>spname indices</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
channel -set <replaceable>spname indices value</replaceable>
            </command>
        </cmdsynopsis>
    </refsynopsisdiv>
    
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Allows you to set or get the values of channels in a spectrum.
        </para>
    </refsect1>
    
    <refsect1>
        <title>OPTIONS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <option>-get</option>
                </term>
                <listitem>
                    <para>
                        The channnel command will retrieve the contents
                        of the channel of <parameter>spname</parameter>
                        specified by the channel indices <parameter>indices</parameter>/
                        The <parameter>indices</parameter> are raw channel parameters.
                        For a two dimensional spectrum, this must be a list of, in order,
                        x and y channel numbers.
                    </para>
                    <para>
                        The result of the command is the channel value.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-set</option></term>
                <listitem>
                    <para>
                        The channel command will set the value of the channel
                        in <parameter>spname</parameter> specified by the
                        raw channel indices <parameter>indices</parameter> to
                        the new value <parameter>value</parameter>.
                        As with <option>-get</option>, for a 2-d spectrum,
                        the <parameter>indices</parameter> parameter must
                        be a list of x and y channel numbers.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    
    <refsect1>
        <title>EXAMPLES</title>
        <example>
            <title>Getting the value of a channel in a 1-d spectrum</title>
            <programlisting>
channel -set TwodSpectrum {123 456} 100
            </programlisting>
        </example>
        <example>
            <title>Clearing a spectrum using <command>channel</command></title>
            <programlisting>
for {set i 0 } { $i &lt; 128 } {incr i } {
   for {set j 0} {$j &lt; 128 } {incr j } {}
      channel -set TwodSpectrum [list $i $j] 0]
    }
}
            </programlisting>
        </example>
        <para>
            Normally use the <command>clear</command> command instead of this
            method.
        </para>
    </refsect1>
    
    <refsect1>
        <title>SEE ALSO</title>
        <itemizedlist>
            <listitem>
                <para>
                    <link linkend='ref.spectrumcommand' endterm='ref.spectrumcommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.clearcommand' endterm='ref.clearcommand.title' />
                </para>
            </listitem>
        </itemizedlist>
    </refsect1>
</refentry>
<refentry id='ref.clearcommand'>
    <refmeta>
        <refentrytitle id='ref.clearcommand.title'>clear</refentrytitle>
        <manvolnum>1SpecTcl</manvolnum>
    </refmeta>
    
    <refnamediv>
        <refname>clear</refname>
        <refpurpose>Clear spectra</refpurpose>
    </refnamediv>
    
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
clear -all
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
clear <replaceable>spec1 ?spec2...?</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
clear -id <replaceable>id1 ?id2...?</replaceable>
            </command>
        </cmdsynopsis>
    </refsynopsisdiv>
    
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Zeroes the channesl of selected or all spectra.
        </para>
    </refsect1>
    
    <refsect1>
        <title>COMMAND FORMS</title>
        <variablelist>
            <varlistentry>
                <term>
                <cmdsynopsis>
                    <command>
clear -all
                    </command>
                </cmdsynopsis>

                </term>
                <listitem>
                    <para>
                        Clears all spectra.  On completion all channels of all
                        spectra will be zero.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <cmdsynopsis>
                    <command>
        clear <replaceable>spec1 ?spec2...?</replaceable>
                    </command>
                </cmdsynopsis>                    
                </term>
                <listitem>
                    <para>
                        Clears all spectra named spectra. 
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
               <cmdsynopsis>
                    <command>
clear -id <replaceable>id1 ?id2...?</replaceable>
                    </command>
                </cmdsynopsis>                                
                </term>
                <listitem>
                    <para>
                        Clears all spectra whose numeric ids are listed
                        by the command.  Spectra have both names and numeric
                        ids.
                    </para>
                </listitem>
            </varlistentry>
 
        </variablelist>
    </refsect1>
    
    <refsect1>
        <title>EXAMPLES</title>
        <example>
            <title>Clearing all spectra</title>
            <programlisting>
clear -all 
            </programlisting>
        </example>
        <example>
            <title>Clearing spectra given their names</title>
            <programlisting>
clear spec1 spec3                
            </programlisting>
        </example>
        <example>
            <title>Clearing spectra given their ids:</title>
            <programlisting>
clear -id 1 5 7
            </programlisting>
        </example>
        <example>
            <title>Clearing spectra whose names match a glob pattern <literal>r*</literal></title>
            <programlisting>
foreach spectrum [spectrum -list r*] {
   clear -id [lindex $spectrum 0]
}                
            </programlisting>
        </example>
        <para>
            Note that this is not directly supported by the <command>clear</command>
            command but the little script above achieves that.  An exercise for
            the reader is to modify the script so that instead of
            <command>clear -id</command>, spectra are cleared by name.
        </para>
    </refsect1>
    
    <refsect1>
        <title>SEE ALSO</title>
        <itemizedlist>
            <listitem>
                <para>
                    <link linkend='ref.spectrumcommand' endterm='ref.spectrumcommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.channelcommand' endterm='ref.channelcommand.title' />
                </para>
            </listitem>
        </itemizedlist>
    </refsect1>
</refentry>
<refentry id='ref.projectcommand'>
    <refmeta>
        <refentrytitle id='ref.projectcommand.title'>project</refentrytitle>
        <manvolnum>1SpecTcl</manvolnum>
    </refmeta>
    
    <refnamediv>
        <refname>project</refname>
        <refpurpose>Create projections of 2-d spectra</refpurpose>
    </refnamediv>
    
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
project ?-?no?<option>snapshot</option>? <replaceable>sourcespec newspec</replaceable>
</command>
<group>
    <arg>x</arg>
    <arg>y</arg>
</group> <command><replaceable>?contourname?</replaceable></command>
        </cmdsynopsis>
    </refsynopsisdiv>
    
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Creates projections of 2d and gamma 2d spectra.
        </para>
        <para>
            <option>-?no?snapshot</option> controls whether or not the resulting
            spectrum will be incremented as a result of further event analysis.
            If <option>-snapshot</option>, the spectrum will remain static.
            If <option>-nosnapshot</option> or if the switch is omitted,
            SpecTcl will continue to increment the spectrum. See the Detailed
            Description below for information about conditions and foldings
            that might be applied to the projection.            
        </para>
        <para>
            <parameter>sourcespec</parameter> is the name of a 2-d or gamma 2-d
            spectrum whose projection will be created.            
        </para>
        <para>
            <parameter>newspec</parameter> is the name of the new spectrum
            generated by the project command. This spectrum must not exist.            
        </para>
        <para>
            <literal>x|y</literal> is the projection direction.
            <literal>x</literal> means that for each x, the projection is done
            by summing channels for that x along the y direction.
            Similarly, <literal>y</literal> meanns that for each y, the
            projection is done by summing channels for that y along the x
            direction.            
        </para>
        <para>
            <replaceable>contourname</replaceable> If present, this is the name
            of a contour (if 2-d spectrum) or gamma contour (if 2-d gamma).
            The contour must include all parameters in the source spectrum.
            Only the region inside the contour is projected in the specified
            direction.            
        </para>
    </refsect1>
    
    <refsect1>
        <title>Detailed Desription</title>
        <para>
            Projections create new 1-d or 1-d gamma spectra (called the target
            spectrum) from existing 2-d or 2-d gamma spectrum (called the source
            spectrum) by taking a projection (possibily limited by a region of
            interest specified by a contour or gamma contour) in either the
            X or Y direction. There are two specific cases to consider.

           
        </para>
        <formalpara>
            <title>Projections of ordinary 2-d spectra.</title>
            <para>
                The result of projecting an ordinary 2-d spectrum is an
                ordinary 1-d spectrum. If the <option>-snapshot</option> switch
                is supplied, this spectrum will be frozen.
            </para>
        </formalpara>
        <para>
            The target spectrum may automatically have gates applied to it.
            Gates will only be applied to targets that are not snapshot spectra.
            The intent of these gates is to ensure that the target spectrum
            increments in such a way that it remains a faithful projection of
            the source spectrum.            
        </para>
        <para>
            Automatic gating is as follows:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    If the source spectrum is ungated, and the projection is
                    not via a contour, the target spectrum is gated with a
                    "TRUE" gate (is ungated).
                </para>
            </listitem>
            <listitem>
                <para>
                    If the source spectrum is gated, and the projection is not
                    via a contour, the target spectrum is gated with the same
                    gate as the source spectrum.
                </para>
            </listitem>
            <listitem>
                <para>
                    If the source spectrum is not gated, and the projection is
                    via a contour, the projection contour gates the target
                    spectrum.
                </para>
            </listitem>
            <listitem>
                <para>
                    If the source spectrum is gated, and the projection is
                    via a contour, a gate is created that is the 
                    <literal>and</literal> of these two gates and applied to
                    the target spectrum. This <literal>AND</literal> gate will
                    be named:
                    <literal>__PROJECTIONGATE__roi__AND__sourcegate__ </literal>
                    where roi is the projection contour and sourcegate is the
                    name of the gate on the source spectrum.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            Suppose, for example, we have a spectrum named
            <literal>pid_gamma</literal> which is gated on a gamma slice named
            <literal>511kev</literal>, and that the X axis of this spectrum is
            an energy, while the Y is e.g. a de. Suppose this spectrum has a
            contour drawn on it (not applied to it) named 6Li. The command:
        </para>
        <informalexample>
            <cmdsynopsis><command>
project pid_gamma 6Li511kev x 6Li
            </command></cmdsynopsis>
        </informalexample>
        <para>
            Produces a new spectrum named <literal>6Li511kev</literal>
            which is gated on the and of <literal>6Li</literal> and
            <literal>511Kev</literal>. The spectrum is initially filled
            with the projection of <literal>pid_gamma</literal> in the x
            direction within the region of interest defined by the
            contour <literal>6Li</literal>. The and gate created is named
            <literal>__PROJECTION_6Li__AND__511Kev__</literal>
        </para>
    
        <formalpara>
            <title>Projection of gamma 2-d spectra. </title>
            <para>
                The target spectrum of a projection of a 2d gamma spectrum is a
                1d gamma spectrum. If the
                <option>-snapshot</option> switch is supplied, the target is
                frozen.
            </para>
        </formalpara>
        <para>
            The target spectrum may have gates and folds automatically applied
            to it. These gates and folds, in general, will not result in a
            continued faithful projection as the target spectrum increments,
            as the increments of gamma spectra are correlated within the sets of
            parameters gates and folds.
        </para>
        <para>
            If the source spectrrum has a fold applied to it, the same fold will
            be applied to the target spectrum. Gates are applied to the target
            spectrum in the same way they are applied to ordinary 2-d projection
            targets.
        </para>
    </refsect1>

    <refsect1>
        <title>SEE ALSO</title>
        <itemizedlist>
            <listitem>
                <para>
                    <link linkend='ref.spectrumcommand' endterm='ref.spectrumcommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.gatecommand' endterm='ref.gatecommand.title' />
                </para>
            </listitem>
        </itemizedlist>
    </refsect1>
</refentry>
<refentry id='ref.specstatscommand'>
    <refmeta>
        <refentrytitle id='ref.specstatscommand.title'>specstats</refentrytitle>
        <manvolnum>1SpecTcl</manvolnum>
    </refmeta>
    
    <refnamediv>
        <refname>specstats</refname>
        <refpurpose>Return spectrum statistics information</refpurpose>
    </refnamediv>
    
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
specstats <replaceable>?pattern?</replaceable>
            </command>
        </cmdsynopsis>
    </refsynopsisdiv>
    
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Provides some spectrum statistics for the spectra
            with names that match the
            optional <parameter>pattern</parameter>.  If <parameter>pattern</parameter>
            is not supplied, the default value of <literal>*</literal> is used
            which matches all spectra.
        </para>
        <para>
            The result is a list of <command>dict</command>s; one dict for each
            spectrum that matches <parameter>pattern</parameter>.  The
            dicts have the following members:
        </para>
        <variablelist>
            <varlistentry>
                <term><literal>name</literal></term>
                <listitem>
                    <para>
                        Name of the spectrum described by this element
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>overflows</literal></term>
                <listitem>
                    <para>
                        A list of 0, 1 or two elements that are overflow
                        counters for each axis.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>underflows</literal></term>
                <listitem>
                    <para>
                        Same as for <literal>overflows</literal> but the counters
                        represent the number of underflows for each axis.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            Note that the <command>clear</command> clears the over/underflow
            counters as well.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <itemizedlist>
            <listitem>
                <para>
                    <link linkend='ref.clearcommand' endterm='ref.clearcommand.title' />
                </para>
            </listitem>
        </itemizedlist>
    </refsect1>
</refentry>
<refentry id='ref.treeparametercommand'>
    <refmeta>
        <refentrytitle id='ref.treeparametercommand.title'>treeparameter</refentrytitle>
        <manvolnum>1SpecTcl</manvolnum>
    </refmeta>
    
    <refnamediv>
        <refname>treeparameter</refname>
        <refpurpose>Create list or modify characteristics treeparameters</refpurpose>
    </refnamediv>
    
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
treeparameter <option>-create</option> <replaceable>name low high units</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
treeparameter <option>-list</option> <replaceable>?pattern?</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
treeparameter <option>-listnew</option>                
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
treeparameter <option>-set</option> <replaceable>name bins low high inc units</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
treeparameter <option>-setinc</option> <replaceable>name inc</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
treeparameter <option>-setbins</option> <replaceable>name bins</replaceable>
            </command>
        </cmdsynopsis> 
        <cmdsynopsis>
            <command>
treeparameter <option>-setunit</option> <replaceable>name units</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
treeparameter <option>-setlimits</option> <replaceable>name low high</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
treeparameter <option>-check</option> <replaceable>name</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
treeparameter <option>-uncheck</option> <replaceable>name</replaceable>                
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
treeparameter <option>-version</option>
            </command>
        </cmdsynopsis>
     
    </refsynopsisdiv>
    
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The treeparameter command is part of the Tree Parameter package.
            The command allows users or scripts to create list or modify
            characteristics of the defined treeparameters.
        </para>
        <para>
           The first command parameter is a switch that tells the treeparameter
           command what you want it to do.
           The switch also defines the number and meaning of the remaining
           command line parameters. Each of the possibilities is described in
           <literal>COMMAND FORMATS</literal> section below.
        </para>
    </refsect1>
    
    <refsect1>
        <title>COMMAND FORMATS</title>
        <para>
            <command>treeparameter</command> is sort of a command ensemble.
            Instead of the second command word being a keyword subcommand,
            it is an option.  The option specified (they are mutually exclusive),
            determines the operation performed and the number and meaning
            of any remaining parameters.
        </para>
        <para>
            Here are the treeparameter subcommands.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                <cmdsynopsis>
                    <command>
treeparameter <option>-create</option> <replaceable>name low high units</replaceable>
                    </command>
                </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        This subcommand creates a new treeparameter, and if
                        necessary, and underlying parameter.  Normally, however,
                        this is used to give tree parameter attributes to a
                        parameter that does not have an underlying
                        <classname>CTreeParameter</classname> object.
                    </para>
                    <para>
                        <parameter>name</parameter> is the name of the new
                        parameter.  This will bel inked to the an existing underlying
                        parameter.  If necessary a new underlying parameter
                        is created.  This may be needed in systems where parameters
                        can be dynmically created.
                    </para>
                    <para>
                        <parameter>low</parameter> and <parameter>high</parameter>
                        are recommended axis limits for spectra defined on this
                        parameter.  These limits are advisory however.
                    </para>
                    <para>
                        <parameter>bins</parameter> is a suggested number of bins
                        to cover the range <parameter>low</parameter> ..
                        <parameter>high</parameter>.  Again, this is an advisory
                        value.
                    </para>
                    <para>
                        <parameter>units</parameter> are units of measure
                        and only serve to document the units of measure of the
                        parameter.   This can be an empty string if the parameter
                        does not have units of measure.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <cmdsynopsis>
                    <command>
treeparameter <option>-list</option> <replaceable>?pattern?</replaceable>
                    </command>
                </cmdsynopsis>    
                </term>
                <listitem>
                    <para>
                        Returns a list of tree parameter descriptions for the
                        tree parameters that match the optional glob
                        <parameter>pattern</parameter>.   If
                        <parameter>pattern</parameter> is not supplied, it defaults
                        to <literal>*</literal> which matches all tree parameters.
                    </para>
                    <para>
                        Each tree parameter description is, itself, a list
                        of 6 parameters which are in order:
                    </para>
                    <orderedlist>
                        <listitem>
                            <para>
                                The name of the parameter.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                The number of channels recommended on the axis
                                (binning).
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                The recommended low limit for the parameter
                                on a spectrum axis
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                The recommended high limit of the parameter on
                                a spectrum axis.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                The width of a channel in real coordinates if the
                                recommended axis limits and binning are used.
                                This is a value computed from the limits and
                                binning.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                The units of measure of the parameter.  This can
                                be an empty string.
                            </para>
                        </listitem>
                    </orderedlist>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
treeparameter <option>-listnew</option>                
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a (possibly empty) Tcl list of names
                        of parameters that have been created with the
                        <command>treeparameter <option>-create</option></command>
                        command.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <cmdsynopsis>
                    <command>
treeparameter <option>-set</option> <replaceable>name bins low high inc units</replaceable>
                    </command>
                </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Sets a new definitioun for an existing tree parameter;
                        <parameter>name</parameter>. 
                    </para>
                    <para>
                        <parameter>name</parameter> is the name of the parameter.
                        Normaly, this is a period separated list that defines
                        the path through the treeparameter hierarchy to the element.
                    </para>
                    <para>
                        <parameter>bins</parameter> provides the
                        recommended number of channels for this parameter on
                        a spectrum axis.
                    </para>
                    <para>
                        <parameter>low</parameter> provides the default low
                        limit for axes on spectra involving this parameter.
                    </para>
                    <para>
                        <parameter>high</parameter> provides the default high
                        limit for axes on spectra involving this parameter.
                    </para>    
                    <para>
                        <parameter>inc</parameter> provides the default channel
                        width in parameter coordinates.  Note that this parameter
                        is a function of low, high and bins. If the calculated
                        value of inc is not close to the value supplied, an
                        error is returned.
                    </para>
                    <para>
                        <parameter>units</parameter> provides the units label
                        for the spectrum axis.                        
                    </para>    
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <cmdsynopsis>                                    
                    <command>
treeparameter <option>-setinc</option> <replaceable>name inc</replaceable>
                    </command>
                </cmdsynopsis>                    
                </term>
                <listitem>
                    <para>
                        Sets the channel width for <parameter>name</parameter>
                        to <parameter>inc</parameter>.  <parameter>inc</parameter>
                        is a floating point value.
                        This is done by holding the number of axis bins and
                        the low limit contant and recomputing the high limit
                        to achieve the desired width.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <cmdsynopsis>
                    <command>
treeparameter <option>-setbins</option> <replaceable>name bins</replaceable>
                    </command>
                </cmdsynopsis>                     
                </term>
                <listitem>
                    <para>
                        Sets the number of bins for the tree parameter
                        <parameter>name</parameter> to <parameter>bins</parameter>.
                        This is done by holding the low and high limits fixed
                        and adjusting the bin width.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <cmdsynopsis>
                    <command>
treeparameter <option>-setunit</option> <replaceable>name units</replaceable>
                    </command>
                </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        This subcommand sets the units label that is used by
                        the parameter <parameter>name</parameter>
                        to <parameter>units</parameter>. The parameter units
                        are used to label parameter's axes on spectra that
                        involve this parameter when the spectrum is viewed in
                        mapped mode.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <cmdsynopsis>
                    <command>
treeparameter <option>-setlimits</option> <replaceable>name low high</replaceable>
                    </command>
                </cmdsynopsis>                    
                </term>
                <listitem>
                    <para>
                        This subcommand sets the default parameter axis limits
                        for spectra that use created by the GUI. The number of bins is kept constant. This command, therefore, implies a change in the channel width.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <cmdsynopsis>
                    <command>
treeparameter <option>-check</option> <replaceable>name</replaceable>
                    </command>
                </cmdsynopsis>                    
                </term>
                <listitem>
                    <para>
                        Returns 0 if the parameter's modified flag is not set
                        and 1 if it is. Each treeparameter has a modified flag
                        associated with it. Whenever a parameter's properties
                        are modified, this flag is set. 
                    </para>
                    <para>
                        The modified flag is
                        never set as a result of programmatic assignments to
                        the tree parameter value on event by event processing,
                        only by modifying the properties of the parameter.
                        The modified flag is used to determine if a parameter's
                        properties must be seaved to file for later recovery.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <cmdsynopsis>
                    <command>
treeparameter <option>-uncheck</option> <replaceable>name</replaceable>                
                    </command>
                </cmdsynopsis>                    
                </term>
                <listitem>
                    <para>
                        Clears the parameter's modified flag.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <cmdsynopsis>
                    <command>
        treeparameter <option>-version</option>
                    </command>
                </cmdsynopsis>
                    
                </term>
                <listitem>
                    <para>
                        Returns the Tree parameter version string.  This allows
                        you to determine if the features needed by your
                        software are available.  This document describes
                        version <literal>2.1</literal>.   Future versions
                        of this document will indicate which version of the
                        software adds new features to the command.
                    </para>
                </listitem>
            </varlistentry>

        </variablelist>
    </refsect1>
    
    <refsect1>
        <title>EXAMPLES</title>
        <example>
            <title>Creating a new tree parameter</title>
            <cmdsynopsis>
            <command>
 treeparameter -create new.tree.parameter -1.0 1.0 100 mm
            </command>
            </cmdsynopsis>
        </example>
        <para>
            If the parameter <literal>new.tree.parameter</literal> already is
            defined, this tree parameter is linked to it.  If
            <literal>new.tree.parameter</literal> is a tree parameter this is
            an error.  If there is no such parameter it is dynamically created.
        </para>
        <para>
            The parameter is defined to request an axis that gos from -1 to 1
            with 100 bins and  has <literal>mm</literal> as its units of measure.
        </para>
         <example>
            <title>Listing all tree parameters with sample output</title>
            <screen><command>
treeparameter -list
<computeroutput>
{event.raw.00 100 1 100 0.99 channels} 
{event.raw.01 100 1 100 0.99 channels} 
{event.raw.02 100 1 100 0.99 channels} 
{event.raw.03 100 1 100 0.99 channels} 
{event.raw.04 100 1 100 0.99 channels} 
{event.raw.05 100 1 100 0.99 channels} 
{event.raw.06 100 1 100 0.99 channels} 
{event.raw.07 100 1 100 0.99 channels} 
{event.raw.08 100 1 100 0.99 channels} 
{event.raw.09 100 1 100 0.99 channels} 
{event.sum 100 1 100 0.99 arbitrary}
</computeroutput>
            </command></screen>
         </example>
         <example>
            <title>Listing only some parameters (using a pattern)</title>
            <screen><command>
treeparameter -list event.raw*
<computeroutput>
{event.raw.00 100 1 100 0.99 channels} 
{event.raw.01 100 1 100 0.99 channels} 
{event.raw.02 100 1 100 0.99 channels} 
{event.raw.03 100 1 100 0.99 channels} 
{event.raw.04 100 1 100 0.99 channels} 
{event.raw.05 100 1 100 0.99 channels} 
{event.raw.06 100 1 100 0.99 channels} 
{event.raw.07 100 1 100 0.99 channels} 
{event.raw.08 100 1 100 0.99 channels} 
{event.raw.09 100 1 100 0.99 channels}
</computeroutput>
            </command></screen>
         </example>
         <example>
            <title>The treeparameter -check command</title>
            <screen><command>
<prompt>(treeparam) 4 %</prompt> treeparameter -check event.sum
<computeroutput>0</computeroutput>
<prompt>(treeparam) 5 %</prompt> treeparameter -setunit event.sum MeV
<prompt>(treeparam) 6 %</prompt> treeparameter -check event.sum
<computeroutput>1</computeroutput>
            </command></screen>
         </example>
         <para>
            We assume coming into this example that the parameter
            <literal>event.sum</literal> is unmodified.  Changing the parameter's
            units sets its check flag.
         </para>
         <example>
            <title>Unsetting the modified flag:</title>
            <screen><command>
<prompt>(treeparam) 6 %</prompt> treeparameter -check event.sum
<computeroutput>1</computeroutput>
<prompt>(treeparam) 7 % </prompt>treeparameter -uncheck event.sum
<prompt>(treeparam) 8 %</prompt> treeparameter -check   event.sum
<computeroutput>0</computeroutput>
            </command></screen>
         </example>
    </refsect1>
    
    <refsect1>
        <title>SEE ALSO</title>
        <itemizedlist>
            <listitem>
                <para>
                    <link linkend='ref.parametercommand' endterm='ref.parametercommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.treevariablecommand' endterm='ref.treevariablecommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    Programming guide and programmer reference manual tree
                    parameter subsystem.
                </para>
            </listitem>
        </itemizedlist>
    </refsect1>
</refentry>
<refentry id='ref.treevariablecommand'>
    <refmeta>
        <refentrytitle id='ref.treevariablecommand.title'>treevariable</refentrytitle>
        <manvolnum>1SpecTcl</manvolnum>
    </refmeta>
    
    <refnamediv>
        <refname>treevariable</refname>
        <refpurpose>List and manipulate tree variables</refpurpose>
    </refnamediv>
    
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
treevariable <option>-list</option>  <replaceable></replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
treevariable <option>-set</option> <replaceable>name value units </replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
treevariable <option>-check</option> <replaceable>name</replaceable>        
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
treevariable <option>-setchanged</option> <replaceable>name</replaceable>        
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
treevariable <option>-firetraces</option> <replaceable>?pattern?</replaceable>
            </command>
        </cmdsynopsis>
                

    </refsynopsisdiv>
    
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The Tree parameter package provides for a binding between a set of
            Tcl variables and elements of a structured data type.
            Such bound variables are called treevariables Associated with a
            tree variable is a units specificationon that can be used to
            document to the user what is expected for the parameter.
        </para>
        <para>
            Note in the discussion below, that the ordinary Tcl set command can
            be used to modify the value of a treevariable, as Tcl's core sees
            them as ordinary variables.
        </para>
        <para>
            The first command parameter after the treevariable command is an
            option that defines the desired operation, the nmber and the
            meaning of the remaining parameters on the command line. The
            following section describes each valid switch,
            its parameters and what it does.
        </para>
    </refsect1>
    
    <refsect1>
        <title>OPTIONS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
treevariable <option>-list</option>  <replaceable></replaceable>
                        </command>
                    </cmdsynopsis>

                </term>
                <listitem>
                    <para>
                        Lists the properties of all or some of the treevariables.
                        The optional
                        <parameter>pattern</parameter> parameter allows you to
                        select which variables are listed (if omitted all
                        are listed). The pattern is a
                        <firstterm>glob pattern</firstterm> which means that
                        all of the wildcard specifications you can use to
                        select Unix filenames are accepted.
                    </para>
                    <para>
                        The output of this command is a list. Each element of
                        the list describes a single variable. Each parameter 
                        is described as a sublist containing the following
                        elements:
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term><literal>name</literal></term>
                            <listitem>
                                <para>
                                    The name of the variable. This is a period
                                    separated path to a single variable.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>value</literal></term>
                            <listitem>
                                <para>
                                    The current value of the variable.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>units</literal></term>
                            <listitem>
                                <para>
                                    Units of measure of the variable. This 
                                    documents the expected units of measure of
                                    the values given to this parameter.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
treevariable <option>-set</option> <replaceable>name value units </replaceable>
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Modifies both the value and units of a tree variable;
                        <parameter>name</parameter>.
                        The new value of the parameter will be
                        <parameter>value</parameter> and
                        the new units <parameter>units</parameter>. 
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
treevariable <option>-check</option> <replaceable>name</replaceable>        
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        This subcommand returns 0 if the variable's changed
                        flag is false and 1 if it is true. Each tree variable
                        has a changed flag that reflects whether or not the
                        variable's properties have changed. In the case of a
                        treevariable, the properties of a variable are
                        considered to be its value and units. 
                    </para>
                    <para>
                        Being able to determine if treevariable properties
                        have changed allows scripts to know if it is necessary
                        to save these changes.
                    </para>
                </listitem>
            </varlistentry>        
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
treevariable <option>-setchanged</option> <replaceable>name</replaceable>        
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        This subcommand allows you to set the variable changed
                        flag. See
                        <command>treevariable <option>-check</option></command>
                        for more information about what this means.
                    </para>
                </listitem>
            </varlistentry>        
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
treevariable <option>-firetraces</option> <replaceable>?pattern?</replaceable>
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        If there are traces established on the variable
                        and its value has changed since the last attempt to
                        fire its traces, the variables that match
                        <parameter>pattern</parameter> will
                        have
                        <function>Tcl_UpdateLinkedVar</function> called on their behalf.
                    </para>
                    <para>
                        <parameter>pattern</parameter> is a glob pattern.
                        If omitted it defaults to <literal>*</literal> which
                        operates on all parameters.
                    </para>
                    <para>
                        Many Tk widgets have a <option>-variable</option>
                        or <option>-textvariable</option> that maps
                        displays the value of a variable in some part of the widget.
                        These widgets rely on traces to know when to update
                        their state.
                    </para>
                </listitem>
            </varlistentry>        
        </variablelist>
    </refsect1>
    
    <refsect1>
        <title>EXAMPLES</title>
        <example>
            <title>Listing all variables:</title>
            <screen><command>
<prompt>treeparam) 10 % </prompt>treevariable -list
<computeroutput>
{vars.unused.00 0 furl/fort} 
{vars.unused.01 0 furl/fort} 
{vars.unused.02 0 furl/fort} 
{vars.unused.03 0 furl/fort} 
{vars.unused.04 0 furl/fort} 
{vars.unused.05 0 furl/fort} 
{vars.unused.06 0 furl/fort} 
{vars.unused.07 0 furl/fort} 
{vars.unused.08 0 furl/fort} 
{vars.unused.09 0 furl/fort} 
{vars.w1 1 arb/chan} 
{vars.w2 1 arb/chan}
</computeroutput>
            </command></screen>
        </example>
        <example>
            <title>Using a glob pattern; listing variables thaty start with vars.w</title>
            <screen><command>
<prompt>(treeparam) 12 % </prompt>treevariable -list vars.w*
<computeroutput>
{vars.w1 1 arb/chan} 
{vars.w2 1 arb/chan} 
</computeroutput>               
            </command></screen>
        </example>
        <example>
            <title>Modifying value and units of a tree variable</title>
            <screen><command>
<prompt>(treeparam) 15 % </prompt>treevariable -list vars.w1
<computeroutput>{vars.w1 1 arb/chan}</computeroutput>
<prompt>(treeparam) 16 % </prompt>treevariable -set vars.w1 0.5 MeV/channel
<prompt>(treeparam) 17 % </prompt>treevariable -list vars.w1
<computeroutput>{vars.w1 0.5 MeV/channel}</computeroutput>
            </command></screen>
        </example>
        <para>
            If we only wnat to modify the value of a tree variable, without
            changing the units, we can take advantage of the fact that a tree
            variable is a wrapper around a Tcl variable of the same name:
        </para>
        <example>
            <title>Changing only the value of a tree parameter</title>
            <screen><command>
<prompt>(treeparam) 17 % </prompt>treevariable -list vars.w1
<computeroutput>{vars.w1 0.5 MeV/channel}</computeroutput>
<prompt>(treeparam) 18 % </prompt>set vars.w1 1.3
<computeroutput>1.3</computeroutput>
<prompt>(treeparam) 19 % </prompt>treevariable -list vars.w1
<computeroutput>{vars.w1 1.3 MeV/channel}</computeroutput>                
            </command></screen>
        </example>
        <para>
            Since the tree variable wraps a Tcl variable with the same name,
            we can use substitution to ensure we only modify the units of
            a tree variable.  Note that the scope of substitution requires
            us to quote tha variable name or else Tcl will think the name of the
            variable stops at the first <literal>.</literal>.
        </para>
        <example>
            <title>Modifying only the units of a tree variable</title>
            <screen><command>
<prompt>(treeparam) 19 % </prompt>treevariable -list vars.w1
<computeroutput>{vars.w1 1.3 MeV/channel}</computeroutput>
<prompt>(treeparam) 23 % </prompt>treevariable -set vars.w1 ${vars.w1} KeV/channel
<prompt>(treeparam) 24 % </prompt>treevariable -list vars.w1
<computeroutput>{vars.w1 1.3 KeV/channel}</computeroutput>                
            </command></screen>
        </example>
        
    </refsect1>
    
    <refsect1>
        <title>SEE ALSO</title>
        <itemizedlist>
            <listitem>
                <para>
                    <link linkend='ref.treeparametercommand' endterm='ref.treeparametercommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    set(3tcl)
                </para>
            </listitem>
            <listitem>
                <para>
                    trace(3tcl)
                </para>
            </listitem>
        </itemizedlist>
    </refsect1>
</refentry>

<refentry id='ref.filtercommand'>
    <refmeta>
        <refentrytitle id='ref.filtercommand.title'>filter</refentrytitle>
        <manvolnum>1SpecTcl</manvolnum>
    </refmeta>
    
    <refnamediv>
        <refname>filter</refname>
        <refpurpose>Create filtered data sets</refpurpose>
    </refnamediv>
    
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
filter <option>-new</option> <replaceable>filtername gatename {par1 ?par2 ...?}</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
filter <option>-delete</option> <replaceable>filtername</replaceable>        
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
filter <option>-enable</option> <replaceable> filtername</replaceable>        
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
filter <option>-disable</option> <replaceable>filtername</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
filter <option>-regate</option> <replaceable>filtername gatename</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
filter <option>-file</option> <replaceable>filename filtername</replaceable>        
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
filter <option>-list</option> <replaceable>?glob-pattern?</replaceable>        
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
filter <option>-format</option> <replaceable>filtername format</replaceable>
            </command>
        </cmdsynopsis>        
    </refsynopsisdiv>
    
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Filters are SpecTcl objects that hook into the system after the
            event analysis pipeline.  Their purpose two output pre-decoded
            events that contain only part of the information.   The events
            written can be filtered by the requirement to satisfy a gate and the
            parameters written for each event can be filtered to a reduced set
            of parameters.
        </para>
        <para>
            Each filter is fully defined by the following information:
        </para>
        <variablelist>
            <varlistentry>
                <term><literal>Name</literal></term>
                <listitem>
                    <para>
                        The name of the filter must be uniquen and is used
                        to identify he filter to the command.  The name
                        is assigned when a filter is created.  It is an error
                        to define a filter with a duplicate name.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>gate</literal></term>
                <listitem>
                    <para>
                        Filters only write data from an event if the event
                        satisfies  the specified gate.  This reduces the
                        data set.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>filename</literal></term>
                <listitem>
                    <para>
                        The name of the file to which the filtered data are
                        written
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>parameters</literal></term>
                <listitem>
                    <para>
                        For each event the filter writes, only a subset of
                        the parameters will be written.  It is up to the
                        user, when the filter is established, to define
                        this subset.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>state</literal></term>
                <listitem>
                    <para>
                        One of <literal>disabled</literal> or <literal>enabled</literal>.
                        Filters are created in the <literal>disabled</literal> state.
                        Filters only write data when <literal>enabled</literal>.
                        When enabled, they open their output file and start
                        writing data.  When disabled, they close any output file
                        and stop writing data.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            The <command>filter</command> command allows you to define and
            manipulate these parameters.
        </para>
        <note>
            <title>NOTE</title>
            <para>
                Filter output files can contain data from more than one run.
                The filter output file is opened when the filter is created
                and closed when the filter is disabled.
            </para>
        </note>
    </refsect1>
    
    <refsect1>
        <title>OPTIONS</title>
        <para>
            The command options make <command>filter</command> a command ensemble
            whose dispatch keyword is the name of the filter. Options are
            all mutually exclusive.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
filter ?<option>-new</option>? <replaceable>filtername gatename {par1 ?par2 ...?}</replaceable>
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates a new filter.  The new filter,
                        <parameter>filtername</parameter> is created in the disabled
                        state.  It has the default filename of <filename>filter.flt</filename>.
                    </para>
                    <para>
                        The <parameter>gatename</parameter> parameter must be the
                        name of the gate that determines which events are written.
                        This gate must exist, however it could be a placeholder
                        (<literal>True</literal>) gate that is later modified
                        to be the desired condition.
                    </para>
                    <para>
                        The final parameter is a Tcl list of the names of the
                        parameters to be written when the filter writes an event.
                    </para>
                    <para>
                        Normally after createing a filter, you should change
                        the output filename and, when you want to write data,
                        enable it.  When you are doe writing data the filter should
                        be disabled and the output file changed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
filter <option>-delete</option> <replaceable>filtername</replaceable>        
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Deletes the filter named <parameter>filtername</parameter>.
                        It is an error to attempt to delete a filter that does
                        not exist.  All of SpecTcl's resources associated with
                        the filter are destroyed.
                    </para>
                    <para>
                        Note that to ensure that any data buffered by the filter
                        is flushed to file, you should disable a filter
                        prior to deleting it.  When SpecTcl exits normally it will
                        flush data associated with all enabled filters and close their
                        files properly.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
filter <option>-enable</option> <replaceable> filtername</replaceable>        
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Enables the filter.  Enabled filters write data
                        to their output files.  If the filter does not
                        have an output file established, this is an error.
                    </para>
                    <para>
                        If the filter is enabled it is first disabled which
                        flushes data and closes the output file.  Note that
                        enabling an already enabled filter does not
                        necessarily mean that the filter file is overwritten.
                        If the order is enable, establish a new filter file
                        enable the next data will be written to the newly
                        established filter file.
                    </para>
                </listitem>
            </varlistentry>        
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
filter <option>-disable</option> <replaceable>filtername</replaceable>
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        If the filter is enabled, flushes any buffered data to the
                        output file, closes it an stops writing data.   If the
                        filter is already disabled, specific filter formats
                        may throw an error.
                    </para>
                </listitem>
            </varlistentry>        
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
filter <option>-regate</option> <replaceable>filtername gatename</replaceable>
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Changes the gate on <parameter>filtername</parameter>
                        to <replaceable>gatename</replaceable>. It is legal,
                        though not recommended to change that gate while writing
                        a filter file.  This is because the output will  then not
                        represent a consistent data set.
                    </para>
                </listitem>
            </varlistentry>        
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
filter <option>-file</option> <replaceable>filename filtername</replaceable>        
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Sets a new <parameter>filename</parameter> for the
                        <parameter>filtername</parameter>.  Note that if the
                        filter is enabled, the old file name continues to be
                        the destination for filtered data until the filter
                        is disabled and enabled (or just re enabled).
                    </para>
                </listitem>
            </varlistentry>        
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
filter <option>-list</option> <replaceable>?glob-pattern?</replaceable>        
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Lists the filters whose names match the
                        optional <parameter>glob-pattern</parameter>.  If
                        the <parameter>glob-pattern</parameter> is not supplied,
                        it defaults to <literal>*</literal> which matches all
                        filter names.
                    </para>
                    <para>
                        The result of this command is a list of filter descriptions.
                        Each element of the list describes one filter.  Each
                        filter description is, itself, a list that contains
                        the following elements:
                    </para>
                    <orderedlist>
                        <listitem>
                            <para>
                                The name of the filter.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                The name of the gate that must be satisfied
                                for an event to be written by the filter.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                The name of the file the filter will or is
                                writing to.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                The list of parameters the filter will write.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                The string <literal>enabled</literal> if the
                                filter is enabled or <literal>disabled</literal>
                                if not.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                The filter format string (e.g. <literal>xdr</literal>).
                            </para>
                        </listitem>
                    </orderedlist>
                </listitem>
            </varlistentry>        
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
filter <option>-format</option> <replaceable>filtername format</replaceable>
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Specifies the format of the filter.
                        <parameter>format</parameter> will be the new
                        filter format for <parameter>filtername</parameter>.
                        Filters default
                        to <literal>xdr</literal> format.  The filter format
                        set can be extended, however.  An example of this is
                        the root filter format plugin which adds the ability
                        to write filter data as root ntuples.
                    </para>
                    <para>
                        It is not legal to change the format of an enabled filter.
                        You must first disable the filter, before you can change
                        its format.  Unless you've already changed its format
                        you don't need to explicitly set the default filter format
                        to <literal>xdr</literal>.  That's the default.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    
    <refsect1>
        <title>EXAMPLES</title>
        <example>
            <title>Creating a filter</title>
            <screen><command>
<prompt>%</prompt> filter george Slice {Distribution1 Distribution2}
<computeroutput>george Slice /user/fox/filter.flt {Distribution1 Distribution2} disabled xdr</computeroutput>
<prompt>%</prompt> filter harry Band1 Distribution3
<computeroutput>harry Band1 /user/fox/filter.flt {Distribution3} disabled xdr</computeroutput>
            </command></screen>
        </example>
        <para>
            Creates two filters named george and harry.  For george, only the
            parameters Distribution1 and Distribution2 are written to the output
            filter file. For Harry,  only Distribution3 is written.  Note that
            both filters are disabled, and the filenames for both filters are t
            he same. 
        </para>
        <para>
            The filter formats have also default to <literal>xdr</literal>.
        </para>
        <example>
            <title>Setting filter filenames</title>
            <screen><command>
<prompt>%</prompt> filter -filename george.flt george
<computeroutput>harry Band1 /user/fox/filter.flt {Distribution3} disabled xdr</computeroutput>
<prompt>% </prompt>filter -filename harry.flt harry
<computeroutput>harry Band1 harry.flt {Distribution3} disabled xdr</computeroutput>
            </command></screen>
        </example>
        <example>
            <title>Enabling filters</title>
            <screen><command>
<prompt>%</prompt> filter -enable george
<computeroutput>george Slice george.flt {Distribution1 Distribution2} enabled xdr</computeroutput>
            </command></screen>
        </example>
        <para>
            From this point forward, until disabled, the filter <literal>george</literal>
            will write data to the file <filename>george.flt</filename> whenever
            the gate <literal>Slice</literal> is satisfied.  The output file
            will only contain data for parameters <literal>Distribution1</literal>
            and <literal>Distribution2</literal>.
        </para>
    </refsect1>
    
    <refsect1>
        <title>SEE ALSO</title>
        <itemizedlist>
            <listitem>
                <para>
                    <link linkend='ref.gatecommand' endterm='ref.gatecommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.parametercommand' endterm='ref.parametercommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.treeparametercommand' endterm='ref.treeparametercommand.title' />
                </para>
            </listitem>
        </itemizedlist>
    </refsect1>
</refentry>

<refentry id='ref.gatecommand'>
    <refmeta>
        <refentrytitle id='ref.gatecommand.title'>gate</refentrytitle>
        <manvolnum>1SpecTcl</manvolnum>
    </refmeta>
    
    <refnamediv>
        <refname>gate</refname>
        <refpurpose>Create, list, delete gates</refpurpose>
    </refnamediv>
    
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
gate <replaceable>name type description</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
gate <option>-list</option> <option>?-byid?</option> <replaceable>?pattern?</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
gate <option>-delete</option> <option>?-id?</option> <replaceable>gate1 ?gate2 ...?</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
gate <option>-trace</option> <replaceable>subcommand arg1 ...</replaceable>
            </command>
        </cmdsynopsis>
    </refsynopsisdiv>
    
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Using the gate command you can:            
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Create a new gate
                </para>
            </listitem>
            <listitem>
                <para>
                    list the existing gates sorted by name or gate id and filtered by pattern.
                </para>
            </listitem>
            <listitem>
                <para>
                    Delete an existing set of gates by name or id.
                </para>
            </listitem>
            <listitem>
                <para>
                    Define traces, Tcl scripts that are invoked when
                    there are changes to the gate dictionary.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            If the first command parameter is not either the -list or -delete
            switch then a new gate is created.   Otherwise the action is as
            indicated by the switch.
        </para>
        <para>
            Gates are conditions which can be applied to a set of spectra to
            control when that spectrum is incremented. 
        </para>
        <para>
            The gate command is quite complex.  The complexity comes from the
            rich set of gate types the gate command supports and the need
            to understand how those gate types are described both when creating
            and listing gates.
            Fortunately, most GUI's and the
            displayers make it unecessary to actually know how to use the
            command directly.  <literal>COMMAND DETAILS</literal> below
            describes how to create, delete and list gates.
        </para>
    </refsect1>
    
    <refsect1>
        <title>COMMAND DETAILS</title>
        <para>
            In this section we're going to describe:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    How to create gates, paying special attention to the types of
                    gates supported by SpecTcl and how to describe them.
                </para>
            </listitem>
            <listitem>
                <para>
                    How to list gates and what to expect from the gate description
                    for the various types of SpecTcl supported gates.
                </para>
            </listitem>
            <listitem>
                <para>
                    How to delete gates and what it actually means to delete
                    a gate in terms of gate processing.
                </para>
            </listitem>
            <listitem>
                <para>
                    How to define gate traces
                </para>
            </listitem>
        </itemizedlist>
        <refsect2>
            <title>Creating a gate</title>
            <para>
                The form of the gate creation command is deceptively simple:
            </para>
            <cmdsynopsis>
                <command>
gate <replaceable>name type description</replaceable>
                </command>
            </cmdsynopsis>
            <para>
                First the basics.  <parameter>name</parameter> is a name that
                you give to the gate that must be unique.  Gates are considered
                mutable.  Therefore, be careful because re-defining an existing
                gate does exactly that, it changes the definition of that gate.
                That change happens immediately relative to event processing.
                In addition to the gate name, gates are assigned a numeric
                <firstterm>id</firstterm> which normally you don't need to know
                about.
            </para>
            <para>
                The <parameter>type</parameter> is a text string that
                identifies the type of gates that can be created.  In the
                subsection <literal>Gate Types</literal> we'll go over each gate
                type.  Understanding the SpecTcl gate types and how to create them
                is an important part of your SpecTcl knowledge.
            </para>
            <para>
                The <parameter>description</parameter> describes the gate being
                made.  In general it is a Tcl list.  The actual contents of that
                list will depend on the type of gate being created.  The
                subsection <literal>Gate Descriptions</literal> will document
                the form of gate descriptions for  each gate type.  Note that
                there are slight differences between these descriptions and
                what you get from <command>gate</command> <option>-list</option>.
            </para>
            <para>
                The gate creation command does not return a result.
            </para>
            <refsect3>
                <title>Gate Types</title>
                <para>
                    SpecTcl provides a rich complement of gate types.  These
                    gate types, allow you great control over when a spectrum
                    is incremented. 
                </para>
                <para>
                    SpecTcl has two classes of gate types, simple (sometimes
                    called primitive) and compound.  A simple gate is defined in
                    terms of some condition in parameters while a compound gate
                    is defined on one or more other gates.
                </para>
                <para>
                    It is important to note that the gates a compound gate
                    is defined on can be a mix of simple and compound gates.
                    This allows you to incrementally build up arbitratry
                    logical conditions.
                </para>
                <para>
                    It is important to also note that simple gates, while they
                    may be entered graphically on spectra are defined on the
                    underlying parameters of that spectrum, not the spectrum.
                    Their existence, once created is totally independent of the
                    spectrum used to define them.  Thus while we can talk about
                    a gate being drawn on or displayed on a spectrum, it's not correct
                    to talk about a gate defined on a spectrum.
                </para>
                <para>
                    Without further ado, let's look at the gate types and their
                    <parameter>type</parameter> codes as they must be used
                    in gate creation and as they are displayed in gate lists.
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>*</literal> - And gate</term>
                        <listitem>
                            <para>
                                A compound gate.  The And gate is made up of
                                a list of any number of gates
                                called <firstterm>constituent gates</firstterm>.
                                The And gate is satisfied only if
                                <emphasis>all</emphasis> of its constituent gates
                                are satisfied.
                            </para>
                            <para>
                                Note that if a gate cannot be evaluated for an
                                event because, for example, one or more of the
                                parameters it depends on is not defined for
                                the event, that gate is considered
                                <literal>false</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>b</literal> Band</term>
                        <listitem>
                            <para>
                                Bands are simple gates.  They are defined on
                                a pair of parameters.  Those parameters define
                                a two dimensional space.   
                            </para>
                            <para>
                                A band has an
                                arbitrary number of points which define a polyline
                                in that two dimensional space.  
                            </para>
                            <para>
                                Each event that has both of the parameters
                                needed to define the band defines a point in the
                                two dimensional paramter space.  If that point is
                                below the band, the gate is satisfied.
                            </para>
                            <para>
                                While you can specify a band that backtracks,
                                This means only that the space below the highest
                                part of the polyline is in the gate.
                            </para>
                            <para>
                                The figure below shows what I mean by this:
                            </para>
                            <figure>
                                <title>A band draw with backtracking</title>
                                <graphic format='PNG' fileref='pathalogicalband.png' />
                            </figure>
                            <para>
                                The black region is the space that satisfies the
                                gate.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>c</literal> Contour</term>
                        <listitem>
                            <para>
                                A countour gate is defined in a manner similiar
                                to a band.  A set of points are provided in a
                                the two dimensional space defined by a pair of
                                parameters.  These points define a closed region
                                of space by connecting the last point with the
                                first point (with a line segment).
                            </para>
                            <para>
                                Contours are satsified for events that have both
                                of the parameters they depend on and for which
                                the point defined by those parameters lies inside
                                the closed figure.
                            </para>
                            <para>
                                It's possible to define some fairly pathalogical
                                figures for which the interior may be difficult
                                to discern.  SpecTcl uses the
                                <firstterm>odd crossing rule</firstterm> to
                                define the interior of a figure.  This is well
                                defined for arbitrarily pathalogical contours.
                            </para>
                            <para>
                                The odd crossing rule means that for any point,
                                draw a ray from that point in any direction.
                                If the ray crosses an odd number of boundaries of the
                                contour it is considered inside the contour.
                            </para>
                            <para>
                                The midly pathalogical contour in the figure
                                below has its interior shaded under this rule:
                            </para>
                            <figure>
                                <title>Contour interior</title>
                                <graphic format='PNG' fileref='contourinterior.png' />
                            </figure>
                        </listitem>
                    </varlistentry><varlistentry>
                        <term><literal>c2band</literal> Two bands to a contour</term>
                        <listitem>
                            <para>
                                A contour formed by joining the endpoints of
                                two bands defined on the same set of parameters.
                                This joining is done statically.  Therefore,
                                while the gate is formed of two other
                                gates (bands),  it becomes a primitive contour
                                in behavior.
                            </para>
                            <para>
                                You can think of this gate as a convenience
                                for turning a series of bands into a set
                                of countours.  A downside to this type of
                                gate is that each time you need to change the
                                definition (move) one of the two bands, you
                                also must remember to change the c2band gates
                                that depend on it.  See, however
                                <literal>Gate Traces</literal> below for
                                a mechanism that can automate this process.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>F</literal> False gate</term>
                        <listitem>
                            <para>
                                A false gate is a simple gate that is never
                                satisfied.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>gb</literal> Gamma Band</term>
                        <listitem>
                            <para>
                                An open set of points forming a polyline on a
                                spectrum. Applied as a fold to a 1-d gamma
                                spectrum, for all pairs of parameters below
                                the polyline, increments for all parameters in
                                the spectrum which are not in the pair. Applied
                                as an ordinary gate to any spectrum via apply
                                the gate is true whenever any pair of parameters
                                in the gate is under the band.
                            </para>
                            <para>
                                Applied to a 2-d spectrum as a fold, for all
                                pairs of parameters, (p1, p2), below the
                                polyline, increments for all pairs of
                                parameters, (x, y) in the spectrum such that
                                (p1, p2) and (x, y) have no intersection.
                                As a gate to any spectrum via the apply
                                command, the gate is true whenever any pair of
                                parameters that make up the gate lie under the band.
                            </para>
                            <para>
                                The same rules for determining which points
                                are under the band are used for gamma bands
                                that are used for ordinary bands.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>gc</literal> Gamma contour</term>
                        <listitem>
                            <para>
                                Closed polygon of points drawn on a 2-d spectrum.
                                The lines may cross abitrarily many times,
                                and the same 'odd-crossing' rule used by contours
                                is used to determine the interior of the shape.
                                Used as a fold on a
                                1-d gamma spectrum, for all pairs of
                                parameters in the interior of the polygon,
                                increments for all parameters in the spectrum
                                which are not in the pair.
                            </para>
                            <para>
                                When applied to a spectrum
                                (<command>apply</command>):
                                This gate has identical meaning to the gamma
                                band but parameter pairs must lie within the
                                contour (according to the odd crossing rule)
                                to make the gate true.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>gs</literal> Gamma slice</term>
                        <listitem>
                            <para>
                                A lower and upper limit set on a spectrum.
                                Applied as a fold to a 1-d spectrum, for all
                                parameters within the bounds of the upper and
                                lower limits, increments for all other
                                parameters in the spectrum.
                            </para>
                            <para>
                                Applied as a gate to any spectrum, via apply,
                                is true whenever any parameter in the gate
                                definition is in the slice.
                            </para>
                            <para>
                                Applied as a fold to a 2-d spectrum, for all
                                parameters within the bounds of the upper and
                                lower limits, increments for all pairs of
                                parameters in the spectrum such that neither
                                parameter in the pair is in the slice.
                            </para>
                            <para>
                                Applied as a gate via apply is true whenever
                                any parameter in the gate is inside the slice.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>-</literal> Not gate</term>
                        <listitem>
                            <para>
                                Takes one and only one constituent gate.  This gate
                                is the logical inverse of its constituent.  If
                                its constituent is satisfied, the not gate is
                                not satisfied.  If the constituent is not satisfied,
                                the not gate is satisfied.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>+</literal> Or gate</term>
                        <listitem>
                            <para>
                                Gate is true if any of the constituent gates is true.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>s</literal> Slice</term>
                        <listitem>
                            <para>
                                Sometimes also called a <firstterm>cut</firstterm>.
                                A lower and upper limit set on a single
                                parameter.  True if the point is in the
                                interval [low,high).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>T</literal> True gate</term>
                        <listitem>
                            <para>
                                This gate is always satisfied. When you creaete
                                a spectrum, a true gate comes pre-applied to it.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>em</literal> Mask equal</term>
                        <listitem>
                            <para>
                                Intended for integer parameters that represent
                                bit registers or other masks.
                                Gate returns true whenever the parameter is equal
                                to a user defined bit pattern.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>am</literal> And mask</term>
                        <listitem>
                            <para>
                                Intended for integer parameters that represent
                                bit masks.
                                Gate returns true whenever the parameter value
                                bitwise anded with the user defined bit pattern
                                is equal to the user defined bit pattern.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>nm</literal> Nand mask</term>
                        <listitem>
                            <para>
                                Intended for integer parameters that represent
                                bit masks.
                                Gate returns true whenever the parameter value
                                bitwise anded with the bitwise not of the user
                                defined bit pattern equals the bitwise not of
                                the user defined bit pattern.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect3>
            <refsect3>
                <title>Gate Descriptions</title>
                <para>
                    This section describes the <parameter>descripion</parameter>
                    parameter of the gate creation command.  For the
                    descriptions returned by <command>gate</command>
                    <option>-list</option>, see <literal>Listing gates</literal>
                    below.
                </para>
                <para>
                    In general the <parameter>description</parameter> gate creation
                    parameter is a Tcl list.
                    The description of each gate type has its own requirements,
                    however.
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>*</literal> And gates.</term>
                        <listitem>
                            <para>
                                The description is a properly formatted Tcl
                                list containing the names of the constituent gates.
                                For each event, all gates must be evaluated and
                                true to satisfy the gate.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>b</literal> Band and <literal>c</literal> Contour gates.</term>
                        <listitem>
                            <para>
                                The desription is a three element list.  The first
                                two elements are the names of the X and Y
                                parameters the gate is checked on, in that order.
                                The last parameters is a list of X, Y
                                coordinate pairs.  Each pair is a two element list.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>c2band</literal> Contour from 2 bands</term>
                        <listitem>
                            <para>
                                The description is a two element list of the
                                two bands that are used to create the contour.
                                The last point of the first gate is connected to the
                                last point of the second gate.  The first point of
                                the first gate is connected to the first point  of
                                the second gate to form the contour.
                                Line segments are used to perform these joins.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>F</literal> false or <literal>T</literal> true gate</term>
                        <listitem>
                            <para>
                                The description is empty.  Note the description
                                cannot be empty. It must be an empty Tcl list.
                                For example <literal>{}</literal> or more
                                verbosely: <command>[list]</command>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>gb</literal> Gamma band and <literal>gc</literal> Gamma contour gates</term>
                        <listitem>
                            <para>
                                The description of this is a two element list
                                The first element of the list is the ordered list
                                of X/Y coordinates that define the contour or
                                the band.  The second element of the list are the
                                names of parameters the gate is checked against.
                            </para>
                            <para>
                                Note that for gamma gates only a minimal number
                                of the parameters (2 for these gates) need to
                                be defined to evaluate the gate.  Not all of
                                the parameters.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>gs</literal> Gamma slice gate</term>
                        <listitem>
                            <para>
                                The description is a two element list.
                                The first element of the list is itself a
                                two element list that contains the low and
                                high limits of the cut.  This defines
                                an interval of the form
                                <literal>[low, high)</literal>, that is inclusive
                                of the low limit and exclusive of the high limit.
                            </para>
                            <para>
                                The second list element is a list of the names
                                of parameters the gate is checked against.  Unlike
                                non-gamma gates only at least one of these parameters
                                must be present
                                in an event for the gate to be checked.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>-</literal> Not Gate</term>
                        <listitem>
                            <para>
                                The description for this is the name of the
                                single gate whose sense is negated to make this
                                gate.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>+</literal> Or Gate.</term>
                        <listitem>
                            <para>
                                The description is a list of the names of
                                the constituent
                                gates that will be ORed together.  The
                                gate is satisfied for any event for which at
                                least one of the constituent gates is
                                true.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>s</literal> Slice gate</term>
                        <listitem>
                            <para>
                                The description is a two element list.  The
                                first element of the list is the parameter on
                                which the gate is checked. The second is
                                a two element list that contains, in order,
                                the low and high limits of the gate.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <literal>em</literal> equal mask,
                            <literal>am</literal> and mask and
                            <literal>nm</literal> Not mask.
                        </term>
                        <listitem>
                            <para>
                                The description of these gate types are all
                                two element lists where the first element is
                                the name of the parameter checked and the
                                second is the bitmask used in the check
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect3>
        </refsect2>
        <refsect2>
            <title>Listing gates</title>
            <para>
                The form of this command is:
            </para>
            <cmdsynopsis>
                <command>
gate <option>-list</option> <option>?-byid?</option> <replaceable>?pattern?</replaceable>
                </command>
            </cmdsynopsis>
            <para>
                The result of the command is a Tcl list of the gates that
                have names which
                match the optional <parameter>pattern</parameter> parameter.
                If <parameter>pattern</parameter> is not provided to the
                command, <literal>*</literal> is used which matches
                all gates.
            </para>
            <para>
                If <option>-byid</option> is present, the gates are sorted by
                their numeric id.  If not, the gates are sorted by their
                names.  The gate id is a unique,
                immutable number assigned to each gate
                when it is created.
            </para>
            <para>
                Each element of the list returned by this command describes
                one gate.    Each description is a four element list containing
                in order:
            </para>
            <orderedlist>
                <listitem>
                    <para>
                        The name of the gate
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The id of the gate.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The type code for the gate.  The type code is the same
                        as the type code used to create the gate.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        A description of the gate that is type code dependent.
                    </para>
                </listitem>
            </orderedlist>
            <para>
                The last element of the gate description list is a type dependent
                description of the gate.  This description contains the information
                needed to define the gate.  Here is the form of that description
                for each of the gate type codes:
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <literal>*</literal> and <literal>+</literal> or
                        gates
                    </term>
                    <listitem>
                        <para>
                            The final element of the gate description is
                            a list of the constituent gtates for this gate type.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <literal>F</literal> false and <literal>T</literal>
                        true gates.
                    </term>
                    <listitem>
                        <para>
                            The final element of the gate description is an
                            empty list as these gates are constants.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <literal>gb</literal> Gamma band or
                        <literal>gc</literal> Gamma contour
                    </term>
                    <listitem>
                        <para>
                            The final description element is a two element list.
                            The first element is a list of coordinate points
                            that define the gate in parameter space.  The
                            second element is the list of parameters the
                            gate is defined on.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>gs</literal> Gamma slice</term>
                    <listitem>
                        <para>
                            The final description element is a two element list.
                            The first element is itself a two element list
                            containing the low and high limits of the slice.
                            The second  element is a list of the parameters
                            on which the gate is defined.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>-</literal> not</term>
                    <listitem>
                        <para>
                            The final description element is just the name
                            of the gate this gate will invert.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>s</literal> Slice</term>
                    <listitem>
                        <para>
                            The final description element is a two element list.
                            The first element is the parameter on which the
                            gate is defined.  The second element is a
                            list containing the lower and upper limit of the slice.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <literal>em</literal> Equal mask,
                        <literal>am</literal> and mask and
                        <literal>nm</literal> not mask.
                    </term>
                    <listitem>
                        <para>
                            The last element of the description is a two element
                            list containing in order, the parameter the gate
                            is defined on and the mask to check.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect2>
        <refsect2>
            <title>Deleting gates</title>
            <para>
                The form of the delete command is:
            </para>
            <cmdsynopsis>
                <command>
gate <option>-delete</option> <option>?-id?</option> <replaceable>gate1 ?gate2 ...?</replaceable>
                </command>
            </cmdsynopsis>
            <para>
                First let's look at what it means to delete a gate.  Just
                removing a gate from the SpecTcl gate dictionary has the problem
                that there may be gates that depend on it.  Or gates that depend
                on gates that depend on it.  What does it mean for those gates
                that a constituent has been deleted?
            </para>
            <para>
                In order to provide consistent meaning to those and other cases,
                SpecTcl doesn't actually delete gates you tell it to delete.
                Instead it redefines them as False gates.  Gates that are never
                satisified.  Most GUIs understand this and suppress the listing
                of False gates.
            </para>
            <formalpara>
                <title>The <option>-id</option> option</title>
                <para>
                    Recall that gates are assigned a numeric id.  If you
                    use the <option>-id</option> option on the
                    <option>-delete</option> command, the <parameter>gate1 ?gate2...</parameter>
                    parameters are gate ids rather than names.  If you don't,
                    then those parameters are expected to be the names of the
                    gates you want to delete.
                </para>
            </formalpara>
        </refsect2>
        <refsect2>
            <title>Gate Traces</title>
            <para>
                The format of the trace command is
            </para>
            <cmdsynopsis>
                <command>
gate -trace </command><group>
    <arg>add</arg><replaceable> ?script?</replaceable>
    <arg>delete</arg><replaceable> ?script?</replaceable>
    <arg>change</arg> <replaceable> ?script?</replaceable> </group>

            </cmdsynopsis>
            <para>
                Gate traces allow you to establish a script that is executed when
                gates are added, deleted or changed.  One potential application
                for this is to automatically update a c2band if one of the
                constituents changes.  Other applications are to inform
                a GUI that the list of gates being displayed must be updated.
            </para>
            <para>
                The command word that follows the <option>-trace</option> option
                indicates which of the three traces we are interested in.
                <literal>add</literal> traces are invoked when a new gate is
                created.  <literal>delete</literal> traces, when a gate is
                deleted.  <literal>change</literal> traces are invoked when
                an existing gate is modified.
            </para>
            <para>
                Regardless of the form of the command, the trace script  established
                prior to the command is returned.  If no trace script has been
                established, an empty string is returned.  
            </para>
            <para>
                If no <parameter>script</parameter> parameter is supplied,
                no change is made to the trace.  If the <parameter>script</parameter>
                parameter is an empty string, traces are turned off.  If the
                <parameter>script</parameter> parameter is a non-empty string,
                That string replaces any existing trace for that event.
            </para>
            <para>
                Unless you know exactly what the previous trace was, your
                trace scripts should also give prior traces a chance to
                execute.  Each trace script is passed the name of the
                on which the trace operation is being performed.
            </para>
        </refsect2>
    </refsect1>
    
    <refsect1>
        <title>EXAMPLES</title>
        <example>
            <title>Creating a slice gate</title>
            <screen><command>
gate exampleSlice s {someParameters {100 200}}
            </command></screen>
        </example>
        <example>
            <title>Listing all gates</title>
            <screen><command>
gate -list
            </command></screen>
        </example>
        <example>
            <title>Deleting a gate</title>
            <screen><command>
gate -delete exampleSlice
            </command></screen>
        </example>
        <example>
            <title>Establishing a trace</title>
            <programlisting>
set oldTrace ""
proc myTrace name {
    # Execute any prior trace
    
    if {$::oldTrace ne ""} {
        uplevel #0 $::oldTrace $name
    }
    puts "myTrace called with the gate named: $name"
}
set oldTrace [gate -trace add myTrace]
            </programlisting>
        </example>
    </refsect1>
    
    <refsect1>
        <title>SEE ALSO</title>
        <itemizedlist>
            <listitem>
                <para>
                    <link linkend='ref.applycommand' endterm='ref.applycommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.ungatecommand' endterm='ref.ungatecommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.foldcommand' endterm='ref.foldcommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.spectrumcommand' endterm='ref.spectrumcommand.title' />
                </para>
            </listitem>
        </itemizedlist>
    </refsect1>
</refentry>
<refentry id='ref.integratecommand'>
    <refmeta>
        <refentrytitle id='ref.integratecommand.title'>integrate</refentrytitle>
        <manvolnum>1SpecTcl</manvolnum>
    </refmeta>
    
    <refnamediv>
        <refname>integrate</refname>
        <refpurpose>Integrate regions of interest on spectra</refpurpose>
    </refnamediv>
    
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
integrate <replaceable>spectrum area-of-interest</replaceable>
            </command>
        </cmdsynopsis>
    </refsynopsisdiv>
    
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Integrates areas of interest in 1-d and 2-d spectra.
            <parameter>spectrum</parameter> is the name of the spectrum to integrate.
            <parameter>area-of-interest</parameter> is either a gate that can
            be displayed on the spectrum (due to the set of parameters defined
            on the gate and the set of parameters the spectrum displays), or
            a set of points in parameter space that define an integration
            region.
        </para>
        <para>
            <command>integrate</command> Integrates a spectrum within some
            selected area of interest. The command returns the centroid,
            total number of counts and full width at half maximum under
            gaussian peak shape assumption.
        </para>
        <para>
            The spectrum can be any kind of spectrum, although clearly, some
            spectra have integrations that may not be very meaningful
            (e.g. summary spectra). The area of interest can either be a
            gate name or a list of points that describe the area of interest.
        </para>
        <para>
            If the area of interest is a gate name it must be the name of gate
            of suitable type that can be displayed on the spectrum.
            Suitable means that if the spectrum is 1-d the gate must be a slice
            like gate,
            while if the spectrum is 2-d the gate must be a contour like gate.
            Displayable means that if you displayed the spectrum in Xamine,
            you would see the gate displayed on that spectrum. In general,
            that means that the parameters that the gate is defined on are the
            same as the parameters the spectrum is defined on.
        </para>
        <para>
            If the area of interest is a set of points, for 1-d spectra, the
            points must be a Tcl list that is a pair that specifies the
            boundaries of the integration region. The points must be specified
            in the coordinate system of the parameter the spectrum is defined
            on, rather than in spectrum channels (note that it is possible,
            but not necessary, that the spectrum was defined in such a way
            that these two coordinate systems are the same.
        </para>
        <para>
            For example; Consider a spectrum defined:
        </para>
        <informalexample>
            <screen><command>
spectrum aSpectrum 1 aParameter {{0 1023 512}}
            </command></screen>
        </informalexample>
        <para>
            The command:
        </para>
        <informalexample>
            <screen><command>
integrate aSpectrum [list 200 300]               
            </command></screen>
        </informalexample>
        <para>
            Will integrate the spectrum from channels 100 through 150 because
            the spectrum is specified as a 2:1 compresssion of the parameter to
            spectrum channels.
        </para>
        <para>
            If the area of interest is a set of points for a 2-d spectrum, the
            points must be a list of coordinate pairs (again in parameter
            coordinates not channels), that define the vertices of a closed
            polyfigure (line crossings are allowed, and there must be a minimum
            of three points). The interior of the polygon is defined in the
            same way the interior of a contour is defined: For any point, extend
            a ray to infinity in any direction. If the line crosses an odd number
            of line segments defining the polygon the point is inside otherwise
            outside.
        </para>
        <para>
            For example:
        </para>
        <informalexample>
            <screen><command>
integrate a2dSpectrum [list [list 0 0] [list 100 0] [list 100 100] [list 0 100]]
            </command></screen>
        </informalexample>
        <para>
            Integrates a square that has one vertex at the origin and has a side 100 parameter units.
        </para>
        <para>
            The command returns a Tcl list that contains the integration
            centroid, the number of counts in the region of interest, and the
            Full width at half maximum (FWHM) under the assumption the region
            of interest encloses a single peak with a gaussian line shape. If
            the spectrum is a 2-d spectrum, The centroid and FWHM are returned
            as pairs that describe the x and y centroids or FWHM's in the X and
            Y directions respectively.
        </para>
    </refsect1>
    
    
    
    <refsect1>
        <title>SEE ALSO</title>
        <itemizedlist>
            <listitem>
                <para>
                    <link linkend='ref.spectrumcommand' endterm='ref.spectrumcommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.gatecommand' endterm='ref.gatecommand.title' />
                </para>
            </listitem>
        </itemizedlist>
    </refsect1>
</refentry>


<refentry id='ref.parametercommand'>
    <refmeta>
        <refentrytitle id='ref.parametercommand.title'>parameter</refentrytitle>
        <manvolnum>1SpecTcl</manvolnum>
    </refmeta>
    
    <refnamediv>
        <refname>parameter</refname>
        <refpurpose>Define, list and delete parameter definitions</refpurpose>
    </refnamediv>
    
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
parameter <option>?-new?</option> name id ?</command>
<group>
    <arg>resolution</arg>
    <arg>resolution {low high units}</arg>
    <arg>?units?</arg>
</group>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
parameter -list ?<option>-byid</option>?
            </command>
<group>
    <arg><replaceable>?pattern?</replaceable></arg>
    <arg><option>-id</option> <replaceable>id</replaceable></arg>
</group>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
parameter -delete                
            </command>
<group>
    <arg><replaceable>name</replaceable></arg>
    <arg><option>-id</option> <replaceable>id</replaceable></arg>
</group>
        </cmdsynopsis>
    </refsynopsisdiv>
    
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Manipulates the SpecTcl parameter dictionary.
        </para>
       <para>
            SpecTcl maintains a parameter dictionary. The parameter
            dictionary creates a correspondence between elements in the Event
            dynamic array and named parameters which are used to create spectra.
            Each parameter has the following properties:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    A Name, which can be used to refer to the parameter when constructing spectra.
                </para>
            </listitem>
            <listitem>
                <para>
                    An Id which represents the offset into the parameter "array"
                    (<varname>rEvent</varname>) at which the parameter will be
                    placed (offsets number from zero).
                </para>
            </listitem>
            <listitem>
                <para>
                    Optional scale information describing the parameter's valid
                    range of values and a mapping between that and a real world
                    coordinate system as well as units of measure.
                </para>
            </listitem>
        </itemizedlist>
    </refsect1>
    
    <refsect1>
        <title>OPTIONS</title>
        <para>
            The first option on the <command>paramter</command> command is like
            a command ensemble keyword.  It selects the operation the
            <command>paramter</command> command will perform.  This section
            will explore those options:
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
            parameter <option>?-new?</option> name id ?</command>
            <group>
                <arg>resolution</arg>
                <arg>resolution {low high units}</arg>
                <arg>?units?</arg>
            </group>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                         The <option>-new</option> option is the default for
                         the <command>parameter</command> command if no option
                         is provided on the command line.  It creates a new
                         parameter definition.
                    </para>
                    <para>
                        The primary purpose of parameter definitions are assign
                        names to specific indices of the event's parameter array
                        like object.  This object is filled in by SpecTcl's
                        application specific code in the event processing pipeline.
                    </para>
                    <para>
                        The names assigned by <command>parameter</command> can
                        then be used later to define spectra, gates and other
                        SpecTcl parameter dependent objects.  Originally,
                        SpecTcl parameters were only integer values and were
                        designed to be values from digitizers that had some
                        fixed number of bits.  Over the years, and with the
                        introduction by Daniel Bazin of the tree parameter package,
                        it became clear that this was an overly restrictive
                        definition.
                    </para>
                    <para>
                        Now, parameters in SpecTcl are double precision floating
                        point variables.   In systems with IEEE floating,
                        this provides a sufficient number of bits of mantissa
                        that integer parameters can still be faithfully
                        represented.
                    </para>
                    <para>
                        Unfortunately, this step-by-step evolution, coupled
                        with the strong desire to maintain backwards compatibility
                        with user script has led to a rather confusing set of
                        options for parameter definition.
                    </para>
                    <para>
                        All parameter definitions must provide a parameter
                        <parameter>name</parameter> and a <parameter>id</parameter>.
                        Note that using the tree parameter package allows
                        SpecTcl to assign the id.
                    </para>
                    <para>
                        The simplest form of the parameter command is:
                    </para>
                    <cmdsynopsis>
                        <command>
parameter ?<option>-new</option>? <replaceable>name id resolution</replaceable>
                        </command>
                    </cmdsynopsis>
                    <para>
                        This creates a parameter that is intended to be an integer
                        with <parameter>resolution</parameter> bits of resolution.
                        Thus the range of the parameter is assumed to be from
                        0 to 2**<parameter>resolution</parameter>-1 inclusive.
                    </para>
                    <cmdsynopsis>
                        <command>
parameter ?<option>-new</option>? <replaceable>name id resolution {low high units}</replaceable>
                        </command>
                    </cmdsynopsis>
                    <para>
                        As an intermediate between integer and floating parameters,
                        SpecTcl supported, and still supports, scaled integer
                        paramers.  These are integer parameters that map
                        linearly into some floating point range.
                    </para>
                    <para>
                        The form of the <command>parameter</command> command
                        above,
                        defines a parameter with range defined as in the first
                        form of the command, but whose values are assumed to
                        linearly map to some real coordinate line in the range
                        [low,high].  The command parameters
                        <parameter>low</parameter> and <parameter>high</parameter>
                        are floating point values.  The parameter is also
                        assumed to have
                        <parameter>units</parameter> (e.g. cm or MeV) described
                        by the string unit.  Parameter of this sort are called
                        mapped parameters and are useful when building histograms
                        of simple calibrated parameters.
                    </para>
                    <cmdsynopsis>
                        <command>
parameter ?<option>-new</option>? <replaceable>name id ?units?</replaceable>
                        </command>
                    </cmdsynopsis>
                    <para>
                        Defines a  real parameter has an arbitrary range, and
                        optional <parameter>units</parameter>.
                        The <parameter>units</parameter>  parameter is a string
                         that represents the units of the parameter (e.g. "MeV")
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
            parameter -list ?<option>-byid</option>?
                        </command>
            <group>
                
                <arg><replaceable>?pattern?</replaceable></arg>
                <arg><option>-id</option> <replaceable>id</replaceable></arg>
            </group>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a list of the parameter definitions. If the
                        optional <option>-byid</option> switch is included, the
                        parameters are sorted by Id number. Otherwise the list
                        is alphabetical by parameter name. The output is in a
                        form which makes processing by other Tcl commands and
                        scripts easy. 
                    </para>
                    <para>
                        The parameters listed can be filtered.  If
                        <option>-id</option> is not present, the
                        optional <parameter>pattern</parameter> parameter
                        is a glob pattern. Only names matching this pattern
                        will be listed.  If the <parameter>pattern</parameter>
                        is not supplied, it defaults to <literal>*</literal>
                        which matches all parameter names.
                    </para>
                    <para>
                        If the <option>-id</option> option is present, the next
                        parameter is mandatory and must be the paramter
                        <parameter>id</parameter>
                        of the parameter you want listed.
                    </para>
                    <para>
                        The output is a Tcl List of definitions.
                        Each element of the list is itself a list that describes
                        one parameter.  In order to make the processing of this
                        list simple, all parameter definitions have the
                        following elements (in order):
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term><literal>name</literal></term>
                            <listitem>
                                <para>
                                    The name of the parameter.  Use this name
                                    to refer to the parameter in SpecTcl
                                    commands that need a parameter.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>id</literal></term>
                            <listitem>
                                <para>
                                    The id of the parameter.  In this case the
                                    id has some significance.  It is the index
                                    into the <varname>rEvent</varname> array like
                                    object at which the event processing pipeline
                                    will store this parameter.
                                </para>
                                <para>
                                    Note that tree parameters make this quite a
                                    bit easier to deal with but in the end,
                                    what SpecTcl's histogramming kernels see are
                                    an array like object of parameters.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>info</literal></term>
                            <listitem>
                                <para>
                                    Information about the parameter in a three
                                    element sublist of <literal>lowlim</literal>,
                                    <literal>hilim</literal> and <literal>units</literal>.
                                    The actual contents and meaning of these three
                                    items depends on how the parameter was defined.
                                </para>
                                <para>
                                    For an integer mapped parameter,
                                    <literal>lowlim</literal>this is the low
                                    limit of the range represented by the parameter.
                                    This is empty for real parameters. For
                                    parameters that are integer unmapped, this
                                    will be zero.
                                </para>
                                <para>
                                    For an integer mapped parameter,
                                    <literal>hilim</literal> is the high limit
                                    of the range represented by the parameter.
                                    This is empty for real parameters.  For
                                    unmapped integer parameters, this is just derived
                                    from the paramter's resolution.
                                </para>
                                <para>
                                    <literal>units</literal> is just the
                                    units that were specified when creating
                                    the parameter.  If the units were not specified,
                                    this will just be an empty string.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
            parameter -delete                
                        </command>
            <group>
                <arg><replaceable>name</replaceable></arg>
                <arg><option>-id</option> <replaceable>id</replaceable></arg>
            </group>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Deletes a parameter definition. Note that when objects that
                        depend on a parameter are created (e.g. spectra), a
                        binding is statically done to the slot in the
                        <varname>rEvent</varname> the parameter is assigned to.
                        This means these objects will continue to function.
                        What they do when listed depends on the type of object.
                    </para>
                    <para>
                        If the <option>-id</option> is not present on the
                        command, the <parameter>name</parameter> specifies the
                        name of the parameter to delete.  If
                        <option>-id</option> is supplied, then <parameter>id</parameter>
                        is the id of the parameter whose definition is deleted.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    
    <refsect1>
        <title>EXAMPLES</title>
        <example>
            <title>Creating a 12 bit 'integer' parameter</title>
            <screen><command>
parameter De1 0 12                 
            </command></screen>
        </example>
        <example>
            <title>Creating a real valued parameter with units in mm</title>
            <screen><command>
parameter position 2 mm
            </command></screen>
        </example>
        
    </refsect1>
    
    <refsect1>
        <title>SEE ALSO</title>
        <itemizedlist>
            <listitem>
                <para>
                    <link linkend='ref.treeparametercommand' endterm='ref.treeparametercommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.pseudocommand' endterm='ref.pseudocommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.spectrumcommand' endterm='ref.spectrumcommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.gatecommand' endterm='ref.gatecommand.title' />
                </para>
            </listitem>
        </itemizedlist>
    </refsect1>
</refentry>
<refentry id='ref.pseudocommand'>
    <refmeta>
        <refentrytitle id='ref.pseudocommand.title'>pseudo</refentrytitle>
        <manvolnum>1SpecTcl</manvolnum>
    </refmeta>
    
    <refnamediv>
        <refname>pseudo</refname>
        <refpurpose>Create, listm, delete pseudo parameters.</refpurpose>
    </refnamediv>
    
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
pseudo <replaceable>name parameters body</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
pseudo <option>-list</option> <replaceable>?pattern?</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
pseudo <option>-delete</option> <replaceable>name1 ?name2...?</replaceable>
            </command>
        </cmdsynopsis>
    </refsynopsisdiv>
    
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The pseudo command allows you to create, list and delete
            dynamically computed pseudo parameters.  The pseudo parameters
            created by this command use Tcl scripts to compute their values.
            As such, they are good for experimentation but, in production
            environments, probably they should be migrated into compiled
            event processors for performance sake.
        </para>
        <para>
            Using the pseudo command you can:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Define a computation which will produce a parameter value
                    as a function of existing parameters and Tcl variables.
                </para>
            </listitem>
            <listitem>
                <para>
                    List the set of pseudo parameters and their definitions
                    sorted by pseudo parameter name.                    
                </para>
            </listitem>
            <listitem>
                <para>
                    Delete a set of previously defined pseudo parameters.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            Pseudo parameters are parameters which are computed online as a
            function of existing parameters in the event (pseudo or raw).
            As Tcl scripts are used to compute pseudos in the main interpreter,
            the pseudo body has
            access to all Tcl variables and procs any other script has.
        </para>
        <para>
            An understanding of how pseudo parameters are implemented may be
            useful for pseudo writers.   The pseudo definition is converted into
            a procedure as follows:            
        </para>
        <informalexample>
            <programlisting>
proc name_Procedure parameters body                
            </programlisting>
        </informalexample>
        <para>
            For each event, a call to this procedure is built with the
            appropriate parameters provided from the event.  The return value
            of the procedure is placed in the parameter corresponding to the
            pseudo.  The procedure is saved as compiled byte code so that it can
            be efficiently called again and again.            
        </para>
    </refsect1>
    
    <refsect1>
        <title>COMMAND FORMATS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
pseudo <replaceable>name parameters body</replaceable>
                        </command>
                    </cmdsynopsis>                    
                </term>
                <listitem>
                    <para>
                        Creates a new pseudo parameter.  The <parameter>name</parameter>
                        must be the name of an existing parameter (or tree parameter).
                        <parameter>parameters</parameter> are a list of parameters
                        that are required to compute the pseudo.
                        <parameter>body</parameter> is a Tcl proc body
                        that returns the value of a pseudo.
                    </para>
                    <para>
                        The body is turned into a proc as described above.
                        The proc is given formal parameters that are the names
                        of the parameters you name when defining the pseudo.
                        It is also given validity parameters for each
                        dependent parameter (see <literal>EXAMPLES)</literal>).
                    </para>
                    <para>
                        For each event, the generated proc is called with actual
                        parameters from the event and validity flags
                        set in accordance with the presence or absence of
                        each parameter in the event.
                    </para>
                    <para>
                        Note that pseudo parameters are evaluated after all
                        stages of the event processing pipeline have run.
                        Psuedo paramters can depend on other pseudos as long
                        as the depenent psuedos are defined first chronologically.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
            pseudo <option>-list</option> <replaceable>?pattern?</replaceable>
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Lists psuedo parameter definitions that match
                        the optional <parameter>pattern</parameter>.  If
                        <parameter>pattern</parameter> is not provided,
                        it defaults to <literal>*</literal> which matches
                        all pseudos.
                    </para>
                    <para>
                        The command result is a Tcl list whose elements each
                        descdribe one psuedo parameter.  The descriptions
                        are themselves Tcl lists containing in order:
                    </para>
                    <orderedlist>
                        <listitem>
                            <para>
                                The pseudo parameter name
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                The pseudo parameter's dependent parameters
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                The body that computes the result.
                            </para>
                        </listitem>
                    </orderedlist>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
            pseudo <option>-delete</option> <replaceable>name1 ?name2...?</replaceable>
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Delets the pseudo parameters <parameter>name1</parameter>...
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <note>
            <title>Computation failures</title>
            <para>
                Note that if a pseudo parameter throws a Tcl error when computing
                its result, it is disabled.  An error message is output to the
                terminal running SpecTcl.  If you don't see your pseudo, check
                for that.
            </para>
        </note>                    
    </refsect1>
    
    <refsect1>
        <title>EXAMPLES</title>
        <example>
            <title>Defining a simple psuedo</title>
            <programlisting>
parameter sum 1234
pseudo sum { par1 par2 } {
   if {$par1isValid &amp;&amp; $par2isValid} {
      return [expr $par1 + $par2]
   } else {
       return -1
   }
}
            </programlisting>
        </example>
        <para>
            <literal>par1</literal> and <literal>par2</literal> are the names
             of the parameters the pseudo depends on.  They result in formal
             parameters with the same name and <literal>par1isValid</literal>
             and <literal>par2isValid</literal> parameters that are flags which
             are true if <literal>par1</literal> and <literal>par2</literal>
             have been assigned values respectively.
        </para>
        <para>
            Using tree parameters brings up some nasty substitution issues
            you must be aware of.  If you write something like
            <literal>$raw.00</literal>, Tcl will attempt to substitute a
            variable named  <varname>raw</varname> and then append to that
            substitution <literal>.00</literal>.  You must use quoting to extend
            the scope of the name being substituted.
        </para>
        <para>
            The next example is identical to the previous one but we use
            parameter names par.01 and par.02 to illustrate the quoting points
            described above:
        </para>
        <example>
            <title>Pseudo illustrating quoting:</title>
            <programlisting>
parameter sum 1234 11  
pseudo sum { par.01 par.02 } {
   if {${par.01isValid} &amp;&amp; ${par.02isValid}} {
      return [expr ${par.01} + ${par.02}]
   } else {
       return -1
   }
}
            </programlisting>
        </example>
        <para>
            Note how {}'s are used to indicate the $ should apply to the entire
            name instead of just the part prior to the period.
        </para>
        <example>
            <title>listing pseudos</title>
            <screen><command>
<prompt>%</prompt> pseudo -list sum
<computeroutput>{sum {par.01 par.02} {if {${par.01isValid} &amp;&amp; ${par.02isValid}} {
      return [expr ${par.01} + ${par.02}]
   } else {
       return -1
   }
}}
</computeroutput>
            </command></screen>
        </example>
    </refsect1>
    
    <refsect1>
        <title>SEE ALSO</title>
        <itemizedlist>
            <listitem>
                <para>
                    <link linkend='ref.parametercommand' endterm='ref.parametercommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.treeparametercommand' endterm='ref.treeparametercommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.spectrumcommand' endterm='ref.spectrumcommand.title' />
                </para>
            </listitem>
        </itemizedlist>
        <para>
              
        </para>
    </refsect1>
</refentry>

<refentry id='ref.sreadcommand'>
    <refmeta>
        <refentrytitle id='ref.sreadcommand.title'>sread</refentrytitle>
        <manvolnum>1SpecTcl</manvolnum>
    </refmeta>
    
    <refnamediv>
        <refname>sread</refname>
        <refpurpose>Read spectrum from file or pipe.</refpurpose>
    </refnamediv>
    
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
sread ?<option>-format</option> <replaceable>fmt</replaceable>?
      ?<option>-?no?snapshot</option>?
      ?<option>-?no?replace</option>?
      ?<option>-?no?bind</option>?  <replaceable>file</replaceable> 
            </command>
        </cmdsynopsis>
    </refsynopsisdiv>
    
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Reads a spectrum either from a file specified by name or a file or
            pipe opened with the Tcl <command>open</command> command.
        </para>
        <para>
            The next spectrum in the file parameter is read.
            The <parameter>file</parameter> parameter can either be a path to a
            file, or a handle returned from the Tcl open command.
            If the file is a path, the file is opened, the first spectrum read,
            and the file is closed.  If the file parameter is a Tcl file
            handle, the next spectrum at the current position in the file
            is read, and the file remains open for further I/O.
        </para>

    </refsect1>
    
    <refsect1>
        <title>OPTIONS</title>
        <para>
            A bit of history.  Many years ago, there was a histogramming program
            that ran on the VMS operating system called SMAUG.  It too had
            spectrum I/O facilities.
            Although SMAUG no longer exists,
            SpecTcl's <command>sread</command> command,
            as we will see, has been written to be able to exchange
            files with SMAUG.  Most users do not know about or use the SMAUG
            interchange capabilities.  All GUIs I know about only read/write
            ASCII formatted files.
        </para>
        <variablelist>
            <varlistentry>
                <term><option>-format</option> fmt</term>
                <listitem>
                    <para>
                        Selects the format the file is in.  SpecTcl supports a
                        simple ASCII format as well as SMAUG binary format.
                        <parameter>fmt</parameter> is a string that describes
                        which of these formats the file is in.
                    </para>
                    <para>
                        If <parameter>fmt</parameter> is <literal>ascii</literal>
                        <literal>nsclascii</literal>, the file is assumed to
                        be in SpecTcl's ASCII format.  If <parameter>fmt</parameter>
                        is either <literal>binary</literal> or <literal>nsclbinary</literal>
                        the file is assumed to be in SMAUG binary format.
                    </para>
                    <para>
                        If not provided, the default format is <literal>nsclascii</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-?no?snapshot</option></term>
                <listitem>
                    <para>
                        Defines how the resulting spectrum is treated in SpecTcl
                        once read in.  
                    </para>
                    <para>
                        If <option>-snapshot</option>, the default,
                        is chosen, the spectrum is read into a
                        <firstterm>snapshot</firstterm> spectrum.  Snapshot
                        spectra are spectra in every sense of the word, however
                        they are not connected to the histogramming kernel and
                        therefore never increment.
                    </para>
                    <para>
                        If <option>-nosnapshot</option> is supplied, once the
                        spectrum is read in, if the parameters the spectrum
                        was defined on exist in this intance of SpecTcl,
                        the spectrum is connected to the histogrammer and
                        will incrmement as new data arrives.   Note that
                        only <literal>nsclascii</literal> (<literal>ascii</literal>)
                        spectra have information about which parameters
                        are in the spectrum and the underlying spectrum type.
                        Therefore <option>-nosnapshot</option> has no effect
                        for other spectrum formats.
                    </para>
                    <para>
                        If the SpecTcl is missing a definition for one or more
                        of the parameters that are needed by the spectrum,
                        the spectrum reverts to a snapshot spectrum.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-?no?replace</option></term>
                <listitem>
                    <para>
                        Determines what <command>sread</command> does if
                        a spectrum with the same name as the one in the file
                        is already defined.  Note that this is orthogonal
                        to <option>-snapshot</option>.
                    </para>
                    <para>
                        If <option>-noreplace</option> (the default), if this
                        spectrum already exists a unique, similarly named
                        spectrum is created so that the existing spectrum is
                        not overwritten.
                    </para>
                    <para>
                        If <option>-replace</option>, existing spectra are
                        delted and overwritten with the spectrum from file.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>?<option>-?no?bind</option></term>
                <listitem>
                    <para>
                        If <option>-bind</option> is present (by default it
                        is), once read in the spectrum is bound into display
                        shared memory.  If <option>-nobind</option> the spectrum
                        is not bound into display memory.  The spectrum can always
                        be bound later on using <command>sbind</command>.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    
    <refsect1>
        <title>EXAMPLES</title>
        <example>
            <title>Reading a spectrum in from file</title>
            <programlisting>
sread /user/fox/test.asc
            </programlisting>
        </example>
        <para>
            Note that file substitutions don't work for <command>sread</command>.
            Since non command line options are provided, the format is
            <literal>nsclascii</literal>, a snapshot spectrum will be created,
            if necessary the spectrum's name will be changed to avoid
            overwriting an existing spectrum and the resulting spectrum
            is bound to display memory.
        </para>
        <example>
            <title>Reading several spectra from one file</title>
            <programlisting>
set file [open ~/test.asc r]
sread -format ascii $file
sread -format ascii $file
sread -format binary $file
close $file
            </programlisting>
        </example>
        <para>
            If <command>sread</command> is pointed to a file it can only read
            one spectrum (the first).  Using a file descriptor to identify
            the file allows several consecutive <command>swrite</command>
            commands to process consective spectra in the file.
        </para>
        <para>
            Note there's no requirement the file not have other data
            <command>sread</command> can be freely mixed with
            e.g. <command>read</command> or <command>gets</command>
            as dictated by the contents of the file.
        </para>
        <example>
            <title>Reading from a pipeline:</title>
            <programlisting>
set file [open {|zcat ~/test.asc.gz} r]
sread -format ascii  $file
sread -format ascii  $file
sread -format ascii  $file
close $file
            </programlisting>
        </example>
        
        <para>
                In this case, <filename>~/test.asc.gz</filename> is a
                file that has been compressed with <command>gzip</command>.
                Once a pipe has been formed with the decompressor we
                can just process spectra from the pipeline as we did
                for actual files.
            </para>
        
    </refsect1>
    
    <refsect1>
        <title>SEE ALSO</title>
        <itemizedlist>
            <listitem>
                <para>
                    <link linkend='ref.spectrumcommand' endterm='ref.spectrumcommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.swritecommand' endterm='ref.swritecommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.sbindcommand' endterm='ref.sbindcommand.title' />
                </para>
            </listitem>
        </itemizedlist>
    </refsect1>
</refentry>
<refentry id='ref.ringformatcommand'>
    <refmeta>
        <refentrytitle id='ref.ringformatcommand.title'>ringformat</refentrytitle>
        <manvolnum>1SpecTcl</manvolnum>
    </refmeta>
    
    <refnamediv>
        <refname>ringformat</refname>
        <refpurpose>Select ringbuffer format</refpurpose>
    </refnamediv>
    
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
ringformat <replaceable>major?.minor?</replaceable>
            </command>
        </cmdsynopsis>
    </refsynopsisdiv>
    
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            NSCLDAQ since version 10.0 uses a <firstterm>ring buffers</firstterm>
            as the cornerstone for its bulk data flow.  While ring buffers
            are byte stream, single producer, multi-consumer objects, NSCLDAQ
            imposes a format on the messages passed through ringbuffers.  
        </para>
        <para>
            Ring buffers are used to transfer a series of <firstterm>ring items</firstterm>.
            At present there are two basic structure variants to these ring items. Those
            used in nscldaq version 10.x and those used in 11.x and later.
            As time goes on, additional ring item structure variants may be added.
        </para>
        <para>
            When attached to a ringbuffer data source, SpecTcl needs to know
            which ring item format that ring buffer will carry.   Since
            nscldaq-11.0, each data taking run begins with a ring format ring item.
            therefore, if SpecTcl is attached to a ring data source prior to
            begin run, it can figure out the format.
        </para>
        <para>
            On the other hand, if not, or to be safe you can use the
            <command>ringformat</command> command, once attached to a ring
            to select a specific  format for the ring items that will
            come from that ring buffer.
        </para>
        <para>
            The parameter to <command>ringformat</command> is the version of
            NSCLDAQ you feel is producing ring items for that ring.  
        </para>
    </refsect1>
    
    <refsect1>
        <title>EXAMPLES</title>
        <example>
            <title>NSCLDAQ version 10 data:</title>
            <screen><command>
ringformat 10
            </command></screen>
        </example>
        <example>
            <title>NSDCLDAQ version 11 data</title>
            <screen><command>
ringformat 11
            </command></screen>
        </example>
        <para>
            Note that at this time NSCLDAQ-12.0 uses the same data formats
            as NSCLDAQ-11.x
        </para>
    </refsect1>
    
    <refsect1>
        <title>SEE ALSO</title>
        <para>
            <link linkend='ref.attachcommand' endterm='ref.attachcommand.title' />
        </para>
    </refsect1>
</refentry>

<refentry id='ref.scontentscommand'>
    <refmeta>
        <refentrytitle id='ref.scontentscommand.title'>scontents</refentrytitle>
        <manvolnum>1SpecTcl</manvolnum>
    </refmeta>
    
    <refnamediv>
        <refname>scontents</refname>
        <refpurpose>Obtain spectrum bulk contents</refpurpose>
    </refnamediv>
    
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
scontents ?<option>-json</option>? <replaceable>spectrum-name</replaceable>
            </command>
        </cmdsynopsis>
    </refsynopsisdiv>
    
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The <command>channel</command> command gives easy access to individual
            channels of a spectrum.  This command provides access to the
            contents of an entire spectrum.  The initial use case for this
            was to provide spectra to clients of the SpecTcl REST plugin.
            Clearly another use caser would be to provide a mechanism to
            export spectra in file formats not supported by SpecTcl's
            <command>swrite</command> command.
        </para>
        <para>
            The <option>-json</option> selects a result that is in
            JavaScript Object Notation (JSON).  If that's omitted a Tcl
            friendly representation is used.  Note that metadata about the
            spectrum (the spectrum definition) is not returned.  You would
            have to couple this command with the appropriate
            <command>spectrm -list</command> command to get that.
        </para>
    </refsect1>
    <refsect1>
        <title>Output format</title>
        <para>
            Depending on the use of the <option>-json</option> option, the
            command produces data either in a Tcl friendly way or as a
            JavaScript Object Notation (JSON) object.
        </para>
        <refsect2>
            <title>Tcl friendly output</title>
            <para>
                Output is zero suppressed.  It consists of a list of lists.
                Each list element contains the coordinates of a non-zero
                channel followed by the value at that channel.  
            </para>
            <para>
                For 1-d spectra each nonzero channel is represented by a
                two element list.  The list contains the channel number
                followed by the channel value.
            </para>
            <para>
                For 2-d spectra the output is similar.  Each channel
                is represented by a three element list.  The list contains
                the x and y channel number that define a channel in the 2-d
                spectrum followed by the value at that channel.  Again, only
                non-zero channels will appear in the output list.
            </para>
        </refsect2>
        <refsect2>
            <title>JSON output</title>
            <para>
                JSON output format is web friendly.  REST interfaces (including
                the SpecTcl REST plugin), often return responses as JSON
                objects.  The output from <command>scontents <option>-json</option></command>,
                is a JSON array.  
            </para>
            <para>
                Each array element represents a non-zero channel.  For 1-d
                spectra, each element of the array is an object that contains
                the attributes:
            </para>
            <variablelist>
                <varlistentry>
                    <term><literal>x</literal></term>
                    <listitem>
                        <para>
                            The channel number of a non zero channel in the
                            spectrum.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>v</literal></term>
                    <listitem>
                        <para>
                            The value of that channel.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                For 2-d spectra again, the result is an array of objects.
                In addition to the attributes described for 1-d output, a
                channel object has a <literal>y</literal> object, the y coordinate
                of the non-zero channel.
            </para>
        </refsect2>
    </refsect1>
    
    <refsect1>
        <title>SEE ALSO</title>
        <itemizedlist>
            <listitem>
                <para>
                    <link linkend='ref.channelcommand' endterm='ref.channelcommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.spectrumcommand' endterm='ref.spectrumcommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.swritecommand' endterm='ref.swritecommand.title' />
                </para>
            </listitem>
        </itemizedlist>
        <para>
              
        </para>
    </refsect1>
</refentry>

<refentry id='ref.memorykeycommand'>
    <refmeta>
        <refentrytitle id='ref.memorykeycommand.title'>shmemkey</refentrytitle>
        <manvolnum>1SpecTcl</manvolnum>
    </refmeta>
    
    <refnamediv>
        <refname>shmemkey</refname>
        <refpurpose>Get shared memory key.</refpurpose>
    </refnamediv>
    
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
shmemkey
            </command>
        </cmdsynopsis>
    </refsynopsisdiv>
    
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Bulk spectrum data are stored in a SYS-V shared memory region.
            These memory regions are identified by a 32 bit key.  This
            key is usually expressed as a four character string.  This
            command returns that string.
        </para>
        <para>
            The use case for this command is to allow the REST plugin to tell
            a local client how to map the bulk spectrum shared memory so that
            it can get higher data transfer than REST request/response would
            allow.
        </para>
    </refsect1>

</refentry>
<refentry id='ref.shmemsizecommand'>
    <refmeta>
        <refentrytitle id='ref.shmemsizecommand.title'>shmemsize</refentrytitle>
        <manvolnum>1SpecTcl</manvolnum>
    </refmeta>
    
    <refnamediv>
        <refname>shmemsize</refname>
        <refpurpose>Return the size of the spectrum shared memory region.</refpurpose>
    </refnamediv>
    
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
shmemsize
            </command>
        </cmdsynopsis>
    </refsynopsisdiv>
    
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
              Bulk spectrum data are stored in a SYS-V shared memory region.
              This command returns the size of that shared memory region in
              megabytes (a megabyte is 1024*1024 bytes).
        </para>
        <para>
            The use case for this command is to allow the REST plugin to tell
            a local client how to map the bulk spectrum shared memory so that
            it can get higher data transfer than REST request/response would
            allow.
        </para>
    </refsect1>

</refentry>

<refentry id='ref.spectrumcommand'>
    <refmeta>
        <refentrytitle id='ref.spectrumcommand.title'>spectrum</refentrytitle>
        <manvolnum>1SpecTcl</manvolnum>
    </refmeta>
    
    <refnamediv>
        <refname>spectrum</refname>
        <refpurpose>Create, list, delete, and trace changes to spectrum definitions.</refpurpose>
    </refnamediv>
    
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
spectrum ?<option>-new</option>? <replaceable>name type parameter-list axis-speclist ?datatype?</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
spectrum <option>-list</option> ?<option>-byid</option>? ?<option>-showgate</option> <replaceable>?pattern?</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
spectrum <option>-list</option> <option>-id</option> ?<option>-showgate</option>? <replaceable>id</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
spectrum <option>-delete</option> <replaceable>name</replaceable> <replaceable>?name...?</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
spectrum <option>-delete</option> <option>-id</option> <replaceable>id1 ?id2...?</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
spectrum <option>-delete</option> <option>-all</option>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
spectrum <option>-trace</option></command>
<group>
    <arg>add <replaceable>?script?</replaceable></arg>
    <arg>delete <replaceable>?script?</replaceable></arg>
</group>  
        </cmdsynopsis>
    </refsynopsisdiv>
    
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            SpecTcl maintains a dictionary of spectra. The size of the
            parameter dictionary and the total amount of spectrum storage is
            limited only by the program's virtual memory.  Spectrum bulk
            storage can be placed into a shared memory region whose size
            is set by the Tcl variable <varname>DisplayMegabytes</varname> and
            further limited by system parameters settings (<literal>shmmax</literal>).
        </para>
        <para>
            SpecTcl's dictionary maintains objects that hold metadata for
            all of the defined spectra.  The metadata for each spectrum include:
        </para>
        <variablelist>
            <varlistentry>
                <term><literal>name</literal></term>
                <listitem>
                    <para>
                        The name you give a spectrum when you create it.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>id</literal></term>
                <listitem>
                    <para>
                        A small integer assigned by SpecTcl to each spectrum.
                        This is generally not useful.  It is also not the same
                        as the binding Id produced when you bind a
                        spectrum's bulk storage into shared memory,.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>type</literal></term>
                <listitem>
                    <para>
                        The type of the spectrum.  Internally this is the
                        type of object that is representing the spectrum.
                        Externally this is a short (one or two character) string.
                        More on spectrum types when we look at creating spectra
                        in <literal>FORMS OF THE COMMAND</literal> below.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>parameters</literal></term>
                <listitem>
                    <para>
                        The parameters the spectrum depends on.  The number
                        and organization of these depends very much on the
                        spectrum type and again we'll say more on this in
                        <literal>FORMS OF THE COMMAND</literal> below.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>axes</literal></term>
                <listitem>
                    <para>
                        One or two axis descriptions.  The number of
                        axis descriptions also depends on the spectrum type.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>channel type</literal></term>
                <listitem>
                    <para>
                        The data type for each channel (byte, word or longword).
                        In the past when systems were heavily memory limited,
                        it was important to make large 2-d spectra word or even
                        byte arrays.  This is normally no longer necessary.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>applied gate</literal></term>
                <listitem>
                    <para>
                        All spectra have gates applied to them. When they are
                        created spectra have a <literal>True</literal> gate applied.
                        The <command>apply</command> command changes which gate is
                        applied to a spectrum.
                    </para>
                    <para>
                        Spectra only increment if their gates are satisfied and
                        the event has defined a sufficient set of parameters.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    
    <refsect1>
        <title>FORMS OF THE COMMAND</title>
        <para>
            This section look as the forms of the <command>spectrum</command>
            command.  We look specifically at:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Spectrum creation.
                </para>
            </listitem>
            <listitem>
                <para>
                    Listing spectra
                </para>
            </listitem>
            <listitem>
                <para>
                    Deleting spectra
                </para>
            </listitem>
            <listitem>
                <para>
                    Estabilishing trace scripts
                </para>
            </listitem>
        </itemizedlist>    
        <refsect2>
            <title>Spectrum creation</title>
            <para>
                Create spectra using commands of the form:
            </para>
            <cmdsynopsis>
                <command>
spectrum ?<option>-new</option>? <replaceable>name type parameter-list axis-speclist ?datatype?</replaceable>
                </command>
            </cmdsynopsis>
            <para>
                <parameter>name</parameter> is the name of the new spectrum.
                This name must be unique over all spectra.  If you attempt to
                redefine an existing spectrum the command will result in an error.
            </para>
            <para>
                <parameter>type</parameter> is the spectrum type. Spectcl
                supports a rich set of spectrum types.  See
                <literal>Spectrum Types</literal> below for information about
                spectrum types and what needs to be supplied to create them.
            </para>
            <para>
                <parameter>parameter-list</parameter> is a Tcl list that, in
                a spectrum type dependent way lists the parameters the spectrum
                depends on.
            </para>
            <para>
                <parameter>axis-speclist</parameter> is a list of axis
                specifications. Each axis specification is a triplet containing,
                in order, the low and high limits ands the number of bins on that
                axis.   The number of axis specifications is determined by
                the spectrum type as well.
            </para>
            <para>
                 The optional <parameter>datatype</parameter> parameter
                 determines the data type of each channel.  It can be
                 <literal>byte</literal> for eight bit channels,
                 <literal>word</literal> for 16 bit channels and
                 <literal>long</literal> for 32 bit channels.
            </para>
            <refsect3>
                <title>Spectrum Types</title>
                <para>
                    SpecTcl provides a rich set of spectrum types.  The
                    type of a spectrum determines when and how the spectrum
                    is incremented as well as how to specify its parameter and
                    axis lists when creating the spectrum.
                </para>
                <para>
                    In this section well look at each spectrum type,
                    the number and organization of parameters expected, and the
                    number of axis specifications required.
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>1</literal> - one dimensional spectrum</term>
                        <listitem>
                            <para>
                                This spectrum requires a single parameter. The
                                values of that parameter are the X axis of the
                                spectrum.  For each even that satisfies the
                                applied gate <emphasis>and</emphasis> defines
                                the spectrum's parameter, the axis specification
                                is used to compute a spectrum channel which,
                                if it is in the range of the axis, is incremented.
                            </para>
                            <para>
                                A list containing a single axis specification
                                is required.  Recall that an axis specification
                                is a three element list consisting of
                                axis low and high limits and bin count.  
                            </para>
                            <para>
                                See EXAMPLES for concrete examples of spectrum
                                definitions.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>2</literal> - two dimensional spectrum.</term>
                        <listitem>
                            <para>
                                This spectrum requires a list of two parameters.
                                The first parameter in the list is the x parameter.
                                The second the y.  A list of two axis specifications,
                                the first for the X the second for the y are
                                required.
                            </para>
                            <para>
                                For each event that satisfies the gate and defines
                                both parameters, The X axis specification and X
                                parameter value are used to compute an x channel.
                                The Y axis specification and Y parameter value
                                are used to compute a y channel.  If both
                                the x and y channels are within the spectrum bounds,
                                the channel selected by x, y is incremented.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>g1</literal> - 1 dimensional gamma spectrum</term>
                        <listitem>
                            <para>
                                Actually more useful than that.  This spectrum
                                requires an arbitrary list of X axis parameters.  It
                                also requires a single X axis axis specification.
                            </para>
                            <para>
                                For each event in which the spectrum's applied gate
                                is satisfied, and for which at least one of the
                                parameters is defined by the event, the spectrum
                                can be incremented.  Each defined parameter in
                                the parameter list computes an x axis bin and,
                                if that bin is in range it is incremented.
                            </para>
                            <para>
                                Note that this means the spectrum can be
                                incremented several times for each event.
                            </para>
                            <para>
                                The increment logic can drastically change
                                if the spectrum has a fold applied.   In this
                                case, if the fold is satisfied by one or more
                                parameters, the increments are only performed for
                                parameters that do not satisfy the fold.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>g2</literal> - 2 dimensional gamma spectrum</term>
                        <listitem>
                            <para>
                                This spectrum requires an arbitrary list of
                                at least two parameters.  It also requires two
                                axis specification.  <literal>g2</literal>
                                spectra can be incremented more than once
                                per event.
                            </para>
                            <para>
                                For each event that satisfies the applied gate
                                and defines at least two of the spectrum's parameters
                                the spectrum can be incremented.   Each pair of
                                parameters is used as an x/y pair and an increment
                                is done for that pair as if the spectrum were
                                an ordinary 2-d spectrum.  For example, suppose
                                that there are three parameters, p1, p2, p3 all
                                of which are defined in an event.
                                Increments will occur for (p1,p2), (p1,p3) and
                                (p2, p3)
                            </para>
                            <para>
                                As with <literal>g1</literal> spectra folds
                                have an effect on the increment logic as well.
                                Increments only occur for parameter pairs that
                                are not involved in satisfying the fold.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>s</literal> - summary spectrum</term>
                        <listitem>
                            <para>
                                A summary spectrum is useful to visualize
                                the health and gain matching of several
                                identical detectors in a system.  It has an
                                arbitrary number of parameters and a single
                                (y) axis specification.  Each parameter is
                                assigned a sequential position on the X axis.
                                For example, if the parameter list is,
                                in order, p1, p2, p3; p1 is assigned X=0, p2: X=1,
                                p3: x=2. 
                            </para>
                            <para>
                                For each event that satsifies the applied gate and
                                defines at least on of the parameters, the spectrum
                                will be incremented once for  each defined parameter.
                                For each defined parameter, the value of the
                                parameter is used, along with the axis specification,
                                to compute a y bin.  The channel incremented has
                                an X coordinate determined by the x assigned to the
                                parameter and a Y coordinate determined by the
                                channel value.
                            </para>
                            <para>
                                A summary spectrum is therefore, effectively
                                a bunch of 1-d spectra where each 1-d spectrum is
                                vertically displayed along a single X channel.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>b</literal> bitmask spectrum.</term>
                        <listitem>
                            <para>
                                A single parameter and a single axis
                                specification are needed.  The parameter is
                                assumed to be fundamentally an integer.
                                The axis specification defines how bits in that
                                spectrum map to channels on the spectrum's
                                X axis.   Suppose, for example, the axis
                                specification is {0 15 16}.  Bits 0-15 are in the
                                range of the axis
                                (bits are numbered from least to most significant).
                                Each of those 16 bits gets its own channel.
                            </para>
                            <para>
                                For each event that satisfies the applied gate
                                and defines the spectrum's parameter an increment
                                can take place for each set bit in the parameter.
                                The channel for each set bit is incremnted.
                                Suppose, for example, using the axis specification
                                {0 15 16}, the hexadecimal representation of the
                                paramters is 0x10055.  The following channels
                                will be incremented 0, 2, 4, 6.  This is because
                                0x55 has is binary: 0101 0101
                                Note that
                                since the 0x10000 is out of range of the axis
                                (it's bit 16) it
                                does not result in an increment.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>S</literal> - Strip chart spectrum</term>
                        <listitem>
                            <para>
                                This requires two parametrs.  The first is an
                                X axis parameter, the second is a value parameter.
                                Only one axis specification (for the X axis) is
                                required and this is an initial condition.
                                While the spectrum is intended cases where the X
                                axis parameter monotonically varies, this is not
                                required.
                            </para>
                            <para>
                                For each event that satisfies the gate and
                                has defined both parameters, the X parameter is
                                converted into an X axis bin.  If the bin is not
                                in the spectrum, the channels are shifted appropriately
                                so that it is (think of a strip chart scrolling).
                                The integer valued  value parameter is then added
                                to that channel.
                            </para>
                            <para>
                                Consider one application.  Suppose the
                                X parameter is run time in say minutes and the
                                Y parameter is the number of counts in some
                                scaler.  The scaler rate strip chart can then
                                be plotted using one of these spectra.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>m2</literal> 2-d sum spectrum</term>
                        <listitem>
                            <para>
                                Requires an event number of parameters.  Each
                                pair of parameters is an X/Y pair.  Requires
                                two axis specifications, one for X and one for Y.
                            </para>
                            <para>
                                If the gate is satisfied for the spectrum, the
                                parameter pairs are iterated over.  For each
                                X/Y pair that is defined in the event, bins are
                                computed and, if possible a channel is incremented.
                                The result is a spectrum that would be the sum
                                of 2-d spectra on the individual parameter pairs.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>gd</literal> - gamma deluxe.</term>
                        <listitem>
                            <para>
                                Requires two parameter lists.  The first parameter
                                list is the set of X parameters.  The second
                                parameter list the set of Y parameters.  The spectrum
                                needs both X and Y axis specifications.
                            </para>
                            <para>
                                If the spectrum's gate is satisifed and the
                                event has at least one X and one Y parameter
                                defined, the spectrum can be incremented.  All
                                pairs of X/Y parameters can cause increments.
                                Suppose the X parameters are x1, x2, x3 and all
                                are present.  Suppose the Y parameters are
                                y1, y2, y3 and only y1 and y3 are present.  Increments
                                can occur for (x1,y1) (x1,y3), (x2, y1), (x2, y3),
                                (x3, y1), (x3, y3).
                            </para>
                            <para>
                                As with any gamma spectrum folds can be applied
                                in which case increments only occurs for parameter
                                pairs where one or both parameters don't satisfy the fold.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>gs</literal></term>
                        <listitem>
                            <para>
                                Gamma summary spectrum.  This works just
                                like a summary spectrum, however each x channel
                                has a list of parameters and the vertical strip
                                of that channel is a g1 spectrum of the
                                parameters for that X channel.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect3>
        </refsect2>
        <refsect2>
            <title>Listing spectra</title>
            <para>
                The command forms that list spectra are:
            </para>
            <cmdsynopsis>
                <command>
spectrum <option>-list</option> ?<option>-byid</option>? ?<option>-showgate</option> <replaceable>?pattern?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
spectrum <option>-list</option> <option>-id</option> ?<option>-showgate</option>? <replaceable>id</replaceable>
                </command>
            </cmdsynopsis>
            <para>
                The only difference between these two command forms is how the
                spectrum/spectra to be listed are selected.  In the first form,
                the more usual form, the spectra listed are filtered by
                an optional
                glob <parameter>pattern</parameter> that the names of listed
                spectra must match.  If <parameter>pattern</parameter> is not
                provided, it defaults to <literal>*</literal> which matches
                everything
            </para>
            <para>
                If <option>-id</option> is used, there must be an
                <parameter>id</parameter> parameter that specifies the numeric
                id of the one spectrum to be listed.
            </para>
            <para>
                Both forms of the command have an <option>-showgate</option> which
                adds an element to the description of each spectrum that
                is the name of the applied gate.  All spectra have an applied gate.
                Spectra are created with the special true gate named
                <literal>-TRUE-</literal> applied to them.
            </para>
            <para>
                If spectra are selected by name, the default ordering of the
                output is by spectrum name.  If <option>-byid</option> is used,
                the spectra will be ordered by increasing spectrum id.
            </para>
            <para>
                The output is a list, where each spectrum is represented by a
                sublist containing in order: The Spectrum id, spectrum name,
                spectrum type, parameter list (a properly formatted sub-sublist)
                axis-definition list (a properly formatted sublist) and data type.
                As described above, if the <option>-showgate</option> is
                specified, an additional  list element, the applied gate name
                is appended.
            </para>
        </refsect2>
        <refsect2>
            <title>Deleting spectra</title>
            <para>
                The forms of the <command>spectrum</command> command for deleting
                spectra are:
            </para>
            <cmdsynopsis>
                <command>
    spectrum <option>-delete</option> <replaceable>name</replaceable> <replaceable>?name...?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
    spectrum <option>-delete</option> <option>-id</option> <replaceable>id1 ?id2...?</replaceable>
                </command>
            </cmdsynopsis>
            <para>
                Deletes one or more spectra.  The difference between the two forms
                is how the spectra are specified.  If
                <option>-id</option> is not specified the remaining
                paramters are the names of spectra to delete.  If
                <option>-id</option> is used, they are spectrum ids.0
            </para>
        </refsect2>
        <refsect2>
            <title>Estabilishing trace scripts</title>
            <para>
                The command for establishing spectrum traces has the following
                form:
            </para>
            <cmdsynopsis>
                <command>
spectrum <option>-trace</option></command>
<group>
    <arg>add <replaceable>?script?</replaceable></arg>
    <arg>delete <replaceable>?script?</replaceable></arg>
</group>  
            </cmdsynopsis>
            <para>
                First a bit about spectrum traces and what they can be used for.
                Traces allow Tcl scripts to take actions when changes are made
                to the SpecTcl spectrum dictionary.  There are two types
                of traces: <firstterm>add</firstterm> trace scripts are run when
                a spectrum is added to the spectrum dictionary.
                <firstterm>delete</firstterm> traces scripts are run
                when a spectrum is removed from the spectrum dictionary.
            </para>
            <para>
                Trace scripts may, themselves, affect the spectrum dictionary.
                Therefore tracing is disabled while a trace script is
                executing.  Note that all tracing is disabled.  By this I mean
                that suppose an add trace deletes a spectrum.  That won't fire
                the delete trace.
            </para>
            <para>
                The command specifies as the first parameter after
                <option>-trace</option> which trace is affected by this
                command.  Regardless of whether or not a new trace is
                provided, the command returns the previous trace or an empty
                string if no trace is established.
            </para>
            <para>
                <parameter>script</parameter>, if provided replaces any existing
                trace.  Note that since only one trace is established at any time,
                you should memorize the prior script and run it
                from your trace script unless you know
                exactly what you're doing.  If the <parameter>script</parameter>
                is empty, the trace is disabled.
            </para>
            <para>
                Trace scripts are invoked with the affected spectrum appended
                to the script.
            </para>
        </refsect2>
    </refsect1>
    
    <refsect1>
        <title>EXAMPLES</title>
        <example>
             <title>Creating a 1-d spectrum</title>
             <screen><command>
<prompt>(sample) 49 % </prompt>spectrum ex1 1 raw.00 {{0 1023 1024}}
<computeroutput>ex1</computeroutput>
             </command></screen>
        </example>
        <example>
            <title>Creating a 2-d spectrum</title>
            <screen><command>
<prompt>(sample) 50 %</prompt> spectrum ex2 2 {raw.00 raw.01} {{0 1023 1024} {0 1023 1024}}
<computeroutput>ex2</computeroutput>
            </command></screen>
        </example>
        <example>
            <title>Creating a g1 spectrum</title>
            <screen><command>
<prompt>(sample) 51 %</prompt> spectrum exg1 g1 {raw.00 raw.01 raw.02 raw.03 raw.04} {{0 1023 1024}}
<computeroutput>exg1</computeroutput>
            </command></screen>
        </example>
        <example>
            <title>Creating a g2 spectrum</title>
            <screen><command>
<prompt>(sample) 52 %</prompt> spectrum exg2 g2 {raw.00 raw.01 raw.02 raw.03 raw.04} \
                                {{0 1023 1024} {0 1023 1024}}
<computeroutput>exg2</computeroutput>
            </command></screen>
        </example>
        <example>
            <title>Creating a summary spectrum</title>
            <screen><command>
<prompt>(sample) 53 %</prompt> spectrum exs s {raw.00 raw.01 raw.02 raw.03 raw.04} {{0 1023 1024}}
<computeroutput>exs</computeroutput>
            </command></screen>
        </example>
        <example>
            <title>Creating a bitmask spectrum</title>
            <screen><command>
<prompt>(sample) 54 % </prompt>spectrum exb b {raw.00} {{0 9 10}}
<computeroutput>exb</computeroutput>	
            </command></screen>
        </example>
        <example>
            <title>Making a strip chart spectrum</title>
            <screen><command>
<prompt>(sample) 55 % </prompt>spectrum exS S {raw.00 raw.01} {{0 1023 1024}}
<computeroutput>exS</computeroutput>
            </command></screen>
        </example>
        <example>
            <title>Creating an m2 (multiple 2d spectrum)</title>
            <screen><command>
<prompt>(sample) 57 %</prompt> spectrum exm2 m2 {raw.00 raw.01 raw.02 raw.03 raw.04 raw.05} \
            {{0 1023 1024} {0 1023 1024}}
<computeroutput>exm2</computeroutput>
            </command></screen>
        </example>
        <example>
            <title>Creating a gd (gamma deluxe) spectrum</title>
            <screen><command>
<prompt>(sample) 59 %</prompt> spectrum exgd gd    \
        {{raw.00 raw.01 raw.03} {raw.04 raw.05 raw.06}} \
        {{0 1023 1024} {0 1023 1024}}
<computeroutput>exgd</computeroutput>
            </command></screen>
        </example>
        <example>
            <title>Creating a gs (gamma summary) spectrum</title>
            <screen><command>
<prompt>% </prompt>spectrum exgs gs {{raw.00 raw.01} {raw.02 raw.03 raw.04} {raw.05 raw.06} } \
                 {{0 1023 1024}}
<computeroutput>exgs</computeroutput>
            </command></screen>
        </example>
        <example>
            <title>Listing all spectra</title>
            <screen><command>
<prompt>%</prompt> spectrum -list
<computeroutput>
{0 raw.00 1 {raw.00} {{0.000000 1023.000000 1024}} long}
{1 raw.01 1 {raw.01} {{0.000000 1023.000000 1024}} long}
{2 raw.02 1 {raw.02} {{0.000000 1023.000000 1024}} long}
{3 raw.03 1 {raw.03} {{0.000000 1023.000000 1024}} long}
{4 raw.04 1 {raw.04} {{0.000000 1023.000000 1024}} long}
{5 raw.05 1 {raw.05} {{0.000000 1023.000000 1024}} long}
{6 raw.06 1 {raw.06} {{0.000000 1023.000000 1024}} long}
{7 raw.07 1 {raw.07} {{0.000000 1023.000000 1024}} long}
{8 raw.08 1 {raw.08} {{0.000000 1023.000000 1024}} long}
{9 raw.09 1 {raw.09} {{0.000000 1023.000000 1024}} long}
{10 twod 2 {raw.00 raw.01} {{0.000000 1023.000000 1024} {0.000000 1023.000000 1024}} long}
</computeroutput>
            </command></screen>
        </example>
        <example>
            <title>Listing only spectra with matching names</title>
            <screen><command>
<prompt>%</prompt> spectrum -list t*
<computeroutput>
{10 twod 2 {raw.00 raw.01} {{0.000000 1023.000000 1024} {0.000000 1023.000000 1024}} long}
</computeroutput>
            </command></screen>     
        </example>
        <example>
            <title>Deleting a spectrum</title>
            <screen><command>
spectrum -delete raw.05	
            </command></screen>
        </example>
        <example>
            <title>Spectrum traces:</title>
            <programlisting>
# Prior add/delete traces:

set oldAdd ""
set oldDel ""

proc spectrumadd name {
    puts "Adding spectrum $name"
    if {$::oldAdd ne ""}  {
        uplevel #0 $oldAdd $name
    }
}

proc spectrumdel name {
    puts "Deleting spectrum $name"
    if {$::oldDel ne ""} {
        uplevfel #0 $oldDel $name
    }
}

set oldAdd [spectrum -trace add spectrumadd]
set oldDel [spectrum -trace delete spectrumdel]

            </programlisting>
            <screen><command>
<prompt>(sample) 50 %</prompt> spectrum summary s {raw.00 raw.01 raw.02 raw.03 raw.04} {{0 1023 1024}}
<computeroutput>Adding spectrum summary
summary</computeroutput>

<prompt>(sample) 51 % </prompt>spectrum -delete raw.01
<computeroutput>Deleting spectrum raw.01</computeroutput>
            </command></screen>
        </example>        
    </refsect1>
    
    <refsect1>
        <title>SEE ALSO</title>
        <itemizedlist>
            <listitem>
                <para>
                    <link linkend='ref.applycommand' endterm='ref.applycommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.foldcommand' endterm='ref.foldcommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.gatecommand' endterm='ref.gatecommand.title' />      
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.parametercommand' endterm='ref.parametercommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.treeparametercommand' endterm='ref.treeparametercommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.sbindcommand' endterm='ref.sbindcommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.channelcommand' endterm='ref.channelcommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.scontentscommand' endterm='ref.scontentscommand.title' />
                </para>
            </listitem>
        </itemizedlist>
                   
    </refsect1>
</refentry>

<refentry id='ref.unbindcommand'>
    <refmeta>
        <refentrytitle id='ref.unbindcommand.title'>unbind</refentrytitle>
        <manvolnum>1SpecTcl</manvolnum>
    </refmeta>
    
    <refnamediv>
        <refname>unbind</refname>
        <refpurpose>Move spectrum storage out of shared display memory</refpurpose>
    </refnamediv>
    
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
unbind <replaceable>name ?name...?</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
unbind <option>-id</option> <replaceable>id1 ?id2...?</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
unbind <option>-all</option>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
unbind <option></option> <replaceable>xid1 ?xid2...?</replaceable>   
            </command>
        </cmdsynopsis>
    </refsynopsisdiv>
    
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Removes the bulk storage of one or more spectra from the
            Display shared memory.   Using <command>sbind</command>
            and <command>unbind</command> you can have SpecTcl work
            with a much larger spectrum storage than the shared memory
            supports; manually swapping spectra in an out of shared memory.
        </para>
        <para>
            There are three ways you can refer to spectra:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                      The name of the
                    spectrum is a text string that you defined when you created the
                    spectrum.
                </para>
            </listitem>
            <listitem>
                <para>
                    The id of a spectrum is a integer that was assigned to the
                    spectrum by SpecTcl when you created it.
                </para>
            </listitem>
            <listitem>
                <para>
                    The xid (originally Xamine Id) is a number that indicates
                    the slot in the spectrum directory that was assigned to
                    a spectrum that is already bound to the display shared
                    memory region.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            In the synopsis above, the first form of the command allows you to
            remove one or more spectra from display shared memory.  Spectra
            are identified by their names.  This command form does not require
            any command options.
        </para>
        <para>
            Using the <option>-id</option> option, you can remove one or more
            spectra from the shared memory region by specifying the SpecTcl
            ids.
        </para>
        <para>
            Using the <option>-all</option> option you can remove all spectra
            from the shared memory.  This option takes no additional parameters.
        </para>
        <para>
            Finally, the <option>-xid</option> allows you to specify the spectra
            to be removed from display shared memory by their xid numbers.
        </para>
        <para>
            Note that <command>unbind</command> has no deleterious effects on the
            spectrum or its contents.  Storage is allocated outside of shared
            memory for the spectrum contents and the current contents are
            copied to that storage.  Furthermore, the spectrum continues
            to increment as before.  I simply cannot be displayed from display
            shared memory.  A sufficiently sophisticated displayer
            <emphasis>could</emphasis> access the spectrum contents via the
            SpecTcl REST plugin at lower performance, however.
        </para>
    </refsect1>
    
    <refsect1>
        <title>SEE ALSO</title>
        <itemizedlist>
            <listitem>
                <para>
                    <link  linkend='ref.spectrumcommand' endterm='ref.spectrumcommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.sbindcommand' endterm='ref.sbindcommand.title' />
                </para>
            </listitem>
        </itemizedlist>
    </refsect1>
</refentry>
<refentry id='ref.ungatecommand'>
    <refmeta>
        <refentrytitle id='ref.ungatecommand.title'>ungate</refentrytitle>
        <manvolnum>1SpecTcl</manvolnum>
    </refmeta>
    
    <refnamediv>
        <refname>ungate</refname>
        <refpurpose>Remove gate applications.</refpurpose>
    </refnamediv>
    
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
ungate <replaceable>spec1 ?spec2...?</replaceable>
            </command>
        </cmdsynopsis>

    </refsynopsisdiv>
    
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            All SpecTcl spectra have a gate applied to them.   The
            <command>apply</command> command applies a different gate to a
            spectrum.  One of the conditions for a gate to increment is that
            the gate applied to it must be satisfied (true) for the event that
            might increment it.
        </para>
        <para>
            <command>ungate</command> replaces the gate applied to the
            spectra <parameter>spec1</parameter> and so on with a predefined
            gate named <literal>-TRUE-</literal>.  As the name implies, the
            <literal>-TRUE-</literal> gate is true for every event (it is
            a gate of type <literal>T</literal>).  This effectively removes
            any applied gate from the spectrum.
        </para>
    </refsect1>
    
    <refsect1>
        <title>SEE ALSO</title>
        <itemizedlist>
            <listitem>
                <para>
                    <link linkend='ref.applycommand' endterm='ref.applycommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.gatecommand' endterm='ref.gatecommand.title' />
                </para>
            </listitem>
        </itemizedlist>
    </refsect1>
</refentry>

<refentry id='ref.versioncommand'>
    <refmeta>
        <refentrytitle id='ref.versioncommand.title'>version</refentrytitle>
        <manvolnum>1SpecTcl</manvolnum>
    </refmeta>
    
    <refnamediv>
        <refname>version</refname>
        <refpurpose>Return SpecTcl version</refpurpose>
    </refnamediv>
    
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
version
            </command>
        </cmdsynopsis>
    </refsynopsisdiv>
    
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This command returns the SpecTcl version.  Scripts and REST clients
            can us the version number to know which features are available
            to SpecTcl and which are not.  The version is returned in a string
            of the form major.minor-editlevel.
        </para>
        <variablelist>
            <varlistentry>
                <term>major</term>
                <listitem>
                    <para>
                        The major part of the version increments when SpecTcl's
                        development leads to potential user source code
                        incompatibility.  Users should refer to version
                        release notes for information about how to port their
                        code.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>minor</term>
                <listitem>
                    <para>
                        The minor version increments when SpecTcl's development
                        requires user code recompilation but no modifications
                        to the user source code are required.  This can happen
                        if classes that are publicly visible have changes made
                        to their shaps.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>editlevel</term>
                <listitem>
                    <para>
                        Edit level increments generally reflect fixes to known
                        defects that require no recompilation or relinking.
                        Simply using the new shared libraries is sufficient.
                        While it is possible to take an existing SpecTcl and
                        redirect where it loads its SpecTcl libraries from,
                        it is generally more practical to modify the Makefile's
                        <literal>INSTDIR</literal> definition and relink the
                        software.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
</refentry>
<refentry id='ref.swritecommand'>
    <refmeta>
        <refentrytitle id='ref.swritecommand.title'>sread</refentrytitle>
        <manvolnum>1SpecTcl</manvolnum>
    </refmeta>
    
    <refnamediv>
        <refname>swrite</refname>
        <refpurpose>Write spectrum contents to file.</refpurpose>
    </refnamediv>
    
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
swrite <option>-format</option> <replaceable>fmt file spec1 ?spec2 ... ?</replaceable>
            </command>
        </cmdsynopsis>
    </refsynopsisdiv>
    
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Writes one or more spectra either to a file specified by name or a
            file opened with the Tcl open command.
        </para>
        <para>
            Writes the spectra specified by
            <parameter>spec1</parameter>...
            <parameter>specn</parameter> to file.  The
            spectra are written in the order they are specified. The optional
            <option>-format</option> switch indicates that the next parameter
            specifies the file format.  The
            <parameter>file</parameter> parameter specifies the file to which
            the spectrum will be written.   The file parameter can be:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    A directory path to a file in which case the file is
                    created, written and closed.
                </para>
            </listitem>
            <listitem>
                <para>
                    A file id returned from the Tcl open command in which case
                    the file id is written to in its current position and
                    remains open after the write.            
                </para>
            </listitem>
        </itemizedlist>
    </refsect1>
    
    <refsect1>
        <title>OPTIONS</title>
        <para>
            The <option>-format</option> option describes how the file will be
            written.  See the <command>sread</command> command for more information
            about the file formats.  THere are two formats (each has two
            names):
        </para>
        <variablelist>
            <varlistentry>
                <term><literal>ascii</literal>, <literal>nsclascii</literal></term>
                <listitem>
                    <para>
                        An ASCII format.  Each spectrum consists of a header
                        and a set of lines containing channel coordinate/value
                        pairs for all nonzero channels in the spectrum.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>binary</literal> <literal>nsclbinary</literal></term>
                <listitem>
                    <para>
                        SMAUG binary format.  This format is not recommended
                        unless you have old SMAUG analysis tools you intend to
                        use on the files.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    
    <refsect1>
        <title>EXAMPLES</title>
        <example>
            <title>Writing spectra to file by filename</title>
            <programlisting>
swrite -format ascii somespectra.spc  raw.00 raw.01 raw02                
            </programlisting>
        </example>
        <para>
            Three psectra are written to file into the file
            <filename>somespectra.spc</filename>.
        </para>
        <example>
            <title>Writing to a file descriptor</title>
            <programlisting>
set fd [open "|gzip  &gt; somespectra.gz" w]
swrite -format ascii $fd raw.00 raw.01 raw.02
            </programlisting>
        </example>
        <para>
            The spectra are written to a pipeline created by the Tcl
            <command>open</command> command that compresses them using
            <command>gzip</command> into a file name <filename>somepsectra.gz</filename>.
            Note that the open command will require the spaces 
            before and after the
            output redirection character (<literal>&gt;</literal>) unlike
            bash.
        </para>
    </refsect1>
    
    <refsect1>
        <title>SEE ALSO</title>
        <itemizedlist>
            <listitem>
                <para>
                    <link linkend='ref.sreadcommand' endterm='ref.sreadcommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.spectrumcommand' endterm='ref.spectrumcommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <command>open</command>(3tcl)
                </para>
            </listitem>
        </itemizedlist>
    </refsect1>
</refentry>

<refentry id='ref.startcommand'>
    <refmeta>
        <refentrytitle id='ref.startcommand.title'>start</refentrytitle>
        <manvolnum>1SpecTcl</manvolnum>
    </refmeta>
    
    <refnamediv>
        <refname>start</refname>
        <refpurpose>Start analyzing data</refpurpose>
    </refnamediv>
    
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
start1
            </command>
        </cmdsynopsis>
    </refsynopsisdiv>
    
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Starts analyzing data from the current data source.  Data will be
            analyzed until one of the following occurs:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    The <command>stop</command> command is issued.
                </para>
            </listitem>
            <listitem>
                <para>
                    The <command>attach</command> command attaches SpecTcl
                    to a new data source.
                </para>
            </listitem>
            <listitem>
                <para>
                    An endfile is encountered on the current data source.
                </para>
            </listitem>
        </itemizedlist>
    </refsect1>

    
    <refsect1>
        <title>SEE ALSO</title>
        <itemizedlist>
            <listitem>
                <para>
                    <link linkend='ref.stopcommand' endterm='ref.stopcommand.title' />
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='ref.attachcommand' endterm='ref.attachcommand.title' />
                </para>
            </listitem>
        </itemizedlist>
    </refsect1>
</refentry>
<refentry id='ref.stopcommand'>
    <refmeta>
        <refentrytitle id='ref.stopcommand.title'>start</refentrytitle>
        <manvolnum>1SpecTcl</manvolnum>
    </refmeta>
    
    <refnamediv>
        <refname>stop</refname>
        <refpurpose>stop analyzing data</refpurpose>
    </refnamediv>
    
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
stop
            </command>
        </cmdsynopsis>
    </refsynopsisdiv>
    
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Stops analyzing data fromt he current data source.  Data is no longer
            analyzed until the <command>start</command> command is next issued.
            Note that if you are using <command>ringselector</command> from
            NSCLDAQ as a pipe data source without the  <option>--non-blocking</option>
            option, this will eventually cause data acquisition to halt with
            backpressure.  We therefore strongly encourage the use of the
            <option>--non-blocking</option> option with
            <command>ringselector</command>.
        </para>
    </refsect1>
    

    
    <refsect1>
        <title>SEE ALSO</title>
        <itemizedlist>
            <listitem>
                <para>
                    <link linkend='ref.startcommand' endterm='ref.startcommand.title' />
                </para></listitem>
            <listitem>
                <para>
                    <link linkend='ref.attachcommand' endterm='ref.attachcommand.title' />
                </para>
            </listitem>
        </itemizedlist>
    </refsect1>
</refentry>
<refentry id='ref.rootexec'>
    <refmeta>
        <refentrytitle id='ref.rootexec.title'>rootexec</refentrytitle>
        <manvolnum>1SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>rootexec (experimental 5.0)</refname>
        <refpurpose>Execute a root macro file.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
rootexec <replaceable>filename</replaceable>
            </command>
        </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            SpecTcl 5.0 introduces an experimental integration with CERN's Root
            data analysis framework.  This command passes the
            <replaceable>filename</replaceable> parameter to the root interpreter
            for execution.  
        </para>
        <para>
            Note that SpecTcl's initialization order is such that this is
            supported from within <filename>SpecTclRC.tcl</filename> but
            <emphasis>not</emphasis> from within
            <filename>SpecTclInit.tcl</filename>
        </para>
    </refsect1>
    <refsect1>
        <title>EXAMPLE</title>
        <para>
            Suppose we have a file named Browser.C that contains the C++ code:
        </para>
        <informalexample>
            <programlisting>
void Browser() {
    new TBrowser;
}
            </programlisting>
        </informalexample>
        <para>
            The command
            <command>rootexec Browser.C</command> will bring up a Root Browser
            window.  Note that all SpecTcl spectra now are histogrammed using
            Root histogram objects and will appear in the
            <filename>root/ROOT memory</filename> folder of the browser.
        </para>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>roottree</refentrytitle>
        <manvolnum>1SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>roottree</refname>
        <refpurpose>Write CERN ROOT Trees.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
roottree create <replaceable>tree-name parameter-pattern-list ?gate?</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
roottree delete <replaceable>tree-name</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
roottree list <replaceable>?tree-name-pattern?</replaceable>
            </command>
        </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This command allows SpecTcl to write  root trees from the
            unpacked parameters.  Root Tree writers act as a
            Event sink, but are linked to an event processor so that they
            are aware when run start/stop records are encountered.
        </para>
        <para>
            The <literal>create</literal> subcommand creates a new
            tree named <parameter>tree-name</parameter> the parameters
            that match any of the list of glob patterns in
            <parameter>parameter-pattern-list</parameter> will be written to the
            tree.  If <parameter>gate</parameter> is supplied, branches will
            only be written to the tree for events that satisfy that
            gate name.
        </para>
        <para>
            The <literal>delete</literal> subcommand deletes the root
            tree named by <parameter>tree-name</parameter>.  Deleting the
            tree does not remove it from any open Root file.  All it does is
            prevent that tree from having any further branches written in any open
            root file and from existing in any future root file.
        </para>
        <para>
            The <literal>list</literal> subcommand produces a Tcl list
            of trees that are currently defined.  If the glob-pattern
            <parameter>tree-name-pattern</parameter> is supplied, only those
            trees whose names match that pattern will be listed.  If
            <parameter>tree-name-pattern</parameter> is omitted, the default
            glob pattern, <literal>*</literal>, matches all trees.
        </para>
        <para>
            The output of the <literal>list</literal> subcommand is
            a Tcl list of tree descriptions.  Each description consists of a
            three element sublist.  The elements of that sublist are, in order,
            The tree name, the list of parameter patterns defining the
            written parameters and the name of the gate that conditionalizes
            branch creation in the tree.  If no gate was selected, this will
            be the string <literal>-T-</literal> indicating a True gate is
            used.
        </para>
        <para>
            The name of the root file written is
            <filename>run-<replaceable>runnumber</replaceable>.root</filename>
            in the current working directory of the login.  If it's necessary to
            write trees but no begin run item has been seen, the trees will be
            written to the file <filename>SpecTcl-<replaceable>seq</replaceable>.root</filename>
            where <replaceable>seq</replaceable> is the number of times we've been
            asked to start writing tree data without seeing a start.
        </para>
        <para>
            Typically the case of not seeing a start occurs when attachingh to
            an online data source.
        </para>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>pman</refentrytitle>
        <manvolnum>1SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>pman</refname>
        <refpurpose>V5.1+ Manipulate the SpecTcl Analysis Pipeline</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
pman mk <replaceable>pipeline-name</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
pman ls ?pattern?             
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
pman current
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
pman ls-all ?pattern?
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
pman ls-evp ?pattern?
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
pman use  <replaceable>pipeline-name</replaceable>     
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
pman add <replaceable>pipeline-name processor-name</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
pman rm <replaceable>pipeline-name processor-name</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
pman clear <replaceable>pipeline-name</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
pman clone <replaceable>existing-pipe new-pipe</replaceable>
            </command>
        </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The <command>pman</command> command ensemble is fully functional
            and available starting with SpecTcl 5.1.  Along with the
            <classname>CPipelineManager</classname> class, it supports
            fully dynamic event processing pipelines within SpecTcl.
        </para>
        <para>
            Once you have registered a set of event processors, you can use the
            <command>pman</command> command to create pipelines of these processors
            and dynamically select which of theses is actively operating.
        </para>
        <para>
            The <command>pman</command> command is a command ensemble.  This
            means it has a mandatory first command parameter which is a subcommand
            that describes which pipeline management function you wish it
            to perform.
        </para>
        <para>
            Note that only the pipeline manager can be used to register
            event processors, however SpecTcl plugins can be created
            that define, instantiate and register event processors when
            loaded.
        </para>
    </refsect1>
    <refsect1>
        <title>SUBCOMMANDS</title>
        <variablelist>
            <varlistentry>
                <term>
        <cmdsynopsis>
            <command>
pman mk <replaceable>pipeline-name</replaceable>
            </command>
        </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates a new event processing pipeline named
                        <parameter>pipeline-name</parameter>.  It is an error
                        to try to create a pipeline with the name of an existing
                        pipeline.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
        <cmdsynopsis>
            <command>
pman ls ?pattern?             
            </command>
        </cmdsynopsis>

                </term>
                <listitem>
                    <para>
                        Lists the names of the pipeline that match the optional
                        glob pattern. If <parameter>pattern</parameter>
                        is omitted, it defaults to <literal>*</literal> which
                        matches all names.
                    </para>
                    <para>
                        The return value of the command is a proper Tcl list
                        whose elements are the names of the pipelines.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
        <cmdsynopsis>
            <command>
pman current
            </command>
        </cmdsynopsis>
                    
                </term>
                <listitem>
                    <para>
                        Describes the current event procsssing pipeline.
                        The result of this command is a two element Tcl
                        list.  The first element of the list is the
                        name of the current pipeline.  The second element
                        is a list whose elements are the names of the
                        event processors in the pipeline.  Note that
                        the names of the event processors are given in the
                        order in which they are in the pipeline.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
        <cmdsynopsis>
            <command>
pman ls-all ?pattern?
            </command>
        </cmdsynopsis>                    
                </term>
                <listitem>
                    <para>
                        Lists all the information about event processing
                        pipelines that have been defined that match the optional
                        <parameter>pattern</parameter>. If
                        <parameter>pattern</parameter> is not provided,
                        it defaults to <literal>*</literal> which matches all
                        pipeline names.
                    </para>
                    <para>
                        The result of this command is a list with one element
                        per pipeline.  Each element is a two element sublist.
                        The first element of that sublist is the name of a pipeline.
                        The second element is, itself, a list that contains the names
                        of the event processors in that pipeline in the order
                        in which they occur.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
pman ls-evp ?pattern?
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Lists the names of the registered event processors
                        that match the optional glob <parameter>pattern</parameter>.
                        If <parameter>pattern</parameter> is omitted, it defaults to
                        <literal>*</literal> which matches all names.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
        <cmdsynopsis>
            <command>
pman use  <replaceable>pipeline-name</replaceable>     
            </command>
        </cmdsynopsis>
                    
                </term>
                <listitem>
                    <para>
                        Tells SpecTcl to use the pipeline named
                        <parameter>pipeline-name</parameter> as the current
                        event processing pipeline.  Beginning with the next
                        event processed, the event processors in
                        <parameter>pipeline-name</parameter> will be used to
                        process events into parameters.
                    </para>
                    <para>
                        It is an error for <parameter>pipeline-name</parameter>
                        not to exist.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
        <cmdsynopsis>
            <command>
pman add <replaceable>pipeline-name processor-name</replaceable>
            </command>
        </cmdsynopsis>
                    
                </term>
                <listitem>
                    <para>
                        Adds an the event processor
                        <parameter>processor-name</parameter> to the end
                        of the event processing pipeline
                        <parameter>pipeline-name</parameter>.
                        An error is thrown if the
                        <parameter>pipeline-name</parameter> is not an
                        event processing pipeline or
                        <parameter>processor-name</parameter> is not a
                        registered event processing pipeline.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
        <cmdsynopsis>
            <command>
pman rm <replaceable>pipeline-name processor-name</replaceable>
            </command>
        </cmdsynopsis>
                    
                </term>
                <listitem>
                    <para>
                        Removes the event processor
                        <parameter>processor-name</parameter> from the
                        pipelnie <parameter>pipeline-name</parameter>.
                        If <parameter>pipeline-name</parameter> is not the  name
                        of a pipeline the command will throw an error.
                        If <parameter>processor-name</parameter> is not the
                        name of an event processor in <parameter>pipeline-name</parameter>,
                        the command will also throw an error.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
        <cmdsynopsis>
            <command>
pman clear <replaceable>pipeline-name</replaceable>
            </command>
        </cmdsynopsis>
                    
                </term>
                <listitem>
                    <para>
                        Removes all event processors from the event processing
                        pipeline named <parameter>pipeline-name</parameter>.
                        If <parameter>pipeline-name</parameter> does not exist,
                        the command throws an error.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
        <cmdsynopsis>
            <command>
pman clone <replaceable>existing-pipe new-pipe</replaceable>
            </command>
        </cmdsynopsis>                    
                </term>
                <listitem>
                    <para>
                        Creates an exact duplicate of the event processing
                        pipeline <parameter>existing-pipe</parameter> and names
                        it <parameter>new-pipe</parameter>.
                        <parameter>new-pipe</parameter> will be a pipeline with
                        exactly the same list of event processors.
                    </para>
                    <para>
                        If <parameter>existing-pipe</parameter> is not an
                        event pipeline an error is thrown.  If
                        <parameter>new-pipe</parameter> is already defined,
                        an error is thrown.
                    </para>
                </listitem>
            </varlistentry>
            
        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>evbunpack</refentrytitle>
        <manvolnum>1SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>evbunpack</refname>
        <refpurpose>Dynamically setup decoding of event built data.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
evbunpack create evpname frequency diag-basename
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
evbunpack addprocessor evpname sid pipe-name
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
evbunpack list ?pattern?
            </command>
        </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <command>evbunpack</command> is a command ensemble that's intended
            to work with <command>pman</command> to support dynamically
            setting up analysis of data from event built data sources.
        </para>
        <para>
            The concept is that you use <command>evbunpack</command> to create
            a <classname>CEventBuilderEventProcessor</classname> at script level.
            You can then tell that processor to use an event processing pipeline
            to analyze data from each source id found in event builder fragments.
            Naturally, this can be cascaded such that a pipeline might contain
            another event builder event processor which allows SpecTcl
            to process data from hierarchically built events.
        </para>
        <para>
            Once you've created and stocked you event processor, you can
            then use <command>pman</command>
            to create a pipeline whose first element is that
            event processor.
        </para>
    </refsect1>
    <refsect1>
        <title>SUBCOMMANDS</title>
        <para>
            The <command>evbunpack</command> command is actually a command
            ensemble.  The first command parameter is, therefore, a subcommand
            that tells <command>evbunpack</command> what to actually do:
        </para>
        <variablelist>
            <varlistentry>
                <term>
        <cmdsynopsis>
            <command>
evbunpack create evpname frequency diag-basename
            </command>
        </cmdsynopsis>
                    
                </term>
                <listitem>
                    <para>
                        Creates a new event processor for unpacking
                        event built data.  <parameter>evpname</parameter>
                        give the processor a name that will be used to
                        register it with the pipeline manager, thus making
                        it available to the <command>pman</command> command.
                    </para>
                    <para>
                        <parameter>frequency</parameter> is the frequency of
                        the timestamping clock in MHz.  This is used to construct
                        the elapsed run time parameter diagnostic parameter of
                        the event processor.
                    </para>
                    <para>
                        <parameter>diag-basename</parameter> is the base name of
                        a set of tree parameters.  The event processor produces
                        and maintains a set of diagnostic parameters that can
                        be used to monitor the correctness of the event builder.
                        See the programming reference manual's documentation
                        of <classname>CEventBuilderEventProcessor</classname>
                        for more informationa about the set of diagnostic parameters
                        produced.
                    </para>
                    <para>
                        Once created without error, the event processor is
                        registered with the <command>pman</command> command
                        allowing it to be placed into event processing pipelines.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
        <cmdsynopsis>
            <command>
evbunpack addprocessor evpname sid pipe-name
            </command>
        </cmdsynopsis>
                    
                </term>
                <listitem>
                    <para>
                        Tells the event processor to use an existing event processing
                        pipeline to analyze fragments from a specific data source.
                        <parameter>evpname</parameter> is the name of an event
                        processor created by <command>evbunpack create</command>.
                        <parameter>sid</parameter> is the source id of the fragments
                        <parameter>pipe-name</parameter> should handle.
                    </para>
                    <para>
                        <parameter>pipe-name</parameter> is the name of a pipeline
                        that <command>pman</command> knows about and can be
                        arbitrarily complex.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
        <cmdsynopsis>
            <command>
evbunpack list ?pattern?
            </command>
        </cmdsynopsis>            
                    
                </term>
                <listitem>
                    <para>
                        Returns a Tcl list of the event processors this command
                        has created.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title>BUGS</title>
        <para>
            At present, there's no way to determine which pipelines are
            analyzing which source ids for an event processor.
        </para>
    </refsect1>

</refentry>
</reference>

</book>

