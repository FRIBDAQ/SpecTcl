<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                      "file:///usr/share/xml/docbook/schema/dtd/4.5/docbookx.dtd
"
>
<book>
    <bookinfo>
      <title>SpecTcl Programming Reference.</title>
      <author><firstname>Ron</firstname><surname>Fox</surname></author>
      <revhistory>
          <revision>
             <revnumber>1.0</revnumber>
             <date>July 24, 2017 and following</date>
             <authorinitials>RF</authorinitials>
             <revremark>Original Release</revremark>
          </revision>
      </revhistory>
    </bookinfo>
    <chapter>
        <title>Introduction</title>
        <para>
            This manual provides reference pages for classes, scripts and
            file formats for the NSCL SpecTcl histogramming program.  Command
            reference information is explicitly not given here but in a separate
            command reference manual.
        </para>
        <para>
            The reference information is divided into the following parts:
        </para>
        <orderedlist>
            <listitem>
                <para>
                    The SpecTcl API provides a reference page for the
                    SpecTcl API class <classname>SpecTcl</classname>.  This
                    is sort of a stovepipe class that provides access to the
                    rest of the public API used by SpecTcl.
                </para>
            </listitem>
            <listitem>
                <para>
                    The Tree parameter/TreeVariable API provide structure as well
                    as metadata on top of SpecTcl's flat parameter array.
                    Authors of  event processors should write in terms of this API.
                </para>
            </listitem>
            <listitem>
                <para>
                    Tcl++ is a separate package, however it is so much an integral
                    part of the SpecTcl interface, that reference information
                    for that package is provided here as well.
                </para>
            </listitem>
            <listitem>
                <para>
                    Core SpecTcl classes include parameters, histograms,
                    and gates.  This part documents these core classes as well
                    as the methods of the <classname>CHistogrammer</classname>
                    class intended to be available for extension programs.
                </para>
            </listitem>
            <listitem>
                <para>
                    File formats.  This part describes the format of filter files
                    as well as both the binary and ASCII format of spectrum
                    files written by the <command>swrite</command> command.
                </para>
            </listitem>
        </orderedlist>
    </chapter>
    <part>
        <title>SpecTclAPI class</title>
        <chapter>
            <title>SpecTcl</title>
            <para>
                The <classname>SpecTcl</classname> class should be the starting
                point for any application needing services from SpecTcl.
                You should use it rather than any knowledge of the internals of
                SpecTcl when writing programs that extend or tailor SpecTcl.
            </para>
        </chapter>
        <refentry >
            <refmeta>
                <refentrytitle >SpecTcl</refentrytitle>
                <manvolnum>3spectcl</manvolnum>
            </refmeta>
            
            <refnamediv>
                <refname>SpecTcl</refname>
                <refpurpose>API Singleton class.</refpurpose>
            </refnamediv>
            
            <refsynopsisdiv>
                <synopsis>
#include <filename>&lt;SpecTcl.h&gt;</filename>
<classname>SpecTcl</classname>
{
public:
  static SpecTcl* getInstance();
  void addBufferDecoder(std::string                      type,
                        CAttachCommand::CDecoderCreator* creator);
  UInt_t AssignParameterId();
  CParameter* AddParameter(std::string name,
                           UInt_t Id,
                           std::string Units);
  CParameter* AddParameter(std::string name,
                           UInt_t id,
                           UInt_t scale);
  CParameter* AddParameter(std::string name,
                           UInt_t id,
                           UInt_t scale,
                           Float_t low, Float_t high,
                           std::string units);
  CParameter* RemoveParameter(std::string name);
  CParameter* FindParameter(std::string name);
  CParameter* FindParameter(UInt_t Id);
  ParameterDictionaryIterator BeginParameters();
  ParameterDictionaryIterator EndParameters();
  UInt_t ParameterCount();
  CSpectrum* CreateSpectrum(std::string Name,
                            SpectrumType_t type,
                            DataType_t dataType,
                            std::vector&lt;std::string&gt; parameters,
                            std::vector&lt;UInt_t&gt; channels,
                            std::vector&lt;Float_t&gt;* pLows,
                            std::vector&lt;Float_t&gt;* pHighs);
  CSpectrum* CreateSpectrum(std::string Name,
                            SpectrumType_t type,
                            DataType_t     dataType,
                            std::vector&lt;std::string&gt; xParameters,
                            std::vector&lt;std::string&gt; yParameters,
                            std::vector&lt;UInt_t&gt;      channels,
                            std::vector&lt;Float_t&gt;*    pLows,
                            std::vector&lt;Float_t&gt;*    pHighs);

  CSpectrum* CreateSpectrum(std::string           Name,
                            SpectrumType_t        type,
                            DataType_t            dataType,
                            std::vector&lt;std::vector&lt;std::string&gt; &gt; parameters,
                            std::vector&lt;UInt_t&gt;   channels,
                            std::vector&lt;Float_t&gt;* lows,
                            std::vector&lt;Float_t&gt;* highs);

  CSpectrum* CreateGammaSummary(std::string                      Name,
                                DataType_t                       dataType,
                                std::vector&lt;std::vector&lt;std::string&gt; &gt; parameters,
                                UInt_t                           nChannels,
                                std::vector&lt;Float_t&gt;*            low,
                                std::vector&lt;Float_t&gt;*            high);

  CSpectrum* CreateG2DDeluxe(std::string Name,
                        DataType_t     dataType,
                        std::vector&lt;std::string&gt; xParameters,
                        std::vector&lt;std::string&gt; yParameters,
                        std::vector&lt;UInt_t&gt;      channels,
                        std::vector&lt;Float_t&gt;*    pLows,
                        std::vector&lt;Float_t&gt;*    pHighs);

  CSpectrum* Create1D(std::string name,
                      DataType_t dataType,
                      CParameter&amp; parameter,
                      UInt_t channels);
  CSpectrum* Create1D(std::string name,
                      DataType_t dataType,
                      CParameter&amp; parameter,
                      UInt_t channels,
                      Float_t lowLimit, Float_t hiLimit);
  CSpectrum* Create2D(std::string name,
                      DataType_t dataType,
                      CParameter&amp; xParameter,
                      CParameter&amp; yParmaeter,
                      UInt_t xChannels, UInt_t yChannels);
  CSpectrum* Create2D(std::string name,
                      DataType_t dataType,
                      CParameter&amp; xParameter, CParameter&amp; yParameter,
                      UInt_t xChannels, Float_t xLow, Float_t xHigh,
                      UInt_t yChannels, Float_t yLow, Float_t yHigh);
  CSpectrum* CreateG1D(std::string name,
                       DataType_t dataType,
                       std::vector&lt;CParameter&gt; parameters,
                       UInt_t channels);
  CSpectrum* CreateG1D(std::string name,
                       DataType_t dataType,
                       std::vector&lt;CParameter&gt; parameters,
                       UInt_t channels,
                       Float_t lowLimit,
                       Float_t hiLimit);
  CSpectrum* CreateG2D(std::string name,
                       DataType_t dataType,
                       std::vector&lt;CParameter&gt; parameters,
                       UInt_t xChannels, UInt_t yChannels);
  CSpectrum* CreateG2D(std::string name,
                       DataType_t dataType,
                       std::vector&lt;CParameter&gt; parameters,
                       UInt_t xChannesl, Float_t xLow, Float_t xHigh,
                       UInt_t yChannesl, Float_t yLow, Float_t yHigh);
  CSpectrum* CreateBit(std::string name,
                       DataType_t dataType,
                       CParameter&amp; parameter,
                       UInt_t channels);
  CSpectrum* CreateBit(std::string name,
                       DataType_t dataType,
                       CParameter&amp; parameter,
                       UInt_t channels, UInt_t lowBit);
  CSpectrum* CreateSummary(std::string name,
                           DataType_t dataType,
                           std::vector&lt;CParameter&gt; parameters,
                           UInt_t channels);
  CSpectrum* CreateSummary(std::string name,
                           DataType_t dataType,
                           std::vector&lt;CParameter&gt; parameters,
                           UInt_t nChannels, Float_t low, Float_t high);


  CSpectrum* CreateGamma2DD(std::string name,
                            DataType_t dataType,
                            std::vector&lt;CParameter&gt; xParameters,
                            std::vector&lt;CParameter&gt; yParameters,
                            UInt_t xChannels, Float_t xLow, Float_t xHigh,
                            UInt_t yChannels, Float_t yLow, Float_t yHigh);
  CSpectrum* Create2DSum(std::string name,
                         DataType_t  dataType,
                         std::vector&lt;CParameter&gt; xParameters,
                         std::vector&lt;CParameter&gt; yParameters,
                         UInt_t xChans, Float_t xLow, Float_t xHigh,
                         UInt_t yChans, Float_t yLow, Float_t yHigh);
  CSpectrum* CreateStripChart(std::string name,
                              DataType_t  dataType,
                              CParameter  counts,
                              CParameter  time,
                              UInt_t      channels, Float_t xLow, Float_t xHigh);


  // Manipulate the spectrum dictionary:

  void AddSpectrum(CSpectrum&amp; spectrum);
  CSpectrum* RemoveSpectrum(std::string name);
  CSpectrum* FindSpectrum(std::string name);
  CSpectrum* FindSpectrum(UInt_t id);
  SpectrumDictionaryIterator SpectrumBegin();
  SpectrumDictionaryIterator SpectrumEnd();
  UInt_t SpectrumCount();

  void addSpectrumDictionaryObserver(SpectrumDictionaryObserver* observer);
  void removeSpectrumDictionaryObserver(SpectrumDictionaryObserver* observer);

  // Misc spectrum utilities:

  void ClearSpectrum(std::string name);
  void ClearAllSpectra();

  // Create gates of various types:

  CGate* CreateGate(CGateFactory::GateType gateType,
                    std::vector&lt;std::string&gt; names);
  CGate* CreateGate(CGateFactory::GateType gateType,
                    std::vector&lt;std::string&gt; parameters,
                    std::vector&lt;FPoint&gt; points);
  CGate* CreateGate(CGateFactory::GateType   gateType,
                    std::vector&lt;FPoint&gt;      points,
                    std::vector&lt;UInt_t&gt; parameters);
  CGate* CreateGate(CGateFactory::GateType gateType,
                    std::vector&lt;std::string&gt; rparameters,
                    long comparison);
  CGate* CreateTrueGate();
  CGate* CreateFalseGate();
  CGate* CreateBand(std::string xparameter, std::string yparameter,
                    std::vector&lt;FPoint&gt; points);
  CGate* CreateContour(std::string xParameter, std::string yParameter,
                       std::vector&lt;FPoint&gt; points);
  CGate* CreateBandContour(std::string firstBand, std::string secondBand);
  CGate* CreateNotGate(std::string name);
  CGate* CreateAndGate(std::vector&lt;std::string&gt; gateNames);
  CGate* CreateOrGate(std::vector&lt;std::string&gt; gateNames);
  CGate* CreateCut(std::string parameter, Float_t low, Float_t high);
  CGate* CreateGammaCut(Float_t low, Float_t high, std::vector&lt;std::string&gt; constituents);
  CGate* CreateGammaBand(std::vector&lt;FPoint&gt; points,
                         std::vector&lt;std::string&gt; constituents);
  CGate* CreateGammaContour(std::vector&lt;FPoint&gt; points,
                            std::vector&lt;std::string&gt; constituents);
  CGate* CreateMaskEqualGate(std::vector&lt;std::string&gt; rParameterName,
                             long Compare);
  CGate* CreateMaskAndGate(std::vector&lt;std::string&gt; rParameterName,
                             long Compare);
  CGate* CreateMaskNotGate(std::vector&lt;std::string&gt; rParameterName,
                             long Compare);


  // Gate dictionary manipulation:

  void AddGate(std::string name, CGate* gate);
  void DeleteGate(std::string gateName);
  void ReplaceGate(std::string gateName, CGate&amp; newGate);
  CGateContainer* FindGate(std::string gateName);
  CGateDictionaryIterator GateBegin();
  CGateDictionaryIterator GateEnd();
  UInt_t GateCount();

  void addGateDictionaryObserver(CGateObserver* observer);
  void removeGateDictionaryObserver(CGateObserver* observer);



  void ApplyGate(std::string gateName, std::string spectrumName);

  // Manipulating the event processor pipeline.

  void AddEventProcessor(CEventProcessor&amp; eventProcessor,
                         const char* name = 0);
  CTclAnalyzer::EventProcessorIterator FindEventProcessor(std::string name);
  CTclAnalyzer::EventProcessorIterator FindEventProcessor(CEventProcessor&amp; processor);
  void InsertEventProcessor(CEventProcessor&amp; processor,
                            CTclAnalyzer::EventProcessorIterator where,
                            const char*  name = 0);
  void RemoveEventProcessor(std::string name);
  void RemoveEventProcessor(CTclAnalyzer::EventProcessorIterator here);
  UInt_t ProcessingPipelineSize();
  CTclAnalyzer::EventProcessorIterator ProcessingPipelineBegin();
  CTclAnalyzer::EventProcessorIterator ProcessingPipelineEnd();

  void AddSpectrumFormatter(std::string name, CSpectrumFormatter&amp; formatter);

  void AddEventSink(CEventSink&amp; sink, const char* name = 0);
  CEventSinkPipeline::EventSinkIterator FindEventSink(std::string sinkName);
  CEventSinkPipeline::EventSinkIterator FindEventSink(CEventSink&amp; sink);
  void InsertEventSink(CEventSink&amp; sink, CEventSinkPipeline::EventSinkIterator here,
                       const char* name = 0);
  CEventSink* RemoveEventSink(std::string name);
  CEventSink* RemoveEventSink(CEventSinkPipeline::EventSinkIterator here);
  UInt_t EventSinkPipelineSize();
  CEventSinkPipeline::EventSinkIterator EventSinkPipelineBegin();
  CEventSinkPipeline::EventSinkIterator EventSinkPipelineEnd();

  void               createFilter(std::string name, CGatedEventFilter* pFilter);
  CGatedEventFilter* findFilter(std::string name);
  bool               filterExists(CGatedEventFilter* pFilter);
  void               deleteFilter(CGatedEventFilter* pFilter);
  void               deleteFilter(std::string filterName);
  void               addFilterOutputFormat(CFilterOutputStageCreator&amp; creator);


  // Expose the guts for the really curious and those who need more
  // than we can offer.

  CTCLInterpreter*    getInterpreter();
  CHistogrammer*      GetHistogrammer();
  CTclAnalyzer*       GetAnalyzer();
  CEventSinkPipeline* GetEventSinkPipeline();
  CDisplayInterface *GetDisplayInterface();
  void SetDisplayInterface(CDisplayInterface&amp; rInterface);
  std::vector&lt;UInt_t&gt;      parameterIds(std::vector&lt;std::string&gt; names);


};

                </synopsis>
            </refsynopsisdiv>
            
            <refsect1>
                <title>DESCRIPTION</title>
                <para>
                    <classname>SpecTcl</classname> is a singleton class that
                    provides an application programming interface to the
                    functions SpecTcl considers public.  While every method in
                    this class is available in some way as a public method
                    in some other SpecTcl class, this set of interfaces is
                    gauranteed to remain avaiable through modifications to
                    SpecTcl's internal structures and algorithms.
                </para>
                <para>
                    As a singleton, the constructor and destructor of this
                    class are declared as <literal>private</literal>.  Use
                    the <methodname>getInstance</methodname> method to
                    obtain a pointer to the single instance of this class.
                </para>
            </refsect1>
            
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>static </modifier>
                                <type>SpecTcl* </type>
                                <methodname>getInstance</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns a pointer to the singleton instance
                                of this class.   This is the only supported
                                way to get an instance of this class.
                                Any two calls to <methodname>getInstance</methodname>
                                will return the same value.
                            </para>
                            <para>
                                There is no gaurantee that an instance of this
                                class will exist until the first call to this
                                method.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void </type>
                                <methodname>addBufferDecoder</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>type</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>CAttachCommand::CDecoderCreator* </type>
                                   <parameter>creator</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Adds a new buffer decoder to SpecTcl.
                                <parameter>type</parameter> is a format type
                                value that can be given to
                                <command>attach</command> <option>-format</option>.
                                <parameter>creator</parameter> is an instance
                                of a class that knows how to create a
                                buffer decoder that can unravel the data in
                                event files of the form specified by
                                <parameter>type</parameter>
                            </para>
                            <para>
                                The programming guide contains a chapter
                                that describes buffer decoders, what they are
                                for, how to write one and add it to the
                                SpecTcl <command>attach</command> command.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>UInt_t </type>
                                <methodname>AssignParameterId</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Each SpecTcl parameter must have a unique id.
                                This id is an integer index into the
                                flat parameter array that SpecTcl uses
                                to drive its gate checking and histogramming.
                                This method allocates a new, unique parameter
                                id.
                            </para>
                            <para>
                                This method should never return the same
                                integer twice. You can not gaurantee that
                                values from this method will be sequential
                                although they mostly will be.  Specifically,
                                <methodname>AssignParameterId</methodname>
                                will not assign a parameter Id that's already
                                been assigned. 
                            </para>
                            <para>
                                Imagine, for example, that this method just
                                returned <literal>1234</literal>.  Suppose
                                further a SpecTcl command or script line looked like:
                                <command>parameter somename 1235</command>.
                                The next call to <methodname>AssignParameterId</methodname>
                                will not return <literal>1235</literal> but an
                                integer that has not already been associated with
                                a parameter.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CParameter* </type>
                                <methodname>AddParameter</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>name</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>Id</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>Units</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Adds a new parameter definition to SpecTcl.
                                This method is the simplest way to add a parameter.
                                <parameter>name</parameter> is the name to be
                                givent to the new parameter.  It is an
                                error to assign the same name to two parameters.
                            </para>
                            <para>
                                <parameter>Id</parameter> is the new parameter's
                                id.  This usually should be a value  gotten
                                from a call to <methodname>AssignParameterId</methodname>.
                            </para>
                            <para>
                                <parameter>Units</parameter> are the units of
                                measure to assign to assign to the parameter.
                                This can be an empty string if the parameter
                                does not have an appropriate unit of measure
                                (e.g. a raw ADC value).
                            </para>
                            <para>
                                The method's return value is a pointer to the
                                new <classname>CParameter</classname>
                                object created and entered in the SpecTcl
                                parameter dictionary.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CParameter* </type>
                                <methodname>AddParameter</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>name</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>id</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>scale</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Adds a new parameter definition.  All of the
                                parameters are the same as the previous overload
                                for this method except that <parameter>scale</parameter>
                                is the number of bits used by the parameter.  This
                                is suitable for use with e.g. raw ADC values.
                            </para>
                            <para>
                                As with all <methodname>AddParameter</methodname>
                                overloads, the return value is a pointer
                                to the new <classname>CParameter</classname>
                                object that was created and entered in the
                                parameter dictionary.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CParameter* </type>
                                <methodname>AddParameter</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>name</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>id</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>scale</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>Float_t</type><parameter> low</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>Float_t </type><parameter>high</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>units</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Another overload that adds a new parameter
                                to SpecTcl.  <parameter>low</parameter> and
                                <parameter>high</parameter> define range
                                limits for the parameter.    These
                                define a mapping from raw parameter space to some
                                world coordinate space.  The value <literal>0</literal>
                                maps to <parameter>low</parameter> and the
                                value <literal>2**scale - 1</literal> maps
                                to <parameter>high</parameter>.
                            </para>
                            <para>
                                In general, it is better to use tree parameters
                                and compute the actual value of the parameter
                                than to use this confusing mapped parameter
                                scheme.  This scheme came into being for
                                SpecTcl-2.0 and is only retained for
                                compatibility with existing SpecTcl code.
                                It is normally used in conjunction with
                                <firstterm>Mapped spectra</firstterm>.
                            </para>
                            <para>
                                As with all overloads of
                                <methodname>AddParameter</methodname>, the
                                return value is a pointer to the
                                <classname>CParameter</classname> object
                                this call created.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CParameter* </type>
                                <methodname>RemoveParameter</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>name</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                If a parameter named <parameter>name</parameter>
                                has been defined it is removed from SpecTcl's
                                parameter dictionary and a pointer to a dynamically
                                allocated copy of that <classname>CParameter</classname>
                                object is returned.   The caller must
                                <literal>delete</literal> that object to
                                prevent memory leaks.
                            </para>
                            <para>
                                If there is no parameter named <parameter>name</parameter>
                                in the parameter dictionary, a null pointer is
                                returned from this method.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CParameter* </type>
                                <methodname>FindParameter</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>name</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Locates and returns a pointer to the parameter
                                object named <parameter>name</parameter>.  If there
                                is no matching parameter, a null pointer is returned.
                                Note that this is a pointer to the actual parameter
                                in the SpecTcl parameter dictionary and any
                                changes to it are reflected in the analysis
                                SpecTcl performs.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CParameter* </type>
                                <methodname>FindParameter</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t</type><parameter> Id</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns a pointer to a parameter given its
                                <parameter>Id</parameter>.  If no parameter
                                has that id, the method returns a null pointer.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                            <modifier></modifier>
                            <type>ParameterDictionaryIterator </type>
                            <methodname>BeginParameters</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>ParameterDictionaryIterator </type>
                                <methodname>EndParameters</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                These two methods support iteration of the
                                SpecTcl parameter dictionary.
                                <methodname>BeginParameters</methodname>
                                returns an iterator that acts like a pointer
                                to the first element of the parameter
                                dictionary. <type>ParameterDictionaryIterator</type>
                                objects support being incremented.  When incremented,
                                the "point" to the next dictionary element.
                                When the last element in the dict has been
                                pointed to, incrementing an iterator
                                gives it the value returned by
                                <methodname>EndParameters</methodname>.
                            </para>
                            <para>
                                The <type>ParameterDictionaryIterator</type>
                                is an STL <type>std::pair&lt;std::string, CParameter&gt;</type>
                                where the first element of the pair is the name of the
                                parameter and the second is a copy of the
                                <classname>CParameter</classname> with that
                                name.
                            </para>
                            <para>
                                Iteration is only good for read-only access to the
                                parameters as iterators 'point' to copies rather
                                than references or pointers to the actual
                                items in the dictionary.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>UInt_t </type>
                                <methodname>ParameterCount</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CSpectrum* </type>
                                <methodname>CreateSpectrum</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>Name</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>SpectrumType_t </type><parameter>type</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>DataType_t </type><parameter>dataType</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::vector&lt;std::string&gt; </type><parameter>parameters</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::vector&lt;UInt_t&gt; </type><parameter>channels</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::vector&lt;Float_t&gt;* </type><parameter>pLows</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::vector&lt;Float_t&gt;*</type><parameter> pHighs</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Creats a new histogram and returns a pointer to it.
                                The new spectrum has been dynamically created and
                                must, eventually, be destroyed with
                                <literal>delete</literal>.  
                            </para>
                            <para>
                                For SpecTcl's histogramming core and
                                command set to know about the new spectrum
                                it must be passed to
                                <methodname>AddSpectrum</methodname> (see below).
                                If this is not done, the caller has created
                                a spectrum that can be used by them but is
                                invisible to SpecTcl.
                            </para>
                            <para>
                                <parameter>Name</parameter> specifies a new name
                                to give to the spectrum.  If the spectrum will
                                be entered in the spectrum dictionary, this name
                                must not have been given to any other spectrum
                                in the spectrum dictionary.
                            </para>
                            <para>
                                <parameter>type</parameter> is the type  of
                                the spectrum.  This can be any value that
                                the enumerated type <type>SpectrumType_t</type>
                                can take and determines the type of the spectrum.
                                Note that we recommend that rather than using
                                this method to create a spectrum you use one of
                                the more specific creators documented below.
                            </para>
                            <para>
                                <parameter>type</parameter>, is the data type
                                for each channel of the spectrum.  This
                                can be one of <literal>keLong</literal> (recommended),
                                <literal>keWord</literal> or <literal>keByte</literal>,
                                and determines how many counts a spectrum channel
                                can have before the channel rolls over.
                            </para>
                            <para>
                                <parameter>parameters</parameter> is a vector
                                of the names of parameters that will be used
                                by the spectrum.  Note that some spectrum
                                types may need to specify x and y parameter lists,
                                see below.
                            </para>
                            <para>
                                <parameter>parameters</parameter> specifies the
                                parameters used by the spectrum.  The use of only
                                a single parameter list means this can only be used
                                to create spectra that don't need to differentiate
                                between X and Y parameters, such as 1D, gamma-1,
                                gamma-2, summary spectra etc.                                
                            </para>
                            <para>
                                <parameter>channels</parameter> is a vector
                                of one or two channel counts for the x and optional
                                y axis.
                            </para>
                            <para>
                                <parameter>pLows</parameter> and
                                <parameter>pHighs</parameter> are pointers to
                                vectors of the low and high limits for each
                                axis respectively.  There must be the same
                                number of <parameter>pHighs</parameter>
                                as <parameter>pLows</parameter>.
                            </para>
                            
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CSpectrum* </type>
                                <methodname>CreateSpectrum</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>Name</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>SpectrumType_t </type><parameter>type</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>DataType_t     </type><parameter>dataType</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::vector&lt;std::string&gt; </type><parameter>xParameters</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::vector&lt;std::string&gt; </type><parameter>yParameters</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::vector&lt;UInt_t&gt; </type><parameter>channels</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::vector&lt;Float_t&gt;* </type><parameter> pLows</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::vector&lt;Float_t&gt;*</type><parameter> pHighs</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Anothr method to create a generic spectrum.  The
                                difference between this and the previous overload
                                is that <parameter>xParameters</parameter> and
                                <parameter>yParameters</parameter> allow specification
                                of a set of parameters for the X and Y axes as are
                                needed for e.g. 2-d Spectra, 2-d Sum spectra or
                                Gamma Deluxe (particle-gamma) spectra.
                            </para>
                            <para>
                                Similarly, <parameter>pLows</parameter> and
                                <parameter>pHighs</parameter> provides a
                                set of limits for all axes.  The <parameter>channels</parameter>
                                vector can have channel counts for both axes.  These
                                are vectors to allow for future expansion in the
                                SpecTcl spectrum types
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CSpectrum* </type>
                                <methodname>CreateSpectrum</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string           </type><parameter>Name</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>SpectrumType_t        </type><parameter>type</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>DataType_t   </type><parameter>dataType</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::vector&lt;std::vector&lt;std::string&gt; &gt;</type><parameter> parameters</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::vector&lt;UInt_t&gt; </type><parameter>channels</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::vector&lt;Float_t&gt;* </type><parameter>lows</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::vector&lt;Float_t&gt;* </type><parameter>highs</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Provides a spectrum creator for when parameters
                                must come as a vector of vectors.  For example
                                for a gamma summary spectrumw where each X
                                channel of the spectrum may require more than
                                one parameter.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    The next several methods create specific types of spectra.
                    They are the recommended way to create spectra.  Usually
                    the generic methods above are a bit harder to use.
                </para>
                <variablelist>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>CreateGammaSummary</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string</type><parameter>Name</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier></modifier>
                                <type>DataType_t</type><parameter>dataType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;std::vector&lt;std::string&gt; &gt; </type><parameter>parameters</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter> nChannels</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;Float_t&gt;* </type><parameter>low</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;Float_t&gt;*  </type><parameter>high</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a gamma summary spectrum.  A gamma summary
                            spectrum, is a two dimensional spectrum whose
                            vertical channel strips are each a gamma spectrum.
                            <parameter>parameters</parameter> are a vector of
                            parameters for each X channel (vertical strip).
                            The outer vector index is a channel number and
                            the inner vector the set of parameters on that
                            strip.
                        </para>
                        <para>
                            The <parameter>nChannels</parameter> parameter is
                            the number of parameters in the Y direction
                            as the number of X channels is determined by the
                            size of the outer vector of
                            <parameter>parameters</parameter>.  The
                            <parameter>low</parameter> and
                            <parameter>high</parameter> vectors are the low and
                            high limits of each vertical strip in the parameter
                            space of the parameters that are histogrammed
                            on it.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>CreateG2DDeluxe</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>Name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>DataType_t </type><parameter>dataType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;std::string&gt; </type><parameter>xParameters</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;std::string&gt; </type><parameter>yParameters</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;UInt_t&gt;</type><parameter>channels,</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;Float_t&gt;* </type><parameter>pLows</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;Float_t&gt;* </type><parameter>pHighs</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a gamma deluxe spectrum.  This is a spectrum
                            multiply incremented spectrum with separate x and
                            y parameters sets.  The spectrum is incremented
                            for each pair of parameters present in the spectrum.
                            <parameter>channels</parameter> is a two element
                            vector containing, in order, the number
                            of channels on the X and Y axis.
                        </para>
                        <para>
                            <parameter>pLows</parameter> and
                            <parameter>pHighs</parameter> are both two
                            element vectors that specify, in order, the low
                            and high parameter space limits of the X and Y axis.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>Create1D</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>DataType_t </type><parameter>dataType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>CParameter&amp; </type><parameter>parameter</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>channels</parameter>
                            </methodparam>
                      
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a 1-d spectrum.  <parameter>parameter</parameter>
                            is the parmeter histogrammed and the
                            X axis will have <parameter>channels</parameter>
                            channels.  In this overload, the range of
                            the parameter histogrammed will be
                            <literal>[0, <parameter>channels)</parameter></literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>Create1D</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>DataType_t </type><parameter>dataType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>CParameter&amp; </type><parameter>parameter</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>channels</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>lowLimit</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>hiLimit</parameter>
                            </methodparam>
                            
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a 1-D spectrum where <parameter>lowLimit</parameter>
                            <parameter>hiLimit</parameter> and <parameter>channels</parameter>
                            define a transformation between parameter and spectrum
                            channel space.
                            This transformation is:
                            <literal>channel = ((parameter- lowLimit)*channels(hiLimit-lowLimit))</literal>.
                            This provides a uniform mapping of the interval
                            <literal>[lowLimit, hiLimit)</literal> to 
                            <literal>[0, channels)</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>Create2D</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>DataType_t </type><parameter>dataType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>CParameter&amp; </type><parameter>xParameter</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>CParameter&amp; </type><parameter>yParmaeter</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>xChannels</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>yChannels</parameter>
                            </methodparam>
                       
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a 2-d spectrum with 1:1 parameter:channel
                            space mapping.  <parameter>xParameter</parameter>
                            is on the X axis and <parameter>yParameter</parameter>
                            on the Y.  There are <parameter>xChannels</parameter>
                            on the X axis that map to the <parameter>xParameter</parameter>
                            value range <literal>[0, xChannels)</literal>.
                            There are <parameter>yChannels</parameter> on the
                            Y axis that map the <parameter>yParameter</parameter>
                            value range <literal>[0, yChannels)</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>Create2D</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>DataType_t </type><parameter>dataType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>CParameter&amp; </type><parameter>xParameter</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>CParameter&amp; </type><parameter>yParameter</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>xChannels</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>xLow</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>xHigh</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>yChannels</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>yLow</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>yHigh</parameter>
                            </methodparam>
                       
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a 2-d spectrum with parameter to channel
                            mappings that are not identities.
                            <parameter>xChannels</parameter>,
                            <parameter>xLow</parameter> and
                            <parameter>xHigh</parameter> determine the
                            mapping of the X parameter to channels on the
                            X axis.
                            <parameter>yChannels</parameter>,
                            <parameter>yLow</parameter> and
                            <parameter>yHigh</parameter> determine the
                            mapping of the Y parameter to channels on the
                            Y axis.
                        </para>
                        <para>
                            The mapping is linear for both parameters.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>CreateG1D</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>DataType_t </type><parameter>dataType</parameter>
                            </methodparam>
                           <methodparam>
                                <modifier></modifier>
                                <type>std::vector&lt;CParameter&gt; </type><parameter>parameters</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>channels</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a gamma-1d spectrum.  The spectrum
                            increments for all <parameter>parameters</parameter>
                            present in the event.  This method creates a
                            spectrum with a unit mapping between paramter
                            and X axis channel space.  Thus values from
                            <literal>[0, <parameter>channels</parameter>)</literal>
                            are histogrammed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>CreateG1D</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>DataType_t </type><parameter>dataType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;CParameter&gt; </type><parameter>parameters</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>channels</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>lowLimit</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>hiLimit</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a gamma-1D spectrum with potentially non
                            unit mappings between the parameter coorinates
                            and spectrum channels.
                            <parameter>lowLimit</parameter>, <parameter>hiLimit</parameter>
                            and <parameter>channels</parameter> define a uniform
                            mapping between parameter coordinates in the
                            range <literal>[lowLimit, hiLimit)</literal>
                            and the channel coordinates
                            <literal>[0, channels)</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>CreateG2D</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>DataType_t </type><parameter>dataType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;CParameter&gt; </type><parameter>parameters</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>xChannels</parameter>
                            </methodparam>
                             <methodparam>
                                <modifier></modifier>
                                <type>UInt_t </type><parameter>yChannels</parameter>
                             </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a 2-d gamma spectrum with unit mapping
                            between the parameters for both the X and Y
                            axis.
                            <parameter>xChannels</parameter> is the n umber
                            of axes on the X axis and
                            <parameter>yChannels</parameter> the number of
                            channels
                            on the Y axis. 
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>CreateG2D</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>DataType_t </type><parameter>dataType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;CParameter&gt; </type><parameter>parameters</parameter>
                            </methodparam>
                            <methodparam>
                          <modifier></modifier>
                          <type>UInt_t </type><parameter>xChannels</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Float_t </type><parameter>xLow</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Float_t </type><parameter>xHigh</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type><parameter>yChannels</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Float_t</type><parameter> yLow</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type> Float_t </type><parameter>yHigh</parameter>
                        </methodparam>
                       
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a gamma 2d spectrum with potentially non
                            unit mappings between parameter and spectrum
                            axis space.  The mapping on the X axis is
                            determined by
                            <parameter>xChannels</parameter>,
                            <parameter>xLow</parameter> and
                            <parameter>xHigh</parameter> such that the
                            parameter space
                            <literal>[xLow, xHigh)</literal> is mapped linearly
                            to <literal>[0, xChannels)</literal>.
                            The mapping on the Y axis is similarly determined by
                            <parameter>yChannels</parameter>,
                            <parameter>yLow</parameter> and
                            <parameter>yHigh</parameter>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>CreateBit</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>DataType_t </type><parameter>dataType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>CParameter&amp; </type><parameter>parameter</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>channels</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a bit map spectrum.  Bit map spectra are
                            incremented once for every bit set in the
                            <parameter>parameter</parameter>.   There
                            are <parameter>channels</parameter> channels in the
                            spectrum, one for each bit that you want monitored.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>CreateBit</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>DataType_t </type><parameter>dataType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>CParameter&amp; </type><parameter>parameter</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>channels</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>lowBit</parameter>
                            </methodparam>
                        
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a bit map spectrum that covers
                            <parameter>channels</parameter> bits of the
                            parameters beginning with the low bit
                            designated by <parameter>lowBit</parameter>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>CreateSummary</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>DataType_t </type><parameter>dataType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;CParameter&gt; </type><parameter>parameters</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>channels</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a summary spectrum. A summary spectrum is
                            a 2-d spectrum whose vertical strips (defined by
                            a single x channel) are 1-d spectra.  Summary
                            spectra make monitoring a set of similar detectors
                            easy.  <parameter>parameters</parameter> are
                            the set of parameters to histogram and define the
                            number of x channels (one for each parameter).
                            <parameter>channels</parameter> defines the
                            number of y channels.  This method defines
                            a unit mapping between parameter values and
                            Y channels.
                        </para>
                        
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>CreateSummary</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam> 
                            <methodparam>
                               <modifier></modifier>
                               <type>DataType_t </type><parameter>dataType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;CParameter&gt; </type><parameter>parameters</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>nChannels</parameter>
                            </methodparam>
                             <methodparam>
                                <modifier></modifier>
                                <type>Float_t </type><parameter>low</parameter>
                             </methodparam>
                             <methodparam>
                                <modifier></modifier>
                                <type>Float_t </type><parameter>high</parameter>
                             </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a summary spectrum on the <parameter>parameters</parameter>.
                            This spectrum will have a mapping from parameter to
                            spectrum y channel coordinates that is a linear map
                            from parameter coordinates in the range
                            <literal>[<parameter>low</parameter>, <parameter>high</parameter>)</literal>
                            to channel coordinates
                            <literal>[0, <parameter>nChannels</parameter>)</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>CreateGamma2DD</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>DataType_t </type><parameter>dataType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;CParameter&gt; </type><parameter>xParameters</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;CParameter&gt; </type><parameter>yParameters</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>xChannels</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>xLow</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>xHigh</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>yChannels</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>yLow</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>yHigh</parameter>
                            </methodparam>  
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a gamma 2d deluxe spectrum.  This type of
                            spectrum increments for all combinations of pairs of
                            <parameter>xParameters</parameter> and
                            <parameter>yParameters</parameter> that are
                            defined in the event.
                            The mapping between parameter and channel coordinates
                            is lineary but not necessarily unity.
                        </para>
                        <para>
                            <parameter>xChannels</parameter>,
                            <parameter>xLow</parameter>, and
                            <parameter>xHigh</parameter> define a linear
                            mapping between parameter
                            X parameter values in the range
                            <literal>[<parameter>xLow</parameter>, <parameter>xHigh)</parameter></literal>
                            and <literal>[0, <parameter>xChannels</parameter>)</literal>
                            on the X axis.
                            On the Y axis a similar mapping is defined by:
                            <parameter>yChannels</parameter>,
                            <parameter>yLow</parameter>, and
                            <parameter>yHigh</parameter>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>Create2DSum</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>DataType_t  </type><parameter>dataType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;CParameter&gt; </type><parameter>xParameters</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;CParameter&gt; </type><parameter>yParameters</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>xChans</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>xLow</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>xHigh</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>yChans</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>yLow</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t</type><parameter> yHigh</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a 2-d sum spectrum.  This spectrum is
                            essentially the spectrum that would result from
                            summing 2-d spectra on
                            <parameter>xParameters[0]</parameter>,
                            <parameter>yParameters[0]</parameter>, ...
                            The mapping from parameter to channel space
                            in both X and Y is
                            defined in the usual way using the low, high and
                            channel count parameters.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodsynopsis>
                        <modifier></modifier>
                        <type>CSpectrum* </type>
                        <methodname>CreateStripChart</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string </type><parameter>name</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>DataType_t  </type><parameter>dataType</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>CParameter</type><parameter>counts</parameter>
                        </methodparam>      
                        <methodparam>
                           <modifier></modifier>
                           <type>CParameter</type><parameter>time</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type><parameter>channels</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Float_t </type><parameter>xLow</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Float_t </type><parameter>xHigh</parameter>
                        </methodparam>
                               
                        <modifier></modifier>
                    </methodsynopsis></term>
                    <listitem>
                        <para>
                            Creates a strip chart spectrum.  Strip chart spectra
                            plot the <parameter>time</parameter> parameter value
                            against the accumulated <parameter>counts</parameter>
                            parameter.  <parameter>xLow</parameter> and
                            <parameter>xHigh</parameter> are an initial range
                            the X axis covers in the <parameter>time</parameter>
                            parameter.  
                        </para>
                        <para>
                            If the <parameter>time</parameter>
                            parameter value is outside the range of the
                            current X axis limits, the X axis will be shifted
                            to cover that new value.    The range covered will
                            be the same as before, however.
                            This shift provides the strip chart functionality
                            that gives this spectrum its name.  Note that
                            currently, there's no command or user interface
                            method to shift the spectrum back to its original
                            range, however the axis can shift backwards
                            if the time value is before the
                            current left limit of the spectrum, which effectively
                            provides this functionality automatically.
                        </para>
                        <para>
                            Note that data shifted off the edge of the spectrum
                            is  lost. Note as well that data are cumulative, thus
                            if the binning is such that two time values fall
                            in the same channel, the resulting channel value
                            will be the sum of the two <parameter>counts</parameter>
                            parameters for those two events (summed with any prior
                            value that channel might have).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>AddSpectrum</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>CSpectrum&amp; </type><parameter>spectrum</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Adds a spectrum to SpecTcl's spectrum dictionary.
                            There cannot be a spectrum with this name
                            in the dictionary else an exception will be thrown.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>RemoveSpectrum</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string</type><parameter> name</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Remove the spectrum named <parameter>name</parameter>
                            from the SpecTcl spectrum dictionary.  The spectrum
                            no longer exists from SpecTcl's point of view.
                            If the spectrum was produced by one of the methods
                            above, you need to <literal>delete</literal> to free
                            it to avoid memory leaks.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>FindSpectrum</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>FindSpectrum</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t</type><parameter> id</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Attemts to locate the spectrum named <parameter>name</parameter>,
                            or has the id <parameter>id</parameter>,
                            in SpecTcl's spectrum dictionary.   A pointer to the
                            spectrum object is returned if found or a null
                            pointer is returned if there no spectrum
                            matching the name.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>SpectrumDictionaryIterator </type>
                            <methodname>SpectrumBegin</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>SpectrumDictionaryIterator </type>
                            <methodname>SpectrumEnd</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            These methods support iteration through the
                            SpecTcl spectrum dictionary.
                            <classname>SpectrumDictionaryIterator</classname>
                            objects are pointer like objecs.  They
                            'point' to a
                            <classname>std::pair&lt;td::string, CSpectrum*&gt;</classname>.
                        </para>
                        <para>
                            The first item of each pair is the name of the spectrum.
                            The second itesm is a pointer to the
                            spectrum with that name.
                        </para>
                        <para>
                            <classname>SpectrumDictionaryIterator</classname>
                            objects can be incremented (<methodname>operator++</methodname>).
                            Incrementing an iterator 'points' it to the next
                            object in the container.
                        </para>
                        <para>
                            <function>SpectrumBegin</function> points  to the first
                            object in the dictionary.  Iterating through the dictionary
                            has finishe when incrementing produces the value
                            returned by
                            <methodname>SpectrumEnd</methodname>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>UInt_t </type>
                            <methodname>SpectrumCount</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the numbr of entries in the SpecTcl
                            spectrum dictionary.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>addSpectrumDictionaryObserver</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>SpectrumDictionaryObserver* </type><parameter>observer</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Adds a new observer to the spectrum dictionary.
                            See e.g. <ulink url='https://en.wikipedia.org/wiki/Observer_pattern' />
                            for information about the observer pattern and observers.
                        </para>
                        <para>
                            Spectrum dictionary observers derived from the
                            <classname>CDictionaryObserver</classname> templated
                            class (defined in <filename>Dictionary.h</filename>).
                            They have a <methodname>onAdd</methodname>, called
                            when a new entry is added to the dictionary, and
                            a method called <methodname>onRemove</methodname>
                            called when an entry is removed from the
                            dictionary.
                        </para>
                        <para>
                            Both obserer entries are passed two parameters.
                            The first is an <classname>std::string</classname>
                            that holds the name of the spectrum being
                            added or removed/  The secod i a a
                            <classname>CSpectrum</classname> reference which is
                            a reference to the spectrum being added or removed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>removeSpectrumDictionaryObserver</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>SpectrumDictionaryObserver* </type><parameter>observer</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Removes a spectrum dictinoary observer from the list
                            of observer methods.  The <methodname>observer</methodname>
                            object is no longer called.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>ClearSpectrum</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Clears the spectrum named <parameter>name</parameter>.
                            If there is no spectrum named <parameter>name</parameter>,
                            an exception (<classname>CDictionaryException</classname>).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void</type>
                            <methodname>ClearAllSpectra</methodname>
                            
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Iterates through the spectrum dictionary
                            zeroing the spectra.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                The next set of methods manipulate gates and the gate dictionary.
                Note that as with Spectra, the act of creating a gate is
                separate from the act of making it known to SpecTcl's
                commands and histogramming core by entering it into a gate
                dictionary.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateGate</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>CGateFactory::GateType </type><parameter>gateType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;std::string&gt; </type><parameter>names</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a new compound gate whose dependent
                            gates are <parameter>names</parameter>.   Legal gate
                            types for this method are
                            <literal>And</literal>, <literal>bandcontour</literal>,
                            <literal>Not</literal>, <literal>Or</literal>,
                            <literal>trueg</literal>, <literal>falseg</literal>
                            or <literal>deleted</literal>.
                        </para>
                        <para>
                            Note that for
                            <literal>trueg</literal>, <literal>falseg</literal>
                            or <literal>deleted</literal>,
                            the <parameter>names</parameter> vector must be empty.
                        </para>
                        <para>
                            Note that the gate has no name.  It is given its name
                            when <methodname>AddGate</methodname>.
                        </para>
                        <para>
                            The method returns a pointer to the new,
                            dynamically create gate object.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateGate</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>CGateFactory::GateType </type><parameter>gateType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;std::string&gt; </type><parameter>parameters</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;FPoint&gt; </type><parameter>points</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateGate</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>CGateFactory::GateType</type><parameter>gateType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;FPoint&gt; </type><parameter>points</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type> std::vector&lt;UInt_t&gt;</type><parameter> parameters</parameter>
                            </methodparam>
                            <modifier></modifier>
                            
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a primitive gate.  <parameter>parameters</parameter>
                            are the names of the parameters the gate is defined on.
                            <parameter>points</parameter> are x/y points that define
                            the gate.  <parameter>gateType</parameter> can be any
                            gate that requires a set of points.
                        </para>
                        <para>
                            The second form of this method provides the
                            <parameter>parameters</parameter> vector as a vector
                            of parameter ids rather than names.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateGate</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>CGateFactory::GateType </type><parameter>gateType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;std::string&gt; </type><parameter>rparameters</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>long</type><parameter> comparison</parameter>
                            </methodparam>
                    
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a bit mask gate of the type
                            specified by <parameter>gateType</parameter>.
                            <parameter>rparameters</parameter> specifies the
                            parameters required for the gate.
                            <parameter>comparison</parameter> is the type
                            of comparison to perform.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateTrueGate</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a true gate. A true gate is true for
                            every event regardless of the set of parameters
                            defined by that event or their values.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateFalseGate</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a false gate.  False gates are false
                            for all events regardless of the parameters
                            defined by an event and its values.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* CreateBand</type>
                            <methodname></methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>xparameter</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>yparameter</parameter>
                            </methodparam>
                             <methodparam>
                                <modifier></modifier>
                                <type>std::vector&lt;FPoint&gt; </type><parameter>points</parameter>
                             </methodparam>
                    
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines a band gate.  A band gate is defined on
                            a pair of parameters.  <parameter>xparameter</parameter>
                            defines the x coordinate of a point in two dimensional
                            space while <parameter>yparameter</parameter> defines
                            the y coordinate.  Both parameters must be present and
                            the point defined by them must be below the polyline
                            defined by the array of <parameter>points</parameter>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateContour</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>xparameter</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>yparameter</parameter>
                            </methodparam>
                             <methodparam>
                                <modifier></modifier>
                                <type>std::vector&lt;FPoint&gt; </type><parameter>points</parameter>
                             </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines a contour gate.  The parameters have the
                            same meaning as for <parameter>CreateBand</parameter>,
                            however the gate is true for events only if both
                            <parameter>xparameter</parameter> and
                            <parameter>yparameter</parameter> are present and
                            the resulting point falls inside the closed shape
                            defined by <parameter>pointts</parameter>
                        </para>
                        <para>
                            For pathalogical closed shapes, note that
                            inside-ness is defined by the
                            <firstterm>odd crossing rule</firstterm>.
                            This means that if you draw a  ray from the point
                            defined by the event in any direction, the point is
                            inside if an odd number of edges of the shape are
                            crossed and outside if an even number are crossed.
                            This provides a consistent definition of inside-ness
                            reagardless of how pathalogically shaped the
                            contour is.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateBandContour</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>firstBand</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>secondBand</parameter>
                            </methodparam>
                             
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a contour by joining together the endpoints
                            of the two band <parameter>firstBand</parameter>
                            and <parameter>secondBand</parameter>.  An exception
                            is thrown if these two gates are not bands.
                            The resulting gate is really a contour and not
                            a compound gate.
                        </para>
                        <para>
                            This gate is useful for detectors that produce a
                            particle id spectrum that looks like a set of
                            hyperbolae.  One can draw bands between each of the
                            particle groups an then form particle ID groups
                            by creating contours from adjacent gates.
                        </para>
                        <para>
                            The intent is that if <parameter>firstBand</parameter>
                            is upper and <parameter>secondBand</parameter> lower,
                            the resulting gate is essentially
                            <literal>firstBand and not secondBand</literal>, however
                            the joining of the end points together may slightly
                            violate that expression near the gate edges.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateNotGate</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a not gate using <parameter>name</parameter>
                            as the dependent gate.  The resulting gate is true
                            only for events for which the gate <parameter>name</parameter>
                            is false.  For all other events it is false.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateAndGate</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>gateNames</type><parameter>gateNames</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates an And gate using <parameter>gateNames</parameter>
                            as the gate's dependent gates.  This gate is only true
                            if <emphasis>all</emphasis> of the gates in
                            <parameter>gateNames</parameter> are true.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateOrGate</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;std::string&gt; </type><parameter>gateNames</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates an or gate whose dependent gates are
                            <parameter>gateNames</parameter>.  This gate
                            is only true for events in which
                            <emphasis>at least</emphasis> of the
                            gates in <parameter>gateNames</parameter> is also
                            true.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>  CGate* </type>
                            <methodname>CreateCut</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>parameter</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t</type><parameter> low</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>high</parameter>
                            </methodparam>  
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a gate that is a cut on 
                            <parameter>parameter</parameter>.   The cut is
                            defined by the x coorinates of
                            <parameter>low</parameter> and
                            <parameter>high</parameter>.  The gate is true
                            only if it defines <parameter>parameter</parameter>
                            and the value is between <parameter>low</parameter>
                            and <parameter>high</parameter>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateGammaCut</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>low</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>high</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;std::string&gt; </type><parameter>parameters</parameter>
                            </methodparam>
                              
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a gamma cut.  The cut is defined by
                            <parameter>low</parameter> and
                            <parameter>high</parameter>.   The parameters
                            involved in the gate are
                            <parameter>parameters</parameter>.
                        </para>
                        <para>
                            The gamma cut is intended to be applied to a gamma
                            spectrum as a fold.  Folds are a mechanism to untangle
                            sequential decay cascades.  If this gate is applied
                            as a fold to a gamma spectrum, the spectrum is incremented
                            if at least one parameter satisfies the gate and
                            is incremented for all parameters that are not
                            in the gate.  The resulting histogram's peaks
                            are those gamma rays that are emitted in coincidence
                            with the gamma ray energy in the peak the gate is
                            set on.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateGammaBand</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;FPoint&gt; </type><parameter>points</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;std::string&gt; </type><parameter>parameters</parameter>
                            </methodparam>
                         
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a gamma band.  This is also intended to be
                            used as a fold in which case the spectrum
                            is incremented only for pairs of parameters
                            that do not satisfy the gate.   Gamma bands
                            are probably not as useful as gamma contours since
                            2-d Gamma spectra tend to make lumps out of
                            pairs of gamma rays that are emitted in coincidence.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateGammaContour</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;FPoint&gt; </type><parameter>points</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;std::string&gt; </type><parameter>parameters</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a gamma contour from the
                            <parameter>points</parameter> defined on the
                            <parameter>parameters</parameter> parameters.
                            This is intended to be used as a fold.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateMaskEqualGate</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;std::string&gt; </type><parameter>rParameterName</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>long </type><parameter>Compare</parameter>
                            </methodparam>
                             
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a mask-equality gate.  The gate will
                            be true for events that define
                            <parameter>rParameterName</parameter> and for which
                            the value of that parameter will be equal to
                            <parameter>Compare</parameter>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateMaskAndGate</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;std::string&gt; </type><parameter>rParameterName</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>long </type><parameter>Compare</parameter>
                            </methodparam>
                             
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a mask and gate.  The gate will be true
                            for events that define <parameter>rParameterName</parameter>
                            and for which the value of that parameter, when bitwise anded
                            with <parameter>Compare</parameter> is the same as
                            <parameter>Compare</parameter>.  That is, the parameter
                            has (among others) all bits set that <parameter>Compare</parameter>
                            has set.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateMaskNotGate</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;std::string&gt; </type><parameter>rParameterName</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>long </type><parameter>Compare</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a Mask not gate.  This gate is defined
                            for all events that define
                            <parameter>rParameterName</parameter> but for
                            which the value of that parameter has all bits
                            set which are not set in <parameter>Compare</parameter>.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                The next set of methods manipulate the gate dictionary.
                Note that the gate creation methods above create the gate but
                don't enter it into the gate dictionary.  To  make the gate
                known to SpecTcl, you must do this by invoking
                <methodname>AddGate</methodname> below.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>AddGate</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>CGate* </type><parameter>gate</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Associates the gate name <parameter>name</parameter>
                            with the gate <parameter>gate</parameter> and tries
                            to add it to the gate dictionary.  If a gate
                            by this name already exists; the method throws
                            a <classname>CDictionaryException</classname>
                            exception.
                        </para>
                        <para>
                            Note that once a gate is known to exist, its
                            definition can be modified by
                            <methodname>ReplaceGate</methodname> below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void DeleteGate</type>
                            <methodname></methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>gateName</parameter>
                            </methodparam>
                            
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Deletes the gate named <parameter>gateName</parameter>
                            from the gate dictionary.    Note that in order
                            for objects that depend on the gate to behave
                            in a well determined manner, the gate is not
                            actually deleted, but replaced with a
                            false gate.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>ReplaceGate</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>gateName</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>CGate&amp; </type><parameter>newGate</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Replaces the gate <parameter>gateName</parameter> with
                            a new gate definition <parameter>newGate</parameter>.
                            The use of <classname>CGateContainer</classname> objects
                            allows this replacement to happen transparently with
                            respect to dependent gates, spectra to which the
                            gate is applied and spectra folded on the gate.
                        </para>
                        <para>
                            If <parameter>gateName</parameter> does not
                            exist a <classname>CDictionaryException</classname>
                            is thrown.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGateContainer*</type>
                            <methodname> FindGate</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>gateName</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Finds the gate <parameter>gateName</parameter>
                            in the gate dictionary.  If found, a pointer
                            to its gate container is returned.   If not found,
                            a null pointer is returned.
                        </para>
                        <para>
                            A <classname>CGateContainer</classname> is a pointer
                            like object that acts like a pointer to an underlying
                            gate.  Gate containers are an additional level of
                            indirection that allow spectra and other gates that
                            depend on a gate to be blissfully unaware of when
                            their gate definitions change.
                        </para>
                        <para>
                            You can think of the gate container as encapsulating
                            the real gate.  What methods like
                            <methodname>DeleteGate</methodname> and
                            <methodname>ReplaceGate</methodname> do is replace
                            the gate that is encapsulated by the gate container.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGateDictionaryIterator </type>
                            <methodname>GateBegin</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>GateDictionaryIterator</type>
                            <methodname>GateEnd</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Supports iteration in the gate dictionary. The
                            <classname>CGateDictionaryIterator</classname>
                            is a pointer like object that points to an
                            <classname>std::pair&lt;std::string, CGateContainer&gt;</classname>
                            object.
                        </para>
                        <para>
                            The first element of the pair is the name of the gate
                            while the second element is the gate container for
                            the gate.  Iteration is accomplished by getting
                            an iterator to the first dictionary element
                            via a call to <methodname>GateBegin</methodname>.
                            Successive elements of the dictionary are visited
                            by incrementing the iterator.  When the last
                            element is visited, incrementing the iterator
                            returns the value returned by
                            <methodname>GateEnd</methodname>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>UInt_t </type>
                            <methodname>GateCount</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns a count of the number of elements in the
                            gate dictionary.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>addGateDictionaryObserver</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>CGateObserver* </type><parameter>observer</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void removeGateDictionaryObserver</type>
                            <methodname></methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>CGateObserver* </type><parameter>observer</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            These two methods provide an observer interface
                            to the Gate dictionary.
                            See e.g. <ulink url='https://en.wikipedia.org/wiki/Observer_pattern' />
                            for information about the observer pattern and observers.
                        </para>
                        <para>
                            <methodname>addGateDictionaryObserver</methodname>
                            adds the specfied <parameter>observer</parameter>
                            to the list of gate observers called by the
                            gate dictionary while
                            <methodname>removeGateDictionaryObserver</methodname>
                            removes <parameter>observer</parameter> from that list.
                        </para>
                        <para>
                            A <classname>CGateObserver</classname> object has
                            the following methods:
                        </para>
                        <variablelist>
                            <varlistentry>
                                <term>
                                    <methodsynopsis>
                                        <modifier>virtual </modifier>
                                        <type>void </type>
                                        <methodname>onAdd</methodname>
                                        <methodparam>
                                           <modifier></modifier>
                                           <type>std::string </type><parameter>name</parameter>
                                        </methodparam>
                                        <methodparam>
                                           <modifier></modifier>
                                           <type>CGateContainer&amp; </type><parameter>item</parameter>
                                        </methodparam>
                                          
                                        <modifier></modifier>
                                    </methodsynopsis>
                                </term>
                                <listitem>
                                    <para>
                                        Called when an entry is added to the dictionary.
                                        <parameter>name</parameter> is the name
                                        of the new gate and
                                        <parameter>item</parameter>
                                        is the gate container for the new item
                                        being added.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>
                                    <methodsynopsis>
                                        <modifier>virtual </modifier>
                                        <type>void </type>
                                        <methodname>onRemove</methodname>
                                        <methodparam>
                                           <modifier></modifier>
                                           <type>std::string </type><parameter>name</parameter>
                                        </methodparam>
                                        <methodparam>
                                           <modifier></modifier>
                                           <type>CGateContainer&amp; </type><parameter>item</parameter>
                                        </methodparam>
                                        <modifier></modifier>
                                    </methodsynopsis>
                                </term>
                                <listitem>
                                    <para>
                                        Called if an entry is removed from the
                                        dictionary.  In normal use this is never
                                        invoked as gates are never deleted,
                                        only modified.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>
                                    <methodsynopsis>
                                        <modifier>virtual</modifier>
                                        <type> void</type>
                                        <methodname> onChange</methodname>
                                        <methodparam>
                                           <modifier></modifier>
                                           <type>std::string</type><parameter> name</parameter>
                                        </methodparam>
                                        <methodparam>
                                           <modifier></modifier>
                                           <type>CGateContainer&amp; </type><parameter>gateContainer</parameter>
                                        </methodparam>
                                        <modifier></modifier>
                                    </methodsynopsis>
                                </term>
                                <listitem>
                                    <para>
                                        Called when a gate has been changed.
                                        <parameter>gateContainer</parameter>
                                        is the new gate container.
                                    </para>
                                </listitem>
                            </varlistentry> 
                        </variablelist>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>ApplyGate</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>gateName</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>spectrumName</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                The next set of methods are responsible for managing the event
                processor pipeline.  The event processing pipeline is a sequence
                of objects that are responsible for taking a raw event
                and transforming it into a set of parameteres that can be
                analyzed by the event sink pipeline.  Each stage of the pipeline
                has access to the raw event as well as the set of parameters
                previous stages have unpacked.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void AddEventProcessor</type>
                            <methodname></methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>CEventProcessor&amp; </type><parameter>eventProcessor</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier>const </modifier>
                               <type>char* </type><parameter>name</parameter>
                               <initializer> 0</initializer>
                            </methodparam>
                         
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Adds an event processor
                            <parameter>eventProcessor</parameter>to the end of the
                            event processing pipeline.  If <parameter>name</parameter>
                            is not a null pointer, it is used as the name of
                            the event processor.  If it is null (not recommended but
                            supported for backwards compatibility), a unique
                            event processor name will be assigned.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CTclAnalyzer::EventProcessorIterator </type>
                            <methodname>FindEventProcessor</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string</type><parameter> name</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Given the <parameter>name</parameter> of an event
                            processor, returns an iterator to it.  If the
                            <parameter>name</parameter> is not found,
                            the value that is normally returned
                            from <methodname>ProcessingPipelineEnd</methodname>
                            is returned (see below).
                        </para>
                        <para>
                            A <classname>CTclAnalyzer::EventprocessorIterator</classname>
                            is a pointer like object.  We'll say more about it
                            when we look at support for iteration.  At this
                            point in time it suffices to know that it can be
                            treated as if it were a pointer to
                            a <classname>std::pair&lt;std::atring, CEventProcessor*&gt;</classname>
                            where the first element of the pair is the name of the event
                            processor pointed to by the second element
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CTclAnalyzer::EventProcessorIterator </type>
                            <methodname>FindEventProcessor</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>CEventProcessor&amp; </type><parameter>processor</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Finds an event processor in the event processing
                            pipeline given a reference to the event
                            processor object itself.  
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>InsertEventProcessor(</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>CEventProcessor&amp; </type><parameter>processor</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>CTclAnalyzer::EventProcessorIterator </type><parameter>where</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier>const </modifier>
                               <type>char*  </type><parameter>name </parameter>
                               <initializer>0</initializer>
                            </methodparam>
                            
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Inserts an event processor
                            (<parameter>processor</parameter>) in the event
                            processing pipeline at the position prior to that
                            indicated by <parameter>where</parameter>.  The
                            event processor will be called <parameter>name</parameter>
                            unless that parameter is a null pointer in which
                            case a unique name will be assigned to it.
                        </para>
                        <para>
                            Note that <parameter>where</parameter> is
                            a <classname>CTclAnalyzer::EventProcessorIterator</classname>,
                            an iterator in the STL sense of the term.  For more
                            information about it, see
                            <methodname>ProcessingPipelineBegin</methodname>
                            and <methodname>ProcessingPipelineEnd</methodname>
                            below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>RemoveEventProcessor</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Removes the event processor named <parameter>name</parameter>.
                            IF there's no event processor named
                            <parameter>name</parameter>, this is a silent
                            no-op.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>RemoveEventProcessor</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>CTclAnalyzer::EventProcessorIterator </type><parameter>here</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Removes the event processor 'pointed to'
                            by <parameter>here</parameter>.  The iterator
                            could have been returned from a call to
                            <methodname>FindEventProcessor</methodname> or
                            have been the result of iteration (see below).
                        </para>
                        <para>
                            This operation invalidates the iterator.
                            The results of dereferencing
                            it in the future are undefined.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>UInt_t </type>
                            <methodname>ProcessingPipelineSize</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the number of elements in the event
                            processing pipeline.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CTclAnalyzer::EventProcessorIterator </type>
                            <methodname>ProcessingPipelineBegin</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CTclAnalyzer::EventProcessorIterator </type>
                            <methodname>ProcessingPipelineEnd</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Supports the iteration protocol.
                            <methodname>ProcessingPipelineBegin</methodname>
                            returns an iterator that 'points' to the
                            first element of the event processing pipeline.
                            The
                            <methodname>FindEventProcessor</methodname>
                            documentation describes exactly what this
                            'points' to.
                        </para>
                        <para>
                            Iterators can be incremented in which case they
                            point to the next element of the pipeline (in
                            processing order).  Once the last element of the
                            pipeline has been reached by the iterator,
                            an additional increment returns a value
                            identical to the value that is returned by
                            <methodname>ProcessingPipelineEnd</methodname>.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                The next set of methods manipulate the event sink pipeline.
                The event sink pipeline gains control after the the event
                processing pipeline has processed one or more events.
                it the event sink pipeline initially comes stocked with the
                histogrammer (<classname>CHistogrammer</classname>).
                Filters are also added at the end of the event processing
                pipeline.
            </para>
            <para>
                This  portion of the API supports additional event
                sink pipeline element types.
            </para>
            <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>AddEventSink</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CEventSink&amp; </type><parameter>sink</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier>const </modifier>
                           <type>char* </type><parameter>name </parameter>
                           <initializer>0</initializer>
                        </methodparam>
                        
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a new event <parameter>sink</parameter> to the
                        end of the event sink pipeline.  If
                        <parameter>name</parameter> is not a null pointer,
                        it will be the name of the processing element.
                        If it is a null pointer, a unique name
                        will be supplied by SpecTcl.
                    </para>
                    <para>
                        The histogrammer registers itself as
                        <literal>::Histogrammer</literal>.  Event filters
                        register themselves with their filter name.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventSinkPipeline::EventSinkIterator </type>
                        <methodname>FindEventSink</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string </type><parameter>sinkName</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an iterator to the event sink
                        <parameter>sinkName</parameter>.  If no such event sink
                        pipeline element exists, the return value will be
                        the same as that returned by
                        <methodname>EventSinkPipelineEnd</methodname>.
                    </para>
                    <para>
                        The iterator returned is a pointer like object.
                        The objects it points to are
                        <classname>std::pair&lt;std::string, CEventSink*&gt;</classname>
                        where the first element of the pair is the name of the event
                        sink pointed to by the second element of the pair.
                    </para>   
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventSinkPipeline::EventSinkIterator </type>
                        <methodname>FindEventSink</methodname>
                        <methodparam>
                            <type>CEventSink&amp; </type><parameter>sink</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an iterator 'pointing' to the event sink
                        pipeline element whose reference is p[assed in
                        to to the method as <parameter>sink</parameter>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>InsertEventSink</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CEventSink&amp; </type><parameter>sink</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>CEventSinkPipeline::EventSinkIterator </type><parameter>here</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier>const </modifier>
                           <type>char* </type><parameter>name</parameter>
                           <initializer>0</initializer>
                        </methodparam> 
                       
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds the event sink <parameter>sink</parameter> to the
                        event sink pipeline prior to the position indicated
                        by <parameter>here</parameter>, an iterator.
                        If not a null pointer, the parameter <parameter>name</parameter>
                        is used to name the pipeline element.  Otherwise
                        a unique name is assigned to the element.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventSink* </type>
                        <methodname>RemoveEventSink</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string </type><parameter>name</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes an event sink named <parameter>name</parameter>
                        from the event sink pipeline.  A pointer to the
                        removed sink is returned on success.  If no
                        event sink with <parameter>name</parameter> exists,
                        a null pointer is returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventSink* </type>
                        <methodname>RemoveEventSink</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CEventSinkPipeline::EventSinkIterator </type><parameter>here</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes an event sink from the pipeline given an
                        iterator that points to the std::pair containing the
                        specific sink.  Returns a pointer to the event sink
                        that was removed.   
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Int_t </type>
                        <methodname>EventSinkPipelineSize</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of elements in the event sink pipeline.
                        Just after SpecTcl starts, this will return
                        at least <literal>1</literal>
                        as the event sink pipeline is initialized with a
                        <classname>CHistogrammer</classname> as an event
                        sink.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventSinkPipeline::EventSinkIterator </type>
                        <methodname>EventSinkPipelineBegin</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventSinkPipeline::EventSinkIterator </type>
                        <methodname>EventSinkPipelineEnd</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        These methods support iteration over the event sink
                        pipeline.  <methodname>EventSinkPipelineBegin</methodname>
                        returns an iterator that 'points' to the first item
                        in the pipeline (usually the histogrammer).  
                    </para>
                    <para>
                        <classname>CEventSinkPipeline::EventSinkIterator</classname>
                        objects can be thought of as pointers.  They point to
                        a
                        <classname>std::pair&lt;std::string, CEvetnSink*&gt;</classname>.
                        The first element of that pair is the name assigned to the
                        event sink.  The second element is a pointer to an
                        event sink that was assigned that name.
                    </para>
                    <para>
                        <classname>CEventSinkPipeline::EventSinkIterator</classname>
                        objects can be incremented.  Each increment points
                        the iterator to the next object in the pipeline.
                        Incrementing an iterator that points to the last item
                        in the pipeline makes it equal to the object
                        returned by
                        <methodname>EventSinkPipelineEnd</methodname>.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            Filters are the most common type of non histogrammer elements
            in the event processing pipeline.  SpecTcl has command line
            mechanisms for creating, configuring and enabling filters.
            The next several methods provide the same functionality for
            C++ extensions to SpecTcl as well as providing a method for
            extending the set of output formats supported by standard filters.
        </para>
        <para>
            Naturally, for special needs, programmers can extend the
            <classname>CGatedEventFilter</classname> class and use
            the resulting filters in these API elements.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void  </type>
                        <methodname>createFilter</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string </type><parameter>name</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>CGatedEventFilter* </type><parameter>pFilter</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a new filter, <parameter>pFilter</parameter> to the
                        event sink pipeline.  The filter will be given the name
                        <parameter>name</parameter>.  The filter is also
                        entered into the filter dictionary so that it is
                        visible to and can be manipulated with SpecTcl
                        commands.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CGatedEventFilter* </type>
                        <methodname>findFilter</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string </type><parameter>name</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Locates returns a pointer to the event filter
                        <parameter>name</parameter>.  If no filter with that
                        name has been created a null pointer is returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodsynopsis>
                    <modifier></modifier>
                    <type>bool  </type>
                    <methodname>filterExists</methodname>
                    <methodparam>
                       <modifier></modifier>
                       <type>CGatedEventFilter* </type><parameter>pFilter</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis></term>
                <listitem>
                    <para>
                        Given a pointer to an event filter <parameter>pFilter</parameter>,
                        determines if a filter with the same address exists in
                        the filter dictionary.  Returns <literal>true</literal>
                        if so and <literal>false</literal> if not.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void  </type>
                        <methodname>deleteFilter</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CGatedEventFilter* </type><parameter>pFilter</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes the filter pointed to by <parameter>pFilter</parameter>
                        from the filter dictionary.  If <parameter>pFilter</parameter>
                        is not in the filter dictionary, no action is taken.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void  </type>
                        <methodname>deleteFilter</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string </type><parameter>filterName</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes a filter from the filter dictionary.    If the
                        filter is not in the dictionary, this is a silent No-op.
                    </para>
                    <para>
                        Neither this method, nor the previous one actually delete
                        the storage associated with a filter, they only
                        remove it from the filter dictionary.  To perform
                        a full deletion would require something like:
                    </para>
                    <informalexample>
                        <programlisting>
                            
// Delete by pointer.
                            
CGatedFilter* pFilter=makeSomeFilter();
...
SpecTcl* pApi = SpecTcl::getInstance();
pApi-&gt;deleteFilter(pFilter);
delete pFilter;

// Delete by name with full deletion.

CGatedFilter *pSomeFilter = pApi-&gt;findFilter("someName");
if (pSomeFilter) {
    pApi-&gt;deleteFilter("someName");
    delete pSomeFilter;
}
                        </programlisting>
                    </informalexample>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void  </type>
                        <methodname>addFilterOutputFormat</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CFilterOutputStageCreator&amp; </type><parameter>creator</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a new filter output format to the filter subsystem.
                        <parameter>creator</parameter>, when given its output
                        format name, recognizes it and returns the appropriate
                        output formatter.  The programming guide provides
                        a worked example that shows how to add filter
                        formats to the system.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            The remainder of the API are miscellaneous methods that don't really
            fit well into any of the method categories above.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>AddSpectrumFormatter</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string</type><parameter> name</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>CSpectrumFormatter&amp; </type><parameter>formatter</parameter>
                        </methodparam>
                        
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Associates the <parameter>formatter</parameter> with
                        outputting spectra (via the <command>swrite</command> command)
                        for the format type <parameter>name</parameter>.
                        The actual <parameter>formatter</parameter> must be in scope
                        for the lifetime of SpecTcl.   Therefore it's recommended
                        that it either be statically allocated at a file scope
                        or alternatively dynamically allocated via <literal>new</literal>
                        and never destroyed with <literal>delete</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CTCLInterpreter* </type>
                        <methodname>getInterpreter</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the object encapsulated
                        Tcl interpreter that SpecTcl is using to execute its
                        commands.  This can be used to add commands to SpecTcl,
                        or anything else that may require a Tcl interpreter.
                        See the Tcl++ section of this manual for more information
                        about how to use this and other classes in the
                        Tcl++ C++ encapsulation of libTcl.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CHistogrammer*</type>
                        <methodname>GetHistogrammer</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to SpecTcl's histogrammer object.
                        Note that most of the things you'd want to do with the
                        <classname>CHistogrammer</classname> are possible
                        directly from the API methods above.  Those are
                        considered 'sacred with respect to modification' while
                        the methods of the histogrammer can be modified in
                        function and signature.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CTclAnalyzer* </type>
                        <methodname>GetAnalyzer</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the current SpecTcl analyzer.
                        The <classname>CAnalyzer</classname> is the method
                        that directs the flow of control within SpecTcl's analysis
                        of data.  Normally, the SpecTcl analyzer is actually a
                        <classname>CTclAnalyzer</classname> object
                        (see <filename>TCLAnalyzer.h</filename> for the class
                        definition).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventSinkPipeline* </type>
                        <methodname>GetEventSinkPipeline</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the event sink pipeline object.
                        Note that other methods in this API provide essentially
                        all of the operations you'll need to perform on this object.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CDisplayInterface* </type>
                        <methodname>GetDisplayInterface</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        SpecTcl 5.0 decouples SpecTcl from its traditional
                        displayer (Xamine), and provides an new Root based
                        displayer (Display).  The interaction between the
                        displayer and SpecTcl is mediate by a
                        <classname>CDisplayerInterface</classname> object
                        that is specific to the displayer type.  This
                        method obtains a pointer to the specific
                        displayer interface object in use.
                    </para>
                    <para>
                        I anticipate that later in the development of SpecTcl 5,
                        we'll see the <classname>SpecTcl</classname> class
                        augmented to provide a stable API to the displayer.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void SetDisplayInterface</type>
                        <methodname>CDisplayInterface&amp; rInterface</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Provides a new display interface to SpecTcl;
                        <parameter>rInterface</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>std::vector&lt;UInt_t&gt;  </type>
                        <methodname>parameterIds</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::vector&lt;std::string&gt; </type><parameter>names</parameter>
                        </methodparam>
                        
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Given a list of parameter <parameter>names</parameter>,
                        Returns a vector of the parameter ids associated with those
                        names.  The 0'th element of the result is the
                        id of the 0'th element of <parameter>names</parameter>
                        and so on.
                    </para>
                    <para>
                        If any of the parameters in <parameter>names</parameter>
                        does not exist a <classname>std::vector&lt;std::string&gt;::iterator</classname>
                        exception is thrown which 'points' to the element of
                        <parameter>names</parameter> that failed its lookup.
                    </para>
                </listitem>
            </varlistentry>

                </variablelist>
            </refsect1>

        </refentry>    
    </part>
    <part>
        <title>Tree Parameter, Tree Variable API</title>
        <chapter>
            <title>Tree parametr, tree variable API</title>
            <para>
                The Tree parameter subsystem was originally developed by
                Daniel Bazin.  It has since been reimplemented  and incorporated
                into SpecTcl.  The tree parameter subsystem provides two facilities
                for SpecTcl parameters and Tcl variables;
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        The ability to structure parameter space in to more
                        convenient organizations than the flat array that
                        SpecTcl uses internally, as well as to associate metadata
                        with SpecTcl parameters.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The ability to bind Tcl variables to metadata (e.g.
                        units of measurement) and to allow access to those data
                        without the need to understand how to program
                        the Tcl or Tcl++ libraries.  This, along with the user
                        interface elements that support tree parameters makes
                        steering computation performed by event pipeline elements
                        much simpler than it otherwise might be.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                In this part we will provide reference information for the
                tree parameter subsystem.  This information will be limited to the
                public interfaces of the classes intended for use by SpecTcl
                programmers.
            </para>
        </chapter>
        <refentry >
            <refmeta>
                <refentrytitle >CTreeParameter</refentrytitle>
                <manvolnum>3treeparam</manvolnum>
            </refmeta>
            
            <refnamediv>
                <refname>CTreeParameter</refname>
                <refpurpose>Parameter object 'independent' of rEvent</refpurpose>
            </refnamediv>
            
            <refsynopsisdiv>
            <synopsis>
#include &lt;TreeParameter.h&gt;

class <classname>CTreeParameter</classname>
{
 CTreeParameter();
  CTreeParameter(std::string name);
  CTreeParameter(std::string name, std::string units);
  CTreeParameter(std::string name, double lowLimit, double highLimit, 
		 std::string units);
  CTreeParameter(std::string name, UInt_t channels, 
		 double lowLimit, double highLimit, std::string units);
  CTreeParameter(std::string name, UInt_t resolution);
  CTreeParameter(std::string name, UInt_t resolution, 
		 double lowLimit, double widthOrHigh, 
		 std::string units, bool widthOrHighGiven);
  CTreeParameter(std::string name, const CTreeParameter&amp; Template);
  CTreeParameter(const CTreeParameter&amp; rhs);
  ~CTreeParameter();
  
  
  void Initialize(std::string name, UInt_t resolution);
  void Initialize(std::string name, UInt_t resolution, 
		  double lowLimit, double highOrWidth, std::string units, 
		  bool highOrWidthGiven);
  void Initialize(std::string name);
  void Initialize(std::string name, std::string units);
  void Initialize(std::string name, UInt_t channels, 
		  double lowLimit, double highLimit, std::string units);
  
  
  static void BindParameters();
  static void setEvent(CEvent&amp; rEvent);
  bool isBound();
  
	// Arithmetic operations...
  
  operator double();
  CTreeParameter&amp; operator= (double newValue);
  CTreeParameter&amp; operator= (CTreeParameter&amp; rhs);
  CTreeParameter&amp; operator+=(double rhs);
  CTreeParameter&amp; operator-=(double rhs);
  CTreeParameter&amp; operator*=(double rhs);
  CTreeParameter&amp; operator/=(double rhs);
  double          operator++(int dummy);
  CTreeParameter&amp; operator++();
  double          operator--(int dummy);
  CTreeParameter&amp; operator--();
  
  
  std::string getName();
  int    getId();
  double getValue();
  void   setValue(double newValue);
  UInt_t getBins();
  void   setBins(UInt_t channels);
  double getStart();
  void   setStart(double low);
  double getStop();
  void   setStop(double high);
  double getInc();
  void   setInc(double channelWidth);
  std::string getUnit();
  void   setUnit(std::string units);
  bool   isValid();
  void   setInvalid();
  void   Reset();
  void   clear();
  bool   hasChanged();
  void   setChanged();
  void   resetChanged();
  static void ResetAll();
  
  
  static std::multimap&lt;std::string, CTreeParameter*&gt;::iterator begin();
  static std::multimap&lt;std::string, CTreeParameter*&gt;::iterator end();
  static std::multimap&lt;std::string, CTreeParameter*&gt;::iterator find(std::string name);
  void Bind();
  
  
  
};
            </synopsis>
            </refsynopsisdiv>
            
            <refsect1>
                <title>DESCRIPTION</title>
                <para>
                    A <classname>CTreeParameter</classname> object is an alias
                    for an element of an event array.  By providing this independent
                    alias:
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            <classname>CTreeParameter</classname> objects
                            can be organized into arbitrary structures
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Additional metadata can be associated with the
                            parameter that's held by the <classname>CTreeParameter</classname>
                            object.
                        </para>
                    </listitem>
                </itemizedlist>
                <para>
                    The life cycle of a tree parameter is that it is
                    constructed and initialized.  Some of the constructors
                    provide for one step construction/initialization.
                    
                </para>
                <para>
                    Once initialized the tree parameters need to be bound to
                    the underlying parameters.  This binding is many to one in the
                    sense that  two tree parameters may have the same name and
                    will bind to the same underlying parameter.  Binding involves
                    associating a parameter id with the tree parameter object.
                    If the parameter is already known to SpecTcl the existing
                    Id is used.  If not, a new parameter is created with an
                    Id allocated by SpecTcl and the resulting Id is used
                    to bind the tree parameter.  SpecTcl will perform this binding
                    late in its initialization process.
                </para>
                <para>
                    For each event SpecTcl processes, a <classname>CEvent</classname>
                    object must associated with the tree parameter subsystem.
                    This association tells the tree parameter exactly which element
                    of which <classname>CEvent</classname> object to fetch
                    when referenced or to set when assigned or modified.
                </para>
            </refsect1>
            
            <refsect1>
                <title>METHODS</title>
                <para>
                    The tree parameter methods are divided  into several
                    categories.  The first set we will describe are constructors
                    and initialization methods:
                </para>
                <variablelist>
                <varlistentry>
                    <term><constructorsynopsis>
                        <methodname>CTreeParameter</methodname>
                        <void />
                    </constructorsynopsis></term>
                    <listitem>
                        <para>
                            Default constructor.  This constructor requires
                            two phase initialization.  That is at some point
                            opne of the <methodname>Initialize</methodname>
                            methods must be called to make this a usable
                            object.
                        </para>
                        <para>
                            Note that a constructed tree parameter
                            <emphasis>can</emphasis> be reinitialized
                            at any time, though if its name changes it must
                            be bound again.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>CTreeParameter</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Constructs a tree parameter with a name and no
                            metadata.  The metadata can be added later either by
                            invoking a <methodname>Initialize</methodname>
                            method or by invoking individual metadata setters.
                        </para>
                        <para>
                            Note if <methodname>Initialize</methodname>
                            is called with a different name after the object
                            has been bound, it must be bound again.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>CTreeParameter</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>units</parameter>
                            </methodparam> 
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Constructs a tree parameter specifying its
                            <parameter>name</parameter> and the
                            <parameter>units</parameter> of measure metadata.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>CTreeParameter</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>double </type><parameter>lowLimit</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>double </type><parameter>highLimit</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>units</parameter>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Constructs a tree parameter named
                            <parameter>name</parameter>.  Metadata is provided
                            that sets the range of the parameter to a low limit
                            of
                            <parameter>lowLimit</parameter> and high limit of
                            <parameter>highLimit</parameter>.  The
                            <parameter>units</parameter> parameter specifies the
                            units of measure.
                        </para>
                        <para>
                            Note that parameter limits are always advisory limits.
                            Nothing happens if the parameter is given a value outside
                            those limits.  Portions of the SpecTcl user interface,
                            however, do use those limits to inform default
                            choices for spectrum axis limits.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>CTreeParameter</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>channels</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>double </type><parameter>lowLimit</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>double </type><parameter>highLimit</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string</type><parameter> units</parameter>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This constructor provides not only the parameter's name,
                            limits and units but also recommends that spectra
                            with this parameter on an axis allocate
                            <parameter>channels</parameter> channels for that axis.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>CTreeParameter</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>resolution</parameter>
                            </methodparam>
                             
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            In this constructor, the metadata for the
                            tree parameter is the <parameter>resolution</parameter>.
                            This is well suited for a tree parameter that
                            reflects raw digitizer value.
                            The <parameter>resolution</parameter> specifies the
                            number of bits of data the digitizer provides.
                        </para>
                        <para>
                            This implies a parameter range of
                            <literal>[0, 2^<parameter>resolution</parameter>)</literal>
                            with a suggested channel count for a unit mapping
                            between parameter and spectrum coordinates.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>CTreeParameter</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>resolution</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>double </type><parameter>lowLimit</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>double </type><parameter>widthOrHigh</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>units</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>bool </type><parameter>widthOrHighGiven</parameter>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Constructs a tree parameter with a rather complex
                            set of metadata that depends on the value of
                            the <parameter>widthOrHeightGiven</parameter> flag.
                            <parameter>resolution</parameter> specifies that the
                            spectrum channel recommendation is for
                            <literal>2^<parameter>resolution</parameter></literal>
                            channels to be allocated on the axis.
                        </para>
                        <para>
                            The parameter (axis) low limit is recommended to
                            be <parameter>lowLimit</parameter>.  The
                            <parameter>widthOrHigh</parameter> meaning depends
                            on the <parameter>widthOrHighGiven</parameter>.
                            If this is <literal>false</literal>,
                            <parameter>widthOrHigh</parameter> is the
                            recommended high limit for the parameter.
                            If <parameter>true</parameter> <parameter>widthOrHigh</parameter>
                            represents the width of each channel.  The high limit
                            will be computed from <parameter>widthOrHigh</parameter>
                            and the <parameter>resolution</parameter> as follows:
                            <literal><parameter>lowLimit</parameter> + <parameter>widthorHigh</parameter> * 2^<parameter>resolution</parameter></literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>CTreeParameter</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>const CTreeParameter&amp; </type><parameter>Template</parameter>
                            </methodparam>
                             
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Constructs a new tree parameter that is a copy of
                            <parameter>Template</parameter>, except that it has
                            the name <parameter>name</parameter>.  This can be
                            used to construct several parameters with the same
                            properties where a <classname>CTreeParameterArray</classname>
                            is not really appropriate for example:
                        </para>
                        <informalexample>
                            <programlisting>
                                ...
// Define PPAC L,R, U,D parameters

CTreeParameter left("ppac.left", 0.0, 4095.0, "channels");
CTreeParameter right("ppac.right", left);
CTreeParameter up("ppac.up", left);
CTreeParameter down("ppac.down", left);
                                ...
                            </programlisting>
                        </informalexample>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type></type>
                            <methodname>CTreeParameter</methodname>
                            <methodparam>
                               <modifier>const </modifier>
                               <type>CTreeParameter&amp; </type><parameter>rhs</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Tree parameter copy constructor.  Among other things,
                            this allows a tree parameter to be passed by value
                            to methods.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>Initialize</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t</type><parameter> resolution</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>Initialize</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>resolution</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>double </type><parameter>lowLimit</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>double </type><parameter>highOrWidth</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string</type><parameter> units</parameter>
                            </methodparam>                          
                            <methodparam>
                               <modifier></modifier>
                               <type>bool </type><parameter>highOrWidthGiven</parameter>
                            </methodparam>  
                            <modifier></modifier>
                        </methodsynopsis>                        
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>Initialize</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>Initialize</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>units</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>Initialize</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>channels</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>double </type><parameter>lowLimit</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>double </type><parameter>highLimit</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>units</parameter>
                            </methodparam>
  
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            These initialization methods support two stage
                            construction.  The idea is that you could
                            construct a tree parameter using the default
                            constructor and then later complete construction
                            using the appropriate <methodname>Initialize</methodname>
                            method above.  Note that with the exception
                            of the default constructor, each constructor has a
                            corresponding <methodname>Initialize</methodname>
                            method with arguments that have the same meaning
                            as in the construcor.  Refer to the constructor
                            documentation for more information.
                        </para>
                    </listitem>
                </varlistentry>
                </variablelist>
                <para>
                    A <classname>CTreeParameter</classname> can be used
                    mostly as if it were a double precision
                    floating point value.  Specifically, it has
                    a <methodname>double</methodname> method which can
                    convert the object into a double.  It also supports
                    several types of arithmetic operations of the
                    compute-and-assign variety.
                </para>
                <para>
                    Note that those which require a right hand side parameter
                    (e.g. <methodname>operator+=</methodname>) take a
                    <type>double</type>.  This in conjuntion with the
                    conversion operator alows the use of tree parameters
                    as well on the righ hand side.
                </para>
                <para>
                    Note as well that a <classname>CException</classname>
                    will be thrown if a method needs the value of the parameter
                    prior to it having been given a value.
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type></type>
                                <methodname>operator double</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This is a conversion operator that extracts
                                extracts and returns the <type>double</type>
                                value of the parameter to which the object
                                is bound for the current event.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeParameter&amp; </type>
                                <methodname>operator= </methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>newValue</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Gives the underlying parameter in the current
                                event the double precision value
                                <parameter>newValue</parameter>.  Note that
                                <classname>CTreeParameter</classname> objects
                                or any other object with conversion operators
                                to doubles can also be on the right hand side
                                of this operator.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeParameter&amp; </type>
                                <methodname>operator+=</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>rhs</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Adds the double value on the right hand side of
                                the <literal>+=</literal> operator to the
                                object's parameter in the current event.
                                Returning a reference to the parameter allows
                                operator chaining such as
                                
                            </para>
                            <programlisting>
                                tp1  = tp2 += 1234.0; 
                            </programlisting>
                            <para>
                                Where both <varname>tp1</varname> and
                                <varname>tp2</varname> are tree parameters.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeParameter&amp; </type>
                                <methodname>operator-=(double rhs</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>rhs</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Subtracts the <parameter>rhs</parameter>
                                from the object and returns a reference to the
                                object.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                            <modifier></modifier>
                            <type>CTreeParameter&amp; </type>
                                    <methodname>operator*=</methodname>
                                    <methodparam>
                                       <modifier></modifier>
                                       <type>double</type><parameter> rhs</parameter>
                                    </methodparam>
                                    <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Multiplies the object by the
                                <parameter>rhs</parameter> and returns a
                                reference to the object.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                           <methodsynopsis>
                            <modifier></modifier>
                            <type>CTreeParameter&amp; </type>
                            <methodname>operator/=</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>double</type><parameter> rhs</parameter>
                            </methodparam>
                            <modifier></modifier>
                           </methodsynopsis> 
                        </term>
                        <listitem>
                            <para>
                                Divides the value of the object by
                                <parameter>rhs</parameter>.  A reference
                                to the object is returned.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>double</type>
                                <methodname>operator++</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>int </type><parameter>dummy</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Provides a post decrement operator.  Because
                                of the semantics of tree parameters, this is
                                not exactly possible.  The <emphasis>value</emphasis>
                                of the parameter prior to incrementing it is
                                returned.  That's why the return is a
                                <type>double</type> not a
                                <classname>CTreeParameter&amp;</classname>
                            </para>
                            <programlisting>
double f = tp++;   // tp a tree parameter.
                            </programlisting>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeParameter&amp; </type>
                                <methodname>operator++</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Increments the value of the tree parameter
                                object then returns a reference to that object.
                                This is the normal pre-decrement semantics.
                            </para>
                            <programlisting>
tp2 = ++tp1;      // Both tp2 and tp1 tree parameters.
                            </programlisting>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>double</type>
                                <methodname>operator--</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>int </type><parameter>dummy</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Post decrement operator.  Note that like the
                                post increment operator, a double is returned,
                                not a reference to the object or a copy of it.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeParameter&amp; </type>
                                <methodname>operator--</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                predecrement operator.  The reference to the
                                object is returned, after it is decremented.
                            </para>
                        </listitem>
                    </varlistentry>
                      
                </variablelist>
                <para>
                    Note that many of the arithmetic operations are not inplemented.
                    For example, there is no <methodname>operator+</methodname>.
                    This is because the <methodname>operator double</methodname>
                    makes those operations unecessary.  For example, given
                    tree parameters <varname>tp1, tp2</varname>
                </para>
                <programlisting>
                    tp1 = tp2 * 100 + 3.1416;
                </programlisting>
                <para>
                    Is perfectly legal and does the right thing.
                    <varname>tp2</varname> is replaced by its  value due to the
                    <methodname>operator double</methodname>.  The computation
                    produces  a double and that is assigned to <varname>tp1</varname>
                    via <methodname>operator=(double)</methodname>.
                </para>
                <para>
                    The next clump of methods are non arithmetic methods.
                    These includes getters and setter for the metata
                    the object has as well as tests that might be needed
                    either to support some Tcl level commands or computation
                    during an event processor.
                </para>
                <variablelist>
                    <varlistentry>
                        <term><methodsynopsis>
                            <modifier></modifier>
                            <type>std::string </type>
                            <methodname>getName</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis></term>
                        <listitem>
                            <para>
                                Returns the name of the tree parameter.
                                
                            </para>
                            <para>
                                While it is possible to change the name of
                                a tree parameter and then bind it to a different
                                underlying parameter, that's not considered the
                                way to do things (why not just instantiate a
                                different tree parameter instead of flopping
                                around the meaning of an existing one).
                                Therefore, there is no method that directly
                                just changes the name of a tree parameter.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>int    </type>
                                <methodname>getId</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the Id of the underlying parameter.
                                If the tree parameter has not yet been bound
                                to its parameter, this will throw a
                                <classname>CTreeException</classname>
                                (defined in <filename>CTreeException.h</filename>).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>double </type>
                                <methodname>getValue</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This is identical to the <methodname>operator double</methodname>
                                method.  The value of the parameter is fetched.
                                <classname>CTreeException</classname> is thrown
                                if there is no current event
                                <classname>std::string</classname> is thrown if
                                the parameter has not yet been given a value
                                in the processing of this event.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void</type>
                                <methodname>setValue</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>newValue</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets the underlying parameter value to
                                <parameter>newValue</parameter>.  This is identical
                                to <methodname>operator=(double)</methodname>.
                                Note that <classname>CTreeException</classname>
                                is thrown if the object has not yet been bound
                                or there's no current event to get the value from.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>UInt_t </type>
                                <methodname>getBins</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void  </type>
                                <methodname> setBins</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>channels</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets/Gets the number of recommended bins for an axis
                                on this parameter.  <parameter>channels</parameter>
                                is the new suggested number of bins.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>double </type>
                                <methodname>getStart</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void   </type>
                                <methodname>setStart</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>low</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Gets/Sets the suggested low limit for spectrum
                                axes on the parameter.  <parameter>low</parameter>
                                will be the new suggested low limit.
                            </para>
                            <para>
                                Note that this and all parameter metadata can be
                                set before the parameter is bound.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>double </type>
                                <methodname>getStop</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void   </type>
                                <methodname>setStop</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double</type><parameter> high</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis> 
  
                        </term>
                        <listitem>
                            <para>
                                Gets/Sets the  suggested high limit
                                for spectrum axes on the parameter.
                                <parameter>high</parameter> will be the new
                                suggested high limit.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>double </type>
                                <methodname>getInc</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void   </type>
                                <methodname>setInc</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>channelWidth</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Gets/Sets the channel width if the suggested
                                channel count, low and high limits are used for
                                spectrum parameters.  The channel width is
                                in parameter coordinates.  <parameter>channelWidth</parameter>
                                is a new channel width.
                            </para>
                            <para>
                                Note that this is computed metadata.  The primitive
                                metadata are the low limit, high limit and
                                number of channels.  There fore,
                                <methodname>setInc</methodname> is actually
                                modifying the suggested number of channels to
                                get the requested channel width.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>std::string </type>
                                <methodname>getUnit</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void  </type>
                                <methodname>setUnit</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>units</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Gets/Sets the units of measure for the parameter.
                                <parameter>units</parameter> is the new
                                units of measure string for the parameter.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>bool  </type>
                                <methodname>isValid</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns <literal>true</literal> if, for this
                                event, the parameter has been given a value.
                                This means that the parameter can be used
                                 in situations where it is an rvalue without
                                 throwing an exception
                            </para>
                            <para>
                                For this method to work, the parameter must be
                                bound and there must be a current event.
                                If either of these conditions is not met,
                                a <classname>CTreeException</classname> is
                                thrown.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void   </type>
                                <methodname>setInvalid</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void  </type>
                                <methodname>Reset</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void  </type>
                                <methodname>clear</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Invalidates the parameter for the current
                                event.  Once invalidated, the parameter
                                will throw an <classname>std::string</classname>
                                exception if used as an r value prior to being
                                used as an l value.
                            </para>
                            <para>
                                <classname>CTreeException</classname> is thrown
                                if the parameter as either not been bound or
                                there is no current event.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>bool   </type>
                                <methodname>hasChanged</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void   </type>
                                <methodname>setChanged</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void   </type>
                                <methodname>resetChanged</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Each tree parameter has a flag that is set
                                whenever any of the metadata for the parameter are
                                modified. <methodname>hasChanged</methodname>
                                returns the value of this boolean flag.
                                <methodname>setChanged</methodname> sets the flag
                                to <literal>true</literal>
                                and <methodname>resetChanged</methodname>
                                set the flag to <literal>false</literal>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodsynopsis>
                            <modifier>static</modifier>
                            <type> void </type>
                            <methodname>ResetAll</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis></term>
                        <listitem>
                            <para>
                                This is normally called by SpecTcl's event
                                processing subsystem before starting to
                                process each event.  It iterates through
                                all tree parameters that have been defined and
                                invokes their <methodname>Reset</methodname>
                                method, which marks them as invalid.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    Creating a <classname>CTreeParameter</classname> object
                    registers it with a static registry.  This registry is
                    used by SpecTcl to, e.g. bind the tree parameters to
                    base parameters after initialization, and to
                    reset the validity on all parameters.
                </para>
                <para>
                    The following methods deal with this registry and parameter
                    binding.
                </para>
                <variablelist>
                    <varlistentry>
                        <term><methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>Bind</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis></term>
                        <listitem>
                            <para>
                                Binds this tree parameter to the underlying parameter.
                                If no underlying parameter with the tree
                                parameter's name exists, one is created and
                                assigned a unique id.
                            </para>
                            <para>
                                Binding a tree parameter that has not been
                                given a name yet binds the tree parameter to
                                a parameter with an empty name string.  This
                                is perfectly legal but probably not what you
                                want.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>static </modifier>
                                <type>void </type>
                                <methodname>BindParameters</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Iterates through all registered
                                <classname>CTreeParameter</classname> objects
                                binding them to underlying parameters.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>static </modifier>
                                <type>void </type>
                                <methodname>setEvent</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>CEvent&amp; </type><parameter>rEvent</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets the event that all tree parameters are
                                working on.  All tree parameters share this
                                object.  Parameter bindings supply each tree
                                parameter with a parameter id.  When the value
                                of a parameter is retrieved/set/modified, that id
                                is the index into <parameter>rEvent</parameter>
                                that is accessed.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>bool </type>
                                <methodname>isBound</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                If the object has been bound to its underlying
                                parameter, this returns <literal>true</literal>.
                                If not it returns <literal>false</literal>.
                                Many tree parameter operations require tht the object
                                be bound.  Some also require there be
                                a current event.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>static </modifier>
                                <type>std::multimap&lt;std::string, CTreeParameter*&gt;::iterator </type>
                                <methodname>begin</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier>static </modifier>
                                <type>std::multimap&lt;std::string, CTreeParameter*&gt;::iterator </type>
                                <methodname>end</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Supports iteration through the tree parameter
                                registry by providing a start  of iteration
                                iterator.  Note that using an
                                <classname>std::multimap</classname> for the
                                registry cleanly supports the many to one mapping
                                of tree parameters to underlying parameters.
                            </para>
                            <para>
                                An iterator is a pointer like object.
                                In this case these pointer point to
                                <classname>std::pair&lt;std::string, CTreeParameter*&gt;</classname>
                                objects where the first element of the par is the
                                name of the tree parameter and the second is a
                                pointer to the tree parameter itself.
                            </para>
                            <para>
                                Iterators can be incremented. When incremented
                                they point to the next item in the container.
                                Note that multimap iterators will step through the
                                map in key (parameter name) sort order.
                                This means that all of the tree parameters
                                that share the same name will be clumped together.
                            </para>
                            <para>
                                If an iterator points to the last item in the
                                collection, incrementing it will produce
                                an iterator that is equal to the iterator
                                returned from <methodname>end</methodname>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>static </modifier>
                                <type>std::multimap&lt;std::string, CTreeParameter*&gt;::iterator </type>
                                <methodname>find</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>name</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns an iterator to an element of the registry
                                that has the indicated <parameter>name</parameter>.
                                Note that more than one tree parameter can have
                                this name.  In that case, this iterator will
                                point to the first of them.  Incrementing the
                                iterator will get successive tree parameters
                                with the same name until either the end of the
                                multimap is reached or a tree parameter with a
                                different name is reached.
                            </para>
                            <para>
                                In practice this iteration over identically
                                named tree parameters is not necessary because
                                like named tree parameters share underlying metadata
                                and data and parameter bindings make each
                                such object interchangeable with the others.
                            </para>
                        </listitem>
                    </varlistentry>                 
                </variablelist>
            </refsect1>
        </refentry>
        <refentry >
            <refmeta>
                <refentrytitle >CTreeParameterArray</refentrytitle>
                <manvolnum>3spectcl</manvolnum>
            </refmeta>
            
            <refnamediv>
                <refname>CTreeParameterArray</refname>
                <refpurpose>Arrays of tree parameters</refpurpose>
            </refnamediv>
            
            <refsynopsisdiv>
                <synopsis>
#include &lt;TreeParameter.h&gt;

class <classname>CTreeParameterArray</classname>
{
CTreeParameterArray();
CTreeParameterArray(std::string baseName, 
          UInt_t resolution, UInt_t numElements, Int_t baseIndex);
CTreeParameterArray(std::string baseName, 
          UInt_t resolution, 
          double lowLimit, double highOrWidth, 
          std::string units, bool widthOrHighGiven, 
          UInt_t elements, Int_t firstIndex);
CTreeParameterArray(std::string baseName, UInt_t elements, Int_t baseIndex);
CTreeParameterArray(std::string baseName, std::string units, 
          UInt_t elements, Int_t firstIndex);
CTreeParameterArray(std::string baseName, 
          double low, double high, std::string units, 
          UInt_t elements, Int_t firstIndex);
CTreeParameterArray(std::string baseName, UInt_t channels, 
          double low, double high, std::string units, 
          UInt_t elements, Int_t firstIndex);

void Initialize(std::string baseName, UInt_t resolution, 
      UInt_t elements, Int_t baseIndex);
void Initialize(std::string baseName, UInt_t resolution, 
      double lowLimit, double widthOrHeight,
      std::string units, bool widthOrHeightGiven, 
      UInt_t elements, Int_t firstIndex);
void Initialize(std::string baseName, UInt_t elements, Int_t firstIndex);
void Initialize(std::string baseName, std::string units, UInt_t elements, 
      Int_t firstIndex);
void Initialize(std::string baseName, double lowLimit, double highLimit, 
      std::string units, UInt_t elements, Int_t firstIndex);
void Initialize(std::string baseName, UInt_t channels, 
      double lowLimit, double highLimit, std::string units, 
      UInt_t elements, Int_t firstIndex);

CTreeParameter&amp; operator[](Int_t nIndex);
void Reset();
std::vector&lt;CTreeParameter*&gt;::iterator begin();
std::vector&lt;CTreeParameter*&gt;::iterator end();
UInt_t size();
Int_t lowIndex();
};
                </synopsis>
            </refsynopsisdiv>
            
            <refsect1>
                <title>DESCRIPTION</title>
                <para>
                    The <classname>CTreeParameterArray</classname> provides
                    support for creating arrays of tree parameters.
                    <classname>CTreeParamterArray</classname> objects can
                    be treated like arrays programmatically but, in parameter
                    space, create a subtree of parameters.
                </para>
                <para>
                    By convention, parameters managed by the tree parameters
                    occupy a hierarcy.  The name of a parameter is a
                    dot (<literal>.</literal>) separated string.  Each
                    dot represents a path separator.  Thus the name
                    <literal>top.raw.adc.01</literal> represents the
                    parameter <literal>01</literal> that has the parent
                    <literal>adc</literal> which in turn has the parent
                    <literal>raw</literal> which in turn is parented by
                    <literal>top</literal>.
                </para>
                <para>
                    Tree parameter array objects create a subtree below
                    a parent name.  The names of the subtree are indices into
                    the tree parameter array.  In the example above, the
                    parent name might have been <literal>top.raw.adc</literal>
                    and the index <literal>01</literal>.  To facilitate
                    sorting, in parameter name space, indices are zero filled
                    to the left to accomodate the number of digits needed by
                    the largest index.
                </para>
                <para>
                    Tree parameter indices are not constrained to start from
                    zero but can start from any integer value (including
                    negative integers).
                </para>
                <para>
                    The main method a <classname>CTreeParameter</classname>
                    has, is of course, the index operator
                    (<methodname>operator[]</methodname>).  If the
                    index provided to it is out of range a
                    <classname>CTreeException</classname> is thrown,
                    otherwise, this method returns a reference to the
                    indexed tree parameter in the array.
                </para>
            </refsect1>
            
            <refsect1>
                <title>METHODS</title>
                <para>
                    Construction and initialization methods;  Like
                    the <classname>CTreeParameter</classname> class,
                    <classname>CTreeParameterArray</classname>
                    supports either one step or two step construction.
                    Two step construction is supported via a
                    default constructor and a set of
                    <methodname>Initialize</methodname> methods
                    that provide the actual properties of the object.
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <constructorsynopsis>
                                <methodname>CTreeParameterArray</methodname>
                                <void />
                            </constructorsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Default constructor.  This is used with
                                two step construction.  After constructing
                                the array, one of the
                                <methodname>Initialize</methodname> methods
                                below needs to be called to define the
                                characteristics of the array.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <constructorsynopsis>
                                <methodname>CTreeParameterArray</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>baseName</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>resolution</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t</type><parameter> numElements</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>Int_t </type><parameter>baseIndex</parameter>
                                </methodparam>                                    
                            </constructorsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Constructs and defines a tree parameter
                                array.  <parameter>baseName</parameter>
                                is used to derive the names of the parameters
                                in the array (see <literal>DESCRIPTION</literal>
                                above).  <parameter>numElements</parameter>
                                and <parameter>baseIndex</parameter>
                                define the number of array elements and the
                                base index for the array.
                                Array indices are in the range
                                <literal>[<parameter>baseName</parameter>, <parameter>baseName</parameter>+<parameter>numElements</parameter>)</literal>.
                            </para>
                            <para>
                                <parameter>resolution</parameter> describes
                                the suggested number of channels and the
                                range of values a spectrum axis on these
                                parameters should have as a number of bits
                                occupied by the parameter.  This form
                                of the constructor is best used for raw
                                digitizer values.
                            </para>
                            <para>
                                All tree parameters in the array
                                will be constructed with the same
                                <parameter>resolution</parameter>, it is
                                unusual, but possible to retrieve individual
                                elements of the array and reconfigure them.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <constructorsynopsis>
                                <methodname>CTreeParameterArray</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>baseName</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>resolution</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>lowLimit</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>highOrWidth</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>units</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>bool </type><parameter>widthOrHighGiven</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>elements</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>Int_t </type><parameter>firstIndex</parameter>
                                </methodparam>
                            </constructorsynopsis>
                        </term>
                        <listitem>
                            <para>
                                <parameter>The additional</parameter>
                                parameters define the limits of the
                                parameter.  <parameter>lowLimit</parameter>
                                is the recommended low limit of axes
                                that are defined on these parameters.
                                The meaning of
                                <parameter>highOrWidth</parameter> depends
                                 on the value of the flag
                                 <parameter>widthOrHighGiven</parameter>.
                            </para>
                            <para>
                                If <parameter>widthOrHighGiven</parameter>
                                is <literal>true</literal>,
                                <parameter>highOrWidth</parameter> defines
                                the suggested high limit of axes on these
                                parameters.  If <literal>false</literal>,
                                the paramete represents the width of each
                                channel in parameter coordinates.  It, along
                                with <parameter>resolution</parameter>
                                (which define the number of channels)
                                are used to compute the high limit recommended
                                for spectrum axes on these parameters.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <constructorsynopsis>
                                <methodname>CTreeParameterArray</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string baseName</type><parameter></parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>elements</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>Int_t </type><parameter>baseIndex</parameter>
                                </methodparam>
                            </constructorsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This constructor does not supply any metadata
                                for the tree parameters it creates.
                                If metadata are desired, they can be supplied
                                later either by a call ot the appropriate
                                <methodname>Initialize</methodname>
                                method or by iterating through the array
                                setting metadata for each element.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <constructorsynopsis>
                                <methodname>CTreeParameterArray</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>baseName</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>units</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>elements</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>Int_t </type><parameter>firstIndex</parameter>
                                </methodparam>
           
                            </constructorsynopsis>
                        </term>
                        <listitem>
                            <para>
                                The <parameter>units</parameter> parameter
                                defines the units of measure for the tree
                                parameters in the array.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <constructorsynopsis>
                                <methodname>CTreeParameterArray</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>baseName</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>low</parameter>
                                </methodparam>                      
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>high</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>units</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t</type><parameter> elements</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>Int_t </type><parameter>firstIndex</parameter>
                                </methodparam>
                            </constructorsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Provides the suggested 
                                <parameter>low</parameter> and
                                <parameter>high</parameter> limits on axes
                                defined on these parameters.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <constructorsynopsis>
                                <methodname>CTreeParameterArray</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>baseName</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>channels</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>low</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double</type><parameter> high</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string</type><parameter> units</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>elements</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>Int_t </type><parameter>firstIndex</parameter>
                                </methodparam>
                            </constructorsynopsis>
                        </term>
                        <listitem>
                            <para>
                                In this case <parameter>channels</parameter>
                                specifies the suggested number of bins
                                on an axis on this parameter where
                                the axis will run between
                                <parameter>low</parameter> and <parameter>high</parameter>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void </type>
                                <methodname>Initialize</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>baseName</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>resolution</parameter>
                                </methodparam>
                                 <methodparam>
                                    <modifier></modifier>
                                    <type>UInt_t </type><parameter>elements</parameter>
                                 </methodparam>
                                 <methodparam>
                                    <modifier></modifier>
                                    <type>Int_t </type><parameter>baseIndex</parameter>
                                 </methodparam>
       
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void </type>
                                <methodname>Initialize</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>baseName</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>resolution</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>lowLimit</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>widthOrHeight</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>units</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>bool </type><parameter>widthOrHeightGiven</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>elements</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>Int_t </type><parameter>firstIndex</parameter>
                                </methodparam>
                                
       
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void </type>
                                <methodname>Initialize</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string</type><parameter> baseName</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>elements</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>Int_t </type><parameter>firstIndex</parameter>
                                </methodparam>
                                  
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void </type>
                                <methodname>Initialize</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>baseName</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>units</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>elements</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>Int_t </type><parameter>firstIndex</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void </type>
                                <methodname>Initialize</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>baseName</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>lowLimit</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>highLimit</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>units</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>elements</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>Int_t </type><parameter>firstIndex</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>    
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void </type>
                                <methodname>Initialize</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>baseName</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>channels</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>lowLimit</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>highLimit</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>units</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>elements</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>Int_t </type><parameter>firstIndex</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>  
                        <listitem>
                            <para>
                                These methods are called as the second
                                step in a two step construction.  The
                                meaning of their parameters is the same
                                as the constructors with corresponding
                                parameters.  See the documentation
                                of the constructors above for more
                                information.
                            </para>
                        </listitem>
                    </varlistentry>

                
                </variablelist>
                <para>
                    The remainder of the methods, besides
                    <methodname>operator[]</methodname> are miscellaneous.
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeParameter&amp; </type>
                                <methodname>operator[]</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>Int_t </type><parameter>nIndex</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns a reference to the tree parameter
                                in the array indexed by
                                <parameter>nIndex</parameter>.
                                A <classname>CTreeException</classname>
                                is thrown if the index is out of range.
                            </para>
                            <para>
                                Since a reference is returned the tree
                                parameter can be modified as well as set
                                or inspected.
                            </para>
                        </listitem>
                    </varlistentry>
                
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void </type>
                                <methodname>Reset</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Invokes the <methodname>Reset</methodname>
                                method on each element of the array.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>std::vector&lt;CTreeParameter*&gt;::iterator </type>
                                <methodname>begin</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>std::vector&lt;CTreeParameter*&gt;::iterator </type>
                                <methodname>end</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Supports iteration of the
                                <classname>std::vector</classname> used to
                                maintain the tree parameters in the object.
                                <methodname>begin</methodname> returns
                                an iterator that can be used as if it were
                                a pointer to <classname>CTreeParameter*</classname>
                                pointer that points to the first element
                                of the vector.  This will be the tree
                                parameter with the lowest index.
                            </para>
                            <para>
                                Incrementing the iterator points to the item with
                                the next index in the container.  Incrementing
                                the iterator when it points to the last
                                tree parameter results in a value that is
                                equal to that returned from
                                <methodname>end</methodname>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>UInt_t </type>
                                <methodname>size</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Retrurns the number of tree parameters in the
                                array.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>Int_t </type>
                                <methodname>lowIndex</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the smallest allowed index into the
                                tree parameter array.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
            
        </refentry>
        <refentry>
            <refmeta>
                <refentrytitle >CTreeVariable</refentrytitle>
                <manvolnum>3spectcl</manvolnum>
            </refmeta>
            
            <refnamediv>
                <refname>CTreeVariable</refname>
                <refpurpose>Access to Tcl variables with metadata</refpurpose>
            </refnamediv>
            
            <refsynopsisdiv>
                <synopsis>
#include &lt;TreeParameter.h&gt;

class <classname>CTreeVariable</classname>
{
  CTreeVariable();
  CTreeVariable(std::string name, double value, std::string units);
  CTreeVariable(const CTreeVariable&amp; rhs);

  void Initialize(std::string name, double value, std::string units);

  operator double() const;
  CTreeVariable&amp; operator=(double rhs);
  CTreeVariable&amp; operator=(const CTreeVariableamp; rhs);
  CTreeVariable&amp; operator+=(double rhs);
  CTreeVariable&amp; operator-=(double rhs);
  CTreeVariable&amp; operator*=(double rhs);
  CTreeVariable&amp; operator/=(double rhs);
  double operator++(int dummy);
  CTreeVariable&amp; operator++();
  double operator--(int dummy);
  CTreeVariable&amp; operator--();
  
  
  std::string getName();
  double getValue();
  std::string getUnit();
  bool hasChanged();
  bool valueChanged();
  void resetChanged();
  
  void Bind();
  static void BindVariables(CTCLInterpreter&amp; rInterp);
  static TreeVariableIterator begin();
  static TreeVariableIterator end();
  static TreeVariableIterator find(std::string name);
  static int size();
  
};
                </synopsis>
            </refsynopsisdiv>
            
            <refsect1>
                <title>DESCRIPTION</title>
                <para>
                    The <classname>CTreeVariable</classname>  class provides
                    simplified access to Tcl intepreter variables.  These
                    variables are globally scoped variables in Tcl and
                    are defined in the interpreter that executes
                    SpecTcl commands.
                </para>
                <para>
                    The operations provided by the class are sufficient
                    to allow you to treat the tree variable as if it were
                    a simple <type>double</type> value, transparently fetching or
                    storing the underlying Tcl variable as needed.
                </para>
                <para>
                    Tree variables also have metadata.  Specifically each tree
                    variable can have a unit of measure property.
                </para>
            </refsect1>
            
            <refsect1>
                <title>METHODS</title>
                <para>
                    Constructors and initializers.  As with tree parameters,
                    tree variables support both one and two step
                    construction.
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <constructorsynopsis>
                                <methodname>CTreeVariable</methodname>
                                <void />
                            </constructorsynopsis>                          
                        </term>
                        <listitem>
                            <para>
                                This default constructor will require that
                                you later invoke
                                <methodname>Initialize</methodname>
                                to complete the two step construction of the
                                object.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <constructorsynopsis>
                                <methodname>CTreeVariable</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>name</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>value</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>units</parameter>
                                </methodparam>
                                  
                            </constructorsynopsis>
                        </term>
                        <listitem>
                            <para>
                                <parameter>name</parameter> is the name of
                                the Tcl variable this object is
                                associated with.  <parameter>value</parameter>
                                is an initial value the variable will be given.
                                <parameter>units</parameter> are the units
                                of measure metadata to be associated
                                with this variable.
                            </para>
                            <para>
                                If there is already a Tcl variable, this does
                                not affect it.  The variable will need to be bound.
                                first.  If there is already a tree variable,
                                The previously established
                                initial value and units override the value and
                                units in this constructor.
                            </para>
                            <para>
                                A bit of information about how all this works
                                that will help you to understand some of the
                                pathalogical cases.  Tcl supports linking
                                a C/C++ variable to a Tcl variable.  We
                                use this, however we have to do some fancy
                                footwork to support many to one mappings from
                                tree variables to Tcl variables.
                            </para>
                            <para>
                                Associated with a tree variable name and,
                                therefore, with all tree variable objects
                                with the same name, is a properties object.
                                The properties object contains the name,
                                value and units metadata, shared between
                                all tree variables objects with the same name.
                                Binding at least one of the objects links the
                                C++ variable containing the value with the
                                Tcl variable with the same name as the
                                tree variable's name.
                            </para>
                            <para>
                                Thus, unlike tree parameters, once a
                                tree variable is constructed, it can be set,
                                gotten, modified and queried without error.
                                What does not happen is for anything done to the
                                value of the tree variable to affect the
                                Tcl variable.  Binding the tree variable
                                links the data containing the value with the
                                Tcl variable and ensures that the Tcl variable
                                has the current value of the tree variable.
                            </para>
                            <para>
                                A short code segment may be useful.
                            </para>
                            <programlisting>
CTreeVariable t1("myvar", 1234, "arb");           // Tcl variable unchanged
CTreeVariable t2("myvar", 456, "inch");           // Tcl and tree variable unchanged.

t1 = 777;        // T1 and T2 are now 777, Tcl variable unchanged.
t2.Bind();       // Tcl variable now 777.

t1 = 0;          // Tcl, t1, and t2 vars are now 0.
                            </programlisting>
                        </listitem>
                    </varlistentry>
                
                    <varlistentry>
                        <term>
                            <constructorsynopsis>
                                <methodname>CTreeVariable</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>const CTreeVariable&amp; </type><parameter>rhs</parameter>
                                </methodparam>
                            </constructorsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Copy construction.  This allows tree variables
                                to be passed by value.  Since, however all like named
                                tree variables use the same underlying data,
                                Changes to the copy constructed object will be
                                reflected in all other like named tree variables and,
                                if the variable is bound, in the Tcl variable.
                            </para>
                            <para>
                                Thus, while pass by value is legal, it has the
                                semantics of pass by reference.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void </type>
                                <methodname>Initialize</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>name</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>value</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>units</parameter>
                                </methodparam>
                                 
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Second step of two step initialization. The
                                parameters have the same meaning as in the one-step
                                construction constructor.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    The next set of methods are provided so that, for the most part,
                    you can treat a <classname>CTreeVariable</classname> as if it
                    were a Double precision variable.  The main contributor to this
                    is the <methodname>operator double</methodname> conversion
                    operator.  This operator allows a <classname>CTreeVariable</classname>
                    variable in an expression to be converted to a double, supporting
                    its use on the right hand side (as an r-value) of assignments.
                </para>
                    
                <variablelist>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type></type>
                                <methodname>operator double</methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                In C++ this sort of method is called a
                                conversion operator, or casting operator.
                                It provides a method that allows
                                <classname>CTreeVariable</classname>
                                objects to be treated as double variables
                                wherever appropriate.
                                The method returns the value of the
                                underlying variable.  Note that if the
                                object has not yet been bound, the value
                                returned is the most recently set value of
                                the object, which can differ from the
                                Tcl variable's value.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeVariable&amp; </type>
                                <methodname>operator=</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>rhs</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Assignment operator.  This is one of the
                                operators that allows
                                <classname>CTreeVariable</classname> objects
                                top be used on the left hand side of
                                assignment operations (as an l-value).
                                The method assigns the
                                double <parameter>rhs</parameter>
                                to the value of the variable. If the
                                object has been bound, this will be the new
                                value of the Tcl variable.  If not, this value
                                will be held in the variable and will become
                                the value of the Tcl variable when it is bound.
                            </para>
                            <para>
                                By returning a reference to the object, assignment
                                chaining is supported,  e.g. like
                            </para>
                            <programlisting>
CTreeVariable t1("avar", 1.234, "arbitrary");
double        d1;

d1  = t1 = 5.6;             // d1 is 5.6 as is t1.
                            </programlisting>
                            <para>
                                The best way to read the last statement is
                                right to left.  First the tree variable is
                                given the value 5.6 and that assignment can be
                                thought of as being replaced by the
                                <varname>t1</varname>  tree variable reference.
                            </para>
                            <para>
                                To accomplish the assignment to <varname>d1</varname>,
                                the <methodname>operator double</methodname>
                                is used to returne the value of
                                <varname>t1</varname> to assign to
                                <varname>d1</varname>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeVariable&amp; </type>
                                <methodname>operator=</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>const CTreeVariableamp; </type><parameter>rhs</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Assigns the value of the <parameter>rhs</parameter>
                                tree variable to the value of this variable.
                                Once more returning a reference to the object
                                allows operator chaining.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeVariable&amp; </type>
                                <methodname>operator+=</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double</type><parameter> rhs</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Like assignment, but <parameter>rhs</parameter>
                                is added to the variable's value.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeVariable&amp; </type>
                                <methodname>operator-=</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>rhs</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Like assignment but
                                <parameter>rhs</parameter> is subtracted
                                from the value of the object.
                            </para>
                        </listitem>
                    </varlistentry>                  
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeVariable&amp; </type>
                                <methodname>operator*=</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>rhs</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>                          
                        </term>
                        <listitem>
                            <para>
                                Like assignment but
                                <parameter>rhs</parameter> multiplies the
                                object's value.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeVariable&amp; </type>
                                <methodname>operator/=</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>rhs</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Like assignment but the value of the object is
                                divided by the <parameter>rhs</parameter>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>double </type>
                                <methodname>operator++</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>int </type><parameter>dummy</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This operator is the post-increment operator.
                                The value of the object prior to the increment
                                is returned.  Because of the binding to an underlying
                                Tcl variable, the normal semantics of  predecrementing
                                are not possible.
                            </para>
                            <para>
                                Specifically  normally post-increments ill return
                                a copy of the object prior to the increment, while
                                here a double is returned instead.  In most cases
                                you won't notice the difference.
                            </para>
                                  
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeVariable&amp; </type>
                                <methodname>operator++</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Pre-increment operator.  The variable's value is incremented
                                and then a reference to the object is returned.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>double </type>
                                <methodname>operator--</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>int </type><parameter>dummy</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Post decrement operator.  The value of the object
                                is decremented but the value returned is the
                                <type>double</type> value prior to the increment.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeVariable&amp; </type>
                                <methodname>operator--</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Pre decrement operator.  The object's value is
                                decremented after which a reference to the
                                decremented object is returned.
                            </para>
                        </listitem>
                    </varlistentry>  
                </variablelist>
                <para>
                    The next set of operations can be best described as
                    queries about the object.
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>std::string </type>
                                <methodname>getName</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>                          
                        </term>
                        <listitem>
                            <para>
                                Returns the name of the object, and hence
                                the Tcl variable the object represents.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>double </type>
                                <methodname>getValue</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                The same as <methodname>operator double</methodname>.
                                The value of the object is returned.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>std::string </type>
                                <methodname>getUnit</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the units of measure metadata for the
                                object.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>bool </type>
                                <methodname>hasChanged</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Each tree variable has an associated flag
                                that is set <literal>true</literal>
                                when the definition of that variable
                                has changed.  This method returns the
                                value of that flag.
                            </para>
                            <para>
                                The main purpose is to control which parameter
                                definitions might need to be written
                                to file during a state save operation.
                            </para>
                        </listitem>
                    </varlistentry>                  
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>bool </type>
                                <methodname>valueChanged</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>                  
                        </term>
                        <listitem>
                            <para>
                                Each variable has a value changed
                                flag as well that is modified when the
                                value of the variable is modified.
                                This is normally used to fire traces
                                on a variable in Tcl.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void </type>
                                <methodname>resetChanged</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Resets both changed flags described above and
                                fires any value changed Tcl traces.  Traces are
                                used by Tk widgets to know when to update
                                values they contain via <option>-variable</option>
                                and <option>-textvariable</option> options.
                                It is therefore important to ensure that
                                these traces get fired after C++ changes
                                to these values if there are user interface
                                elements that display these variables.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    The remainder of the methods primarily relate to bindings,
                    the registry of variables,
                    and the interface of the variable to its Tcl counterpart.
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void </type>
                                <methodname>Bind</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Binds this variable to the Tcl variable of the
                                same name, creating it if necessary.  The
                                object's value will be put into the Tcl variable.
                                If the object is already bound this is a silent
                                No-op.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>static </modifier>
                                <type>void </type>
                                <methodname>BindVariables</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>CTCLInterpreter&amp; </type><parameter>rInterp</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                A registry is maintained of all tree variable
                                objects.  This method iterates this registry
                                and binds all tree variables to their underlying
                                Tcl variables.  You can think of this as
                                invoking <methodname>Bind</methodname> on every
                                tree parameter.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>static</modifier>
                                <type> TreeVariableIterator </type>
                                <methodname>begin</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier>static</modifier>
                                <type> TreeVariableIterator </type>
                                <methodname>end</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier>static</modifier>
                                <type> TreeVariableIterator </type>
                                <methodname>find</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>name</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Return pointer like objects that can be
                                used to iterate the tree varaible registry.
                                When dereferenced, the object returns a
                                <classname>std::pair&lt;std::string, CTreeVariableProperties*&gt;</classname>
                                The first item of each pair is the name of the
                                tree variable.  The second are the set of
                                properties that are shared between all
                                variables of the same name.
                            </para>
                            <para>
                                <classname>CTreeVariableProperties</classname>
                                will be described later in this reference section.
                            </para>
                            <para>
                                <methodname>begin</methodname> returns the
                                iterator 'pointing' to the first object in the
                                container.
                                Incrementing an iterator  'points' it to the
                                next tree variable in the container.  Incrementing
                                the iterator pointing at the last object in the
                                container returns a value equal to that returned
                                by <methodname>end</methodname>.
                            </para>
                            <para>
                                <methodname>find</methodname> returns an iterator
                                that points to the item in  the container named
                                <parameter>name</parameter>.  Note that since
                                the registry contains <classname>CTreeVariableProperties</classname>
                                objects, there won't be duplication.
                                I there is no entry in the registry with the
                                <parameter>name</parameter>, the value
                                returned from <methodname>end</methodname>
                                is returned.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>static </modifier>
                                <type>int </type>
                                <methodname>size</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the number of entries in the
                                registry.  Note that since the registry
                                contains
                                <classname>CTreeVariablePropertiew</classname>
                                objects, the number of entries in the registry
                                may be less than the number of
                                <classname>CTreeVariable</classname> objects that
                                have been created.
                            </para>
                        </listitem>
                    </varlistentry>
                    
                </variablelist>

            </refsect1>
        </refentry>
        <refentry >
            <refmeta>
                <refentrytitle >CTreeVariableProperites</refentrytitle>
                <manvolnum>3spectcl</manvolnum>
            </refmeta>
            
            <refnamediv>
                <refname>CTreeVariableProperties</refname>
                <refpurpose>Shared properties of CTreeVariable</refpurpose>
            </refnamediv>
            
            <refsynopsisdiv>
                <synopsis>
#include &lt;CTreeVariableProperties.h&gt;

class <classname>CTreeVariableProperties</classname>
{
public:
  CTreeVariableProperties&amp; operator=(double value);
  CTreeVariableProperties&amp; operator=(const CTreeVariableProperties&amp; rhs);
  CTreeVariableProperties&amp; operator=(const CTreeVariable&amp; rhs);
  operator double();

  bool    definitionChanged();
  std::string  getName();  
  std::string  getUnits();
  bool    valueChanged();
  
  void    setUnits(std::string units);
  void    resetDefinitionChanged();
  void    fireTraces();
  void    Link(CTCLInterpreter&amp; rInterp);
};
                </synopsis>
            </refsynopsisdiv>
            
            <refsect1>
                <title>DESCRIPTION</title>
                <para>
                    Unless you are iterating the tree variable dictionary, this
                    class can be completely ignored as internal to the
                    tree parameter subsystem.  A <classname>CTreeVariableProperties</classname>
                    object contains the properties shared between several instances
                    of a <classname>CTreeVariable</classname> that have
                    the same name.
                </para>
                <para>
                    Furthermore, it is the <classname>CTreeVariableProperties</classname>
                    object that carries the binding between the variable and the
                    associated Tcl variable.   
                </para>
                <para>
                    Each tree variable holds the following information in this
                    object:
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            The variable's name.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            The variable's units.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            The variable's value.  This is linked to a
                            Tcl variable with the same name as this object.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Definition and value changed flags.
                        </para>
                    </listitem>
                </itemizedlist>
            </refsect1>
            
            <refsect1>
                <title>METHODS</title>
                <para>
                    Note that since these objects are typically constructed
                    by <classname>CTreeVariable</classname> objects, we're not
                    going to document the class constructors.
                </para>
                <para>
                    The first set of methods we document are those used
                    by <classname>CTreeVariable</classname> to mimic
                    a <type>double</type>L
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeVariableProperties&amp; </type>
                                <methodname>operator=</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>value</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeVariableProperties&amp; </type>
                                <methodname>operator=</methodname>
                                <methodparam>
                                   <modifier>const </modifier>
                                   <type>CTreeVariableProperties&amp; </type><parameter>rhs</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeVariableProperties&amp; </type>
                                <methodname>operator=</methodname>
                                <methodparam>
                                   <modifier>const </modifier>
                                   <type>CTreeVariable&amp; </type><parameter>rhs</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Assigns the <parameter>rhs</parameter> or its
                                value to the value of the object.
                                Returning a reference to the object supports
                                assignment chaining.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type></type>
                                <methodname>operator double</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the value of the object.  This
                                allows the object to be treated like
                                a <type>double</type> for many purposes.
                            </para>
                        </listitem>
                    </varlistentry>
                  </variablelist>
                    <para>
                        The next set of methods are used to query various
                        aspects of the object:
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term>
                                <methodsynopsis>
                                    <modifier></modifier>
                                    <type>bool    </type>
                                    <methodname>definitionChanged</methodname>
                                    <void />
                                    <modifier></modifier>
                                </methodsynopsis>
                            </term>
                            <listitem>
                                <para>
                                    Returns <literal>true</literal> if the
                                    definition has changed either since construction
                                    or since the change flags were reset last.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <methodsynopsis>
                                    <modifier></modifier>
                                    <type>std::string  </type>
                                    <methodname>getName</methodname>
                                    <void />
                                    <modifier></modifier>
                                </methodsynopsis>
                            </term>
                            <listitem>
                                <para>
                                    Returns the name of the variable.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <methodsynopsis>
                                    <modifier></modifier>
                                    <type>std::string  </type>
                                    <methodname>getUnits</methodname>
                                    <void />
                                    <modifier></modifier>
                                </methodsynopsis>
                            </term>
                            <listitem>
                                <para>
                                    Returns the units of measure associated
                                    with the variable.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <methodsynopsis>
                                    <modifier></modifier>
                                    <type>bool    </type>
                                    <methodname>valueChanged</methodname>
                                    <void />
                                    <modifier></modifier>
                                </methodsynopsis>
                            </term>
                            <listitem>
                                <para>
                                    Returns <literal>true</literal> if the
                                    value of the object was changed either since
                                    it was constructed or since the flag
                                    that keeps track of this was last reset.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                    <para>
                        These methods perform actions on the object:
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term>
                                <methodsynopsis>
                                    <modifier></modifier>
                                    <type>void    </type>
                                    <methodname>setUnits</methodname>
                                    <methodparam>
                                       <modifier></modifier>
                                       <type>std::string </type><parameter>units</parameter>
                                    </methodparam>
                                    <modifier></modifier>
                                </methodsynopsis>
                            </term>
                            <listitem>
                                <para>
                                    Sets the units of measure for the object
                                    to <parameter>units</parameter>.  This
                                    also sets the definition modified flag
                                    to <literal>true</literal>.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <methodsynopsis>
                                    <modifier></modifier>
                                    <type>void    </type>
                                    <methodname>resetDefinitionChanged</methodname>
                                    <void />
                                    <modifier></modifier>
                                </methodsynopsis>
                            </term>
                            <listitem>
                                <para>
                                    Resest the definition changed flag to
                                    <literal>false</literal>.
                                    Normally this is done after finding the
                                    flag was <literal>true</literal> and
                                    taking appropriate action.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <methodsynopsis>
                                    <modifier></modifier>
                                    <type>void    </type>
                                    <methodname>fireTraces</methodname>
                                    <void />
                                    <modifier></modifier>
                                </methodsynopsis>
                            </term>
                            <listitem>
                                <para>
                                    Calls <function>Tcl_UpdateLinkedVar</function>
                                    to ensure the Tcl variable is updated and traces are fired.
                                    for that variable.  This is necessary after
                                    changes have been made to the value and the
                                    variable is quiescent again.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <methodsynopsis>
                                    <modifier></modifier>
                                    <type>void    </type>
                                    <methodname>Link</methodname>
                                    <methodparam>
                                       <modifier></modifier>
                                       <type>CTCLInterpreter&amp; </type><parameter>rInterp</parameter>
                                    </methodparam>
                                    <modifier></modifier>
                                </methodsynopsis>
                            </term>
                            <listitem>
                                <para>
                                    Actually links the data in this object
                                    to the Tcl variable of the same name.  The
                                    current value of the variable is refreshed
                                    so that the Tcl variable is assured to be
                                    have the same value as the object's
                                    value prior to this method call.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                    
            </refsect1>
        </refentry>
        <refentry >
            <refmeta>
                <refentrytitle >CTreeVariableArray</refentrytitle>
                <manvolnum>3SpecTcl</manvolnum>
            </refmeta>
            
            <refnamediv>
                <refname>CTreeVariableArray</refname>
                <refpurpose>Container for an array of tree variables.</refpurpose>
            </refnamediv>
            
            <refsynopsisdiv>
                    <synopsis>
#include &lt;TreeParameter.h&gt;

class <classname>CTreeVariableArray</classname>
{
public:
  CTreeVariableArray();
  CTreeVariableArray(std::string baseName, double initialValue, 
		     std::string units, UInt_t size, int firstIndex = 0);
  CTreeVariableArray(const CTreeVariableArray&amp; rhs);
  
  void Initialize(std::string baseName, double initialValue, 
		  std::string units, UInt_t size, Int_t firstElement);

  CTreeVariable&amp; operator[](Int_t index);
  CTreeVariableArray&amp; operator=(const CTreeVariableArray&amp; rhs);
  
  UInt_t size();
  Int_t  firstIndex();
};
                    </synopsis>
            </refsynopsisdiv>
            
            <refsect1>
                <title>DESCRIPTION</title>
                <para>
                    Objects of type <classname>CTreeVariableName</classname>
                    are built to act programmatically like arrays of tree
                    parameters with identical definitions and a common base name.
                    Tree variables in a tree variable name are given names
                    of the form <replaceable>basename.n</replaceable>
                    where <replaceable>n</replaceable> is a multidigit
                    fixed length number.  
                </para>
                <para>
                    The number of digits is chosen so
                    that the largest index will fit.  The use of fixed
                    sized integers makes sorting with alphabetic keys work properly
                    for these indices. For example, a tree variable with 16
                    elements starting at element zero and with a base name
                    of tv, will have names <literal>tv.00</literal>,
                    <literal>tv.01</literal>... <literal>tv.15</literal>.
                </para>
                <para>
                    
                </para>
            </refsect1>
            
            <refsect1>
                <title>METHODS</title>
                <para>
                    The first set of methods we're going to document are
                    associated with construction and initialization.
                    A tree parameter array can be constructred in either one
                    or two steps. 
                </para>
                <para>
                    One step construction uses one of the parameterized constructors.
                    Two step construction uses the default constructor and
                    the special <methodname>Initialize</methodname> method.
                    <methodname>Initialize</methodname> should be invoked prior
                    to the completion of initialization so that the variables
                    are properly bound.  If this is not done, the variables
                    that make up the object will need to be bound manually
                    after <methodname>Initialize</methodname> has been
                    called.
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <constructorsynopsis>
                                <methodname>CTreeVariableArray</methodname>
                                <void />
                            </constructorsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Default constructor.  After this is called,
                                initialization must be completed by invoking
                                <methodname>Initialize</methodname>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <constructorsynopsis>
                                <methodname>CTreeVariableArray</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>baseName</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>initialValue</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>units</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>size</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>int </type><parameter>firstIndex</parameter>
                                   <initializer>0</initializer>
                                </methodparam>
                            </constructorsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Full one-step construction.  <parameter>baseName</parameter>
                                is the base name for the variables this creates.
                                <parameter>initialValue</parameter> is the value
                                initially given to all of the created variables.
                                <parameter>units</parameter> will be the units of measure.
                                The array will have <parameter>size</parameter>
                                elements and the first index will be
                                <parameter>firstIndex</parameter>.
                            </para>
                        </listitem>
                    </varlistentry>                  
                    <varlistentry>
                        <term>
                            <constructorsynopsis>
                                <methodname> CTreeVariableArray</methodname>
                                <methodparam>
                                   <modifier>const</modifier>
                                   <type> CTreeVariableArray&amp;</type><parameter> rhs</parameter>
                                </methodparam>
                            </constructorsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Copy construction creates a copy of the
                                array that can be used in pass by value
                                parmeters in function/method calls.
                                The <literal>const</literal>  The
                                copy is a copy in name only as the
                                resulting tree variables will be bound to the
                                same Tcl variables as the original.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void</type>
                                <methodname>Initialize</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>baseName</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>initialValue</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>units</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>size</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>int </type><parameter>firstIndex</parameter>
                                   <initializer>0</initializer>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Performs the second step in two phase initialization.
                                The first was performed by invoking the default
                                constructor.
                            </para>
                        </listitem>
                    </varlistentry>        
                </variablelist>
                <para>
                    The remaining methods are methods associated with the
                    ability to treat <classname>CTreeVariableArray</classname>
                    objects like arrays:
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeVariable&amp; </type>
                                <methodname>operator[]</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>Int_t </type><parameter>index</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                The indexing operator returns a reference to the
                                tree variable at the specified
                                <parameter>index</parameter>. Note again
                                that the object's initial index may be
                                non zero.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeVariableArray&amp; </type>
                                <methodname>operator=</methodname>
                                <methodparam>
                                   <modifier>const </modifier>
                                   <type>CTreeVariableArray&amp; </type><parameter>rhs</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Assigns to the object from
                                <parameter>rhs</parameter>.  Note that
                                because of how tree variables work, the left
                                and right hand sides of the assignment will
                                then refer to the same underlying tree variables
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>UInt_t </type>
                                <methodname>size</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the number of elements in the array.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>Int_t  </type>
                                <methodname>firstIndex</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the lowest legal index value for
                                the array.  This will be the
                                value of the
                                <parameter>firstIndex</parameter> parameter
                                to the costructor or the call to
                                <methodname>Initialize</methodname> or,
                                if the object was assignedvia
                                <methodname>operator=</methodname> the
                                number of elements in the right hand
                                side tree variable
                            </para>
                        </listitem>
                    </varlistentry>
      
  
  
                </variablelist>
            </refsect1>
        </refentry>
        
    </part>
    <part>
        <title>Tcl++ classes</title>
        <chapter>
            <title>
                Tcl++ classes
            </title>
            <para>
                The Tcl++ class library is an object oriented wrapper on
                libtcl, the Tcl API.  It can be used either as an application
                framework, to create new specialized interpreters (SpecTcl
                does this), or as a library for existing applications and
                extensions.
            </para>
            <para>
                This manual section (3tcl++) provides documentation for the
                classes in the library.  The main base classes are:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        <classname>CTCLInterpreter</classname> wraps an
                        interpreter with methods to manipulate it.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <classname>CTCLInterpreterObject</classname>
                        wraps a Tcl API object along with its interpreter
                        and the appropriate methods to manipulate it.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <classname>CTCLObject</classname> wraps a
                        <type>Tcl_Obj*</type> in an object oriented shell.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <classname>CTCLObjectProcessor</classname> wraps a
                        command processor that uses the
                        <type>Tcl_Obj</type> array interface.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <classname>CTCLProcessor</classname> wraps a
                        command processor that uses the old argc/argv
                        interface.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <classname>CTCLVariable</classname> wraps a Tcl
                        variable.  
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                Several other classes either extensions of theses or
                utility classes in their own right are defined.
            </para>
        </chapter>

<refentry id="manpage.CTCLInterpreter">
    <refmeta>
        <refentrytitle id='manpage.CTCLInterpreter.title'>CTCLInterpreter</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLInterpreter</refname>
        <refpurpose>
            Encapsulate a Tcl interpreter.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;TCLInterpreter.h&gt;

class CTCLInterpreter
{
public:
  CTCLInterpreter ();
  CTCLInterpreter (Tcl_Interp* am_pInterpreter  );

  Tcl_Interp* getInterpreter()
  std::string Eval (const char* pScript) ;
  std::string Eval(const CTCLString&amp; rScript);
  std::string Eval(const std::string&amp; rScript);
  std::string EvalFile (const char* pFilename)   ;
  std::string EvalFile(const CTCLString&amp; rFilename);
  std::string EvalFile(const std::string&amp; rFilename);

  std::string GlobalEval (const char* pScript)   ;
  std::string GlobalEval (const CTCLString&amp; rScript) ;
  std::string GlobalEval(const std::string&amp; rScript) ;

  std::string RecordAndEval (const char* pScript, Bool_t fEval=kfFALSE);
  std::string RecordAndEval(const CTCLString&amp; rScript,
                            Bool_t fEval=kfFALSE);
  std::string RecordAndEval(const std::string&amp; rScript,
                            Bool_t fEval = kfFALSE);

  std::string ExprString (const char* pExpression)   ;
  std::string ExprString(const CTCLString&amp; rExpr);
  std::string ExprString(const std::string&amp; rExpr);

  Long_t ExprLong (const char* pExpression)   ;
  Long_t ExprLong (std::string&amp; rExpression);
  Long_t ExprLong (const CTCLString&amp; rExpr);

  DFloat_t ExprDouble (const char* pExpression)   ;
  DFloat_t ExprDouble (const CTCLString&amp; rExpression);
  DFloat_t ExprDouble(const std::string&amp; rExpression);

  Bool_t ExprBoolean (const char*  pExpression)   ;
  Bool_t ExprBoolean (const CTCLString&amp; rExpression);
  Bool_t ExprBoolean(const std::string&amp; rExpression);

  std::string TildeSubst (const char* pFilename) const  ;
  std::string TildeSubst (const CTCLString&amp; rName) const;
  std::string TildeSubst (const std::string&amp; rName) const;
  std::string EvalFile (const char* pFilename)   ;
  std::string EvalFile(const CTCLString&amp; rFilename);
  std::string EvalFile(const std::string&amp; rFilename);

  std::string GlobalEval (const char* pScript)   ;
  std::string GlobalEval (const CTCLString&amp; rScript) ;
  std::string GlobalEval(const std::string&amp; rScript) ;

  std::string RecordAndEval (const char* pScript, Bool_t fEval=kfFALSE);
  std::string RecordAndEval(const CTCLString&amp; rScript,
                            Bool_t fEval=kfFALSE);
  std::string RecordAndEval(const std::string&amp; rScript,
                            Bool_t fEval = kfFALSE);

  std::string ExprString (const char* pExpression)   ;
  std::string ExprString(const CTCLString&amp; rExpr);
  std::string ExprString(const std::string&amp; rExpr);

  Long_t ExprLong (const char* pExpression)   ;
  Long_t ExprLong (std::string&amp; rExpression);
  Long_t ExprLong (const CTCLString&amp; rExpr);

  DFloat_t ExprDouble (const char* pExpression)   ;
  DFloat_t ExprDouble (const CTCLString&amp; rExpression);
  DFloat_t ExprDouble(const std::string&amp; rExpression);

  Bool_t ExprBoolean (const char*  pExpression)   ;
  Bool_t ExprBoolean (const CTCLString&amp; rExpression);
  Bool_t ExprBoolean(const std::string&amp; rExpression);

  std::string TildeSubst (const char* pFilename) const  ;
  std::string TildeSubst (const CTCLString&amp; rName) const;
  std::string TildeSubst (const std::string&amp; rName) const;
  Tcl_Interp* operator-&gt; ();
  operator Tcl_Interp* ();
  
  
  void setResult(const char* resultString);
  void setResult(std::string resultString);
  void setResult(Tcl_Obj*    resultObj);
  void setResult(CTCLObject&amp; resultObj);

};



    </programlisting>
    </refsynopsisdiv>


    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <classname>CTCLInterpreter</classname>
            encapsulates a <type>Tcl_Interp*</type> in an object.
            Method invocations on that object provide access to many of the
            Tcl interpreter. See METHODS below for more information about htis.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            <function>CTCLInterpreter () </function>
        </para>
        <para>
            <function>CTCLInterpreter</function> (
                <type>Tcl_Interp</type>* <parameter>pInterp</parameter>)
        </para>
        <para>
            Constructs an interpreter object.  The first form of this
            constructor creates a new <type>Tcl_Interp*</type> using
            <function>Tcl_CreateInterp()</function> and wraps the object
            around it.  All members of the object will operate on that
            newly created interpreter.  The second form, wraps an object
            around <parameter>pInterp</parameter>,
            a previously created <type>Tcl_Interp*</type>.
            Note that in either case on destruction, <function>Tcl_DeleteInterp()</function>
            is called on the wrapped interpreter.
        </para>
        <para>
            <type>Tcl_Interp</type>* <function>getInterpreter</function>()
        </para>
        <para>
            Returns the interpreter that is being wrapped by this object.
            This interpreter can be used as an <parameter>interp</parameter>
            parameter for any <function>Tcl_xxxxxx</function> call in the Tcl
            API.
        </para>
        <para>
            <programlisting>
<type>std::string</type> <function>Eval</function>(<type>const char</type>* <parameter>pScript</parameter>) ;
<type>std::string</type> <function>Eval</function>(<type>const CTCLString</type>&amp; <parameter>rScript</parameter>);
<type>std::string</type> <function>Eval</function>(<type>const std::string</type>&amp; <parameter>rScript</parameter>);
            </programlisting>
        </para>
        <para>
            Evaluates the script passed as a parameter.  The only differences between
            these functions is the form of the script parameter.  Each function will
            return the result of the script.  If there is an error in the script,
            a <classname>CTCLException</classname> will be thrown that will describe
            what happened.  For example:
            <programlisting>
    std::string commands;
    CTCLInterpreter interp;     // New intepreter.
    ...
    // after commands has been built up:

    string result
    try {
        result = interp.Eval(commands);
        cout &lt;&lt; "Eval of " &lt;&lt; commands &lt;&lt; " was "
             &lt;&lt;  result &lt;&lt; endl;
    }
    catch (CTCLException &amp;e) {
        cerr &lt;&lt; "Eval of " &lt;&lt; commands &lt;&lt; " failed: "
             &lt;&lt; e.ReasonText() &lt;&lt; endl;
    }
    // If no exception, result is usable as the output of the eval.

            </programlisting>
        </para>
        <para>
        <programlisting>
  <type>std::string</type> <function>EvalFile</function>(<type>const char</type>* <parameter>pFilename</parameter>)   ;
  <type>std::string</type> <function>EvalFile</function>(<type>const CTCLString</type>&amp; <parameter>rFilename</parameter>);
  <type>std::string</type> <function>EvalFile</function>(<type>const std::string</type>&amp; <parameter>rFilename</parameter>);
        </programlisting>
        </para>
        <para>
            Sources the specified file in and executes it as a script in the interpreter that
            is wrapped by the object.  The only difference between these functions is
            how the name of the file is passed.  The return value is the script result.
            A <classname>CTCLException</classname> will be thrown in the event the script
            reports an error.  See the example in
            <classname>CTCLInterpreter</classname>::<function>Eval</function>
            to see how to catch and report this kind of exception.
        </para>
        <para>
            <programlisting>
  <type>std::string</type> <function>GlobalEval</function>(<type>const char</type>* <parameter>pScript</parameter>);
  <type>std::string</type> <function>GlobalEval</function>(<type>const CTCLString</type>&amp; <parameter>rScript</parameter>);
  <type>std::string</type> <function>GlobalEval</function>(<type>const std::string</type>&amp; <parameter>rScript</parameter>);
            </programlisting>
        </para>
        <para>
            This function evaluates a script at the global level.  Note that
            <classname>CTCLInterpreter</classname>::<function>Eval</function>,
            and <classname>CTCLInterpreter></classname>::<function>EvalFile</function>
            evaluates the script at whatever call level the interpreter is currently
            executing at.
            The only difference between the methods above is how the script is passed.
            The functions all return the interpreter result after the script executes.
            If the script reports an error, a <classname>CTCLException</classname> will
            be thrown.
        </para>
        <para>
            <programlisting>
  <type>std::string</type> <function>RecordAndEval</function> (<type>const char</type>* <parameter>pScript</parameter>,
                       <type>Bool_t</type> <parameter>fEval</parameter>=<literal>kfFALSE</literal>);
  <type>std::string</type> <function>RecordAndEval</function>(<type>const CTCLString</type>&amp; <parameter>rScript</parameter>,
                       <type>Bool_t</type> <parameter>fEval</parameter>=<literal>kfFALSE</literal>);
  <type>std::string</type> <function>RecordAndEval</function>(<type>const std::string</type>&amp; <parameter>rScript</parameter>,
                      <type>Bool_t</type> <parameter>fEval</parameter>=<literal>kfFALSE</literal>);
            </programlisting>
        </para>
        <para>
            Records a script in the Tcl interpreter history and, if <parameter>fEval</parameter>
            is <literal>kfTRUE</literal>, evaluates it as well.  The
            return value is the interpreter result, which is only meaningful if the
            script was evalutated.  If the script reports an error, a
            <classname>CTCLException</classname> is thrown.
        </para>
        <para>
            <programlisting>
  <type>std::string</type> <function>ExprString</function>(<type>const char</type>* <parameter>pExpression</parameter>);
  <type>std::string</type> <function>ExprString</function>(<type>const CTCLString</type>&amp; <parameter>rExpr</parameter>);
  <type>std::string</type> <function>ExprString</function>(<type>const std::string</type>&amp; <parameter>rExpr</parameter>);
            </programlisting>
        </para>
        <para>
            Evaluates an expression (as if with the <command>expr</command>
            Tcl command), and returns the result
            of the evaluation as a string.  If the expression has an error,
            a <classname>CTCLException</classname> will be thrown.
            The only difference between these functions is how the expression is passed.
        </para>
        <para>
            <programlisting>
  <type>Long_t</type> <function>ExprLong</function>(<type>const char</type>* <parameter>pExpression</parameter>)   ;
  <type>Long_t</type> <function>ExprLong</function>(<type>std::string</type>&amp; <parameter>rExpression</parameter>);
  <type>Long_t</type> <function>ExprLong</function>(<type>const CTCLString</type>&amp; <parameter>rExpr</parameter>);
            </programlisting>
        </para>
        <para>
            Evaluates an expression (as if with the <command>expr</command>
            Tcl command).  If the result
            can be converted into an integer, it is returned as a <type>Long_t</type>.
            If the expression either cannot be converted to an integer (e.g. it's a non-numerical
            expression), or if the expression contains an error, a <classname>CTCLException</classname>
            will be
            thrown.
        </para>
        <para>
            <programlisting>
  <type>DFloat_t</type> <function>ExprDouble</function>(<type>const char</type>* <parameter>pExpression</parameter>)   ;
  <type>DFloat_t</type> <function>ExprDouble</function>(<type>const CTCLString</type>&amp; <parameter>rExpression</parameter>);
  <type>DFloat_t</type> <function>ExprDouble</function>(<type>const std::string</type>&amp; <parameter>rExpression</parameter>);
            </programlisting>
        </para>
        <para>
            Evaluates the parameter as an expression (as if with the <command>expr</command> Tcl command).
            If the result can be converted to a floating point value it is returned as
            the function value.  If not, or if there is an error in the expression,
            a <classname>CTCLException</classname> is thrown.
        </para>
        <para>
            <programlisting>
  <type>Bool_t</type> <function>ExprBoolean</function>(<type>const char</type>*  <parameter>pExpression</parameter>)   ;
  <type>Bool_t</type> <function>ExprBoolean</function>(<type>const CTCLString</type>&amp; <parameter>rExpression</parameter>);
  <type>Bool_t</type> <function>ExprBoolean</function>(<type>const std::string</type>&amp; <parameter>rExpression</parameter>);
            </programlisting>
        </para>
        <para>
            Evaluates the parameter as an expression (as if with the <command>expr</command>
            Tcl command).  If the result can be interpreted as a boolean, it is returned
            as the function value.  If not, or if there is an error in the expression,
            a <classname>CTCLException</classname> is thrown.
        </para>
        <para>
            <programlisting>
  <type>std::string</type> <function>TildeSubst</function>(<type>const char</type>* <parameter>pFilename</parameter>) const  ;
  <type>std::string</type> <function>TildeSubst</function>(<type>const CTCLString</type>&amp; <parameter>rName</parameter>) const;
  <type>std::string</type> <function>TildeSubst</function>(<type>const std::string</type>&amp; <parameter>rName</parameter>) const;
            </programlisting>
        </para>
        <para>
            Performs tilde substitution on its parameter.   Tilde substitution means that leading
            &#152; characters are expanded to the current user's home directory path, while
            a leading &#152; followed by a word that is a username will be expanded to the
            home directory path of that user.  The expanded value is returned.
            Note thatthe use of this member is deprecated as the underlying Tcl library
            function is also deprecated.
        </para>
        <para>
        <programlisting>
  <type>Tcl_Interp</type>* <function>operator-&gt;</function>();
  <function>operator Tcl_Interp* </function>();
        </programlisting>
        </para>
        <para>
            These two functions allow objects that are <classname>CTCLInterpreter</classname>
            objects to be treated as if they were <type>Tcl_Interp*</type>'s.
            <function>operator-&gt;</function> supports dereferncing to fields of the
            wrapped interpreter (note that this is now deprecated within Tcl itself).
            <function>operator Tcl_Interp*</function> supports dynamic type conversion from
            a <classname>CTCLInterpreteter</classname> object and a <type>Tcl_Interp*</type>
            pointer.
        </para>
        <programlisting>
  <type>void</type>
  <function>setResult</function>(<type>const char*</type> <parameter>resultString</parameter>)            
  <type>void</type>
  <function>setResult</function>(<type>std::string</type> <parameter>resultString</parameter>);
  <type>void</type>
  <function>setResult</function>(<type>Tcl_Obj*</type>    <parameter>resultObj</parameter>);
  <type>void</type>
  <function>setResult</function>(<type>CTCLObject&amp;</type> <parameter>resultObj</parameter>);
        </programlisting>
        <para>
            This set of overloaded methods sets the result of the interpreter.
            The result is the value returned by a command on success or an
            error message on failure.
        </para>
    </refsect1>
    <refsect1>
        <title>DEFECTS</title>
        <para>
            It is not possible to avoid destroying the interpreter when the
            object is destroyed.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
        CTCLException, CTCLApplication, CTCLChannel, CTCLCommandPackage,
        CTCLFileHandler, CTCLList, CTCLObject, CTCLObjectProcessor, CTCLTimer,
        CTCLVariable
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLInterpreterObject">
    <refmeta>
        <refentrytitle>CTCLInterpreterObject </refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLInterpreterObject</refname>
        <refpurpose>
            Base class for objects that are associated with a Tcl Interpreter.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <programlisting>
#include &lt;CTCLInterpreterObject.h&gt;
...
class CTCLInterpreterObject
{
public:
  CTCLInterpreterObject ();
  CTCLInterpreterObject (CTCLInterpreter* pInterp );
  CTCLInterpreterObject (const CTCLInterpreterObject&amp; src );

  CTCLInterpreterObject&amp; operator=
                        (const CTCLInterpreterObject&amp; rhs);
  int operator== (const CTCLInterpreterObject&amp; rhs) const;


  CTCLInterpreter* getInterpreter() const;
  CTCLInterpreter* Bind (CTCLInterpreter&amp; rBinding);
  CTCLInterpreter* Bind (CTCLInterpreter* pBinding);

};


        </programlisting>

    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <classname>CTCLInterpreterObject</classname>
            is a base class for any object that requires a <type>CTCLInterpreter</type>
            (Tcl interpreter) to operate.  Almost  all objects in the Tcl++ library are
            derived from this base class.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            <function>CTCLInterpreterObject()</function>
        </para>
        <para>
            Constructor for an interpreter object that will be bound to an underlying
            interpreter at a later time.  See the <function>Bind</function> functions
            for more information about binding interpreters. More normally, if you
            already have an interpreter you will construct using that interpreter.
        </para>
        <para>
            <function>CTCLInterpreterObject</function>
                       (<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>)
        </para>
        <para>
            Constructs a <classname>CTCLInterpreterObject</classname> given
            that <parameter>pInterp</parameter> is an existing
            interpreter encapsulated in a <classname>CTCLInterpreter</classname>.
        </para>
        <para>
            <function>CTCLInterpreterObject</function>
                    (<type>const CTCLObject</type>&amp; <parameter>src</parameter>)
        </para>
        <para>
            Constructs a new <classname>CTCLInterpreterObject</classname>
            that is an exact copy of <parameter>src</parameter>.
        </para>
        <para>
            <classname>CTCLInterpreterObject</classname>&amp;
            <function>operator=</function>
                (const <type>CTCLInterpreterObjectd</type>&amp; <parameter>rhs</parameter>)
        </para>
        <para>
            Provides a mechanism for assigning a <classname>CTCLInterpreterObject</classname>
            a copy of the <parameter>rhs</parameter> <classname>CTCLInterpreterObject</classname>.
            The return value is just a reference to the left hand side of the assignment.  This
            permits operator chaining.
        </para>
        <para>
            <type>int</type> <function>operator==</function>(
                            const <type>CTCLInterpreterObject</type>&amp; rhs)
        </para>
        <para>
            Compares a <classname>CTCLInterpreterObject</classname> to another
            (<parameter>rhs</parameter>).  If the underlying interpreters are the
            same, the objects are said to be equal and <literal>1</literal> is
            returned.  If not, <literal>0</literal> is returned.
        </para>
        <para>
            <type>CTCLInterpreter</type>* <function>getInterpreter</function>() const
        </para>
        <para>
            Returns a pointer to the underlying <classname>CTCLInterpreter</classname>
            object.  See the <classname>CTCLInterpreter</classname>(3) manpage for
            more information about the services offered by that class.
        </para>
        <para>
            <type>CTCLInterpreter</type>* <function>Bind</function>(
                        <type>CTCLInterpreter</type>&amp; <parameter>rBinding</parameter>
                                                          )
        </para>
        <para>
            <type>CTCLInterpeter</type>* <function>Bind</function>(
                        <type>CTCLInterpreter</type>* <parameter>pBinding</parameter>)
        </para>
        <para>
            Binds the object to a new interpreter.  Typically this will only be
            called when the object was constructed without an initial interpreter.
            This is because most objects really are related to some interpreter and cannot
            be willy-nilly rebound.  The return value is  a pointer to the
            <classname>CTCLInterpreter</classname> the object was previously
            bound to.  This will be <literal>NULL</literal> if the object was not
            initially bound.
        </para>
    </refsect1>
    <refsect1>
        <title>DEFECTS</title>
        <para>
            No <function>operator!=</function> was defined.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
        CTCLInterpreter, CTCLApplication, CTCLChannel, CTCLCommandPackage,
        CTCLFileHandler, CTCLList, CTCLObject, CTCLObjectProcessor, CTCLTimer,
        CTCLVariable
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLResult">
    <refmeta>
        <refentrytitle>CTCLResult</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLResult</refname>
        <refpurpose>
            Provide an object oriented interace to the Tcl interpreter result.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLResult.h&gt;
...
class CTCLResult  : public CTCLObject
{
  CTCLResult (CTCLInterpreter* pInterp, bool reset=true );
  CTCLResult (const CTCLResult&amp; aCTCLResult );
  virtual ~CTCLResult ( );

  CTCLResult&amp; operator= (const CTCLResult&amp; aCTCLResult);
  CTCLResult&amp; operator= (const char* rhs);
  CTCLResult&amp; operator=(std::string    rhs);

  int operator== (const CTCLResult&amp; aCTCLResult) ;
  int operator!= (const CTCLResult&amp; rhs);

  CTCLResult&amp; operator+= (const char* pString);
  CTCLResult&amp; operator+= (const std::string&amp; rString);

  void Clear ()  ;
  void AppendElement (const char* pString)  ;
  void AppendElement (const std::string&amp; rString);
  void commit() const;
  std::string getString();
};

    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Each Tcl command can return <firstterm>result string</firstterm>
            the result string can be used by subsequent commands in the event
            the command operated successfully, or by <command>catch</command>
            commands if the command failed.  <classname>CTCLResult</classname>
            provides an extension of the <classname>CTCLObject</classname>
            class that builds up a string which can then be comitted to the
            result.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
<function>CTCLResult</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
           <type>bool</type> <parameter>reset</parameter>=<literal>true</literal> );
<function>CTCLResult</function>(const <type>CTCLResult</type>&amp; <parameter>aCTCLResult</parameter>);
          </programlisting>
          </para>
          <para>
            Constructs a Tcl interpreter result string.  <parameter>pInterp</parameter> is the interpeter
            that will be associated with this result. <parameter>reset</parameter> controls
            whether or not the result string is reset when constructed, or if it is loaded
            with the current value of the result string.  In the case of copy construction,
            the interpreter associated with <parameter>aCTCLResult</parameter> is used.
            <parameter>aCTCLResult</parameter> is committed to the interpreter result, and
            the object under construction is then loaded from that interpreter's result.
          </para>
          <para>
          <programlisting>
  <type>CTCLResult</type>&amp; <function>operator=</function> (const <type>CTCLResult</type>&amp; <parameter>rhs</parameter>);
  <type>CTCLResult</type>&amp; <function>operator=</function> (const <type>char</type>* <parameter>rhs</parameter>);
  <type>CTCLResult</type>&amp; <function>operator=</function>(<type>std::string</type>    <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            Assigns a value to the result from <parameter>rhs</parameter>.
            If the <parameter>rhs</parameter> is a <classname>CTCLResult</classname>, then the
            <parameter>rhs</parameter> is first committed to its interpreter result,
            the left hand object is then bound to the same interpreter as <parameter>rhs</parameter>
            and loaded with the result string of that interpreter.
        </para>
        <para>
        <programlisting>
  <type>int</type> <function>operator==</function> (const <type>CTCLResult</type>&amp; <parameter>rhs</parameter>) ;
  <type>int</type> <function>operator!=</function> (const <type>CTCLResult</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            These functions suport comparison. Equality comparison is true
            (<function>operator==</function>) if the interpreters match as the assumption
            is that the user is working to maintain coherency if several <classname>CTCLResult</classname>
            objects are simultaneously live on a single interpreter.
            Inequality (<function>operator!=</function>) is defined as true when
            <function>operator==</function> is false.
        </para>
        <para>
        <programlisting>
<type>CTCLResult</type>&amp; <function>operator+=</function> (const <type>char</type>* <parameter>rhs</parameter>);
<type>CTCLResult</type>&amp; <function>operator+=</function>(const <type>std::string</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            <parameter>rhs</parameter> is textually appended to the result string being built
            up.   Note that the semantics of this are different than for the base class
            where <function>operator+=</function> is a list append.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>Clear</function>()  ;
          </programlisting>
          </para>
          <para>
            Clears the result string being built up as well as clearing the
            underlying interpreter's result.
          </para>
          <para>
          <programlisting>
  <type>void</type> <function>AppendElement</function>(const <type>char</type>* <parameter>item</parameter>)  ;
  <type>void</type> <function>AppendElement</function>(const <type>std::string</type>&amp; <parameter>item</parameter>);
          </programlisting>
          </para>
          <para>
            Appends <parameter>item</parameter> to the result string being built up as a
            list element.  This means that under some circumstances extra quoting may be
            done to ensure that the result will be maintained as a valid list.
          </para>
          <para>
          <programlisting>
  <type>void</type> <function>commit</function>() const;
  <type>std::string</type> <function>getString</function>();
        </programlisting>
        </para>
        <para>
            <function>commit</function> sets the interpreter result string equal
            to the string being built up in the object.  <function>getString</function>
            does a commit and then returns the string.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLObject(3)
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLException">
    <refmeta>
        <refentrytitle>CTCLException</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLException</refname>
        <refpurpose>
            Class for reporting exceptional conditions in Tcl applications
            via the C++ try/catch mechanism.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLException.h&gt;
...
class CTCLException  : public CTCLInterpreterObject ,public CException
{
public:
  CTCLException (CTCLInterpreter&amp; am_rInterpreter,
                 Int_t am_nReason,
                 const char* pString);
  CTCLException(CTCLInterpreter&amp; am_rInterpreter,
                Int_t am_nReason,
                const std::string&amp; rString);
  CTCLException (const CTCLException&amp; aCTCLException );
  virtual ~CTCLException ( );

  CTCLException operator= (const CTCLException&amp; aCTCLException);
  int operator== (const CTCLException&amp; aCTCLException);

  void AddErrorInfo (const char* pMessage)  ;
  void AddErrorInfo(const std::string&amp; rMessage);
  void AddErrorInfo(const CTCLString&amp; rMessage);

  void SetErrorCode (const char* pMessage,
                     const char* pMnemonic="???",
                     const char* pFacility="TCL",
                     const char* pSeverity="FATAL")  ;
  void SetErrorCode(const std::string rMessage,
                    const std::string &amp;rMnemonic=std::string("???"),
                    const std::string &amp;rFacility=std::string("TCL"),
                    const std::string &amp;rSeverity=std::string("FATAL"));

  virtual   const char* ReasonText () const;
  virtual   Int_t ReasonCode () const  ;
};

    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The <classname>CTCLException</classname> class allows you to
            instantiate and throw exceptions that are distinguishable as coming
            from the TCL library and its extensions.   In most cases the
            TclPlus library itself will convert error conditions detected by the
            Tcl API and intantiate and throw an appropriate exception.
        </para>
        <para>
            The following example shows how to execute code that is aware of
            these exceptions.  In this case, the code just reports the error
            message and continues.
            <informalexample>
            <programlisting>
    try {
        // In here is TclPlus invoking code.
    }
    catch (CTCLException&amp; e) {
        cerr &lt;&lt; "TclPlus error caught: " &lt;&lt; e.ReasonText() &lt;&lt; endl;
    }
            </programlisting>
            </informalexample>
        </para>
        <para>
            The following example shows a typical code segment that throws a
            <classname>CTCLException</classname>:
                <programlisting>
    int status = Tcl_xxxxxxx(pInterp-&gt;getInterpreter()....); // Some Tcl call.
    if (status != TCL_OK) {
        throw CTCLException(*pInterp, status,
                            "Call to Tcl_xxxxxx returned an error");
    }
                </programlisting>
        </para>
        <para>
            Note that constructing a <classname>CTCLException</classname> object
            incorporates the Tcl result string at the time into the
            text returned by the <function>ReasonText()</function> member function.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
  <function>CTCLException</function> (<type>CTCLInterpreter</type>&amp; <parameter>rInterpreter</parameter>,
                 <type>Int_t</type> <parameter>nReason</parameter>,
                 const <type>char</type>* <parameter>pString</parameter>);
  <function>CTCLException</function>(<type>CTCLInterpreter</type>&amp; <parameter>rInterpreter</parameter>,
                <type>Int_t</type> <parameter>nReason</parameter>,
                const <type>std::string</type>&amp; <parameter>rString</parameter>);
  <function>CTCLException</function> (const <type>CTCLException</type>&amp; <parameter>aCTCLException</parameter> );
        </programlisting>
        </para>
        <para>
            These construct a <classname>CTCLException</classname>.
            <parameter>rInterpreter</parameter> is a reference to the intepreter that was
            used in the operation that resulted in the error.  The result string of that
            interpreter will be saved as part of the text returned by the
            <function>ReasonText</function> member function.
        </para>
        <para>
            The <parameter>nReason</parameter> is a reason for the exception.  Typically
            this will be <literal>TCL_ERROR</literal> however other error codes can be
            created and used for application specific problems.  This is the value that will
            be returned by the <function>ReasonCode</function> member function.
        </para>
        <para>
            <parameter>rString</parameter> and <parameter>pString</parameter> are intended to provide
            information about the context of the error, and will be incorporated into the
            text strin greturned from <function>ReasonText</function>.
        </para>
        <para>
            <parameter>aCTCLException</parameter> is a reference for the sourc object of
            the copy constructor.
        </para>
        <para>
        <programlisting>
  <type>CTCLException</type> <function>operator=</function> (const <type>CTCLException</type>&amp; <parameter>rhs</parameter>);
  <type>int</type> <function>operator==</function>(const <type>CTCLException</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            These two functions provide a mechanism to assign exceptions and to compare
            them for equality.  <parameter>rhs</parameter> is the object that is the source
            of the assignment or the object to which <varname>this</varname> is being compared.
            Equality is defined as the two exceptions having the same underlying interpreter,
            and same reason text.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>AddErrorInfo</function> (const <type>char</type>* <parameter>pMessage</parameter>)  ;
  <type>void</type> <function>AddErrorInfo</function>(const <type>std::string</type>&amp; <parameter>rMessage</parameter>);
  <type>void</type> <function>AddErrorInfo</function>(const <type>CTCLString</type>&amp; <parameter>rMessage</parameter>);
        </programlisting>
        </para>
        <para>
            These functions are wrapperf ro the API function <function>Tcl_AddErrorInfo</function>
            the <parameter>pMessage</parameter>, and <parameter>rMessage</parameter>
            parameters provide the message that is added to the <parameter>errorInfo</parameter>
            variable.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>SetErrorCode</function> (const <type>char</type>* <parameter>pMessage,</parameter>
                     const <type>char</type>* <parameter>pMnemonic</parameter>=<literal>"???"</literal>,
                     const <type>char</type>* <parameter>pFacility</parameter>=<literal>"TCL"</literal>,
                     const <type>char</type>* <parameter>pSeverity</parameter>=<literal>"FATAL"</literal>)  ;
  <type>void</type> <function>SetErrorCode</function>(const <type>std::string</type> <parameter>rMessage</parameter>,
                    const <type>std::string</type>&amp; <parameter>rMnemonic</parameter>=<type>std::string</type>(<literal>"???"</literal>),
                    const <type>std::string</type>&amp; <parameter>rFacility</parameter>=<type>std::string</type>(<literal>"TCL"</literal>),
                    const <type>std::string</type>&amp; <parameter>rSeverity</parameter>=<type>std::string</type>(<literal>"FATAL</literal>"));
        </programlisting>
        </para>
        <para>
            These function set the <varname>errorCode</varname> Tcl interpreter variable.
            The convention these function support is to set the error code to a list that
            consists of a message (<parameter>pMessage</parameter> and <parameter>rMessage</parameter>,
            mnemonic for the message (<parameter>pMnemonic</parameter> or <parameter>rMnemonic</parameter>, the
            Facility (<parameter>pFacility</parameter> or <parameter>rFacility</parameter>)that is throwing
            the error and the severity (<parameter>pSeverity</parameter> or <parameter>rSeverity</parameter>)
            of the error.
        </para>
        <para>
            <programlisting>
virtual   const <type>char</type>* <function>ReasonText</function> () const;
virtual   <type>Int_t</type> <function>ReasonCode</function> () const  ;
        </programlisting>
        </para>
        <para>
            These two functions are intended for use by exception catch blocks.
            <function>ReasonText</function> provides human readable text that
            describes the exception.  <function>ReasonCode</function> provides a
            numerical code that describes the exception.  Often this just has the
            value <literal>TCL_ERROR</literal>
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
Tcl_AddErrorInfo(3tcl),
Tcl_SetErrorCode(3tcl)
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLObjectProcessor">
    <refmeta>
        <refentrytitle>CTCLObjectProcessor</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLObjectProcessor</refname>
        <refpurpose>
            Abstract base class to encapsulate the Tcl object command interface exposed by
            <function>Tcl_CreateObjCommand</function>.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLObjectProcessor.h&gt;
...
class CTCLObjectProcessor : public CTCLInterpreterObject
{
public:
  CTCLObjectProcessor(CTCLInterpreter&amp; interp,
                      std::string      name,
                      bool             registerMe=true);
  virtual ~CTCLObjectProcessor();

  void Register();              // Register command on the interpreter.
  void unregister();            // Unregister command from the interp.
  std::string getName() const;  // Return the name of the object.
  Tcl_CmdInfo getInfo() const;  // Return info about the command.

protected:
  virtual int operator()(CTCLInterpreter&amp; interp,
                         std::vector&lt;CTCLObject&gt;&amp; objv) = 0;
  virtual void onUnregister();

protected:
  void bindAll(CTCLInterpreter&amp; interp, std::vector&lt;CTCLObject&gt;&amp; objv);
  void requireAtLeast(std::vector&gt;CTCLObject&lt;&amp; objv, unsigned n, const char* msg=0) const;
  void requireAtMost(std::vector&lt;CTCLObject&gt;&amp; objv, unsigned n, const char* msg=0) const;
  void requireExactly(std::vector&lt;CTCLObject&gt;&amp; objv, unsigned n, const char* msg=0) const;



};

    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Tcl supports the addition of commands to the interpreter.  <classname>CTCLObjectProcessor</classname>
            supports an object oriented encapsulation of this part of the API.
            To add a command to an interpreter, write a subclass of
            <classname>CTCLObjectProcessor</classname>.  This subclass should override
            <function>operator()</function>, and optionally <function>onUnregister</function>.
            to implement the desired behavior for the new command.
        </para>
        <para>
            Create an instance of this new class and invoke its
            <function>Register</function>
            member to add it to the interpreter onto which it is bound.  Whenever a
            script executes the new command that object's
            <function>operator()</function> is invoked to process the command.
            If the interpreter is destroyed, or if the command is ever unregistered,
            the <function>onUnregister</function> function is called to perform any
            required global cleanup.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
<function>CTCLObjectProcessor</function>(<type>CTCLInterpreter</type>&amp; <parameter>interp</parameter>,
                    <type>std::string</type>      <parameter>name</parameter>,
                    <type>bool</type>             <parameter>registerMe</parameter>=<literal>true</literal>);

        </programlisting>
        </para>
        <para>
            Constructs a new command processor.  <parameter>interp</parameter> is the
            interpreter on which the command will be registered when the
            <function>Register</function> member is invoked.
            <parameter>name</parameter> is the name of the command.
            If <parameter>registerMe</parameter> is not supplied or is supplied but is
            <literal>true</literal>, the command will be registered as part of the construction process.
            If <parameter>registerMe</parameter> is supplied and is <literal>false</literal>,
            the command is not immediately added, and <function>Register</function> must
            be called later to incorporate it into the interpreter.
        </para>
        <para>
        <programlisting>
<type>void</type> <function>Register</function>();
<type>void</type> <function>unregister</function>();
        </programlisting>
        </para>
        <para>
            <function>Register</function> incorporates the command into the
            interpreter.  If the command is already registered, a
            <classname>CStateException</classname> is thrown.
        </para>
        <para>
            <function>unRegister</function> removes the command from the interpreter.
            This causes <function>onUnregister</function> to be called.
            if the command is registered at destruction time, destruction implies a call
            to <function>unRegister</function> (and therefore <function>onUnregister</function>).
        </para>
        <para>
        <programlisting>
<type>std::string</type> <function>getName</function>() const;
<type>Tcl_CmdInfo</type> <function>getInfo</function>() const;
        </programlisting>
        </para>
        <para>
            <function>getName</function> returns the name of the command
            that will invoke this object's <function>operator()</function>.
            If the command has been registered, and subsequently renamed at the
            script level, this function will reflect the rename.
        </para>
        <para>
            <function>getInfo</function> returns information about the command
            see <function>Tcl_GetCommandInfo</function> for more information about
            what is returned and what it means.
        </para>
        <para>
        <programlisting>
virtual <type>int</type> <function>operator()</function>(<type>CTCLInterpreter</type>&amp; <parameter>interp</parameter>,
                       <type>std::vector&lt;CTCLObject&gt;</type>&amp; <parameter>objv</parameter>) = 0;
        </programlisting>
        </para>
        <para>
            This pure virtual function must be overridden in concrete object command processors.
            The function is called to execute the command that this object is performing.
            <parameter>interp</parameter> provides a reference to the interpreter on which
            the command is being run. <parameter>objv</parameter> is a reference to a
            <type>std::vector&lt;CTCLObject&gt;</type>.
            Each element of <parameter>objv</parameter> is a <classname>CTCLObject</classname>
            containing a word of the command line that invoked us.
        </para>
        <para>
            The function should return <literal>TCL_OK</literal> on success and
            <literal>TCL_ERROR</literal> on failure.  Other return values are possible
            for e.g. commands that implement new control structures however this is beyond
            the scope of this manpage.  If the command processor wants to make a result
            available to the interpreter, it can create a <classname>CTCLResult</classname>
            object, fill it in and commit it.
        </para>
        <para>
        <programlisting>
virtual void onUnregister();
        </programlisting>
        </para>
        <para>
            This function is called when the interpreter is being destroyed or if the
            command is being unregistered either due to object destruction or a call to
            <function>unregister</function>.  The default behavior is to do nothing, but
            this can be overidden in your derived class if desired.
        </para>
        <programlisting>
void bindAll(CTCLInterpreter&amp; interp, std::vector&lt;CTCLObject&gt;&amp; objv);            
        </programlisting>
        <para>
            This is a convenience method for derived classes.  It binds the
            interpreter to all of the elements of the
            <parameter>objv</parameter> vector.  Several of the methods of
            <classname>CTCLObject</classname> require that an interpreter
            be bound.
        </para>
        <programlisting>
void requireAtLeast(std::vector&gt;CTCLObject&lt;&amp; objv, unsigned n, const char* msg=0) const;            
        </programlisting>
        <para>
            Utility method.  Throws an <classname>std::string</classname>
            exception if the <parameter>objv</parameter> vector does
            not have at least <parameter>n</parameter> elements.
            If <parameter>msg</parameter> is provided (non Null pointer),
            that string is incorporated in the exception string.
        </para>
        <programlisting>
void requireAtMost(std::vector&lt;CTCLObject&gt;&amp; objv, unsigned n, const char* msg=0) const;            
        </programlisting>
        <para>
            If <parameter>objv</parameter> has more than
            <parameter>n</parameter> elements, an
            <classname>std::string</classname> exception is thrown.  If
            <parameter>msg</parameter> is provided (not a null
            pointer) it is incorprorated into the exception string.
        </para>
        <programlisting>
void requireExactly(std::vector&lt;CTCLObject&gt;&amp; objv, unsigned n, const char* msg=0) const;            
        </programlisting>
        <para>
            If the <parameter>objv</parameter> vector does not have exactly
            <parameter>n</parameter> elements, an <classname>std::string</classname>
            exception is thrown.  If <parameter>msg</parameter> is supplied
            (not a null pointer), the exception string will incorporate it.
            
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLCompatibilityProcessor(3),
CTCLInterpreter(3),
CTCLInterpreterObject(3),
CTCLObject(3),
CTCLProcessor(3),
CTCLResult(3),
Tcl_CreateObjCommand(3tcl),
Tcl_GetCommandInfo(3tcl)
        </para>
    </refsect1>
</refentry>
<refentry id="manpage.CTCLProcessor">
    <refmeta>
        <refentrytitle>CTCLProcessor</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLProcessor</refname>
        <refpurpose>
            Provide <parameter>argc</parameter>, <parameter>argv</parameter>
            extension commands to Tcl.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLProcessor.h&gt;
...
class CTCLProcessor : public CTCLInterpreterObject
{
public:
  CTCLProcessor(const std::string sCommand, CTCLInterpreter* pInterp);
  CTCLProcessor(const char*       pCommand, CTCLInterpreter* pInterp);
  virtual ~CTCLProcessor();

  std::string getCommandName() const;

  virtual int operator()(CTCLInterpreter&amp; rInterpreter,
                         CTCLResult&amp;      rResult,
                         int argc, char** argv) = 0;
  virtual void OnDelete();

  void Register();
  void Unregister();

  static  std::string ConcatenateParameters (int nArguments,
                                              char* pArguments[])  ;
  int ParseInt (const char* pString, int* pInteger)  ;
  int ParseInt (const std::string&amp; rString, int* pInteger)

  int ParseDouble (const char* pString, double* pDouble)  ;
  int ParseDouble (const std::string&amp; rString, double* pDouble)

  int ParseBoolean (const char* pString, Bool_t* pBoolean)  ;
  int ParseBoolean (const std::string&amp; rString, Bool_t* pBoolean)

  static int MatchKeyword(std::vector&lt;std::string&gt;&amp; MatchTable,
                          const std::string&amp; rValue,
                          int NoMatch = -1);


};

    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <parameter>Do not use this for new commands</parameter>.  Use
            <classname>CTCLObjectProcessor</classname> instead.
        </para>
        <para>
            The <classname>CTCLProcessor</classname> provides a compatibility
            interface to the old Tcl style <parameter>argc</parameter>,
            <parameter>argv</parameter> style of command extension.
            New commands should be written using the
            <classname>CTCLObjectProcessor</classname> class instead.
        </para>
        <para>
            To extend the interpreter using this mechanism, you must
            derive a class from <classname>CTCLProcessor</classname> and
            minimally override and implement its
            <function>operator()</function> pure virtual function.  You may optionally
            overrid its <function>OnDelete</function> member as well.
            Having written the class, you must create an object of that class and
            register it on an interpreter.  Once the class is registered,
            invocations of the command under which it was registered will
            invoke your <function>operator()</function>.
        </para>
        <para>
            If the interpreter is destroyed or the object destroyed, or unregistered,
            the <function>OnDelete</function> member will be called.
            <classname>CTCLProcessor</classname> defines and implements this function
            with an empty body, so it is only necessary for you to override and implement
            this if you have some cleanup actions that must be done when the command is
            deleted.
        </para>
        <para>
            This class is now implemented in terms of a <classname>CTCLObjectProcessor</classname>
            derived class called a <classname>CTCLCompatibilityProcessor</classname>. It is
            less efficient to use this class than to use a class derived directly from a
            <classname>CTCLObjectProcessor</classname>.  This class is therefore not
            recommended for use with new extensions, but is only provided for
            compatibility with existing extensions written before
            <classname>CTCLObjectProcessor</classname> was developed.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
<function>CTCLProcessor</function>(const <type>std::string</type> <command>sCommand</command>,
             <type>CTCLInterpreter</type>* <parameter>pInterp</parameter>);
<function>CTCLProcessor</function>(const <type>char</type>*       <parameter>pCommand</parameter>,
             <type>CTCLInterpreter</type>* <parameter>pInterp</parameter>);
        </programlisting>
        </para>
        <para>
            Constructs a <classname>CTCLProcessor</classname>.  <parameter>sCommand</parameter>
            or <parameter>pCommand</parameter> are the initial name of the command.
            Note that the Tcl interpreter supports command renaming at the script level,
            so there is no gaurentee that this will always be the name of the command.
            <parameter>pInterp</parameter> is the interpreter on which the command
            will be registered when the <function>Register</function> function is called.
        </para>
        <para>
        <programlisting>

<type>std::string</type> <function>getCommandName</function>() const;
        </programlisting>
        </para>
        <para>
            Returns the initial name of the command.  Unlike
            <classname>CTCLObjectCommand</classname>::<function>getName</function>()
            this function does not track changes in the command name.
        </para>
        <para>
        <programlisting>

virtual <type>int</type> <function>operator</function>()(<type>CTCLInterpreter</type>&amp; <parameter>rInterpreter</parameter>,
                       <type>CTCLResult</type>&amp; <parameter>rResult</parameter>,
                       <type>int</type> <parameter>argc</parameter>,
                       <type>char</type>** <parameter>argv</parameter>) = 0;
virtual <type>void</type> <function>OnDelete</function>();
        </programlisting>
        </para>
        <para>
            <function>operator()</function> is a pure virtual function and therefore must
            be overidden and implemented in concrete command implementations.
            <parameter>rInterpreter</parameter> is a reference to the interpreter that is
            executing this command. <parameter>rResult</parameter> is a reference to
            a <classname>CTCLResult</classname> object that represents the result of the
            interpreter.  Any text stored into this object will be made available to the
            interpreter as the result of the command. <parameter>argc</parameter>
            and <parameter>argv</parameter> are the number of words on the command line and
            a pointer to an array of pointers to the command words respectively.
        </para>
        <para>
            <function>operator()</function> should be written to return
            <literal>TCL_OK</literal>
            if it is successful and
            <literal>TCL_ERROR</literal>
            if it encounters an error.   Other return values are possible and meaningful
            for commands that implement flow of control structures, but documenting these
            is beyond the scope of this manpage.   See the return(3tcl) manpage for
            more information about these.
        </para>
        <para>
            <function>OnDelete</function> is called whenever the interpreter
            or the object is being
            destroyed, or the object's <function>Unregister</function> function has been
            called.  <classname>CTCLProcessor</classname> provides a default implementation
            for <function>OnDelete</function> which does nothing.  It is only necessary
            to override and implement this function if you require specific action when
            the command is being unregistered.
        </para>
        <para>
        <programlisting>
<type>void</type> <function>Register</function>();
<type>void</type> <function>Unregister</function>();
        </programlisting>
        </para>
        <para>
            These functions register and unregister the command with the intepreter
            respectively.
        </para>
        <para>
        <programlisting>
static  <type>std::string</type> <function>ConcatenateParameters</function>(<type>int</type> <parameter>nArguments</parameter>,
                                           <type>char</type>* <parameter>pArguments</parameter>[])  ;
        </programlisting>
        </para>
        <para>
            Concatenates all of the <parameter>nArguments</parameter>
            words in the <parameter>pArguments</parameter> array into a <type>std::string</type>
            and returns it.  The words are space separated.
        </para>
        <para>
        <programlisting>
<type>int</type> <function>ParseInt</function>(const <type>char</type>* <parameter>pString</parameter>,
             <type>int</type>* <parameter>pInteger</parameter>)  ;
<type>int</type> <function>ParseInt</function>(const <type>std::string</type>&amp; <parameter>rString</parameter>,
             <type>int</type>* <parameter>pInteger</parameter>)
        </programlisting>
        </para>
        <para>
            Parses the character string <parameter>pString</parameter> or <parameter>rString</parameter>
            as a 32 bit signed integer into <parameter>pInteger</parameter>.  Returns
            <literal>TCL_OK</literal>
            if successful, or
            <literal>TCL_ERROR</literal>
            if the string coult no be parsed.  In that case, the result string
            of the interpreter will report why the string could not be parsed.
        </para>
        <para>
        <programlisting>
<type>int</type> <parameter>ParseDouble</parameter>(const <type>char</type>* <parameter>pString</parameter>,
                <type>double</type>* <parameter>pDouble</parameter>)  ;
<type>int</type> <function>ParseDouble</function>(const <type>std::string</type>&amp; <parameter>rString</parameter>,
                <type>double</type>* <parameter>pDouble</parameter>)
        </programlisting>
        </para>
        <para>
            Parses the input string, either <parameter>pString</parameter> or
            <parameter>rString</parameter>
            as a double precision floating point value, storing the result in the
            double pointed to by <parameter>pDouble</parameter>.
            On success,
            <literal>TCL_OK</literal>
            is returned.  On failure,
            <literal>TCL_ERROR</literal> and the interpreter result is
            a textual reason for the failure.
        </para>
        <para>
        <programlisting>
<type>int</type> <function>ParseBoolean</function>(const <type>char</type>* <parameter>pString</parameter>,
                 <type>Bool_t</type>* <parameter>pBoolean</parameter>)  ;
<type>int</type> <function>ParseBoolean</function>(const <type>std::string</type>&amp; <parameter>rString</parameter>,
                 <type>Bool_t</type>* <function>pBoolean</function>)
        </programlisting>
        </para>
        <para>
            Parses either <parameter>pString</parameter>
            or <parameter>rString</parameter> as a boolean value.  The result
            is stored in boolean pointed to by <parameter>pBoolean</parameter>.
            <literal>TCL_OK</literal>
            is returned on success,
            <literal>TCL_ERROR</literal>
            on error.  If <literal>TCL_ERROR</literal> was returned, the interpreter
            result is the textual reason for the failure.
        </para>
        <para>
        <programlisting>
static <type>int</type> <function>MatchKeyword</function>(<type>std::vector&lt;std::string&gt;</type>&amp; <parameter>MatchTable</parameter>,
                        const <type>std::string</type>&amp; <parameter>rValue</parameter>,
                        <type>int</type> <parameter>NoMatch</parameter> = <literal>-1</literal>);
        </programlisting>
        </para>
        <para>
            Searches for the string <parameter>rValue</parameter> in the vector of strings
            <parameter>MatchTable</parameter>, and returns the index in the vector at which
            the match occured.  If no match could be found, the value
            <parameter>NoMatch</parameter> is returned.
        </para>
        <para>
            Within SpecTcl, this is often used to match command switches.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLCompatibilityProcessor(3),
CTCLObjectProcessor(3),
CTCLPackagedCommand(3),
CTCLResult(3),
return(3tcl)
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLCompatibilityProcessor">
    <refmeta>
        <refentrytitle>CTCLCompatibiltyProcessor</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLCompatibilityProcessor</refname>
        <refpurpose>
            Adaptor between <classname>CTCLOjbectProcessor</classname>
            and <classname>CTCLProcessor</classname>.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLCompatibilityProcessor.h&gt;
...
class CTCLCompatibilityProcessor : public CTCLObjectProcessor
{

public:

  CTCLCompatibilityProcessor(CTCLProcessor&amp; actualCommand);
  virtual ~CTCLCompatibilityProcessor();

  virtual int operator()(CTCLInterpreter&amp; interp,
                         std::vector&lt;CTCLObject&gt;&amp; objv);
  virtual void onUnregister();
};

    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Note that the information on this page is only to be used to
            "grandfather" old <classname>CTCLProcessor</classname> objects
            into Tcl.  New command processors should be based on the
            CTCLObjectProcessor.
        </para>
        <para>
            A rewrite of the TCL++ library in March 2006 eliminated the use of
            Tcl functions that are scheduled to be deprecated in the known future
            of Tcl.    One set of functions scheduled for deprecation are those
            that revolve around direct access to the Tcl interpreter result, and
            command processors that use the <parameter>argc</parameter>,
            <parameter>argv</parameter> interfaces.
        </para>
        <para>
            Since a number of existing command extensions are, no doubt built on
            top of the <classname>CTCLProcessor</classname> <parameter>argc</parameter>
                                                            <parameter>argv</parameter>
            interface, a mechanism that allows the use of existing commands was built
            as well.
        </para>
        <para>
            The current implementation of a <classname>CTCLProcessor</classname> includes
            as member data a <classname>CTCLCompatibilityProcessor</classname> object.
            This object registers itself as a <classname>CTCLObjectProcessor</classname>
            for the command intended by the <classname>CTCLProcessor</classname> and
            serves as an adaptor between these two command types, marshalling command
            objects into an <parameter>argc</parameter>, <parameter>argv</parameter> pair,
            creating and committing a <classname>CTCLResult</classname> object.
        </para>
        <para>
            For most users of this library, this is completely transparent, this documentation
            is provided for completeness, however.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
<function>CTCLCompatibilityProcessor</function>(<type>CTCLProcessor</type>&amp; <parameter>actualCommand</parameter>);
        </programlisting>
        </para>
        <para>
            Constructs a  compatibility processor that adapts the object based command
            interface for <parameter>actualCommand</parameter>.  <parameter>actualCommand</parameter>
            must already be bound to an interpreter.
        </para>
        <para>
        <programlisting>
virtual <type>int</type> <function>operator()</function>(<type>CTCLInterpreter</type>&amp; <parameter>interp</parameter>,
                       <type>std::vector&lt;CTCLObject&gt;</type>&amp; <parameter>objv</parameter>);
        </programlisting>
        </para>
        <para>
            Called when the command is executed.  <parameter>objv</parameter> is marshalled
            into an argc, argv pair.  A <classname>CTCLResult</classname> is created and the
            actual command's <function>operator()</function> is called to execute the command.
            On return, the result is committed, and all dynamic storage released prior to
            returning the status from the command processor.
        </para>
        <para>
        <programlisting>
virtual <type>void</type> <function>onUnregister</function>();
        </programlisting>
        </para>
        <para>
            Called when the command is unregistered.  The actual command's <function>OnDelete</function>
            member is called.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLObject(3),
CTCLObjectProcessor(3),
CTCLProcessor(3),
CTCLResult(3),
        </para>
    </refsect1>
    <refsect1>
        <title>REFERENCES</title>
        <para>
            <programlisting>
Gamma, Helm, Johnson, Vlissides <parameter>Design Patterns Elements of Reusable
Object-Oriented Software</parameter>
Addison-Wesley Professional Computing Series 1995 ISBN 0-0201-63361-2
See Chapter 4 the Adapter pattern.
            </programlisting>
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLCommandPacakge">
    <refmeta>
        <refentrytitle>CTCLCommandPackage</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLCommandPackage</refname>
        <refpurpose>
            Group several related Tcl command extensions and common services they
            may require together.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLCommandPackage.h&gt;
...
typedef std::list &lt;CTCLProcessor*&gt;   CommandList;
typedef CommandList::iterator  CommandListIterator;

class CTCLCommandPackage  : public CTCLInterpreterObject
{

public:
  CTCLCommandPackage (CTCLInterpreter* pInterp,
                      const std::string&amp; rSignon=std::string("Unnamed pkg"));
  CTCLCommandPackage(CTCLInterpreter* pInterp,
                     const char* pSignon = "Unnamed pkg");
  virtual ~ CTCLCommandPackage ( );
  CTCLCommandPackage (const CTCLCommandPackage&amp; aCTCLCommandPackage );
  CTCLCommandPackage&amp; operator= (const CTCLCommandPackage&amp; aCTCLCommandPackage);
  int operator== (const CTCLCommandPackage&amp; aCTCLCommandPackage);

  std::string getSignon() const;
  CommandList getCommandList() const;
protected:
  void setSignon (std::string am_sSignon);

public:
  void Register ()  ;
  void Unregister ()  ;
  void AddProcessor (CTCLProcessor* pProcessor);
  void AddProcessors(CommandList&amp; rList);
  CommandListIterator begin ();
  CommandListIterator end ();
};
    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Extensions to Tcl often come in a set of related commands.  These commands
            may require access to a common set of services.  The <classname>CTCLCommandPackage</classname>
            along with the <classname>CTCLPackagedCommand</classname> provide a pair of base
            classes that facilitate the construction of such commands.
        </para>
        <para>
            The pattern to follow to derive class from <classname>CTCLCommandPackage</classname>
            This class defines and implements common services for the related commands.
            The constructor of the derived class will also create instances of
            classes derived from <classname>CTCLPackagedCommand</classname>.  These objects
            define and implement the related commands.  These command processors will be
            added to the package via <function>AddProcessor</function>, and
            <function>AddProcessors</function>.
        </para>
        <para>
            When the <classname>CTCLCommandPackage</classname>::<function>Register</function>
            function is called, all of the commands added to the package will be
            registered as well.  When a command processor is invoked, it can call its
            <function>getMyPackage</function> member function to obtain a pointer to the
            owning package and therefore access to the services this package provides.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
  <function>CTCLCommandPackage</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
                      <type>const std::string</type>&amp; <parameter>rSignon</parameter>=<type>std::string</type>(<literal>"Unnamed pkg"</literal>));
  <function>CTCLCommandPackage</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
                     <type>const char</type>* <parameter>pSignon</parameter> = <literal>"Unnamed pkg"</literal>);
  <function>CTCLCommandPackage</function> (<type>const CTCLCommandPackage</type>&amp; <parameter>aCTCLCommandPackage</parameter> );
        </programlisting>
        </para>
        <para>
            Constructs instances of the package.  <parameter>pInterp</parameter> is a pointer
            to the interpreter object on which these commands will be registered.
            <parameter>signon</parameter> is a text string that will be emitted to
            <literal>stderr</literal> when the package is asked to register its commands.
            This string is typically a credit or copyright notice for the package.  It can
            be empty if the user desires.
        </para>
        <para>
            The first and second form of the constructor only differ in how the signon message
            is passed.  The final form of the constructor is a copy constructor.  While
            copy construction is legal it is anticipated that this will not normally be used
            as command packages are usually <firstterm>singleton</firstterm> objects.
        </para>
        <para>
        <programlisting>
  <type>std::string</type> <function>getSignon</function>() const;
        </programlisting>
        </para>
        <para>
            Retrieves the signon string from the current object.
        </para>
        <para>
            <programlisting>
  <type>CommandList</type> <function>getCommandList</function>() const;
            </programlisting>
        </para>
        <para>
            Retrieves the list of commands that are managed by this package.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>setSignon</function> (<type>std::string</type> <parameter>am_sSignon</parameter>);
        </programlisting>
        </para>
        <para>
            Allows derived classes to set the signon string after construction is complete.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>Register</function> ()  ;
  <type>void</type> <function>Unregister</function> ()  ;
        </programlisting>
        </para>
        <para>
            <function>Regsiter</function> registers all of the commands in the package
            with the package's interpreter.  <function>Unregister</function> unregisters
            these commands.  It is therefore not advisable to change the set of commands in
            the package between registration and unregistration.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>AddProcessor</function>(<type>CTCLProcessor</type>* <parameter>pProcessor</parameter>);
  <type>void</type> <function>AddProcessors</function>(<type>CommandList</type>&amp; <parameter>rList</parameter>);
        </programlisting>
        </para>
        <para>
            These functions add command processors to the package.  Any type of processor
            can be added to the package, however usually <classname>CTCLPackagedCommand</classname>
            derived objects are in order to provide a mechanism to access the package services.
            <parameter>pProcessor</parameter> is a pointer to a single processor while
            <parameter>rList</parameter> is a reference to a list of such processors.
        </para>
        <para>
        <programlisting>
  <type>CommandListIterator</type> <function>begin</function> ();
  <type>CommandListIterator</type> <function>end</function> ();
        </programlisting>
        </para>
        <para>
            Returns STL list iterators to the beginning and off the end of the
            set of command packages.
            List iterators behave roughly like pointers.  In this case, pointers
            to <classname>CTCLProcessor*</classname>.   Incrementing an interator
            'points' it to the next item in the list.  A full discussion of STL iterators
            is well beyond the scope of this man page.  See references below.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLProcessor(3), CTCLPackagedCommand(3)
        </para>
    </refsect1>
    <refsect1>
        <title>References</title>
        <para>
        <programlisting>
Musser, Derge, Saini: <parameter>STL Tutorial and Reference Guide</parameter>
Addison-Wesley Professional Computing Series; 2001 ISBN 0-201-37923-6
        </programlisting>
        </para>
    </refsect1>
</refentry>


<refentry id="manpage.CTCLPackagedCommand">
    <refmeta>
        <refentrytitle>CTCLPackagedCommand</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLPackagedCommand</refname>
        <refpurpose>
            Base class for a command that lives in a <classname>CTCLCommandPackage</classname>
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLPackagedCommand.h&gt;
...
class CTCLPackagedCommand   : public CTCLProcessor
{

  CTCLPackagedCommand (const std::string&amp; sCommand, CTCLInterpreter* pInterp,
                       CTCLCommandPackage&amp; rPackage);
  CTCLPackagedCommand (const char* pCommand, CTCLInterpreter* pInterp,
                       CTCLCommandPackage&amp; rPackage);
   ~ CTCLPackagedCommand ( );

  CTCLCommandPackage&amp; getMyPackage();

  void setMyPackage (CTCLCommandPackage&amp; am_rMyPackage);

};
    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Command packages (see CTCLCommandPackage(3)), provide a way to organize
            a set of related Tcl command processors  around a set of shared services.
            Objects derived from <classname>CTCLPackagedCommand</classname> are added
            to an object derived from <classname>CTCLCommandPackage</classname>.
            The <classname>CTCLCommandPackage</classname> manages bulk registration of
            all of the commands added to it.  Construcint a
            <classname>CTCLPackagedCommand</classname> object provides it a
            reference to its package so
            that public members of the package can be invoked when the package commands
            are executing.
        </para>
        <para>
            Note that since <classname>CTCLPackagedCommand</classname> is derived from
            <classname>CTCLProcessor</classname>, and does not supply a <function>operator()</function>
            You must derive concrete classes from this class implementing
            <function>operator()</function> to provide the desired command functionality.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
  <function>CTCLPackagedCommand</function> (const <type>std::string</type>&amp; <parameter>sCommand</parameter>,
                       <type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
                       <type>CTCLCommandPackage</type>&amp; <parameter>rPackage</parameter>);
  <function>CTCLPackagedCommand></function> (const <type>char</type>* <parameter>pCommand</parameter>,
                       <type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
                       <type>CTCLCommandPackage</type>&amp; <parameter>rPackage</parameter>);
        </programlisting>
        </para>
        <para>
            Constructs a packaged command.
            <parameter>sCommand</parameter> or
            <parameter>pCommand</parameter>
            provide the command name.  <parameter>pInterp</parameter> is a pointer to the
            interpreter on which the command will be registered.
            <parameter>rPackage</parameter> is a reference to the package this object will
            be a member of.
        </para>
        <para>
            <programlisting>

<type>CTCLCommandPackage</type>&amp; <function>getMyPackage()</function>;
            </programlisting>
        </para>
        <para>
            Returns a reference to the object's package.  This can be cast to the
            actual type of the package at which point package public members can be
            accessed.
        </para>
        <para>
            <programlisting>
  <type>void</type> <function>setMyPackage</function> (<type>CTCLCommandPackage</type>&amp; <parameter>rMyPackage</parameter>);
        </programlisting>
        </para>
        <para>
            Provides a new package for the command.
        </para>
        <para>
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLCommandPackage(3),
CTCLProcessor(3)
        </para>
    </refsect1>
</refentry>


<refentry id="manpage.CTCLVariable">
    <refmeta>
        <refentrytitle>CTCLVariable</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLVariable</refname>
        <refpurpose>
            Encapsulate Tcl interpreter variables.
        </refpurpose>
    </refnamediv>

<refsynopsisdiv>
<programlisting>
#include &lt;TCLVariable.h&gt;
class <classname>CTCLVariable</classname>
{
  std::string getVariableName() const;
  Bool_t IsTracing() const;

  void setVariableName (const std::string am_sVariable);
  virtual   char*  operator() (char* pName,
                               char* pSubscript,
                               int Flags)  ;

   static  char* TraceRelay (ClientData pObject, Tcl_Interp* pInterpreter,
                             tclConstCharPtr  pName,
                             tclConstCharPtr pIndex,
                             int flags)  ;

  const char* Set (const char* pValue, int flags=TCL_LEAVE_ERR_MSG |
                                                 TCL_GLOBAL_ONLY)  ;
  const char* Set (const char* pSubscript, char* pValue,
                   int flags=TCL_LEAVE_ERR_MSG | TCL_GLOBAL_ONLY)  ;
  const char* Get (int flags=TCL_LEAVE_ERR_MSG | TCL_GLOBAL_ONLY,
                   char* pIndex=0)  ;
  int Link (void* pVariable, int Type)  ;
  void Unlink ()  ;
  int Trace (int flags=TCL_TRACE_READS | TCL_TRACE_WRITES | TCL_TRACE_UNSETS,
             char* pIndex = (char*)kpNULL)  ;

  void UnTrace ()  ;

};
</programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <classname>CTCLVariable</classname> allows an existing or new Tcl interpreter
            variable to be encapsulated so that it can be accessed, traced or linked
            in C++ code.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            <programlisting>
  <function>CTCLVariable</function>(<type>std::string</type> <parameter>sName</parameter>,
             <type>Bool_t</type> <parameter>fTracing</parameter>  );
  <function>CTCLVariable</function> (<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
             <type>std::string</type> <parameter>sName</parameter>,
             <type>Bool_t</type> <parameter>fTracing</parameter>  );
  <function>CTCLVariable</function> (<type>const CTCLVariable</type>&amp; <parameter>aCTCLVariable</parameter> );
            </programlisting>
        </para>
        <para>
            In the first two cases, <parameter>sName</parameter> is the name of the variable
            that will be wrapped by this object.  The variable name can contain namespace
            qualifications as well as indices.  If <parameter>fTracing</parameter> is true,
            the object is set to record that it is tracing the variable.  Normally
            this parameter should be allowed to default to <literal>kfFALSE</literal>,
            and the trace member functions used to set explicit traces.
            For the final form of the constructor (copy constructor),
            <parameter>aCTCLVariable</parameter> is a <classname>CTCLVariable</classname> that
            will be copied into this object.
        </para>
        <para>
            In the first form of the constructor, one must later call the
            <function>Bind</function> function (see CTCLInterpreterObject), to bind
            the variable to a specific interpreter prior to accessing it.
        </para>
        <para>
            <programlisting>
  <type>CTCLVariable</type>&amp; <function>operator=</function>(<type>const CTCLVariable</type>&amp; <parameter>rhs</parameter>);
            </programlisting>
        </para>
        <para>
            Assigns the <parameter>rhs</parameter> object to this one.  A reference to the
            left hand side of the assignment is returned.  The semantics of assignment are
            not that the variable values are assigned, but that the left side of the
            assignment becomes a functional equivalent of <parameter>rhs</parameter>,
            that is it stands for the same object and has the same traces (if any) set.
            Thus, if <parameter>rhs</parameter> wraps the interpreter variable <varname>a</varname>
            and the object on the left side wraps interpreter variable <varname>b</varname>
            after the assignment executes, the left side object will be wrapping
            <varname>a</varname>.
            A reference to the object on the left hand side of the assignment is returned.
        </para>
        <para>
            <programlisting>
  <type>int</type> <function>operator==</function>(<type>const CTCLVariable</type>&amp; <parameter>rhs</parameter>) const;
            </programlisting>
        </para>
        <para>
            Compares this object for functional equality with <parameter>rhs</parameter>.
            Functional equality is defined as the two objects referring to the same
            variable, in the same interpreter, and having traces set on the same
            operations.
        </para>
        <para>
            <programlisting>
  <type>std::string</type> <function>getVariableName</function>() const;
            </programlisting>
        </para>
        <para>
            Returns the name of the Tcl variable that is wrapped by this object.
        </para>
        <para>
            <programlisting>
<type>int</type> <function>Trace</function>(<type>int</type> <parameter>flags</parameter>=<literal>TCL_TRACE_READS | TCL_TRACE_WRITES | TCL_TRACE_UNSETS</literal>,
          <type>char</type>* <parameter>pIndex</parameter> = (<type>char</type>*)<literal>kpNULL</literal>)  ;
<type>void</type> <function>UnTrace</function> ()  ;
<type>Bool_t</type> <function>IsTracing</function>() const;
virtual <type>char</type>*  <function>operator()</function> (<type>char</type>* <parameter>pName</parameter>,
                        <type>char</type>* <parameter>pSubscript</parameter>,
                        <type>int</type> <parameter>Flags</parameter>)  ;
            </programlisting>
        </para>
        <para>
            This set of functions supports variable tracing.  In Tcl, a trace is a function
            that is called when some event of interest occurs on a varialbe.  The possible
            events are read, write, and unset.  To effectively use variable tracing, you
            must create a subclass of <classname>CTCLVariable</classname>, override its
            <function>operator()</function> member to handle the trace and call
            <function>Trace</function> to initiate tracing.
        </para>
        <para>
            The <function>Trace</function> member initiates tracing on the variable.
            <parameter>flags</parameter> describes when the trace should fire.
            See the manpage for <function>Tcl_TraceVar</function> for information about
            the legal flag values.
        </para>
        <para>
            <function>Untrace</function> cancels all traces on the variable represented by
            this object.
        </para>
        <para>
            <function>IsTracing</function> returns <literal>kfTRUE</literal> if tracing
            is being performed on the variable.
        </para>
        <para>
            When a trace fires, the <function>operator()</function> member will be called.
            This is why you must override the <classname>CTCLVariable</classname> base
            class to do anything useful with a trace.  The parameters to the
            call are; <parameter>pName</parameter> is the name of the variable that
            has been traced. <parameter>pSubscript</parameter> is the array subscript in the
            event the trace fires on an array or element of an array, and is
            <literal>NULL</literal> otherwise.  <parameter>Flag</parameter> describes
            why the trace fired.  Again, see the <function>Tcl_TraceVar</function>
            manpage for more information.
            Note that for write traces, the variable has already been set.  Modifying
            the value of the traced variable within a trace function will not fire any
            additional traces.
            The <function>operator()</function> function must return a <literal>NULL</literal>
            pointer if the trace is successful.  It must return a pointer to an error message
            if the trace is not successful.  An example of an unsuccessful trace might be
            a write trace that ensures that only particular values are assigned to the
            variable.
        </para>
        <para>
            <programlisting>
const <type>char</type>* <function>Set</function>(const <type>char</type>* <parameter>pValue</parameter>,
                <type>int</type> <parameter>flags</parameter>=<literal>TCL_LEAVE_ERR_MSG</literal> |
                          <literal>TCL_GLOBAL_ONLY</literal>)  ;
const <type>char</type>* <function>Set</function>(const <type>char</type>* <parameter>pSubscript</parameter>,
               <type>char</type>* <parameter>pValue</parameter>,
               <type>int</type> <parameter>flags</parameter>=<literal>TCL_LEAVE_ERR_MSG</literal> | <literal>TCL_GLOBAL_ONLY</literal>)  ;
            </programlisting>
        </para>
        <para>
            Sets the value of the variable to the string pointed to by <parameter>pValue</parameter>
            The second form of this assumes that the <classname>CTCLVariable</classname>
            represents an array and the <parameter>pSubscript</parameter> parameter
            specifies the subscript of the array that is being set.  The <parameter>flags</parameter>
            parameter is fully documented in the Tcl manpage for Tcl_SetVar
        </para>
        <para>
            <programlisting>
const <type>char</type>* <function>Get</function>(<type>int</type> <parameter>flags</parameter>=<literal>TCL_LEAVE_ERR_MSG</literal> | <literal>TCL_GLOBAL_ONLY</literal>,
              <type>char</type>* <parameter>pIndex</parameter>=<literal>0</literal>)  ;
            </programlisting>
        </para>
        <para>
            Retrieves the current value of a variable.  If the <parameter>pIndex</parameter>
            parameter is supplied, the variable wrapped by <classname>CTCLVariable</classname>
            is assumed to be an array and <parameter>pIndex</parameter> points to the subscript of the
            element to retrieve.  The <parameter>flags</parameter> parameter is fully
            documented in the Tcl_GetVar manpage.  The return value of the function is
            a null terminated character string that is the current value of the variable.
            If the variable does not exist, then a <literal>NULL</literal> is returned.
        </para>
        <para>
            <programlisting>
<type>int</type> <function>Link</function>(<type>void</type>* <parameter>pVariable</parameter>,
         <type>int</type> <parameter>Type</parameter>)  ;
<type>void</type> <function>Unlink</function>()  ;
            </programlisting>
        </para>
        <para>
            <function>Link</function> and <function>Unlink</function> support variable
            linking.  Variable linking is when a Tcl variable is made to track the value
            of a C/C++ variable or C++ member variable of an object.
            <function>Link</function> establishes the link.  <parameter>pVariable</parameter>
            points to the C or C++ variable or member variable to link to this
            <classname>CTCLVariable</classname>.  The <parameter>Type</parameter>
            parameter is one of following values:
            <literal>TCL_LINK_INT</literal>,
            <literal>TCL_LINK_DOUBLE</literal>,
            <literal>TCL_LINK_BOOLEAN</literal>,
            <literal>TCL_LINK_WIDE_INT</literal>, or
            <literal>TCL_LINK_STRING</literal> indicating the type of the variable
            to which <parameter>pVariable</parameter> points.  For all but
            <literal>TCL_LINK_STRING</literal>, <parameter>pVariable</parameter> points
            to a variable of the type indicated, and that variable will be linked.
            for <literal>TCL_LINK_STRING</literal>, <parameter>pVariable</parameter> points
            to a <type>char*</type> which should be initialized to point to <literal>NULL</literal>.
            The Tcl interpreter will use <function>Tcl_Alloc</function> and <function>Tcl_Free</function>
            to maintain a dynamically allocated string pointed to by that pointer which
            reflects the value of the variable.  If the C/C++ program modifies this string,
            it must <function>Tcl_Free</function> the prior value and <function>Tcl_Alloc</function>
            a new value with the new variable value.
        </para>
    </refsect1>
    <refsect1>
        <title>DEFECTS</title>
        <para>
            No <function>operator!=</function> has been defined.
        </para>
        <para>
            There is no protection against multiple links... the most recent link
            for an underlying Tcl variable is the one effective.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
        CTCLInterpreter(3), CTCLInterpreterObject(3),
        Tcl_GetVar(3tcl), Tcl_LinkVar(3tcl), Tcl_SetVar(3tcl), Tcl_TraceVar(3tcl)
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLApplication">
    <refmeta>
        <refentrytitle>CTCLApplication 3</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLApplication</refname>
        <refpurpose>
            Base class for TCL/Tk applications.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <programlisting>
#include &lt;tcl.h&gt;
#include &lt;TCLApplication.h&gt;
...
class CTCLApplication  : public CTCLInterpreterObject
{
public:
  CTCLApplication ();
  ~CTCLApplication ( );
  virtual   int operator() ()  =0;
  void      getProgramArguments(int&amp;, char**&amp; argv);
};
        </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <classname>CTCLApplication</classname> is an abstract base class
            that facilitates the creation of applications that extend the
            Tcl interpreter.  The `main program' of SpecTcl is derived from
            this class, for example.
        </para>
        <para>
            Initializing a Tcl application generallly consists of a bunch
            of boilerplate that initializes the interpreter, and then a bunch
            of application specific code to register extensions to the interpreter.
            <classname>CTCLApplication</classname>
            provides the main boilerplate.  It is expected that you
            derive a class from
            <classname>CTCLApplication</classname>
            Implement <function>operator()</function> to register
            application specific commands, and then create exactly one
            instance of your application class named, and a global pointer
            to that object named gpTCLApplication.
        </para>
        <para>
            For example, suppose you have created a class named MyTclApp:
            <informalexample>
            <programlisting>
// This code is at the global level:
...
MyTclApp app;                              // Makes an instance of this
CTCLApplication* gpTCLApplication = &amp;app;  // Pointer expected by framework.
...
            </programlisting>
            </informalexample>
            Will ensure that the <function>operator()</function> of your
            application object will be called with the interpreter already
            initialized.
        </para>
        <para>
            Note that if you use this class as shown above, to create an application,
            you must not define <function>main</function>.  A
            <function>main</function> is defined in the tcl++ library and
            it must be used to initialize the interpreter and, eventually
            hand off control to your application's
            <methodname>operator()</methodname>.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            <type>int</type> <function>operator()</function>()
        </para>
        <para>
            This function is pure virtual and must be overridden by your
            derived class.  <function>operator()</function> is expected to
            install all required extensions to the interprter and return to it
            to start the main event loop.  The return value from this should be
            <literal>TCL_OK</literal> if the application was successfully initialized
            or <literal>TCL_ERROR</literal> if the program encountered an error that
            should prevent the interpreter main loop from starting
        </para>

        <methodsynopsis>
            <type>void</type> <methodname>getProgramArgs</methodname>
            <methodparam>
                <type>int&amp;</type> <parameter>argc</parameter>
            </methodparam>
            <methodparam>
                <type>char**&amp;</type> <parameter>argv</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Provides a mechanism for the concrete class to get the program
            arguments. This allows the program arguments to be parsed for
            application specific switches and arguments.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
        CTCLInterpreter, CTCLInterpreterObject, CTCLObjectProcessor, CTCLVariable
        </para>
    </refsect1>
</refentry>


<refentry id="manpage.CTCLHashTable">
    <refmeta>
        <refentrytitle>CTCLHashTable</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLHashTable</refname>
        <refpurpose>
            Object oriented interface to Tcl's hash table functions.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLHashTable.h&gt;

template &lt;class T&gt;
class CTCLHashTable
{
public:
  CTCLHashTable () ;
  CTCLHashTable (  Tcl_HashTable am_HashTable  );
  CTCLHashTable (const CTCLHashTable&amp; aCTCLHashTable );
  virtual ~CTCLHashTable ( );

  CTCLHashTable operator= (const CTCLHashTable&amp; aCTCLHashTable);

  int operator== (const CTCLHashTable&amp; aCTCLHashTable);

  Tcl_HashTable* getHashTable() const;

  void Enter (const std::string&amp; rKey, rCTCLTHashTableItem rValue);
  const CTCLTHashTableItem* Find (const std::string&amp; rsKeyword) const;
  CTCLTHashTableItem* Delete (const std::string&amp; rsKeyword);
  CTCLTHashTableIterator begin ();
  CTCLTHashTableIterator end ();
  std::string Statistics ();
};

    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Hash tables are tables of keyword value pairs that are organized
            such that the lookup time for any key in the table is <firstterm>amortized
            constant</firstterm>.  Hash tables operate by running the key through a
            function called the <firstterm>hash function</firstterm>, and storing the
            key/value pair as an element of an array indexed by the result of that hash
            function (<firstterm>hash index</firstterm>).  Depending on the implementation of the hash table, different
            methods are used to resolve cases where two keys result in the same
            hash index.
        </para>
        <para>
            Tcl includes support libraries for hash tables with string keys and
            arbitrary value types (e.g. structures, pointers etc. etc.).  One example
            of the use of this sort of data structure is Tcl's storage of array variables.
            Each array is a hash table indexed by the hash index of the array subscripts.
            In this way Tcl supports subscripts that are arbitrary strings without
            any search overhead when referencing an element of the array.
        </para>
        <para>
            The <classname>CTCLHashTable</classname> and related classes provide an object oriented
            interface to the Tcl API for hash tables.  This class is a <firstterm>template class</firstterm>.
            The template parameter is the type of data that will be associated with each
            hash key.  For example, to create a has key of <classname>CSpectrum*</classname>
            (pointers to SpecTcl Spectra):
            <programlisting>
        CTCLHashTable&lt;CSpectrum*&gt; spectrumHashTable;
            </programlisting>
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
  <function>CTCLHashTable</function> () ;
  <function>CTCLHashTable</function> (  <type>Tcl_HashTable</type> <parameter>aHashTable</parameter>  );
  <function>CTCLHashTable</function> (const <type>CTCLHashTable</type>&amp; <parameter>aCTCLHashTable</parameter> );
        </programlisting>
        </para>
        <para>
            Three methods for creating <classname>CTCLHashTable</classname> objects
            are defined.   The first of these creates a new, empty hash table.
            The second, takes the handle to an existing hash table;
            <type>Tcl_HashTable</type> <parameter>aHashTable</parameter> and wraps
            a <classname>CTCLHashTable</classname> around this existing hash table
            providing an object oriented interface to that hash table.
            The final constructor, a copy constructor, creates a
            <classname>CTCLHashTable</classname> that refers to the same underlying
            <type>Tcl_HashTable</type> as the <parameter>aCTCLHashTable</parameter> parameter.
        </para>
        <para>
        <programlisting>
  <type>CTCLHashTable</type> <function>operator</function>= (const <type>CTCLHashTable</type>&amp; <parameter>rhs</parameter>);
  <type>int</type> <function>operator==</function> (const <type>CTCLHashTable</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            <function>operator=</function>  assigns <parameter>rhs</parameter> to an existing
            object.  The semantics of assignment are that
            followingt assignment, <varname>*this</varname> and <parameter>rhs</parameter>
            will refer to the same underlying hash table.
        </para>
        <para>
            <function>operator==</function> compares two hash tables, <varname>*this</varname>
            and <parameter>rhs</parameter> for equality.  The semantics of equality are
            that the two <classname>CTCLHashTable</classname> objects refer to the same
            underlying Tcl hash tables.
        </para>
        <para>
        <programlisting>
  <type>Tcl_HashTable</type>* <function>getHashTable</function>() const;
        </programlisting>
        </para>
        <para>
            Gets the underlying <type>Tcl_HashTable</type> that is wrapped by
            a <classname>CTCLHashTable</classname> object.
        </para>
        <para>
            <programlisting>
<type>void</type> <function>Enter</function> (const <type>std::string</type>&amp; <parameter>rKey</parameter>,
            <type>CTCLTHashTableItem&lt;T&gt;</type> <parameter>rValue</parameter>);
            </programlisting>
            </para>
            <para>
            Adds an entry to a hash table.  <parameter>rKey</parameter> is the
            lookup key that will be associated with the entry.  <parameter>rValue</parameter>
            is the data that is associated with that key.  Note that <type>T</type>
            is the template type that was used to create the hashtable.  E.g. if the
            hash table is a <classname>CTCLHashTable&lt;float&gt;</classname>,
            <parameter>rValue</parameter> must be a <classname>CTCLHashTableItem&lt;float&gt;</classname>.
            Note that Tcl hash tables do not support duplicate keys.  If a hash table
            entry with the key <parameter>rKey</parameter> already is in the table it is
            replaced.
            </para>
            <para>
                <programlisting>
  const <type>CTCLTHashTableItem</type>* <function>Find</function> (const <type>std::string</type>&amp; <parameter>rsKeyword</parameter>) const;
                </programlisting>
            </para>
            <para>
                Looks up a hash table item by key.  If a hash table item with
                the key <parameter>rsKeyword</parameter> exists, a pointer to its
                entry is returned.   If <parameter>rsKeyword</parameter> has not
                yet been <function>Enter</function>ed in the hash table, a
                <literal>NULL</literal> pointer is returned.
            </para>
            <para>
                <programlisting>
  <type>CTCLTHashTableItem</type>* <function>Delete</function> (const <type>std::string</type>&amp; <parameter>rsKeyword</parameter>);
                </programlisting>
            </para>
            <para>
                Removes the hash table entry with the key <parameter>rsKeyword</parameter>.
                If the item existed, a pointer to it is returned.  If the item does not
                exist in the hash table a <literal>NULL</literal> pointer is returned.
            </para>
            <para>
                <programlisting>
  <type>CTCLTHashTableIterator</type> <function>begin</function> ();
  <type>CTCLTHashTableIterator</type> <function>end</function> ();
                </programlisting>
            </para>
            <para>
                <function>begin</function> returns an <firstterm>iterator</firstterm> that
                "points" to the first entry in the hash table.  dereferencing the
                iterator yields the pointer to a HashTableItem.  The iterator can be
                incremented via ++ so that it advances to the next item in the table.
            </para>
            <para>
                <function>end</function>returns an iterator that points past the end of the
                table and can be used to determine when iteration is complete.
            </para>
            <para>
                Iterators are pointer like objects.  See the STL reference below for more
                information about them.  The following example Takes a Hash table and
                counts up the number of elements it contains.
                <programlisting>
        CTCLHashTableIterator i = table.begin();    // Table a CTCLHashTable
        int                   n = 0;
        while (i != table.end()) {
            n++;
        }
        // N is a count of elements in the table.

            </programlisting>
            </para>
            <para>
                <programlisting>
  <type>std::string</type> <function>Statistics</function> ();
                </programlisting>
        </para>
        <para>
            Returns a string that contains statistics about the hash table.
            This is a wrapper for <function>Tcl_HashStats</function>
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLHashTableItem(3),
CTCLHashTableIterator(3),
Tcl_HashStats(3tcl)
        </para>
    </refsect1>
    <refsect1>
        <title>REFERENCES</title>
        <para>
        <programlisting>
Niklaus Wirth <parameter>Algorithms + Data Structures = Programs</parameter>
Prentice Hall Series in Automatic Computation 1976 See section 4.6

Musser, Derge, Saini: <parameter>STL Tutorial and Reference Guide</parameter>
Addison-Wesley Professional Computing Series; 2001 ISBN 0-201-37923-6
        </programlisting>
        </para>
    </refsect1>
</refentry>


<refentry id="manpage.CTCLHashTableItem">
    <refmeta>
        <refentrytitle>CTCLHashTableItem</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLHashTableItem</refname>
        <refpurpose>
            Encapsulation of an entry in a Tcl Hash table as encapsulated
            in <classname>CTCLHashTable</classname>
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <programlisting>
#include &lt;TCLHashTableItem.h&gt;
...

template &lt;class T&gt;              // T Must have copy ctor &amp; Assignment defined.
class CTCLHashTableItem
{
  CTCLHashTableItem (T am_Item );
  CTCLHashTableItem (const CTCLHashTableItem&amp; aCTCLHashTableItem );
  virtual ~CTCLHashTableItem ( );

  CTCLHashTableItem operator= (const CTCLHashTableItem&amp; aCTCLHashTableItem);
   int operator== (const CTCLHashTableItem&amp; aCTCLHashTableItem);
  T getItem() const;
  T* operator-&gt; ();
}
        </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title></title>
        <para>
            Provides an object oriented interface to elements of a hash table.
            See CTCLHashTable(3), and the first REFERENCE below for more information
            about hash tables.
        </para>
        <para>
            Note that this is a templated class.  The template parameter is
            the type of the item to be stored in the hash table.  Suppose,
            for example, we have a bunch of named calibration parameters
            (floating point) that are stored in a hash table.  A calibration
            The following code creates the calibration table, and inserts an
            element named george in it with the initial value of 0.0:
            <programlisting>
        CTCLHashTable&lt;float&gt;  calibrationTable;
        CTCLHashTableItem&lt;float&gt; entry(0.0);
        calibrationTable.Enter(std::string("george"), entry);
            </programlisting>
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
<function>CTCLHashTableItem</function> (<type>T</type> <parameter>Item</parameter> );
<function>CTCLHashTableItem</function> (const <type>CTCLHashTableItem</type>&amp; <parameter>hashItem</parameter> );
        </programlisting>
        </para>
        <para>
            Constructs a <classname>CTCLHashTableItem</classname> either from the underlying
            type (<parameter>Item</parameter>) or from an existing <classname>CTCLHashTableItem</classname>
            (<parameter>hashItem</parameter>).
        </para>
        <para>
        <programlisting>
<type>CTCLHashTableItem</type> <function>operator=</function>(const <type>CTCLHashTableItem</type>&amp; <parameter>rhs</parameter>);
<type>int</type> <parameter>operator==</parameter> (const <type>CTCLHashTableItem</type>&amp; <type>rhs</type>);
        </programlisting>
        </para>
        <para>
            <function>operator=</function> allows you to assign the value of one
            <classname>CTCLHashTableItem</classname> to another.  The underlying
            templated type must be capable of assignment.
        </para>
        <para>
            <function>operator==</function> allows you to compare two
            <classname>CTCLHashTableItem</classname>s to each other.  The underlying
            templated type must be capable of equality comparison.
        </para>
        <para>
            <programlisting>
<type>T</type> <function>getItem</function>() const;
            </programlisting>
        </para>
        <para>
            Returns the value of the item wrapped by the <classname>CTCLHashTableItem</classname>
            The underlying type must be capable of copy construction.
        </para>
        <para>
            <programlisting>
<type>T</type>* <function>operator-&gt;</function> ();       </programlisting>
        </para>
        <para>
            Returns the address of the contents of the <classname>CTCLHashTableItem</classname>.
            This is most useful if <classname>T</classname> is a structure or class as it can be
            used to dereference member (data or functions) of the structure or class.
            For example:
            <programlisting>
                struct complex {
                                 double real;
                                 double imaginary;
                                 complex(double r, double i) :
                                    real(r), imaginary(i) {}
                                } complex;
                CTCLHashTableItem&lt;complex&gt; v(1.0, 2.0);
                double real = v-&gt;real;             // real = 1.0
                double imag = v-&gt;imaginary;        // imag = 2.0
            </programlisting>
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLHashTable(3),
CTCLHashTableIterator(3)
        </para>
    </refsect1>
    <refsect1>
        <title>REFERENCES</title>
        <para>
            <programlisting>
Niklaus Wirth <parameter>Algorithms + Data Structures = Programs</parameter>
Prentice Hall Series in Automatic Computation 1976 See section 4.6
            </programlisting>
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLHashTableIterator">
    <refmeta>
        <refentrytitle>CTCLHashTableIterator</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLHashTableIterator</refname>
        <refpurpose>
            Iterator for visiting all elements of a <classname>CTCLHashTable</classname>
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>

#include &gt;TCLHashTableIterator.h&gt;
...
template &lt;class T&gt;
class CTCLHashTableIterator
{

public:
  CTCLHashTableIterator (Tcl_HashTable*   pTable);
  CTCLHashTableIterator (const CTCLHashTableIterator&amp; aCTCLHashTableIterator );
  virtual ~ CTCLHashTableIterator ( );

  CTCLHashTableIterator operator=
                     (const CTCLHashTableIterator&amp; aCTCLHashTableIterator);
  int operator== (const CTCLHashTableIterator&amp; aCTCLHashTableIterator);
  CTCLHashTableItem&lt;T&gt;* getCurrentEntry() const;
  Tcl_HashTable* getHashTable() const;

  CTCLHashTableIterator&amp; operator++ ();
  CTCLHashTableIterator operator++ (int i);
  CTCLHashTableItem&lt;T&gt;&amp; operator* ();
  CTCLHashTableItem&lt;T&gt;* operator-&gt;();

};



    </programlisting>

    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <classname>CTCLHashTableIterator</classname> objects are created and returned
        by <classname>CTCLHashTableIterator</classname>::<function>begin</function>
        and <classname>CTCLHashTableIterator</classname>::<function>end</function>.
        These objects are pointer like objects to <classname>CTCLHashTableItem</classname>
        objects within the hash table.
        </para>
        <para>
            If you imagine that all containers can have an ordering defined on them,
            iterators are like pointers to elements of this ordering.
            Dereference operators yield an element of the container, and increment operators
            make the iterator 'point' to the next element in the container according to the
            ordering.
        </para>
        <para>
            For more information on both hash tables and iterators see the
            REFERENCES.  For information about the classes that are related to this,
            consult manpages pointed to by the SEE ALSO section.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
  <function>CTCLHashTableIterator</function> (<type>Tcl_HashTable</type>* <parameter>pTable</parameter>);
  <function>CTCLHashTableIterator</function>(const <type>CTCLHashTableIterator</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            Construct a hash table iterator.  Normally you will not need to use these
            constructors directly.  They will be created, instead by
            <classname>CTCLHashTable</classname>::<function>begin()</function>
            or <classname>CTCLHashTable</classname>::<function>end()</function>.
            <parameter>pTable</parameter> is a pointer to an existing <type>Tcl_HashTable</type>
            created via <function>Tcl_InitHashTable</function>.  <parameter>rhs</parameter>
            is an existing <classname>CTCLHashTableIterator</classname> object whose state
            will be used to initialize the object under construction.
        </para>
        <para>
        <programlisting>
  <type>CTCLHashTableIterator</type> <function>operator=</function>
                     (const <type>CTCLHashTableIterator</type>&amp; <parameter>rhs</parameter>);
  <type>int</type> <function>operator==</function>(const <type>CTCLHashTableIterator</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            <function>operator=</function> allows you to assign the state of one <classname>CTCLHashTableIterator</classname>
            to another.  When the assignment is complete, the left hand side object will
            be 'pointing' to the same object as the right hand side object but be separately
            incrementable.
        </para>
        <para>
            <function>operator==</function> allows you to compare two iterators for equality.
            equality is defined as the two iterators being defined on the same underlying
            hash table, pointing to the same element, and having the same increment context
            (e.g. an increment of both iterators will leave them both pointing to the
            same hash table item (different from the one prior to the increment).
        </para>
        <para>
        <programlisting>
<type>CTCLHashTableItem&lt;T&gt;</type>* <function>getCurrentEntry</function>() const;
<type>Tcl_HashTable</type>* <function>getHashTable</function>() const;
        </programlisting>
        </para>
        <para>
            These two functions get at the information the iterator is encapsulating.
            <function>getCurrentEntry</function> returns a pointer to the entry that
            the iterator si currently 'pointing' at.  This is identical to the
            <function>operator-&gt;</function> function.
            <function>getHashTable</function> returns a pointer to the underlying
            <type>Tcl_HashTable</type> created by <function>Tcl_InitHashTable</function>.
        </para>
        <para>
            <programlisting>
CTCLHashTableIterator&amp; operator++ ();
CTCLHashTableIterator operator++ (int i);
            </programlisting>
        </para>
        <para>
            These two function support both pre and post increment operations on an
            iterator.  There are slight differences in semantics between these
            operators best illustrated with a sample code fragment.  In the fragment
            below, i is an <classname>CTCLHashTableIterator</classname>
            <programlisting>
CTCLHashTableItem item1 = *i++;   // item 1 is the item pointed to prior to increment
CTCLHashTableItem item2 = *++i;   // item 2 is the item pointed to after increment.
            </programlisting>
        </para>
        <para>
            <programlisting>
<type>CTCLHashTableItem&lt;T&gt;</type>&amp; <function>operator*</function> ();
<type>CTCLHashTableItem&lt;T&gt;</type>* <function>operator-&gt;</function>();
        </programlisting>
        </para>
        <para>
            These operators allow <classname>CTCLHashTableIterator</classname> objects
            to be treated like pointers to <classname>CTCLHashTableItem</classname> objects.
            <function>operator*</function> provides 'pointer' dereferencing that allows
            code like:
            <programlisting>
                (*i).getItem();
            </programlisting>
        </para>
        <para>
            <function>operator-&gt;</function> provides a pointer to struct like semantics
            allowing code like:
            <programlisting>
                i->getItem();
            </programlisting>
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLHashTable(3),
CTCLHashTableItem(3),
Tcl_InitHashTable(3tcl),
Tcl_FirstHashEntry(3tcl),
Tcl_NextHashEntry(3tcl)
        </para>
    </refsect1>
    <refsect1>
        <title>REFERENCES</title>
        <para>
        <programlisting>
Niklaus Wirth <parameter>Algorithms + Data Structures = Programs</parameter>
Prentice Hall Series in Automatic Computation 1976 See section 4.6

Musser, Derge, Saini: <parameter>STL Tutorial and Reference Guide</parameter>
Addison-Wesley Professional Computing Series; 2001 ISBN 0-201-37923-6
        </programlisting>
        </para>
    </refsect1>
</refentry>


<refentry id="manpage.CTCLString">
    <refmeta>
        <refentrytitle>CTCLString</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLString</refname>
        <refpurpose>
            Provide a wrapper for the <type>Tcl_DString</type> data type
            and its API
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLString.h&gt;
...
class CTCLString
{
public:
  CTCLString ();
  CTCLString (const char* pString  ) ;
  CTCLString(const std::string&amp; rString);
  CTCLString(const Tcl_DString&amp; rString);
  CTCLString (const CTCLString&amp; aCTCLString );
  ~ CTCLString ();

  CTCLString&amp; operator= (const CTCLString&amp; aCTCLString);
  int operator== (const CTCLString&amp; aCTCLString);
  int operator!= (const CTCLString&amp; aCTCLString);
  int operator&gt; (const CTCLString&amp; aCTCLString);
  int operator&lt; (const CTCLString&amp; aCTCLString);
  int operator&gt;=(const CTCLString&amp; aCTCLString);
  int operator&lt;=(const CTCLString&amp; aCTCLString);

  Tcl_DString&amp; getString();
  CTCLString&amp; Append (const std::string&amp; rString, Int_t nLength=-1);
  CTCLString&amp; Append (const CTCLString&amp;  rString, Int_t nLength=-1);
  CTCLString&amp; Append (Tcl_DString&amp;       pString, Int_t nLength=-1);
  CTCLString&amp; Append (const char*        pString, Int_t nLength=-1);
  CTCLString&amp; AppendElement (const Tcl_DString*      pRhs);
  CTCLString&amp; AppendElement (const CTCLString&amp;       rRhs);
  CTCLString&amp; AppendElement (const std::string&amp;      rRhs);
  CTCLString&amp; AppendElement (const char*             pRhs);
  CTCLString&amp; AppendElement(DFloat_t value, const char* pFormat = "%f");
  CTCLString&amp; AppendElement(long value, const char* pFormat = "%i");

  CTCLString&amp; StartSublist ()  ;
  CTCLString&amp; EndSublist ()  ;
  UInt_t  Length () const ;
  CTCLString&amp; Truncate (UInt_t nNewLength)  ;
  Bool_t isCommand () const  ;

  Bool_t Match (const char*       pPattern) const;
  Bool_t Match (std::string&amp;      rPattern) const;
  Bool_t Match (const CTCLString&amp; rPattern) const;

  operator const char* () const;
  operator std::string () const;
  operator Tcl_DString* ();
};
    </programlisting>


    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The Tcl API provides a dynamic string type <type>Tcl_DString</type>.
            For many purposes, the C++ <type>std::string</type> is sufficient, however
            the <type>Tcl_DString</type> list building functions are unmatched in
            <type>std::string</type>.  <classname>CTCLString</classname> is an object oriented
            wrapping of a <type>Tcl_DString</type>
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            <programlisting>
<type>CTCLString</type> ();
<type>CTCLString</type> (const <type>char</type>* <parameter>pString</parameter>) ;
<type>CTCLString</type>(const <type>std::string</type>&amp; <parameter>rString</parameter>);
<type>CTCLString</type>(const <type>Tcl_DString</type>&amp; <parameter>rString</parameter>);
<type>CTCLString</type> (const <type>CTCLString</type>&amp; <type>aCTCLString</type> );
            </programlisting>
            </para>
            <para>
                Constructs a <classname>CTCLString</classname> object.  With the exception
                of the first constructor, which produces an empty string, all of these
                constructors initialize the contents of the underlying
                <classname>Tcl_DString</classname> with the string representation of their
                parameter.
            </para>
            <para>
            <programlisting>
<type>CTCLString</type>&amp; <function>operator=</function> (const <type>CTCLString</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            Supports assignment to a <classname>CTCLString</classname> from another;
            <parameter>rhs</parameter>.
        </para>
        <para>
        <programlisting>
<type>int</type> <function>operator==</function> (const <type>CTCLString</type>&amp; <parameter>rhs</parameter>);
<type>int</type> <function>operator!=</function> (const <type>CTCLString</type>&amp; <parameter>rhs</parameter>);
<type>int</type> <function>operator&gt;</function> (const <type>CTCLString</type>&amp; <parameter>rhs</parameter>);
<type>int</type> <function>operator&lt;</function> (const <type>CTCLString</type>&amp; <parameter>rhs</parameter>);
<type>int</type> <function>operator&gt;=</function>(const <type>CTCLString</type>&amp; <parameter>rhs</parameter>);
<type>int</type> <function>operator&lt;=</function>(const <type>CTCLString</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            Relational operators provide for lexicographic copmarisons between the object
            and <parameter>rhs</parameter> which is another <classname>CTCLString</classname>.
        </para>
        <para>
        <programlisting>
<type>Tcl_DString</type>&amp; <function>getString</function>();
        </programlisting>
        </para>
        <para>
            Returns a reference tothe underlying <type>Tcl_DString</type> of the
            object.
        </para>
        <para>
        <programlisting>
<type>CTCLString</type>&amp; <function>Append</function> (const <type>std::string</type>&amp; <parameter>String</parameter>,
                  <type>Int_t</type> <parameter>nLength</parameter>=<literal>-1</literal>);
<type>CTCLString</type>&amp; <function>Append</function> (const <type>CTCLString</type>&amp; <parameter>String</parameter>,
                  <type>Int_t</type> <parameter>nLength</parameter>=<literal>-1</literal>);
<type>CTCLString</type>&amp; <function>Append</function> (<type>Tcl_DString</type>&amp;       <parameter>String</parameter>,
                  <type>Int_t</type> <parameter>nLength</parameter>=<literal>-1</literal>);
<type>CTCLString</type>&amp; <function>Append</function> (const <type>char</type>*            <parameter>String</parameter>,
                  <type>Int_t</type> <parameter>nLength</parameter>=<literal>-1</literal>);
        </programlisting>
        </para>
        <para>
            Appends a section of <parameter>String</parameter> to the
            <classname>CTCLString</classname> that is being built up.
            The first <parameter>nLength</parameter> characters are appended.
            if <parameter>nLength</parameter> is <literal>-1</literal> then
            all <parameter>String</parameter> is appended.
        </para>
        <para>
        <programlisting>
<type>CTCLString</type>&amp; <function>AppendElement</function> (const <type>Tcl_DString</type>*  <parameter>item</parameter>);
<type>CTCLString</type>&amp; <function>AppendElement</function> (const <type>CTCLString</type>&amp;   <parameter>item</parameter>);
<type>CTCLString</type>&amp; <function>AppendElement</function> (const <type>std::string</type>&amp;  <parameter>item</parameter>);
<type>CTCLString</type>&amp; <function>AppendElement</function> (const <type>char*</type>         <parameter>item</parameter>);
<type>CTCLString</type>&amp; <function>AppendElement</function>(<type>DFloat_t</type> <parameter>item</parameter>,
                         const <type>char*</type> <parameter>pFormat</parameter> = <literal>"%f"</literal>);
<type>CTCLString</type>&amp; <function>AppendElement</function>(<type>long</type>     <parameter>item</parameter>,
                         const <type>char*</type> <parameter>pFormat</parameter> = <literal>"%i"</literal>);
        </programlisting>
        </para>
        <para>
            Appends <parameter>item</parameter> as a list element to the end of the
            string.  If necessary quotation is performed to ensure the item is treated as a
            single list element.  The <parameter>pFormat</parameter> parameter
            controls the conversion of non string data types to a string and is of the form
            of any control sequence used by sprintf.  For example
            <literal>"i = %d"</literal> could be used to convert an integer to a label
            and its value which would be appended to the string as e.g.
            <literal>{i = 1234}</literal>
        </para>
        <para>
        <programlisting>
<type>CTCLString</type>&amp; <function>StartSublist</function> ()  ;
<type>CTCLString</type>&amp; <function>EndSublist</function> ()  ;
        </programlisting>
        </para>
        <para>
            Used in conjuntion with <function>AppendElement</function> these
            start and end sublists which are list elements that consist of lists.
            Sublists can be nested to any depth.
            For example:
            <programlisting>
    CTCLString s;
    s.AppendElement("a");
    s.StartSublist();
    s.AppendElement("b");
    s.AppendElement("c");
    s.StartSublist();
    s.AppendElement("d");
    s.AppendElement("e");
    s.EndSublist();
    s.AppendElement("f");
    s.EndSublist();
    s.AppendElement("g");
            </programlisting>
        Would make the <varname>s</varname> contain the string
        <literal>"a {b c {d e} f} g"</literal>
        </para>
        <para>
        <programlisting>
<type>UInt_t</type>  <function>Length</function>() const ;
        </programlisting>
        </para>
        <para>
            Returns the number of characters in the string.
        </para>
        <informalexample>
        <programlisting>
CTCLString&amp; Truncate (UInt_t nNewLength)  ;
        </programlisting>
        </informalexample>
        <para>
            Truncates the string to the first <parameter>nNewLength</parameter>
            characters.
        </para>
    
        <informalexample>
        <programlisting>
<type>Bool_t</type> <function>isCommand</function> () const  ;
        </programlisting>
        </informalexample>
        <para>
            Analyzes the string and returns <literal>kfTRUE</literal> if the
            string is a 'well formed command'.  Note that a well formed command
            may still have syntax and execution errors.  This just ensures that
            a string has a balanced set of quoting characters.
        </para>
        <informalexample>
        <programlisting>
<type>Bool_t</type> <function>Match</function> (const <type>char</type>*           <parameter>Pattern</parameter>) const;
<type>Bool_t</type> <function>Match</function> (<type>std::string</type>&amp;      <parameter>Pattern</parameter>) const;
<type>Bool_t</type> <function>Match</function> (const <type>CTCLString</type>&amp; <parameter>Pattern</parameter>) const;
        </programlisting>
        </informalexample>
        <para>
            Returns <literal>kfTRUE</literal> if the contents of the string matches the
            <parameter>Pattern</parameter>
            parameter.  The <parameter>Pattern</parameter> parameter can contain all of the
            wildcards in <firstterm>glob</firstterm> style pattern matching.  See
            REFERENCES below for moer information about glob style matching.
        </para>
        <informalexample>
        <programlisting>
operator const char* () const;
operator std::string () const;
operator Tcl_DString* ();
    </programlisting>
        </informalexample>
        <para>
            These operators are implicit and explicit type conversion operators that
            allow a <classname>CTCLString</classname> object to be treated as a
            <type>char*</type> pointing to a null terminated string, a
            <type>std::string</type> object, or a <type>Tcl_DString</type> pointer.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
Tcl_DStringAppend(3tcl),
Tcl_DStringAppendElement(3tcl),
Tcl_DStringEndSublist(3tcl),
Tcl_DStringFree(3tcl),
Tcl_DStringGetResult(3tcl),
Tcl_DStringInit(3tcl),
Tcl_DStringLength(3tcl),
Tcl_DStringResult(3tcl),
Tcl_DStringSetLength(3tcl),
Tcl_DStringStartSublist(3tcl)
        </para>
    </refsect1>
    <refsect1>
        <title>REFERENCES</title>
        <informalexample>
            <programlisting>
J.K. Ousterhout <parameter>Tcl and the Tk Toolkit</parameter>
Addison-Wesley Professional Computing Series 1994 see section 9.2
            </programlisting>
        </informalexample>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLList">
    <refmeta>
        <refentrytitle>CTCLList</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLList</refname>
        <refpurpose>
            Provide access to Tcl List parsing.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <programlisting>
#include &lt;TCLList.h&gt;
...
class CTCLList  : public CTCLInterpreterObject
{

public:
  CTCLList (CTCLInterpreter* pInterp);
  CTCLList (CTCLInterpreter* pInterp, const  char* am_pList  );
  CTCLList (CTCLInterpreter* pInterp, const std::string&amp; rList);
  CTCLList (const CTCLList&amp; aCTCLList );

  CTCLList&amp; operator= (const CTCLList&amp; aCTCLList);
  int operator== (const CTCLList&amp; aCTCLList);
  int operator!= (const CTCLList&amp; aCTCLList);

  const char* getList() const;

  int Split (StringArray&amp; rElements)  ;
  int Split (int&amp; argc, char*** argv);

  const char* Merge (const StringArray&amp; rElements)  ;
  const char* Merge(int argc, char** argv);

};


        </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Tcl Lists are white space separated words.  It is definition of
            words and quoting issues that makes the parsing of lists less than
            straightforward.
        </para>
        <para>
            Fortunately, Tcl provides several list processing functions.  The
            concept of a list and access to list processing functions are
            encapsulated in the <classname>CTCLList</classname> class.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>

<type>CTCLList</type> (<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>);
<type>CTCLList</type> (<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
          const  <type>char</type>* <parameter>pList</parameter>  );
<type>CTCLList</type> (<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
          const <type>std::string</type>&amp; <parameter>rList</parameter>);
<type>CTCLList</type> (const <type>CTCLList</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            These four functions provide various ways to create a <classname>CTCLList</classname>
            object.  The first constructor creates an empty list.  The next two, create a list
            that has an initial value given by either the <literal>NULL</literal>
            terminated string <parameter>pList</parameter>, or the <type>std::string</type>
            object <parameter>rList</parameter>.
            The final constructor creates a list that is a duplicate of the list
            described by the object <parameter>rhs</parameter>.
        </para>
        <para>
            <programlisting>

  <type>CTCLList</type>&amp; <function>operator=</function> (const <type>CTCLList</type>&amp; <parameter>rhs</parameter>);
  <type>int</type> <function>operator==</function> (const <type>CTCLList</type>&amp; <parameter>rhs</parameter>);
  <type>int</type> <function>operator!=</function> (const <type>CTCLList</type>&amp; <parameter>rhs</parameter>);
            </programlisting>
        </para>
        <para>
            These function provide assignment (<function>operator=</function>),
            equality comparison (<function>operator==</function>), and
            inequality comparison (<function>operator!=</function>) with another
            <classname>CTCLList</classname> object, <parameter>rhs</parameter>.
            Assignment is defined as copying the string format of the list.
            Equality comparison is defined as the both interpreter and strings being equal.
            Inequality is defined as !operator==.
        </para>
        <para>
            <programlisting>
  const <type>char</type>* <function>getList()</function> const;
            </programlisting>
        </para>
        <para>
            <function>getList</function> returns an immutable pointer to
            the string rerpesentation of the list.  Note that the const qualfier
            on the pointer means that attempts to dereference the pointer which
            would modify the list result in error messages.  For Example:
            <programlisting>
        CTCLList aList(pInterp, "some list");
        const char* pData = aList.getList();
        *pData = 'S';         // Compiler error!!!!
            </programlisting>
        </para>
        <para>
            <programlisting>
<type>int</type> <function>Split</function> (<type>StringArray</type>&amp; <parameter>rElements</parameter>)  ;
<type>int</type> <function>Split</function> (<type>int</type>&amp; <parameter>argc</parameter>,
           <type>char</type>*** <parameter>argv</parameter>);
            </programlisting>
        </para>
        <para>
            Splits a list up into its component words.   <parameter>relements</parameter>
            is a <type>std::vector&lt;std::string&gt;</type> into which the elements will be split.
            <parameter>argc</parameter> is a reference to an integer into which the
            number of elements will be put. <parameter>argv</parameter> is a pointer to a
            <type>char</type>** into which will be placed a pointer to dynamically
            allocated storage containing a list of <parameter>argc</parameter> pointers
            to the words in the string.  This storage must be released by the caller
            with  <function>Tcl_Free</function>.
            For example:
            <programlisting>
                CTCLList someList(pInterp, someInitialContents);
                ...
                int argc;
                char** argv;
                someList.Split(argc, &amp;argv);
                //
                //  ... do something with the data
                //
                ...
                //
                // Done with the list elements.
                //
                Tcl_Free((char*)argv);
            </programlisting>
        </para>
        <para>
            <programlisting>
const <type>char</type>* <function>Merge</function> (const <type>StringArray</type>&amp; <parameter>rElements</parameter>)  ;
const <type>char</type>* <function>Merge</function>(<type>int</type> argc,
                 <type>char</type>** <parameter>argv</parameter>);
        </programlisting>
        </para>
        <para>
            Merges a bunch of words in to a list.  If necessary, quoting is performed to
            ensure that words that have whitespace or other special characters will be
            correctly formatted into the list. <parameter>rElements</parameter> is a
            <type>std::vector&lt;std::string&gt;</type> of words that will be merged into the
            string.  <parameter>argc</parameter> is a count of the number of words,
            and <parameter>argv</parameter> is a pointer to an array of pointers to the
            words stored as <literal>NULL</literal> terminated strings.
            The return value is the final string representation of the list after the
            merge operation has been performed.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLInterpreter(3),
CTCLInterpreterObject(3),
Tcl_Free(3tcl)
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLChannel">
    <refmeta>
        <refentrytitle>CTCLChannel</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLChannel</refname>
        <refpurpose>
            Provide a C++ abstraction wrapper for Tcl Channels.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLChannel.h&gt;
...
class CTCLChannel : public CTCLInterpreterObject
{
public:

  CTCLChannel(CTCLInterpreter* pInterp,
              std::string      Filename,
              const char*      pMode,
              int              permissions);
  CTCLChannel(CTCLInterpreter* pInterp,
              int              argc,
              const char**           pargv,
              int              flags);
  CTCLChannel(CTCLInterpreter* pInterp,
              int              port,
              std::string      host)
  CTCLChannel(CTCLInterpreter* pInterp,
              int              port,
              Tcl_TcpAcceptProc* proc,
              ClientData       AppData);
  CTCLChannel(CTCLInterpreter* pInterp,
              Tcl_Channel      Channel);
  CTCLChannel(const CTCLChannel&amp; rhs);
  virtual ~CTCLChannel();

  Tcl_Channel getChannel() const;
  bool ClosesOnDestroy() const;

  int Read( void** pData, int nChars);
  int Write(const void* pData, int nBytes);

  bool atEof();
  void Flush();
  void Close();
  void Register();
  void SetEncoding(std::string Name);
  std::string GetEncoding();

    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The Tcl API supplies an I/O abstraction layer on top of the
            operating systems I/O subsystem.  This layer makes use of what Tcl documentation
            refers to a s <firstterm>channels</firstterm>. A channel represents a connection
            to an I/O endpoint (source or sink of data or both).  The <classname>CTCLChannel</classname>
            class allows you to wrap a C++ class around a Tcl channel.
        </para>
        <para>
            Using a <classname>CTCLChannel</classname>, rather than direct operating system
            I/O allows you to improve the portability of your program, as well as allowing
            I/O from the TCL scripting level to be cleanly mixed with I/O at the C/C++ level.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
  <function>CTCLChannel</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
              <type>std::string</type>      <parameter>Filename</parameter>,
              <type>const char</type>*      <parameter>pMode</parameter>,
              <type>int</type>              <parameter>permissions</parameter>);
  <function>CTCLChannel</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
              <type>int</type>              <parameter>argc</parameter>,
              <type>const char</type>**           <parameter>pargv</parameter>,
              <type>int</type>              <parameter>flags</parameter>);
  <function>CTCLChannel</function>(<type>CTCLInterpreter</type>  * <parameter>pInterp</parameter>,
              <type>int</type>              <parameter>port</parameter>,
              <type>std::string</type>      <parameter>host</parameter>);
  <function>CTCLChannel</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
              <type>int</type>              <parameter>port</parameter>,
              <type>Tcl_TcpAcceptProc</type>* <parameter>proc</parameter>,
              <type>ClientData</type>      <parameter>AppData</parameter>);
  <function>CTCLChannel</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
              <type>Tcl_Channel</type>      <parameter>Channel</parameter>);
  <function>CTCLChannel</function>(<type>const CTCLChannel</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            These constructors wrap a <classname>CTCLChannel</classname>
            object around a Tcl channel.  The variety of constructors reflects the
            variety of endpoints around which a <type>Tcl_Channel</type> can be
            wrapped.
        </para>
        <para>
            The first of the constructors attaches the object to a file via
            <function>Tcl_OpenFileChannel</function>.  <parameter>pInterp</parameter>
            is the channel the file is associated.  <parameter>Filename</parameter>
            is the name of the file the channel is connected to. <parameter>pMode</parameter>
            is the connection mode which can be any of of the mode values for the
            Tcl <command>open</command> scripting command.   <parameter>permissions</parameter>
            represents the permissions mask fo rthe file in POSIX format.  See
            open(2) for information about the possible mode bit values.
        </para>
        <para>
            The second form of the constructor connects a channel that is a pipe to a
            program.  The program and its command line arguments are specified
            via the <parameter>argc</parameter> and <parameter>pargv</parameter>
            parameters. The <parameter>flags</parameter> parameter specifies
            how the stdio channels of the program are or are not disposed into the
            channel.   Valid bits are:
            <literal>TCL_STDIN</literal>,
            <literal>TCL_STDOUT</literal>,
            <literal>TCL_STDERR</literal>,
            <literal>TCL_ENFORCE_MODE</literal>.  See the <function>Tcl_OpenCommandChannel</function>
            manpage for information about the meaning of these bits.
        </para>
        <para>
            The third form of the constructor constructs a channel that connects to a
            TCP/IP server, via <function>Tcl_OpenTcpClient</function>.  The
            <parameter>port</parameter> parameter specifies the port number on which the
            server is listening, while <parameter>host</parameter> is the name of the
            host to which the connection should be formed.  The host name can either be a
            DNS resolvable host name or the textual encoding of the TCP/IP address of the
            host (e.g. string("spdaq22.nscl.msu.edu") or string("35.9.56.56").
            This function will block until the connection is accepted by the server.
        </para>
        <para>
            The fourth form of the constructor creates a channel that is a Tcp/IP server.
            <parameter>port</parameter> is the port number on which the server listens
            for connections.
            <parameter>proc</parameter> is a function that will be called when a
            connection has been accepted by the Tcl event loop.
            <parameter>AppData</parameter> is application data that is passed, without
            interpretation to <parameter>proc</parameter>.  See the <function>Tcl_OpenTcpServer</function>
            manpage for more information about how the <parameter>proc</parameter> is
            called.
        </para>
        <para>
            The fifth form of the constructor creates a <classname>CTCLChannel</classname>
            object by wrapping an existing <type>Tcl_Channel</type>; <parameter>Channel</parameter>
            which has been obtained
            directly from the Tcl application programming interface.
        </para>
        <para>
            The final form of the constructor copies an existing <classname>CTCLChannel</classname>
            object so that the two objects refer to the same channel.  The object is created
            so that it will not close the channel on destruction.  Note however that the
            source channel may, depending on how it was constructed.  It is up to the
            application programmer to ensure that channels are closed at appropriate times.
        </para>
        <para>
        <programlisting>
  <type>Tcl_Channel</type> <function>getChannel</function>() const;
        </programlisting>
        </para>
        <para>
            Returns the underlying <type>Tcl_Channel</type> this object is
            wrapped around.  Once this is obtained, it can be usd in any
            Tcl API call that requires a channel.
        </para>
        <para>
        <programlisting>
  <type>bool</type> <function>ClosesOnDestroy</function>() const;
        </programlisting>
        </para>
        <para>
            When a <classname>CTCLChannel</classname> is copy constructed into
            being it is flagged such that destruction will not close the underlying channel.
            the return value from this function is <literal>true</literal> if the
            object will close the underlying channel on destruction and <literal>false</literal>
            if the object will not close the underlying channel on destruction.
        </para>
        <para>
        <programlisting>
  <type>int</type> <function>Read</function>( <type>void</type>** <parameter>pData</parameter>,
           <type>int</type> <parameter>nChars</parameter>);
  <type>int</type> <function>Write</function>(<type>const void</type>* <parameter>pData</parameter>,
           <type>int</type> <parameter>nBytes</parameter>);
        </programlisting>
        </para>
        <para>
            <function>Read</function> transfers data from the channel to the users's buffer;
            <parameter>pData</parameter>.  <parameter>nChars</parameter> is the number
            of characters of data that will be transferred.
            <function>Write</function> transfers <parameter>nBytes</parameter>
            <firstterm>bytes</firstterm> data to the chnnel from <parameter>pData</parameter>.
            Both function return the number of characters actually transferred.
            An important note about the <parameter>nChars</parameter> parameter:  If the
            channel is not opened as a binary channel, this parameter is the number of
            UTF-8 characters transferred.  Depending on the characters actually transmitted,
            this may  not be the same as the number of bytes transmitted.
            The return value is the number of units (bytes or characters) actually transferred.
        </para>
        <para>
        <programlisting>

  <type>bool</type> <function>atEof</function>();
        </programlisting>
        </para>
        <para>
            Returns <literal>true</literal> if the underlying channel is at the end of file.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>Flush</function>();
        </programlisting>
        </para>
        <para>
            Tcl channels are internally buffered. The <function>Flush</function> member
            flushes internal output buffers to the underlying I/O endpoint.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>Close</function>();
        </programlisting>
        </para>
        <para>
            Closes the underlying channel. Note that this is normally done on
            destruction unless the channel object was created via copy construction.
            If the channel was registered to be visible to the interpreter, it is
            unregistered as well.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>Register</function>();
        </programlisting>
        </para>
        <para>
            Makes the channel visible to the interpreter.  This allows the user
            to return the channel name to the script level at which point it can be
            used in Tcl script commands that operate on channels.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>SetEncoding</function>(<type>std::string</type> <parameter>Name</parameter>);
  <type>std::string</type> <function>GetEncoding</function>();
        </programlisting>
        </para>
        <para>
            These functions allow the user to get and set the encoding for the channel.
            See the <command>fconfigure</command> Tcl man page for more information about this.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
close(3tcl),
fconfigure(3tcl),
open(2),
Tcl_OpenCommandChannel(3tcl),
Tcl_OpenFileChannel(3tcl),
Tcl_OpenTcpClient(3tcl),
Tcl_OpenTcpServer(3tcl)
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLFileHandler">
    <refmeta>
        <refentrytitle>CTCLFileHandler</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLFileHandler</refname>
        <refpurpose>
            Base class for building object oriented Tcl File event handlers.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLFileHandler.h&gt;
...

class CTCLFileHandler  : public CTCLInterpreterObject
{
  CTCLFileHandler(CTCLInterpreter* pInterp,
                   UInt_t am_nFid = STDIN_FILENO);
  CTCLFileHandler(CTCLInterpreter* pInterp,
                  FILE* pFile);
  CTCLFileHandler (const CTCLFileHandler&amp; aCTCLFileHandler );
  ~CTCLFileHandler ( );
  CTCLFileHandler&amp; operator= (const CTCLFileHandler&amp; aCTCLFileHandler);
  int operator== (const CTCLFileHandler&amp; aCTCLFileHandler) const;

  UInt_t getFid() const;

  virtual   void operator() (int mask)   = 0;

  void Set (int mask)  ;
  void Clear ()  ;
};

    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Tcl supplies an event loop.  It is possible to add events specifications
            to this loop.  One very useful event type is based on readability or writability
            of a file descriptor.   The <classname>CTCLFileHandler</classname> allows you
            to create an object oriented file handler, and register it with the event
            loop so that you can gain control when, for example, a file becomes readable.
        </para>
        <para>
            As <classname>CTCLFileHandler</classname> is an abstract base class,
            it is necessary to create a derived class.  The derived class should
            implement the <function>operator()</function> which will be called
            when the specific event is fired.  An instance of this derived class should
            be created, and then the <function>Set</function> and <function>Clear</function>
            members used to establish and remove the event handler.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
  <function>CTCLFileHandler</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
                   <type>UInt_t</type> <parameter>nFid</parameter> = <literal>STDIN_FILENO</literal>);
  <function>CTCLFileHandler</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
                  <type>FILE</type>* <parameter>pFile</parameter>);
  <function>CTCLFileHandler</function> (const <type>CTCLFileHandler</type>&amp; <parameter>aCTCLFileHandler</parameter> );
        </programlisting>
        </para>
        <para>
            Constructs a file handler object.  <parameter>pInterp</parameter> is a
            pointer to the interpreter on which the file handler will be registered.
            The file can be specified either by <parameter>nFid</parameter>, a file
            descriptor, or <parameter>pFile</parameter> an stdio File stream pointer.
        </para>
        <para>
            A copy constructor allows the creation of a copy of the file handler object
            given <parameter>aCTCLFileHandler</parameter> an existing one.  This is normally
            not useful.
        </para>
        <para>
            <programlisting>
  <type>CTCLFileHandler</type>&amp; <function>operator=</function> (const <type>CTCLFileHandler</type>&amp; <parameter>aCTCLFileHandler</parameter>);
  <type>int</type> <function>operator==</function> (const <type>CTCLFileHandler</type>&amp; <parameter>aCTCLFileHandler</parameter>) const;
            </programlisting>
        </para>
        <para>
            These functions support assignment and equality comparison.  Note that these functions
            are usually not very useful for file handlers.
        </para>
        <para>
        <programlisting>
  <type>UInt_t</type> <function>getFid()</function> const;
        </programlisting>
        </para>
        <para>
            Returns the file id that is associated with the event.
        </para>
        <para>
            <programlisting>
  virtual   <type>void</type> <function>operator</function>() (<type>int</type> <parameter>mask</parameter>)   = 0;
            </programlisting>
        </para>
        <para>
            The user's derived class must override this to provide the desired
            funtionality when event fires.  <parameter>mask</parameter>
            indicates which event fired the function and can be an or of the following:
            <literal>TCL_READABLE</literal> if the file can be read without blocking,
            <literal>TCL_WRITABLE</literal> if the file can be written without blocking,
            or <literal>TCL_EXCEPTION</literal> if some exceptional condition occured on the
            file.
        </para>
        <para>
            <programlisting>
  <type>void</type> <function>Set</function> (<type>int</type> <parameter>mask</parameter>)  ;
  <type>void</type> <function>Clear</function> ()  ;
        </programlisting>
        </para>
        <para>
            <function>Set</function> establishes the event handler for the set of conditions
            described in <parameter>mask</parameter>.  The valid bits for <parameter>mask</parameter>,
            are described in the documentation for the <parameter>mask</parameter>
            parameter to <function>operator()</function>.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLObject(3),
CTCLInterpreter(3)
Tcl_CreateFileHandler(3tcl),
Tcl_DeleteFileHandler(3tcl)
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLIdleProcess">
    <refmeta>
        <refentrytitle>CTCLIdleProcess</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLIdleProcess</refname>
        <refpurpose>
            Allows the establishment of an executable object that
            can be scheduled to be invoked when the Tcl/Tk intperpreter
            has no events that require processing.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLIdleProcess.h&gt;

class CTCLIdleProcess : protected CTCLTimer
{
public:
  CTCLIdleProcess(CTCLInterpreterObject* pObject);
  CTCLIdleProcess(CTCLInterpreter* pInterp);
  virtual ~CTCLIdleProcess();

  void Set();
  void Clear();
  virtual void operator()() = 0;
};
    </programlisting>

    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            While Tcl provides a mechanism for scheduling the execution of
            a function when the interpreter main loop is idle (no pending events),
            this is not suitable for processes that may need to be rescheduled.
            Therefore, <classname>CTCLIdleProcess</classname> is actually based on a
            timer dispatch where the delay interval is 0ms.
        </para>
        <para>
        <classname>CTCLIdleProcess</classname>
        provides an abstract base class for creating function like classes that
        are 'called' to run interleaved with the interpreter.
        A function like class is one that implements <classname>operator()</classname>
        (see REFERENCES) below.  You can create an idle processor by creating
        a subclass of <classname>CTCLIdleProcess</classname> overriding
        <classname>operator()</classname>, creating an instance of that new class,
        and invoking the <function>Set()</function> function to schedule the
        execution of the <function>operator()</function>.  Note that
        It is possible for the code in your <function>operator()</function> to
        reschedule itself by calling <function>Set()</function>.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
  <function>CTCLIdleProcess</function>(<type>CTCLInterpreterObject</type>* <parameter>pObject</parameter>);
  <function>CTCLIdleProcess</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>);
        </programlisting>
        </para>
        <para>
            Creates a <classname>CTCLIdleProcess</classname> and initializes the timer on which this
            is based. <parameter>pInterp</parameter> is the interpreter that will schedule
            the object's <function>operator()</function>.  <parameter>pObject</parameter>
            points to an interpreter object who's interpreter will schedule the
            <function>operator()</function> to run.
        </para>
        <para>
            <programlisting>
  <type>void</type> <function>Set</function>();
  <type>void</type> <function>Clear</function>();
            </programlisting>
        </para>
        <para>
            These function control the scheduling of the <function>operator()</function>
            call. <function>Set</function> schedules the function to be called pretty much
            the next time the interpreter loop is intered, while <function>Clear</function>
            cancels a pending schedule.
        </para>
        <para>
            <programlisting>
  virtual <type>void</type> <function>operator()</function>() = 0;
        </programlisting>
        </para>
        <para>
            This pure virtual function is overridden by your idle processor to
            provide the behavior of the idle processor.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLTimer(3),
Tcl_CreateTimerHandler(3tcl),
Tcl_DoWhenIdle(3tcl),

        </para>
    </refsect1>
    <refsect1>
        <title>REFERENCES</title>
        <para>
            <programlisting>
Musser, Derge, Saini: <parameter>STL Tutorial and Reference Guide</parameter>
Addison-Wesley Professional Computing Series; 2001 ISBN 0-201-37923-6
See section 2.4 for a description and discussion of function objects.
            </programlisting>
        </para>
    </refsect1>
</refentry>



<refentry id="manpage.CTCLTimer">
    <refmeta>
        <refentrytitle>CTCLTimer</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLTimer</refname>
        <refpurpose>
            Abstract base class for C++ objects attached to timer events.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLTimer.h&gt;
...
class CTCLTimer  : public CTCLInterpreterObject
{
public:
  CTCLTimer ();
  CTCLTimer(CTCLInterpreter* pInterp, UInt_t nMsec = 0);
  virtual ~CTCLTimer ( );


  Tk_TimerToken getToken() const;
  UInt_t getMsec() const;
  Bool_t IsSet() const;

  virtual   void operator() ()   = 0;

  void Set ()  ;
  void Set(UInt_t nms);
  void Clear ()  ;
};


    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Tcl/Tk provide a mechanism for scheduling functions to be executed
            after a time delay specified in milliseconds.   The <classname>CTCLTimer</classname>
            class is an abstract base class that provides an interface into the API
            for that facility.  To use <classname>CTCLTimer</classname> you must
            create a class derived from <classname>CTCLTimer</classname> that
            overrides and implement the <function>operator()</function> function.
            Create an object from the resulting function class.  Use the object's
            <function>Set</function> and <function>Clear</function> members to schedule
            or cancel a scheduled execution.  The code fragment
            example below shows how to do this
            to create a class that periodically emits the text "Tick" to stderr.
            Many #include directives are missing for brevity.
            </para>
            <informalexample>
            <programlisting>
// Interface to <classname>Ticker</classname> normally goes in a header.
class Ticker : public CTCLTimer
{
public:
    Ticker(CTCLInterpreter* pInterp, int seconds);
    virtual ~Ticker();

    virtual void operator()();
};
...
// Implementation of <classname>Ticker</classname> normally goes in a .cpp

// Constructor of Ticker:

Ticker::Ticker(int seconds) :
    CTCLTimer(pInterp, seconds*1000)
{
    Set();                   // Schedule first one.
}
// Destructor.. chain to base class.
Ticker::~Ticker() {}

// called when timer goes off:
void
Ticker::operator()() {
    cerr &lt;&lt; "Tick\n";
    Set();                 // Schedule next one.
}
...


Ticker Tick(pInterp, 1);  // Tick every second.

            </programlisting>
            </informalexample>
        
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <informalexample>
        <programlisting>
<function>CTCLTimer</function> ();
<function>CTCLTimer</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
          <type>UInt_t</type> <parameter>nMsec</parameter> = <literal>0</literal>);
          </programlisting>
        </informalexample>
          <para>
            Construct timer objects.  The first form of the constructor creates a timer
            object that must be later bound into an interpreter via a call to
            <classname>CTCLInterpreterObject</classname>::<function>Bind</function>.
            The seconf form of the contructor creates a timer object that is already
            bound to <parameter>pInterp</parameter> and has an initial schedule delay
            of <parameter>nMsec</parameter>.
          </para>
          <informalexample>
          <programlisting>
  Tk_TimerToken getToken() const;
  UInt_t getMsec() const;
          </programlisting>
          </informalexample>
          <para>
            These two members access internal state of the object.
            <function>getToken</function> returns the <type>Tk_TimerToken</type>
            associated with the timer object.  This is the Tcl/Tk token that
            identifies the timer request to the interpreter.
            <function>getMsec</function> retrieves the current value of the delay parameter
            in milliseconds.
          </para>
          <informalexample>
          <programlisting>
  virtual   void operator() ()   = 0;
        </programlisting>
          </informalexample>
        <para>
            This function must be overidden and implemented in concrete timer classes.
            See the example in DESCRIPTION above.
        </para>
        
        <informalexample>
        <programlisting>

  void Set ()  ;
  void Set(UInt_t nms);
  Bool_t IsSet() const;
        </programlisting>
        </informalexample>
        
        <para>
            <function>Set</function> schedules the object for execution.  If
            <parameter>nms</parameter> is provided it is saved as the scheduling
            parameter and determines the delay
            in milliseconds before <function>operator()</function> is
            next called.  If not provided, the most recently used delay will be
            used again.
        </para>
        <para>
            <function>IsSet</function> returns <literal>kfTRUE</literal> if the
            timer is currently pending, or <literal>kfFALSE</literal> if no pending
            timer request is active.
        </para>
        <para>
        <informalexample>
        <programlisting>
  void Clear ()  ;
        </programlisting>
        </informalexample>
        </para>
        <para>
           If a Timer request is pending, cancels it.  If no timer request is pending,
            this function does nothing, and does not report an error.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLInterpreterObject(3)
        </para>
    </refsect1>
    <refsect1>
        <title>REFERENCES</title>
        <para>
            <informalexample>
            <programlisting>
Musser, Derge, Saini: <parameter>STL Tutorial and Reference Guide</parameter>
Addison-Wesley Professional Computing Series; 2001 ISBN 0-201-37923-6
See section 2.4 for a description and discussion of function objects.
            </programlisting>
            </informalexample>
        </para>
    </refsect1>
</refentry>
    <refentry id="manpage.CTCLLiveEventLoop">
      <refmeta>
         <refentrytitle>CTCLLiveEventLoop</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CTCLLiveEventLoop</refname>
	 <refpurpose>Run Tcl with event loop.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CTCLLiveEventLoop.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CTCLLiveEventLoop</classname></ooclass>
            <methodsynopsis>
                <modifier>static</modifier> <type>CTCLLiveEventLoop*</type>
                                            <methodname>getInstance</methodname>
                                            <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>start</methodname>
                                  <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>start</methodname>
                <methodparam>
                    <type>CTCLInterpreter*</type> <parameter>pInterp</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>stop</methodname>
                                  <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>long</type> <methodname>setStopLatency</methodname>
                <methodparam>
                    <type>long</type> <parameter>ms</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>long</type> <methodname>getStopLatency</methodname>
                                <void /> <modifier>const</modifier>
            </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            The Tcl/Tk applications programming interfaces provides an event loop.
            In the case of Tk programs, the event loop is active once the Tk
            package starts.  For pure Tcl (non GUI) programs, the event loop
            is not active unless the script explicitly enters the event loop
            via e.g. <command>vwait</command>.
         </para>
         <para>
            <command>vwait</command> and other pure Tcl commands that enter
            the event loop block the interpreter from processing commands on
            stdin while the loop is running.  For some Tcl based data acquisition
            programs this is not acceptable.  For example, a readout program may
            want to accept commands on the command line while doing some periodic
            processing.  This class provides the ability to do this.
         </para>
         <para>
            The class is a singleton pattern instance, which means that you cannot
            actually construct an instance, but must use the <methodname>getInstance</methodname>
            method to get a pointer to the single instance of the singleton.
            The class works by establishing an event handler on stdin,
            and manually running the event loop at the C++ level.
            The C++ event loop and stdin input handler do prompting analagous
            to that of tclsh.  When the stdin event handler has accumulated a
            syntactically complete command it passes that on to the interpreter
            for evaluation, reporting the result to stdout.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <methodsynopsis>
                <modifier>static</modifier> <type>CTCLLiveEventLoop*</type>
                                            <methodname>getInstance</methodname>
                                            <void />
            </methodsynopsis>
            <para>
                Returns a pointer to the singleton instance of the
                live event loop object.  The object is a singleton because
                while each application may have more than one interpreter,
                there is only at most one event loop.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>start</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Starts the event loop.  This will not return to the caller
                until some external force has stopped the event loop.
                External forces include the user closing stdin, or
                the event loop being asked to stop.
            </para>
            <para>
                In this invocation, the commands accumulated on stdin are
                dispatched to the interpreter that was bound to the
                <classname>CTCLApplication</classname> object.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>start</methodname>
                <methodparam>
                    <type>CTCLInterpreter*</type> <parameter>pInterp</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Starts the event loop.  Commands accumulated by the stdin event
                handler are submited to <parameter>pInterp</parameter> for
                execution.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>stop</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Requests the event loop to stop processing.
                See below for the latency between this request and the
                actual stop time. Note that a different thread can call this
                than the one running the target interpreter.
            </para>
            <methodsynopsis>
                <type>long</type> <methodname>setStopLatency</methodname>
                <methodparam>
                    <type>long</type> <parameter>ms</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                The event loop waits for events with a timeout. When a wait
                has completed, if there are events in the queue, they are all
                processed.  After processing any pending events, the event loop
                determines if a stop has been requested, and if so, returns to
                its caller.
            </para>
            <para>
                The wait timeout is set by this member function to
                <parameter>ms</parameter> milliseconds.  This effectively sets
                an estimated latency between the <methodname>stop</methodname>
                member being called, and the event loop actually exiting.
            </para>
            <para>
                The function returns the prior latency setting.
            </para>
            <methodsynopsis>
                <type>long</type> <methodname>getStopLatency</methodname>
                                <void /> <modifier>const</modifier>
            </methodsynopsis>
            <para>
                Returns the current value of the latency setting.
                See <methodname>setStopLatency</methodname> above for
                more information. 
            </para>
      </refsect1>
      <refsect1>
         <title>EXAMPLES</title>
         <para>
            The sample below is a stock tclsh that always runs the event loop
             in the background.  It is installed in the NSCLDAQ
             <filename>bin</filename> directory as
            <application>evttclsh</application>
         </para>
         <example>
            <title>evttclsh</title>
            <programlisting>
#include &lt;TCLApplication.h&gt;
#include &lt;TCLLiveEventLoop.h&gt;

class evttclsh : public CTCLApplication
{
public:
  virtual int operator()();
};

int
evttclsh::operator()()
{
  CTCLLiveEventLoop* pLoop = CTCLLiveEventLoop::getInstance();
  pLoop-&gt;start();
  return TCL_ERROR;
}

CTCLApplication* gpTCLApplication = new evttclsh;

            </programlisting>
         </example>
      </refsect1>
   </refentry>


    <refentry id="manpage.ctclchannelcommander">
      <refmeta>
         <refentrytitle>CTCLChannelCommander</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CTCLChannelCommander</refname>
	 <refpurpose>Accept commands on a Tcl channel from the event loop.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CTCLChannelCommander.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CTCLChannelCommander</classname></ooclass>
            <constructorsynopsis>
                <methodname>CTCLChannelCommander</methodname>
                <methodparam>
                    <type>CTCLInterpreter*</type> <parameter>interp</parameter>
                </methodparam>
                <methodparam>
                    <type>Tcl_Channel</type>      <parameter>channel</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~CTCLChannelCommander</methodname>
                                             <void />
            </destructorsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>start</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>stop</methodname>
                                             <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>Tcl_Channel</type>  <methodname>getChannel</methodname>
                                          <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>onInput</methodname>
                                             <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>onInputException</methodname>
                                                               <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>onEndFile</methodname>
                                                               <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>onCommand</methodname>
                                             <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>returnResult</methodname>
                                             <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>prompt1</methodname>
                                <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>prompt2</methodname>
                                             <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>sendPrompt</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>prompt</parameter>
                </methodparam>
            </methodsynopsis>


         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            The <classname>CTCLChannelCommander</classname> is a class that
            registers an input event handler for a Tcl channel.  When input
            is available on the channel, a line of text is read, and appended
            to a command under construction.  When the command is syntactically
            complete, it is dispatched to a Tcl interpreter for execution.
         </para>
         <para>
            The subclass <classname>CTCLStdioCommander</classname> is specifically
            tailored to accept commands on stdin.  ALong with the server listener
            <classname>CTCLServer</classname>, <classname>CTCLTcpServerInstance</classname>
            is tailored to accpet commands on a socket.
         </para>
         <para>
            Many aspects of the class are tailorable by overriding the various
            methods in derived classes.  The class is capable of generating prompts
            in case the channel is interactive.  The classs can also return the
            results of commands to the client over the medium of its choice.
            End file and exception handling can be simlarly tailored.
         </para>
         <para>
            When deriving a specific class be sure you understand the default actions
            of all of the base class members. You may save a great deal of work by
            carefully chosing exactly which members to override, or generate a
            great deal of work by making poor choices.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
           <methodsynopsis>
                <methodname>CTCLChannelCommander</methodname>
                <methodparam>
                    <type>CTCLInterpreter*</type> <parameter>interp</parameter>
                </methodparam>
                <methodparam>
                    <type>Tcl_Channel</type>      <parameter>channel</parameter>
                </methodparam>
            </methodsynopsis>
           <para>
            Constructs a new channel commander. Activation of the commander is
            a two step process.  First the commander is constructed, second
            it <methodname>start</methodname> method is called to register the
            event handlers.  
           </para>
           <para>
            <parameter>interp</parameter> is a pointer to the interpreter
            channel on to which the commands will be dispatched.
            <parameter>channel</parameter> is the channel from which commands
            will be accepted.
           </para>
           <para>
            The application must also be visiting the event loop for
            commands to be processed from the
            <parameter>channel</parameter>.
            Tk applications automatically run the event loop.
            Pure Tcl applications run the event loop only when
            <command>vwait</command> is waiting, while the
            special shell or tcl applications based around
            <classname>CTCLLiveEventLoop</classname> run the
            event loop automatically just like Tk does.
           </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>start</methodname>
                <void />
            </methodsynopsis>
            <para>
                Enables processing of commands from the channel.  When
                the event loop is entered, if the channel is readable,
                control will be to
                <methodname>onInput</methodname> in object context.
                It is not considered an error to call
                <methodname>start</methodname> when event processing
                is in progress.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>stop</methodname>
                                             <void />
            </methodsynopsis>
            <para>
                Requests channel processing be disabled.  The event handlers
                that arrange for control to be dispatched to the
                <methodname>onInput</methodname>
                method are disabled.  The channel remains open and must
                be closed (if desired) by any client software.
            </para>
            <methodsynopsis>
                <type>Tcl_Channel</type>  <methodname>getChannel</methodname>
                                          <void /> <modifier>const</modifier>
            </methodsynopsis>
            <para>
                Returns the channel from which commands are being accepted.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>onInput</methodname>
                                             <void />
            </methodsynopsis>
            <para>
                This member function is called when data can be read from the
                input channel.  The function attempts to read a line of text.
                The text is appended to a command under construction and,
                if <function>Tcl_CommandComplete</function> says that
                string is a syntactically complete command,
                <methodname>onCommand</methodname> is invoked to execute the
                command.  
            </para>
            <para>
                All of this command acquisition and exection is also mixed up
                with prompting.
                <methodname>prompt1</methodname>
                is called when the object is ready to get  a new command, and
                <methodname>prompt2</methodname> is called when the
                object is ready to accept the next line of a multi-line command.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>onInputException</methodname>
                                                               <void />
            </methodsynopsis>
            <para>
                Called when an exception condition is detected on the channel. The default implementation
                calls
                <methodname>onEndFile</methodname>
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>onEndFile</methodname>
                                                               <void />
            </methodsynopsis>
            <para>
                Called when reads of the channel indicate an end file condition.
                <methodname>onInputException</methodname>'s default implementation
                also calls this.  The default behavior is to invoke
                <methodname>stop</methodname> so that no additional events will
                be posted.  This is the normal and reasonable behavior because
                a channel with an endfile condition continously generates
                readable events.
            </para>
            <para>
                The channel remains open.  It is always up to client software to
                close the channel.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>onCommand</methodname>
                                             <void />
            </methodsynopsis>
            <para>
                Called when a complete command has been accepted.  Complete in this
                case means syntactically complete.  It does not imply correctness,
                or even proper number of arguments.
            </para>
            <para>
                Default behavior is to submit the command string to the
                interpreter. Once the command has been executed,
                <methodname>returnResult</methodname>
                is executed to allow the command result to be reported
                if desired.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>returnResult</methodname>
                                             <void />
            </methodsynopsis>
            <para>
                By default this does nothing.  It is provided to allow subclasses
                to tailore what is done with command results.  For example,
                the
                <classname>CTCLStdioCommander</classname>
                class reports the result on
                <literal>stdout</literal>.
                <classname>CTCLTcpServerInstance</classname> on the other hand
                reports the result back to the client over the socket.
            </para>
            <para>
                The <methodname>GetResultString</methodname> method of the
                interpreter object (the pointer <varname>m_pInterp</varname>
                is a pointer to the interpreter object) should be used to
                get the result string.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>prompt1</methodname>
                                <void />
            </methodsynopsis>
            <para>
                Called when its time to prompt for the first line of a command.
                This calls
                <methodname>prompt1String</methodname> to get the prompt string,
                and calls
                <methodname>sendPrompt</methodname> to actually emit the prompt.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>prompt2</methodname>
                                             <void />
            </methodsynopsis>
            <para>
                Called when its time to prompt for additional linesof a command.
                This calls
                <methodname>prompt2String</methodname> to get the prompt string
                and calls
                <methodname>sendPrompt</methodname> to actually emit the prompt.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>sendPrompt</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>prompt</parameter>
                </methodparam>
            </methodsynopsis>
       </refsect1>
      <refsect1>
        <title>Prompting</title>
        <para>
            The class provides a framework for prompting interactive channels.
            This frameworks is based on two prompt strings that can be gotten
            via calls to
            <methodname>prompt1String</methodname> and
            <methodname>prompt2String</methodname>
            respectively.
        </para>
        <para>
            The first of these prompts is emitted when the software is
            ready to accept the first line of a new command.
            By default it is the text "<literal>% </literal>".  Scripts
            can customize this prompt by defining the
            variable <varname>tcl_prompt1</varname> to be a script
            whose returned value is the prompt.
        </para>
        <para>
            The second of these prompts is emitted when the software
            is ready to accept continuation lines of multiline commands.
            By default it is the text "<literal>%_ </literal>".
            Scripts can customize this prompt by defining the
            variable <varname>tcl_prompt2</varname> to be a script
            whose returned value is the desired prompt.
        </para>
      </refsect1>
   </refentry>
    <refentry id="manpage.CTCLStdioCommander">
      <refmeta>
         <refentrytitle>CTCLStdioCommander</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CTCLStdioCommander</refname>
	 <refpurpose>Event driven command input on stdin/stdout</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CTCLStdioCommander.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CTCLStdioCommander</classname></ooclass>
            <constructorsynopsis>
                <methodname>CTCLStdioCommander</methodname>
                <methodparam>
                    <type>CTCLInterpreter*</type> <parameter>pInterp</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~CTCLStdioCommander</methodname>
                                             <void />
            </destructorsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>sendPrompt</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>prompt</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>returnResult</methodname>
                                             <void />
            </methodsynopsis>

         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            Provides a commander that can be hooked to the event loop to allow
            event loop driven applications to continue to process commands on
            stdin/stdout as interactive shells do.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <methodsynopsis>
                <methodname>CTCLStdioCommander</methodname>
                <methodparam>
                    <type>CTCLInterpreter*</type> <parameter>pInterp</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Constructs a commander.  <parameter>pInterp</parameter> is the
                interpreter to which the complete commands will be submitted.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>sendPrompt</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>prompt</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Overrides the base class <methodname>sendPrompt</methodname>
                method by sending the requested <parameter>prompt</parameter>
                string to the <type>Tcl_Channel</type> Tcl has open on
                <literal>stdout</literal>. The channel is also flushed to
                ensure that the prompt is made immediately visible.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>returnResult</methodname>
                                             <void />
            </methodsynopsis>
            <para>
                Overrides the base class member.
                Retrieves the result from the interpreter, appends a newline
                character and passes the resulting string to
                <methodname>sendPrompt</methodname> which makes the result
                visible on stdout.
            </para>
      </refsect1>
   </refentry>


    <refentry id="manpage.CTCLServer">
      <refmeta>
         <refentrytitle>CTCLServer</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CTCLServer</refname>
	 <refpurpose>Listener for a Tcl server.</refpurpose>
      </refnamediv>     
      <refsynopsisdiv>
         <programlisting>
#include &lt;CTCLServer.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CTCLServer</classname></ooclass>
            <constructorsynopsis>
                <methodname>CTCLServer</methodname>
                <methodparam>
                    <type>CTCLInterpreter*</type> <parameter>pInterp</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>port</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~CTCLServer</methodname>
                                             <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>void</type>
                <methodname>instanceExit</methodname>
                <methodparam>
                    <type>CTCLTcpServerInstance*</type> <parameter>pInstance</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type>
                <methodname>shutdown</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>protected virtual</modifier>
                <type>bool</type> <methodname>allowConnection</methodname>
                <methodparam>
                    <type>Tcl_Channel</type> <parameter>connection</parameter>
                </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>hostname</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>protected virtual</modifier>
                <type>CTCLTcpServerInstance*</type>
                <methodname>createInstance</methodname>
                <methodparam>
                    <type>Tcl_Channel</type> <parameter>connection</parameter>
                </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>hostname</parameter>
                </methodparam>
            </methodsynopsis>
 
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            Tcl servers allow a Tcp/Ip client to connect to a tcl application
            and poke commands at it.  While this is a very powerful communications
            mechanism, it should be used very cautiously as it can also be quite
            dangerous (imagine a client pushing a command like
            <command>exec /bin/bash -c rm -rf ~</command> for example).
         </para>
         <para>
            <classname>CTCLServer</classname> is a class that provides the listener
            portion of the server.  The application that uses this must execute
            a Tcl event loop in a timely fashion.
            <classname>CTCLServer</classname> processes connections and creates,
            where appropriate <classname>CTCLTcpServerInstance</classname> objects
            that handle communication with clients.
            The server object maintains a directory of server instances so that when
            asked to shutdown it can shutdown all server instances as well.
         </para>
         <para>
            The class provides strategy pattern hooks to support arbitrary
            authorization models, as well as the production of any subclass
            of <classname>CTCLTcpServerInstance</classname> to process
            the commands.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <methodsynopsis>
                <methodname>CTCLServer</methodname>
                <methodparam>
                    <type>CTCLInterpreter*</type> <parameter>pInterp</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>port</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Constructs and activates a server object. Activation means that
                the Tcl event loop can dispatch events for client connections
                to the object for processing.
                <parameter>pInterp</parameter> is the interpreter this server
                is supposed to be servicing.  In the standard scheme, this is
                the interpreter to which commands will be dispatched.
                <parameter>port</parameter> is the Tcp/IP port on which the
                server will listen for connections.
            </para>
            <methodsynopsis>
                <type>void</type>
                <methodname>instanceExit</methodname>
                <methodparam>
                    <type>CTCLTcpServerInstance*</type> <parameter>pInstance</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                The server maintains a directory of server instances.  When server
                instances exit they must call this function in the server listener
                passing a pointer to themselves (<varname>this</varname>) as a
                parameter.  This function locates the instance in the
                directory, removes it from the directory and
                <emphasis>deletes that object</emphasis>.
            </para>
            <para>
                Having called this, the server instance should return
                immediately as its object context has become invalid.
                If the server listener object is asked to shutdown, it will
                also call <methodname>instanceExit</methodname> on all
                instances to shut them down as well.
            </para>
            <methodsynopsis>
                <type>void</type>
                <methodname>shutdown</methodname>
                <void />
            </methodsynopsis>
            <para>
                Stops listening for connections on the server port and
                shuts down all instances by invoking
                <methodname>instanceExit</methodname> on them.
            </para>
            <methodsynopsis>
                <modifier>protected virtual</modifier>
                <type>bool</type> <methodname>allowConnection</methodname>
                <methodparam>
                    <type>Tcl_Channel</type> <parameter>connection</parameter>
                </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>hostname</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Called at connection time to determine if the connection should
                be allowed.  <parameter>connection</parameter> is the
                <type>Tcl_Channel</type> that is open on the client.
                overrides of this are perfectly free to do any sort of
                communication back and fort with the client to determine
                its elligibility to connect. 
            </para>
            <para>
                <parameter>hostname</parameter> is the name of the host
                that is connecting.  This allows a host based authentication
                scheme to be developed.
            </para>
            <para>
                The function must return <literal>true</literal> to accept the
                connection and <literal>false</literal> to deny it.
            </para>
            <methodsynopsis>
                <modifier>protected virtual</modifier>
                <type>CTCLTcpServerInstance*</type>
                <methodname>createInstance</methodname>
                <methodparam>
                    <type>Tcl_Channel</type> <parameter>connection</parameter>
                </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>hostname</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Called to create a client instance.  The client instance is responsible
                for interacting with the client to do whatever communication is needed.
                By making this virtual, any type descended from
                <classname>CTCLTcpServerInstance</classname> can be created.
            </para>
            <para>
                <parameter>connection</parameter> is the <type>Tcl_Channel</type>
                open on the client.
                <parameter>hostname</parameter> is the host that is connecting.
            </para>
      </refsect1>

   </refentry>

    <refentry id="manpage.CTCLTcpServerInstance">
      <refmeta>
         <refentrytitle>CTCLTcpServerInstance</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CTCLTcpServerInstance</refname>
	 <refpurpose>Channel commander that is a server instance for <classname>CTCLServer</classname></refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CTCLTcpServerInstance.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CTCLTcpServerInstance : public CTCLChannelCommander</classname></ooclass>
            <constructorsynopsis>
                <methodname>CTCLTcpServerInstance</methodname>
                <methodparam>
                    <type>CTCLInterpreter*</type> <parameter>pInterp</parameter>
                </methodparam>
                <methodparam>
                    <type>Tcl_Channel</type> <parameter>connection</parameter>
                </methodparam>
                <methodparam>
                    <type>CTCLServer*</type> <parameter>pServer</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~CTCLTcpServerInstance</methodname>
                                             <void />
            </destructorsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                            <methodname>onEndFile</methodname>
                            <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                        <methodname>returnResult</methodname>
                                        <void />
            </methodsynopsis>

         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            Server instance that takes client commands and submits them to
            an interpreter.  The results of each command are sent back to the
            client. At this point the client can only look at the
            result value to determine if there was an error as no error indication
            is passed back.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <constructorsynopsis>
                <methodname>CTCLTcpServerInstance</methodname>
                <methodparam>
                    <type>CTCLInterpreter*</type> <parameter>pInterp</parameter>
                </methodparam>
                <methodparam>
                    <type>Tcl_Channel</type> <parameter>connection</parameter>
                </methodparam>
                <methodparam>
                    <type>CTCLServer*</type> <parameter>pServer</parameter>
                </methodparam>
            </constructorsynopsis>
            <para>
                Constructs a new server instance.
                <parameter>pInterp</parameter> is the interpreter to which
                commands should be directed.
                <parameter>connection</parameter> is the <type>Tcl_Channel</type>
                that represents the Tcp/IP connection to the client.
                <parameter>pServer</parameter> is the TCL server object
                that starts us.  That server's
                <methodname>instanceExit</methodname> member should be called
                to shut down and clean up this object.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                            <methodname>onEndFile</methodname>
                            <void />
            </methodsynopsis>
            <para>
                Override to end of file handling.  Closes the
                channel and invokes the
                server listener's <methodname>instanceExit</methodname>
                method to get ourselves deleted.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                        <methodname>returnResult</methodname>
                                        <void />
            </methodsynopsis>
            <para>
                Returns a command result by fetching it from the interpreter
                and sending it back to the client on the socket.
            </para>
      </refsect1>
   </refentry>

    <refentry id="manpage.citemconfiguration">
      <refmeta>
         <refentrytitle>CItemConfiguration</refentrytitle>
         <manvolnum>3tcl</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CItemConfiguration</refname>
     <refpurpose>Hold a configuration</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CItemConfiguration.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CItemConfiguration</classname></ooclass>
            <constructorsynopsis>
                <methodname>CItemConfiguration</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CItemConfiguration</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CItemConfiguration&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier>   <methodname>~CItemConfiguration</methodname>
                <void />
                </destructorsynopsis>
            <methodsynopsis>
                <type>CItemConfiguration&amp;</type>
                <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>CItemConfiguration&amp;</type> <parameter>rhs</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>int</type>
                <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CItemConfiguration&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                <modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CItemConfiguration&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                <modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type>
                <methodname>getName</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type> <methodname>cget</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>ConfigurationArray</type> <methodname>cget</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>getIntegerParameter</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>unsigned int</type> <methodname>getUnsignedParameter</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>bool</type>    <methodname>getBoolParameter</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>double</type> <methodname>getFloatParameter</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>std::vector&lt;int&gt;</type> <methodname>getIntegerList</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addParameter</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>typeChecker</type> <parameter>checker</parameter>
                    </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type>  <parameter>defaultValue</parameter>
                    <initializer>std::string("")</initializer>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>clearConfiguration</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>configure</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>value</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>bool</type> <methodname>isInteger</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type>  <parameter>value</parameter>
                    </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>bool</type> <methodname>isBool</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type>  <parameter>value</parameter>
                    </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>bool</type> <methodname>isEnum</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type>  <parameter>value</parameter>
                    </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>bool</type> <methodname>isFloat</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type>  <parameter>value</parameter>
                    </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>bool</type> <methodname>isList</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type>  <parameter>value</parameter>
                    </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier> <type>bool</type>
                <methodname>isBoolList</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type>  <parameter>value</parameter>
                    </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>bool</type> <methodname>isIntList</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type>  <parameter>value</parameter>
                    </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier> <type>bool</type>
                <methodname>isStringList</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type>  <parameter>value</parameter>
                    </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            <classname>CItemConfiguration</classname> captures the configuration of an
            item.   A configuration is a set of name-value pairs.  
         </para>
         <para>
            While the values are all stored as strings, validators and type safe
            'getters' allow you to store strictly typed data as well.  A validator
            is a function that is called to ensure a proposed new value for a
            parameter is suitable for the parameter.    Validators are described
            in "Types and public data" below.  A rich set of pre-defined
            validators should meet most needs, however it is possible to write
            and use custom validators should the built in ones be insufficient for
            your application.
            </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
        <methodsynopsis>
            <methodname>CItemConfiguration</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Constructs the configuration.  <parameter>name</parameter> is just
            any string you'd like to associate with the configuration.
            <methodname>getName</methodname> can be used to fetch the value
            of this string.  Names are used with collections of configurations
            when they may be inserted in an STL Map with the item name as the
            lookup key.
            </para>
        <methodsynopsis>
            <methodname>CItemConfiguration</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CItemConfiguration&amp;</type>
                <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Copy construction.  Note that if your application causes copy
                construction several configurations with the same name can be
                be created.  If you want to ensure that copy construction can't
                exist, us a class derived from this in which the copy constructor
                is declared <firstterm>private</firstterm> but never implemented.
                </para>
        <methodsynopsis>
            <modifier>virtual</modifier>   <methodname>~CItemConfiguration</methodname>
            <void />
            </methodsynopsis>
        <para>
            Destructor.
            </para>
        <methodsynopsis>
            <type>CItemConfiguration&amp;</type>
            <methodname>operator=</methodname>
            <methodparam>
                <modifier>const</modifier>
                <type>CItemConfiguration&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Assignment operator.  Note that in the presence of named
            configuration items, this can result in objects with duplicate
            names.  To avoid this derive from this class and set
            the <literal>=</literal> operator to be private...without ever
            Implementing it.
            </para>
        <methodsynopsis>
            <type>int</type>
            <methodname>operator==</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CItemConfiguration&amp;</type>
                <parameter>rhs</parameter>
                </methodparam>
            <modifier>const</modifier>
            </methodsynopsis>
        <para>
            Compares two objects for equality.  Equality is defined as having
            the same name, same set of configuration items with matching values.
            </para>
        <methodsynopsis>
            <type>int</type> <methodname>operator!=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CItemConfiguration&amp;</type>
                <parameter>rhs</parameter>
                </methodparam>
            <modifier>const</modifier>
            </methodsynopsis>
        <para>
            Inequality test operator is the logical inverse of equality.
            </para>
        <methodsynopsis>
            <type>std::string</type>
            <methodname>getName</methodname>
            <void /><modifier>const</modifier>
            </methodsynopsis>
        <para>
            Returns the name string used to construct the object.
            </para>
        <methodsynopsis>
            <type>std::string</type> <methodname>cget</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Returns the string value of the configuration parameter
            <parameter>name</parameter>.  If the name is not a defined
            configuration parameter, this will throw an explanatory string exception.
            See <methodname>addParameter</methodname> for information about how
            to define configuration parameters.
            </para>
        <methodsynopsis>
            <type>ConfigurationArray</type> <methodname>cget</methodname>
            <void />
            </methodsynopsis>
        <para>
            Returns a container <type>ConfigurationArray</type> that provides
            the entire configuration.  See "Types and public data" for more
            information about the <type>ConfigurationArray</type>
            data type.
            </para>
        <methodsynopsis>
            <type>int</type> <methodname>getIntegerParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Returns the value of a parameter <parameter>name</parameter> converted
            to an integer.  This can throw an explanatory string exception either
            if <parameter>name</parameter> is not a defined parameter or if its
            current value does not translate to an integer
            (using <function>strtoul</function>).  Typically <parameter>name</parameter>
            should have been defined with a validator that will make sure the
            value will always be a legal integer.
            </para>
        <methodsynopsis>
            <type>unsigned int</type> <methodname>getUnsignedParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Same as <methodname>getIntegerParameter</methodname> however
            <function>strtoul</function> is used to convert the string ot
            an unsigned value.  Once more the configuration parameter
            <parameter>name</parameter> should have a validator attached
            to it to ensure that the value always represents a legal
            unsigned integer.
            </para>
        <methodsynopsis>
            <type>bool</type>    <methodname>getBoolParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Returns the value of <parameter>name</parameter> as a boolean.
            This will throw a descriptive string exception if <parameter>name</parameter>
            is not a define configuration parameter or if the value is not one of
            <literal>true</literal>,
            <literal>yes</literal>,
            <literal>1</literal>,
            <literal>on</literal>,
            or <literal>enabled</literal> for true and
            <literal>false</literal>,
            <literal>no</literal>,
            <literal>0</literal>,
            <literal>off</literal> or
            <literal>disabled</literal> for false.
            </para>
        <methodsynopsis>
            <type>double</type> <methodname>getFloatParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Returns the value of a parameter <parameter>name</parameter>
            as a floating point <type>double</type>
            value.  If the parameter cannot be decoded as a floating point number
            a string exception is thrown that describes this.
            </para>

        <methodsynopsis>
            <type>std::vector&lt;int&gt;</type> <methodname>getIntegerList</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Returns a parameter <parameter>name</parameter>
            that is supposed to be a list of integers.
            The list is returned as a <type>std::vector&lt;int&gt;</type>.
            A string exception is thrown describing the error in the event
            that either the parameter value is not a valid Tcl list or
            any of the values does not decode as an integer.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>addParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>typeChecker</type> <parameter>checker</parameter>
                </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type>  <parameter>defaultValue</parameter>
                <initializer>std::string("")</initializer>
                </methodparam>
            </methodsynopsis>
        <para>
            Defines a new configuration parameter.  The value of this configuration
            parameter is modified by calling <methodname>configure</methodname>
            below.  <parameter>name</parameter> is the name of the new parameter.
            This parameter definition is ovewritten if it already exists.
            </para>
        <para>
            <parameter>checker</parameter> is a validation function that will be
            called to approve or disapprove of changes to the configuration
            value. Passing a <literal>NULL</literal> for <parameter>checker</parameter>
            disables value checking.
            <parameter>arg</parameter> is a parameter passed to the type checker.
            See "Types and public data " below for a definition of the
            <type>typeChecker</type> function prototype.
            </para>
        <para>
            <parameter>default</parameter> is the initial value of the parameter.
            This defaults to the empty string.  Note that <parameter>default</parameter>
            is not passed through the <parameter>checker</parameter>, so it
            is up to the definer to ensure this value is a legal value for
            the functions used to fetch it from the parameter.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>clearConfiguration</methodname>
            <void />
            </methodsynopsis>
        <para>
            Destroys all parameter definitions.  After this is called,
            no configuration parameters are defined.
            </para> 
        <methodsynopsis>
            <type>void</type> <methodname>configure</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Modifies the value of the configuration parameter
            <parameter>name</parameter> to
            <parameter>value</parameter>.  If either the
            parameter <parameter>name</parameter> has not been defined, or
            <parameter>value</parameter> fails checking, a string
            exception is thrown to describe in human terms the problem.
            </para>

      </refsect1>
      <refsect1>
         <title>Types and public data</title>
         <para>
            This class exports several public data types.  For the sake of
            brevity only the final typename is give, therefore, when you
            use a type like <type>ConfigurationArray</type> remember that it
            must be qualified with the <classname>CItemConfiguration</classname>
            class name (e.g. referred to in your source code as
            <type>CItemConfiguration::ConfigurationArray</type>)
         </para>
         <para>
            One type is exported in the global (unqualified) namespace, this is
            <type>typeChecker</type> which defines the function prototype for
            a configuration parameter validity checker.  The prototype of
            this function is:
            </para>
         <methodsynopsis>
            <type>bool</type> <methodname>(*typeChecker)</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>value</parameter>
                </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Type checkers are registered when a configuration parameter is
            created via <methodname>addParameter</methodname>.  When
            <methodname>configure</methodname> is called and the parameter
            has a type checker it is called.  <parameter>name</parameter> is the
            name of the configuration parameter being configured,
            <parameter>value</parameter> is the proposed new value for the
            parameter.
        </para>
        <para>
            <parameter>arg</parameter> is the <parameter>arg</parameter>
            parameter specified in the call to <methodname>addParameter</methodname>
            that created the configuration parameter in the first place.
            Usually this is some additional information required to validate the
            proposed value.
        </para>
        <para>
            The function must return <literal>true</literal> in the event
            the proposed <parameter>value</parameter> is acceptable and
            <type>false</type> if not.
            </para>
        <refsect2>
            <title>ConfigurationArray</title>
            <para>
                This type is defined as
                <type>std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt;</type>.
                This is a vector that contains pairs of strings.  The first string of
                each pair is the name of a configuration parameter.  The second
                string is the configuration parameter's current value.
                This type is returned from one of the overloaded <methodname>cget</methodname>
                methods.
                </para>
            <para>
                You cannot make any assumption about the order of the parameters
                in this array.
                </para>
            </refsect2>
        <refsect2>
            <title>Pre-defined type checkers and related data types</title>
            <para>
                This section describes type checkers that are defined as
                static member functions of the <classname>CItemConfiguration</classname>
                class.  Each type checker's <parameter>arg</parameter> is also
                described along with a description of the
                checker.
                </para>
            <para>
                Prior to writing your own type checker you should ensure that
                a suitable one does not already exist.
                </para>
            <para>
                For all of the type checkers the parameters have the same
                names an meanings:
                 </para>
                <variablelist>
                    <varlistentry>
                        <term><type>std::string</type> <parameter>name</parameter></term>
                        <listitem>
                            <para>
                                Name of the configuration parameter being checked.
                                </para>
                            </listitem>
                        </varlistentry>
                    <varlistentry>
                        <term><type>std::string</type> <parameter>value</parameter></term>
                        <listitem>
                            <para>
                                The proposed new value for the configuration
                                parameter.  This is the value to be checked
                                by the validation function.
                                </para>
                            </listitem>
                        </varlistentry>
                    <varlistentry>
                        <term><type>void*</type> <parameter>arg</parameter></term>
                        <listitem>
                            <para>
                                This anonymous pointer points to data that
                                is used to further qualify type checking.
                                For exmaple.  Integer type checkers can specify
                                optional limits on the range of integers that
                                are acceptable, for <methodname>isInteger</methodname>,
                                therefore <parameter>arg</parameter> is actually
                                a pointer to a data structure that specifies
                                limit information.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
               
            
            <methodsynopsis>
            <modifier>static</modifier>
            <type>bool</type> <methodname>isInteger</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type>  <parameter>value</parameter>
                </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Ensures that <parameter>value</parameter> is a legal integer value.
            The <parameter>arg</parameter> parameter is a pointer to a
            <type>Limits</type> type.  This is a
            <type>std::pair&lt;limit, limit&gt;</type>.  Each <type>limit</type>
            defines a limit on the range of acceptable values.  The first one
            defines the lower end of the range, the second the high end of the
            range.
            </para>
        <para>
            If <parameter>arg</parameter> is <literal>NULL</literal> no
            limit checking is performed.
            </para>
        <para>
            The <type>limit</type> is, in turn a struct that has the following
            members:
            </para>
            <informalexample>
            <programlisting>
                bool s_checkMe;          // Check this limit if true
                long s_value             // Limit value
                </programlisting>
            </informalexample>
            <para>
                The <structname>limit</structname> structure also defines
                two construtors:
                <methodsynopsis>
                    <type></type><methodname>limit()</methodname>
                    <void />
                    </methodsynopsis>
                Defines a limit structure with <structfield>s_checkMe</structfield>
                initialized to
                <literal>false</literal> (that is a limit that will not be checked).
                <methodsynopsis>
                    <type></type><methodname>limit</methodname>
                    <methodparam>
                        <type>long</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                defines a limit with <structfield>s_checkMe</structfield> set
                to <literal>true</literal> and
                <structfield>s_value</structfield> initialized to
                <parameter>value</parameter>.
            </para>
        <methodsynopsis>
            <modifier>static</modifier>
            <type>bool</type> <methodname>isBool</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type>  <parameter>value</parameter>
                </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            This type checker ensures that the proposed
            <parameter>value</parameter> is a legal boolean value.
            <methodname>isBool</methodname> does not use its
            <parameter>arg</parameter> parameter.  Legal boolean values
            are any text strings from the following set:
            <literal>{true, yes, 1, on, enabled, false, no, 0, off,  disabled}</literal>.
            Any string not in this set results in a failed type check.
            </para>
        <methodsynopsis>
            <modifier>static</modifier>
            <type>bool</type> <methodname>isEnum</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type>  <parameter>value</parameter>
                </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            This is a type checker for enumerated parameters.  An enumerated
            parameter is a parameter that is constrained to have specific
            discrete values (A boolean is a special case of an enumerated
            parameter).  The <parameter>arg</parameter> value is required and
            must be a pointer to an
            <type>std::set&lt;string&gt;</type>.  The elements you put in this
            set define the allowed values for <parameter>value</parameter>.
            </para>
        <methodsynopsis>
            <modifier>static</modifier>
            <type>bool</type> <methodname>isFloat</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type>  <parameter>value</parameter>
                </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Checks that <parameter>value</parameter> decodes as a floating point
            number and optionally peforms limit checks on the value.
            </para>
        <para>
            <parameter>arg</parameter> is a pointer to a
            <type>FloatingLimits</type>.  <type>FloatingLimits</type> in turn
            is defined to be a <type>std::pair&lt;flimit, flimit&gt;</type>.
            The first <type>flimit</type> of the pair specifies the lower limit
            if any, while the second specifies the upper limit.  If
            <parameter>arg</parameter> is <literal>NULL</literal> no
            limit checking is performed.
            </para>
        <para>
            <type>flimit</type> is a struct that has the following
            members
            </para>

            <para>
                Data members of <structname>flimit</structname> are:
                <informalexample>
                <programlisting>
bool   s_checkMe;        // If true limit is checked.
float  s_value;          // Limit value.
                </programlisting>
                </informalexample>
                </para>
            <para>
                If <structfield>s_checkMe</structfield> is <literal>true</literal>,
                then <structfield>s_value</structfield> is relevant and is the value
                of the limit.
                </para>
            <para>
                <structfield>flimit</structfield> defines a pair of constructors:
                </para>
            <methodsynopsis>
                <type></type> <methodname>flimit</methodname>
                <void />
                </methodsynopsis>
            <para>Initializes <structfield>s_checkMe</structfield> to
            <literal>false</literal> disabling the limit.
            </para>
            <methodsynopsis>
                <type></type> <methodname>flimit</methodname>
                <methodparam>
                    <type>float</type> <parameter>value</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Initializes <structfield>s_checkMe</structfield>
                to <literal>true</literal> and sets
                <structfield>s_value</structfield>
                to <parameter>value</parameter>.  This enables the limit
                and sets it's value to <parameter>value</parameter>.
                </para>
 
    
        <methodsynopsis>
            <modifier>static</modifier>
            <type>bool</type> <methodname>isList</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type>  <parameter>value</parameter>
                </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            This validation function ensures tht the proposed parameter is a
            properly formatted Tcl list. <parameter>arg</parameter>, if supplied,
            allows the list size to be constrained and optionally
            elements of the list to be validated.  If <literal>NULL</literal>
            no constraints are enforced on the contents of the list.
            </para>
        <para>
            <parameter>arg</parameter> if not <literal>NULL</literal> is a pointer
            to a <structname>isListParameter</structname> struct which contains
            the following fields:
            <informalexample>
            <programlisting>
ListSizeConstraint  s_allowedSize;   // Constraints on list size.
TypeCheckInfo       s_checker;       // Element type checker.
                </programlisting>
            </informalexample>
            </para>
            <para>
                <structfield>s_allowedSize</structfield> constrains the number
                of elements in a list.  It is of type
                <structname>ListSizeConstraint</structname> which is a struct
                containing two <type>limit</type> element;
                <structfield>s_atLeast</structfield> which describes the minimum
                number of elements the list must contain and
                <structfield>s_atMost</structfield> which specifies the maximum
                numbger of elements the list must contain.  See
                the <methodname>isInteger</methodname> function description above
                for more information about the <type>limit</type> type.
                </para>
            <para>
                <structfield>s_checker</structfield>, of type
                <type>TypeCheckInfo</type> allows each element of the list to be
                validated (e.g. to require that a list contain integers that are
                all within some range).  
                <type>TypeCheckInfo</type> is a
                <type>std::pair&lt;typeChecker, void*&gt;</type>.  Where the
                <type>typeChecker</type> function is given each list value to
                validate and the <type>void*</type> element of the pair is the
                <parameter>arg</parameter> parameter passed to that validator.
                If <type>TypeCheckInfo</type> is <literal>NULL</literal> no per
                element validation is performed, however the list size can be
                constrained.
                </para>
            <para>
                When elements are validated, the <parameter>name</parameter>
                parameter passed to the element validator is the name of the
                configuration parameter that contains the list.  The
                <parameter>value</parameter> parameter is the proposed value
                of a list element.
                </para>
        <methodsynopsis>
            <modifier>static</modifier> <type>bool</type>
            <methodname>isBoolList</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type>  <parameter>value</parameter>
                </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            This is a specialization of <methodname>isList</methodname>.
            <parameter>arg</parameter> shoule be either be a pointer to
            a <type>ListSizeConstraint</type> to constrain the number of
            elements in the list or <literal>NULL</literal> to keep the size
            unsconstrained.  The method passes each list element through
            <methodname>isBool</methodname> to ensure that the
            list contains only boolean values.
            </para>
        <methodsynopsis>
            <modifier>static</modifier>
            <type>bool</type> <methodname>isIntList</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type>  <parameter>value</parameter>
                </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            This is a specialization of the <methodname>isList</methodname>
            function.  <parameter>arg</parameter> should either be
            a pointer to a <type>ListSizeConstraint</type> or it should be a
            <literal>NULL</literal>.
            If <parameter>arg</parameter> is <literal>NULL</literal>,
            the size of the list is unconstrained.  If not, the
            <type>ListSizeConstraint</type> is used to validate the
            size of the list.
            </para>
        <para>
            The list items are checked via <methodname>isInteger</methodname>
            to be sure they are legal integers.  No capability to set limits on
            the integer values is provdided for at this time.
            </para>
        <methodsynopsis>
            <modifier>static</modifier> <type>bool</type>
            <methodname>isStringList</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type>  <parameter>value</parameter>
                </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            This is a specialization of <methodname>isList</methodname>.  Any
            string is allowed as a list item (if it has the necessary quoting to maintain
            legal Tcl list syntax).   If not <literal>NULL</literal>,
            <parameter>arg</parameter> is a poitner to a
            <type>ListSizeConstraint</type> which can limit the number of elements
            in the list.  If <literal>NULL</literal> no list size constraint
            is enforced.
            </para>
        </refsect2>
      </refsect1>
      <refsect1>
         <title>Exceptions</title>
         <para>
            In the event of error, the class thows exceptions of
            type <type>std::string</type>.  The contents of the string are a
            human readable message that explains the problem and when it was
            detected.
         </para>
      </refsect1>
      <refsect1>
         <title>
            SEE ALSO
         </title>
     <para>
        <link linkend="manpage.cconfigurableobject">CConfigurableObject(3tcl)</link>
     </para>
      </refsect1>
   </refentry>

    <refentry id="manpage.cconfigurableobject">
      <refmeta>
         <refentrytitle>CConfigurableObject</refentrytitle>
         <manvolnum>3tcl</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CConfigurableObject</refname>
     <refpurpose>Base class for objects tht have a configuration.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CConfigurableObject.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CConfigurableObject</classname></ooclass>
            <constructorsynopsis>
                <methodname>CConfigurableObject</methodname>
                <void />
                </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CConfigurableObject</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>CConfigurableObject&amp;</type> <parameter>rhs</parameter>
                    </methodparam>
                </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier>
                <methodname>~CConfigurableObject</methodname>
                <void />
                </destructorsynopsis>
            <methodsynopsis>
                <type>CConfigurableObject&amp;</type>
                <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>CConfigurableObject&amp;</type> <parameter>rsh</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>CConfigurableObject&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                <modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>int</type>
                <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CConfigurableObject&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                <modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>Attach</methodname>
                <methodparam>
                    <type>CItemConfiguration*</type> <parameter>pConfiguration</parameter>
                    </methodparam>
                <methodparam>
                    <type>bool</type> <parameter>dynamic</parameter>
                    <initializer>true</initializer>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>configure</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>value</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type> <methodname>getName</methodname>
                <void />
                <modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type>
                <methodname>cget</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>CItemConfiguration::ConfigurationArray</type>
                <methodname>cget</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>onAttach</methodname>
                <void /><modifier>=0</modifier>
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            <classname>CConfigurableObject</classname> is an abstract base class
            for objects
            that contain configurations via the
            <classname>CItemConfiguration</classname>
            class.  The class embeds an <classname>CItemConfiguration</classname>
            and provides a mechanism for initializing the configuration as it is
            attached.
         </para>
        <para>
            Due to the rules regarding virtual member use in constructors,
            construction and initialization of a <classname>CConfigurableObject</classname>
            is usually a two step process.  The object is constructed, and then
            either an empty or initialized configuration is attached to the
            object via  call to <methodname>Attach</methodname>.
            </para>
        <para>
            When <methodname>Attach</methodname> is called it, in turn calls
            the virtual method (pure/abstract in this base class), to
            allow the actual concrete class to initialize the configuration
            by defining an appropriate set of parameters and their constraints.
            </para>
        <para>
            Once initialized, a partial facade is supplied that allows external
            clients to configure and dump the configuration of an object.
            </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
        <methodsynopsis>
            <methodname>CConfigurableObject</methodname>
            <void />
            </methodsynopsis>
        <para>
            Construts a configurable object.  Note that this does not
            create a configuration unless explicitly done by the constructor.
            Normally due to restrictions in when virtual functions are actually
            virtual (they are not in constructors), The client that constructs
            this will also construct and attach a
            <classname>CItemConfiguration</classname> via
            <methodname>Attach</methodname> soon after constructing the object.
            </para>
        <methodsynopsis>
            <methodname>CConfigurableObject</methodname>
            <methodparam>
                <modifier>const</modifier>
                <type>CConfigurableObject&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Copy construction.  This results in a snapshot of the configuration
            being dynamically made, and marked for deletion on destruction of
            the object.  No attempt is made to synchronize the copy with the
            original.
            </para>
        <methodsynopsis>
            <modifier>virtual</modifier>
            <methodname>~CConfigurableObject</methodname>
            <void />
            </methodsynopsis>
        <para>
            Destroys the configurable object.  If the configuration attached
            was marked as dynamcially allocated it is deleted in order
            to prevent memory leaks.  Dynamic marking is done either
            by copy construction or by specifying at
            <methodname>Attach</methodname> time that the object is responsible
            for deleting <classname>ItemConfiguration</classname>
            object being attached.
            </para>
        <methodsynopsis>
            <type>CConfigurableObject&amp;</type>
            <methodname>operator=</methodname>
            <methodparam>
                <modifier>const</modifier>
                <type>CConfigurableObject&amp;</type> <parameter>rsh</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Object assignment.  If the target object's configuration exists
            and was dynamically attached, it is deleted.  Regardless, the source's
            configuration cloned and assigned to the current configuration with
            dynamic marking.
            </para>
        <methodsynopsis>
            <type>int</type> <methodname>operator==</methodname>
            <methodparam>
                <modifier>const</modifier>
                <type>CConfigurableObject&amp;</type>
                <parameter>rhs</parameter>
                </methodparam>
            <modifier>const</modifier>
            </methodsynopsis>
        <para>
            Returns nonzero if <parameter>rhs</parameter>'s configuration is
            identical to that of <parameter>this</parameter>.
            </para>
        <methodsynopsis>
            <type>int</type>
            <methodname>operator!=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CConfigurableObject&amp;</type>
                <parameter>rhs</parameter>
                </methodparam>
            <modifier>const</modifier>
            </methodsynopsis>
        <para>
            Returns nonzero if <methodname>operator==</methodname> returns 0.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>Attach</methodname>
            <methodparam>
                <type>CItemConfiguration*</type> <parameter>pConfiguration</parameter>
                </methodparam>
            <methodparam>
                <type>bool</type> <parameter>dynamic</parameter>
                <initializer>true</initializer>
                </methodparam>
            </methodsynopsis>
        <para>
            The client should call this to attach a configuration,
            <parameter>pConfiguration</parameter>, (either
            pre-configured or empty) to the object.
            <parameter>dynamic</parameter> should be <literal>true</literal>
            if <parameter>pConfiguration</parameter> should be
            deleted when the object is destroyed.
            </para>
        <para>
            The virtual function <methodname>onAttach</methodname> will be invoked
            to allow the configuration to be set up for the object.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>configure</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Passes the <parameter>name</parameter> and <parameter>value</parameter>
            parameters on to the configuration object's
            <classname>CItemConfiguration</classname> object.  If no configuration
            has been attached to the object, a string exception is
            thrown describing this fact.
            </para>
        <methodsynopsis>
            <type>std::string</type> <methodname>getName</methodname>
            <void />
            <modifier>const</modifier>
            </methodsynopsis>
        <para>
            Returns the configuration's name.  This will throw a string
            exception if no configuration has been attached to the object.
            </para>
        <methodsynopsis>
            <type>std::string</type>
            <methodname>cget</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Returns the value of a configuration option <parameter>name</parameter>.
            The assumption is that clients only want to present configuration
            option values to humans, or save them and therefore ther is only
            a facade in front of the string value function.
            </para>
        <para>
            In addition to the string exceptions that can be thrown by the
            configuration object, an exception will be thrown if the
            object has no attached configuration.
            </para>
        <methodsynopsis>
            <type>CItemConfiguration::ConfigurationArray</type>
            <methodname>cget</methodname>
            <void />
            </methodsynopsis>
        <para>
            Returns the entire configuration. Throws a string exception if no
            configuration object has been attached.
            </para>
        <methodsynopsis>
            <modifier>virtual</modifier>
            <type>void</type> <methodname>onAttach</methodname>
            <void /><modifier>=0</modifier>
            </methodsynopsis>
        <para>
            Concrete base classes should supply and implement this. Normally
            <methodname>onAttache</methodname> is used to initialize the
            configuration which is stored in the protected data member
            <varname>m_pConfiguration</varname>, a pointer to
            <classname>CItemConfiguration</classname>.
            </para>
      </refsect1>
      <refsect1>
         <title>Exceptions</title>
         <para>
            <type>std::string</type> exceptions are thrown both from this and
            the calls it makes to <classname>CItemConfiguration</classname>.
         </para>
      </refsect1>
      <refsect1>
         <title>
            SEE ALSO
         </title>
     <para>
        <link linkend='manpage.citemconfiguration'>CItemConfiguration</link>
     </para>
      </refsect1>
   </refentry>


    <refentry id="manpage.CTCLObjectPackage">
      <refmeta>
         <refentrytitle>CTCLObjectPackage</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CTCLObjectPackage</refname>
	 <refpurpose>Provide common functionality for a set of
                related commands.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;TCLObjectPackage.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CTCLObjectPackage</classname></ooclass>
            <methodsynopsis>
                <type>void</type><methodname>addCommand</methodname>
                <methodparam>
                    <type>CTCLPackagedObjectProcessor*</type> <parameter>processor</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>CTCLObjectPackage::CommandIterator</type>
                <methodname>begin</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>CTCLObjectPackage::CommandIterator</type>
                <methodname>end</methodname>
                <void />
            </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            This class is a base class for a set of common services that
            can be offered to a set of related commands.  The commands themselves
            must be derived from CTCLPackagedObjectProcessor.  
         </para>
         <para>
            The base class provides the infrastructor for maintaining the list
            of command objects that participate in the package, for associating
            a command with the package, and for iterating through associated
            command objects.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
           <methodsynopsis>
                <type>void</type><methodname>addCommand</methodname>
                <methodparam>
                    <type>CTCLPackagedObjectProcessor*</type> <parameter>processor</parameter>
                </methodparam>
            </methodsynopsis>
           <para>
                Adds a new command object to the package.  The command object
                will have its <methodname>onAttache</methodname> method
                invoked, which allows it to save the command package (passed in
                as a parameter), and to do any initialization that requires
                the command package services.
           </para>
            <methodsynopsis>
                <type>CTCLObjectPackage::CommandIterator</type>
                <methodname>begin</methodname>
                <void />
            </methodsynopsis>
            <para>
                Returns an iterator for the first command object associated
                with the object.  The iterator is a pointer like object in the
                sense that dereferencing it will yield a pointer to ta
                command object.  The iterator can be stepped through the
                collection via the incremenet operator (<literal>++</literal>).
                Iteration is complete when the iterator is equal to
                <methodname>end()</methodname> see below.
            </para>
            <methodsynopsis>
                <type>CTCLObjectPackage::CommandIterator</type>
                <methodname>end</methodname>
                <void />
            </methodsynopsis>
            <para>
                Provides an end iterator against which to compare an iterator
                over the commands to determine if all of them have been
                visited.
            </para>
      </refsect1>
      <refsect1>
         <title>Types and public data</title>
         <para>
            <classname>CTCLObjectPackage::CommandIterator</classname> is a
            pointer like object returned by the
            <methodname>begin</methodname> and <methodname>end</methodname>
            methods to allow iteration through the set of command objects
            associated with this package.
         </para>
      </refsect1>
 
      <refsect1>
         <title>
            SEE ALSO
         </title>
	 <para>
            <link linkend="manpage.CTCLPackagedObjectProcessor">
                CTCLPackagedObjectProcessor(3daq)</link>
	 </para>
      </refsect1>
   </refentry>

    <refentry id="manpage.CTCLPackagedObjectProcessor">
      <refmeta>
         <refentrytitle>CTCLPackagedObjectProcessor</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CTCLPackagedObjectProcessor</refname>
	 <refpurpose>Base class for commands living in a
                    <classname>CTCLObjectPackage</classname>
         </refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;TCLPackagedObjectProcessor.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CTCLPackagedObjectProcessor</classname></ooclass>
            <constructorsynopsis>
                <methodname>CTCLPackagedObjectProcessor</methodname>
                <methodparam><type>CTCLInterpreter&amp;</type>
                             <parameter>interp</parameter>
                </methodparam>
                <methodparam><type>std::string</type>
                             <parameter>command</parameter>
                </methodparam>
                <methodparam><type>bool</type>
                             <parameter>registerMe</parameter>
                             <initializer>true</initializer>
                </methodparam>
            </constructorsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>onAttach</methodname>
                <methodparam>
                    <type>CTCLObjectPackage*</type> <parameter>package</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>protected</modifier>
                <type>CTCLObjectPackage*</type>  <methodname>getPackage</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>protected virtual</modifier>
                <type>void</type> <methodname>Initialize</methodname>
                <void />
            </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            A packaged object command is a <classname>CTCLObjectProcessor</classname>
            that can draw on a set of services shared between it and a
            set of related commands.  The set of commands and the common set
            of services is called a <firstterm>package</firstterm>.
         </para>
         <para>
            The <classname>CTCLPackagedObjectProcessor</classname> class
            described here provides a base class for such commands.  The base
            class provides mechanisms for the package to associate the object
            that contains the shared services with the command, and a mechanism
            for the subclass that actually implements real commands to access this
            associated object.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
           <methodsynopsis>
                <methodname>CTCLPackagedObjectProcessor</methodname>
                <methodparam><type>CTCLInterpreter&amp;</type>
                             <parameter>interp</parameter>
                </methodparam>
                <methodparam><type>std::string</type>
                             <parameter>command</parameter>
                </methodparam>
                <methodparam><type>bool</type>
                             <parameter>registerMe</parameter>
                             <initializer>true</initializer>
                </methodparam>
            </methodsynopsis>
            <para>
                Construct the object.  The parameters are the same as for
                a <classname>CTCLObjectProcessor</classname>;
                <parameter>interp</parameter> is a reference to the TCL interpreter
                to which the command will be added.  <parameter>command</parameter>
                is the command keyword that will invoke the object's
                <methodname>operator()</methodname>.
                <parameter>regsiterMe</parameter> is
                <literal>true</literal> if the
                command should be registered on the interpreter immediately
                (this is usually the case and hence the parameter is optional,
                defaulting to <literal>true</literal>
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>onAttach</methodname>
                <methodparam>
                    <type>CTCLObjectPackage*</type> <parameter>package</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                This method is called by the package when the command object is
                added to the package.  <parameter>package</parameter> is a pointer
                to the package object, which contains its shared services.
                This is saved and can be retrieved by subclass objects via
                <methodname>getPackage</methodname>.
            </para>
            <methodsynopsis>
                <modifier>protected</modifier>
                <type>CTCLObjectPackage*</type>  <methodname>getPackage</methodname>
                <void />
            </methodsynopsis>
            <para>
                Returns the package object pointer supplied to
                <methodname>onAttach</methodname>
                by the package.  Normally this will need to be cast to a
                specific concrete package type by the caller so that its methods
                can be accessed.
            </para>
            <para>
                If called prior to the
                <methodname>onAttach</methodname> call, this returns
                a null pointer.
            </para>
            <methodsynopsis>
                <modifier>protected virtual</modifier>
                <type>void</type> <methodname>Initialize</methodname>
                <void />
            </methodsynopsis>
            <para>
                Called by <methodname>onAttach</methodname> after the
                package has been saved (and is therefore accessible by
                <methodname>getPackage</methodname>.  This does nothing in the
                base class but can be overidden in subclasses to allow
                for initialization that requires access to the package services.
            </para>
      </refsect1>
      <refsect1>
         <title>
            SEE ALSO
         </title>
	 <para>
            <link linkend="manpage.CTCLObjectPackage">CTCLObjectPackage(3daq)</link>
	 </para>
      </refsect1>
   </refentry>


    </part>
    <part>
        <title>Core SpecTcl classes</title>
        <partintro>
            <title>Core SpecTcl classes</title>
            <para>
                This part describes the core SpecTcl classes.  These  classes
                are those which can either be used by extensions to do their work
                or provide hooks for extensions written by users.
            </para>
        </partintro>
        <refentry>
            <refmeta>
                <refentrytitle>CTclGrammerApp</refentrytitle>
                <manvolnum>3SpecTcl</manvolnum>
            </refmeta>
            <refnamediv>
                <refname>CTclGrammerApp</refname>
                <refpurpose>Base Application class</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <synopsis>
#include &lt;TclGrammerApp.h&gt;
class <classname>CTclGrammerApp</classname>
{
  UInt_t getDisplaySize() const;
  UInt_t getParams() const; 
  UInt_t getListSize() const;
  CAnalyzer* getAnalyzer() const;
  CTCLHistogrammer* getHistogrammer() const;
  CTKRunControl* getRunControl() const;
  CXamineEventHandler* getXamineEvents() const;
  CRunControlPackage* getRunControlPackage() const;
  CParameterPackage* getParameterPackage() const;
  CSpectrumPackage* getSpectrumPackage() const;
  CDataSourcePackage* getDataSourcePackage() const;
  CGatePackage* getGatePackage() const;
  CTCLVariable getTclDisplaySize() const;
  CTCLVariable getTclParameterCount() const;
  CTCLVariable getTclEventListSize() const;
  CMultiTestSource* getTestDataSource();
  CDisplayInterface* getDisplayInterface();
  
protected:
  void setDisplaySize (const UInt_t am_nDisplaySize);
  void setParams (const UInt_t am_nParams);
  void setListSize (const UInt_t am_nListSize);
  void setAnalyzer (CAnalyzer* am_pAnalyzer);
  void setHistogrammer (CTCLHistogrammer* am_pHistogrammer);
  void setRunControl (CTKRunControl* am_pRunControl);
  void setXamineEvents (CXamineEventHandler* am_pXamineEvents);
  void setRunControlPackage (CRunControlPackage* am_pRunControlPackage);
  void setParameterPackage (CParameterPackage* am_pParameterPackage);
  void setSpectrumPackage (CSpectrumPackage* am_pSpectrumPackage);
  void setDataSourcePackage (CDataSourcePackage* am_pDataSourcePackage);
  void setGatePackage (CGatePackage* am_pGatePackage);
  void setRCFile (const CTCLVariable am_RCFile);
  void setTclDisplaySize (const CTCLVariable am_TclDisplaySize);
  void setTclParameterCount (const CTCLVariable am_TclParameterCount);
  void setTclEventListSize (const CTCLVariable am_TclEventListSize);
  void setDisplayInterface(CDisplayInterface* pInterface);

public:
  void RegisterEventProcessor(CEventProcessor&amp; rEventProcessor,
                              const char* name = 0); 
  virtual void BindTCLVariables(CTCLInterpreter&amp; rInterp); 
  virtual void SourceLimitScripts(CTCLInterpreter&amp; rInterpreter);
  virtual void SetLimits(); 
  virtual void CreateHistogrammer(); 
  virtual void CreateDisplays(); 
  virtual void SelectDisplayer();
  virtual void SetUpDisplay(); 
  virtual void SetupTestDataSource(); 
  virtual void CreateAnalyzer(CEventSink* pSink);
  virtual void SelectDecoder(CAnalyzer&amp; rAnalyzer); 
  virtual void CreateAnalysisPipeline(CAnalyzer&amp; rAnalyzer) = 0;
  virtual void AddCommands(CTCLInterpreter&amp; rInterp);
  void SetupRunControl();
  virtual void SourceFunctionalScripts(CTCLInterpreter&amp; rInterp);
  virtual int operator()(); 

  virtual void run();
  CTCLInterpreter* getInterpreter();

  static CTclGrammerApp* getInstance();

protected:
  static void UpdateUInt(CTCLVariable&amp; rVar, UInt_t&amp; rValue);
  static void UpdateString(CTCLVariable&amp; rVar, std::string&amp; rString);
  static std::string SourceOptionalFile(CTCLInterpreter&amp; rInterp,
    std::string filename);


 public:
  static CTclGrammerApp* m_pInstance; 
  static int             m_argc;  
  static char**          m_pArgV; 

};

                </synopsis>
            </refsynopsisdiv>
            <refsect1>
                <title>DESCRIPTION</title>
                <para>
                    This class is the base class of the SpecTcl application
                    class.  The standard SpecTcl skeleton provides a derivation
                    (<classname>MySpecTclApp</classname>) which has stubs for all
                    of the pure virtual methods.  Specialized derived classes
                    can do quite a bit more.
                </para>
                <para>
                    In general, to make a complete SpecTcl, you must write
                    a class derived from <classname>CTclGrammerApp</classname>,
                    instantiate it and assign a pointer to the global variable
                    <varname>CTclGrammerApp::m_pInstance</varname>. 
                </para>
                <para>
                    While normally this sort of thing might be a singleton
                    pattern, our need to derive and use the <firstterm>strategy pattern</firstterm>
                    makes these gymnastics necessary.  For more on the
                    singleton pattern see:
                    <ulink url='https://en.wikipedia.org/wiki/Singleton_pattern' />.
                    For information on the strategy pattern, see:
                    <ulink url='https://en.wikipedia.org/wiki/Strategy_pattern' />.
                </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <para>
                    The methods for this class come in several categories.
                    Since this is an important base class, we'll be documenting
                    methods that include accessors and mutators for member data
                    as well as protected methods that may be of use in special
                    situations.
                </para>
                <para>
                    The first category of methods we'll document are accessors.
                    These are methods that allow read access to member data.
                    They are all public as external objects may want to
                    obtain the values of these variables as well as derived
                    classes:
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>UInt_t </type>
                                <methodname>getDisplaySize</methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                SpecTcl places bulk spectrum data in a shared
                                memory region using the <command>sbind</command>
                                command.  This allows displayers running on the
                                same system as SpecTcl rapid access to these
                                data improving display rendering times.
                            </para>
                            <para>
                                The size of the shared memory region is determined
                                at startup (just after limit scripts are sourced).
                                This method returns the number of megabytes allocated
                                to this shared memory region.  
                            </para>
                            <para>
                                Note that as for most computer applications
                                Mega means <literal>1024*1024</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>UInt_t </type>
                                <methodname>getParams() </methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                SpecTcl uses a <classname>CEvent</classname>
                                object to represent unpacked parameters from
                                an event.   This object is self-resizing.
                                It looks like an array but if an element is
                                referenced out of range of the allowed indices,
                                it is expanded as needed.
                            </para>
                            <para>
                                The <classname>CEvent</classname> object
                                is instantiated by SpecTcl with an initial size.
                                This method returns the initial number of elements
                                in a <classname>CEvent</classname>.  Note that
                                since these objects are recycled from event
                                to event, tuning the initial size has no
                                amortized effect on performance as all
                                of these objects eventually grow to the appropriate
                                size (usually quite quickly).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>UInt_t </type>
                                <methodname>getListSize</methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Determines the number of <classname>CEvent</classname>
                                objects that are collected for each pass through
                                the histogrammer.  
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CAnalyzer*</type>
                                <methodname> getAnalyzer</methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>                          
                        </term>
                        <listitem>
                            <para>
                                Returns a pointer to the analyzer object.
                                This is deprecated in favor of the
                                <methodname>GetAnalyzer</methodname> method
                                in the <classname>SpecTcl</classname> API
                                class.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTCLHistogrammer* </type>
                                <methodname>getHistogrammer</methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns a pointer to the histogrammer object.
                                This is the special event sink pipeline element
                                that performs gating and histogramming
                            </para>
                            <para>
                                Note that this is deprecated in favor of the
                                <methodname>GetHistogrammer</methodname> method
                                if the <classname>SpecTcl</classname> API class.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTKRunControl* </type>
                                <methodname>getRunControl</methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                <classname>CRunControl</classname> objects are
                                responsible for starting and stopping playback
                                from data sources as well as providing a
                                callback when data can be read from a source.
                            </para>
                            <para>
                                The drun control object used by default for
                                <classname>CTclGrammerApp</classname> objects
                                is a <classname>CTKRunControl</classname> object
                                that uses file events to know when data are ready
                                from a data source.  This method returns a pointer
                                to the run control object currently in use.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CXamineEventHandler* </type>
                                <methodname>getXamineEvents</methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                The Xamine displayer communicates with the
                                its client via Unix IPC objects.  Shared memory
                                is used to provide bulk spectrum data and metadata
                                to Xamine.  Message based IPS are used to
                                pass events from Xamine to SpecTcl.
                            </para>
                            <para>
                                An <classname>XamineEventHandler</classname>
                                object is an object that is used to mediate
                                message traffic from Xamine to SpecTcl.
                                It handles both gate notifictions and notifications
                                of button clicks for user button boxes.
                            </para>
                            <para>
                                This method returns thye current instance
                                of the <classname>CXamienEventHandler</classname>.
                                This may not be meaningful if a displayer other
                                than Xamine is used.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>  CRunControlPackage* </type>
                                <methodname>getRunControlPackage</methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                SpecTcl's commands are grouped into sets of
                                related functionality called
                                <firstterm>command packages</firstterm>.  Command
                                package objects,
                                derived from <classname>CTCCommandPackage</classname>,
                                not only contain a set of commands
                                but also provide services that can be accessed by
                                the commands in the package. 
                            </para>
                            <para>
                                This scheme also servers to insulate SpecTcl's
                                command functionality from the language that
                                invokes it... to some extent.
                            </para>
                            <para>
                                This method returns a pointer to the run control
                                command package.  This package provides services
                                for the run control commands;
                                <command>start</command> and
                                <command>stop</command>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CParameterPackage* </type>
                                <methodname>getParameterPackage</methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                See <methodname>getRunControlPackage</methodname>
                                for background information about command
                                packages.  <classname>CParameterPackage</classname>
                                is a package containing the commands that manipulate
                                SpecTcl parameter definitions.  This includes both
                                the <command>parameter</command> and
                                <command>psuedo</command> commands.
                            </para>
                            <para>
                                This method returns a pointer to the parameter
                                package object.
                            </para>
                        </listitem>
                    </varlistentry>                  
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CSpectrumPackage* </type>
                                <methodname>getSpectrumPackage</methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                The <classname>CSpectrumPackage</classname>
                                object contains and provides services for
                                commands that affect spectra.  These include
                                <command>spectrum</command>,
                                <command>clar</command>,
                                <command>sbind</command>,
                                <command>unbind</command>,
                                <command>channel</command>,
                                <command>swrite</command> and
                                <command>sread</command>.
                                This method returns a pointer to this package
                                object.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CDataSourcePackage* </type>
                                <methodname>getDataSourcePackage</methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                The <classname>CDataSourcePackage</classname>
                                contains and provides services for commands that
                                provide access to SpecTcl data sources.
                                These include the <command>attach</command>
                                and <command>ringformat</command> classes.
                                Older versions of SpecTcl also provide
                                access to the obsolete <command>tape</command>
                                command.
                            </para>
                            <para>
                                This method returns a pointer to the
                                data source package object.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CGatePackage* </type>
                                <methodname>getGatePackage</methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                <classname>CGatePackage</classname> contains and
                                provides services for commands that have to do
                                with gates.  These commands include:
                                <command>gate</command>,
                                <command>apply</command> and
                                <command>ungate</command>.
                            </para>
                            <para>
                                This method returns a pointer to the
                                <classname>CGatePackage</classname> object used
                                by SpecTcl.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTCLVariable </type>
                                <methodname>getTclDisplaySize</methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns a <classname>CTCLVariable</classname> that,
                                in <methodname>BindTCLVariables</methodname>
                                is bound to the Tcl variable
                                <literal>DisplayMegabytes</literal>. 
                            </para>
                            <para>
                                This can be set to be the default number of
                                display shared memory megabytes.  This must
                                be done prior to the call to
                                <methodname>SourceLimitScripts</methodname>.
                                One way to accomplish this is to override
                                <methodname>SourceLimitScripts</methodname>
                                and replace it with something like:
                            </para>
                            <programlisting>
void MySpecTclApp::SourceLimitScripts(CTCLInterpreter&amp; interp)
{
    CTCLVariable displaySize = getTclDisplaySize();
    displaySize.Bind();
    displaySize.Set("16");
    
    TclGrammerApp::SourceLimitScripts(interp);
}
                            </programlisting>
                            <para>
                                The method above, sets the default value for
                                the display size to <literal>16MB</literal>
                                before invoking the base class method to
                                actually source the limit scripts. 
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTCLVariable </type>
                                <methodname>getTclParameterCount</methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns an object that represents the
                                Tcl variable that sets the
                                default value for the initial size of
                                new <classname>CEvent</classname> objects.
                                As discussed previously, there's not much to be
                                gained from altering this default as eventually
                                these objects equilibrate in size to the size needed
                                to hold all of the parameters.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTCLVariable</type>
                                <methodname>getTclEventListSize</methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns an object that respresents the Tcl
                                variable that holds the default number of events
                                that are processed by the event processing pipeline
                                before passing events to the event sink pipeline.
                                This can be set prior to the base class executing
                                <methodname>SourceLimitScripts</methodname>.
                                Note that method may invoke a script that overrides
                                the default and that method will also set that
                                parameter.  It is possible that playing with this
                                will have a minor effect on SpecTcl performancde.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CMultiTestSource* </type>
                                <methodname>getTestDataSource</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the object that provides test data
                                for SpecTcl prior to first being attached
                                to a real data source.  It's possible,
                                once you have that object to add or select other
                                than the default test source (fixed length
                                events with gaussian parameters).
                            </para>
                            <para>
                                One potential use for this would be to hook
                                directly to some event simulator, although
                                much simpler would be to teach SpecTcl to analyze
                                the saved event files from such a simulator.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CDisplayInterface* </type>
                                <methodname>getDisplayInterface</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Provides a pointer to the current display
                                interface.  This object provides methods
                                to manage displayers that can be used by
                                SpecTcl.
                            </para>
                        </listitem>
                    </varlistentry>
    
                </variablelist>
                <para>
                    The second set of methods we will document are mutators.
                    A mutator is a method that allows you to modify internal
                    attributes of an object.  These methods are all intended
                    to be used by derived classes and therefore are all
                    <literal>protected</literal>.
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void </type>
                                <methodname>setDisplaySize </methodname>
                                <methodparam>
                                   <modifier>const</modifier>
                                   <type>UInt_t </type><parameter>am_nDisplaySize</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets the display memory size in megabytes.  This
                                must be called after
                                <methodname>SourceLimitScripts</methodname> to
                                override the value in those scripts or prior to
                                set the default value.   It should also be
                                called prior to
                                <methodname>CreateDisplays</methodname> which
                                actually sets up the display shared memory.
                            </para>
                        </listitem>
                    </varlistentry>                    
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void </type>
                                <methodname>setParams </methodname>
                                <methodparam>
                                   <modifier>const </modifier>
                                   <type>UInt_t </type><parameter>am_nParams</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets the number of parameters that will be used
                                as the initial size for <classname>CEvent</classname>
                                vectors.   To override the user's settings, this
                                should be called after
                                <methodname>SourceLimitScripts</methodname>, otherwise
                                it is used as a default value for that
                                parameter if it is not set in the user's scripts.
                            </para>
                            <para>
                                As previously discussed, setting this has
                                essentially no impact on SpecTcl's performance
                                due to the autosizing and recycling of parameter
                                vectors.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>
                                    void 
                                </type>
                                <methodname>setListSize </methodname>
                                <methodparam>
                                   <modifier>const </modifier>
                                   <type>UInt_t </type><parameter>am_nListSize</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets the event list size.  This is the number
                                of events that is analyzed by the event processing
                                pipeline before those events are passed to the
                                event sink pipeline for histogramming and
                                other processing.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    This set of methods are virtual and therefore can be overridden.
                    These methods are all exposed in the
                    <classname>MySpecTclApp</classname> class in the SpecTcl
                    Skeleton.  In that class, the base class method is invoked.
                    You can add code as needed to meet your needs.
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier> </modifier>
                                <type>void</type>
                                <methodname>RegisterEventProcessor</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>CEventProcessor&amp;</type><parameter> rEventProcessor</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier>const</modifier>
                                   <type> char* </type><parameter>name </parameter>
                                   <initializer>0</initializer>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Not actually a virtual method, this method is
                                used to add an event processor to the end of
                                the event processing pipeline.
                                <parameter>rEventProcessor</parameter>, is the
                                processor to add and <parameter>name</parameter>,
                                if supplied is a name associated with the event
                                processor.  If <parameter>name</parameter>
                                is not supplied, one is assigned.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>void </type>
                                <methodname>BindTCLVariables</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>CTCLInterpreter&amp; </type><parameter>rInterp</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This is called to bind SpecTcl's special Tcl
                                variables to this object's
                                <classname>CTCLVariable</classname>
                                members.  Doing this allows those objects
                                to access the underlying Tcl variables.
                                Variables bound and created include:
                            </para>
                            <itemizedlist>
                                <listitem>
                                    <para>
                                        <varname>tcl_rcFilename</varname>
                                        The name of the early Tcl initialization
                                        file.
                                    </para>
                                </listitem>
                                <listitem>
                                    <para>
                                        <varname>DisplayMegabytes</varname>
                                        Number of megabytes of display shared
                                        memory allocated.
                                    </para>
                                </listitem>
                                <listitem>
                                    <para>
                                        <varname>ParameterCount</varname>
                                        Number of parameers allocated in the
                                        initial create of <classname>CEvent</classname>
                                        objects.
                                    </para>
                                </listitem>
                                <listitem>
                                    <para>
                                        <varname>EventListSize</varname>
                                        Number events analyzed by the analysis
                                        pipeline before passing them on to the
                                        sink pipeline.
                                    </para>
                                </listitem>
                                <listitem>
                                    <para>
                                        <varname>DisplayType</varname>
                                        type of displayer used.
                                    </para>
                                </listitem>
                            </itemizedlist>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>void </type>
                                <methodname>SourceLimitScripts</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>CTCLInterpreter&amp;</type><parameter> rInterpreter</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sources the limit setting scripts
                                (<filename>SpecTclInit.tcl</filename>) into
                                <parameter>rInterpreter</parameter>.  All
                                of the following locations are searched and for
                                the reasons given:
                            </para>
                            <itemizedlist>
                                <listitem>
                                    <para>
                                        The <filename>etc</filename> subdirectory
                                        of the SpecTcl installation is searched
                                        to provide system defaults that override
                                        the default values compiled in to
                                        SpecTcl.
                                    </para>
                                </listitem>
                                <listitem>
                                    <para>
                                        The user's home directory is searched
                                        to provide account wide settings that may
                                        override the system wide settings.
                                    </para>
                                </listitem>
                                <listitem>
                                    <para>
                                        The current working directory is searched
                                         to provide project specific settings.
                                    </para>
                                </listitem>
                            </itemizedlist>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>void </type>
                                <methodname>SetLimits</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Updates the SpecTcl Tcl variables from the
                                final tuning values after
                                <methodname>SourceLimitScripts</methodname>
                                has been executed.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual</modifier>
                                <type> void </type>
                                <methodname>CreateHistogrammer</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This method creates the event sink pipeline,
                                assigning a pointer to it to
                                <varname>gpEventSinkPipeline</varname>.
                                It then immediately creates a
                                <classname>CHistogrammer</classname> object
                                saving it's pointer in
                                <varname>gpEventSink</varname> and adding it
                                to the end of the event sink pipeline.
                            </para>
                            <para>
                                In addition an observer is attached to the
                                spectrum dictionary (part of the histogrammer).
                                This observer, a
                                <classname>SpectrumDictionaryFitObserver</classname>
                                destroys fits on spectra that are being removed
                                from the spectrum dictionary.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>void </type>
                                <methodname>CreateDisplays</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                SpecTcl supports more than one displayer.
                                Currently it supports Xamine, a displayer built
                                directly on Motif and the Xt/X11 toolkit and
                                Spectra, a displayer build on Root.
                                This method sets up a factory of display
                                interfaces.
                                It stocks it with creators for
                                Xamine, Spectra and headless (batch) mode.
                            </para>
                            
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>void </type>
                                <methodname>SelectDisplayer</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Selects and starts the displayer whose name is
                                stored in the Tcl variable
                                <varname>DisplayType</varname>.
                                <varname>DisplayType</varname> must have been
                                set prior to
                                <methodname>SourceLimitScripts</methodname>.
                            </para>
                            <para>
                                The displayer process is started if appropriate.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>void </type>
                                <methodname>SetUpDisplay</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets up communication between SpecTcl and the
                                displayer.  Specifically, when gates are
                                created or destroyed, when spectra have gates
                                applied to them or are ungated, the displayer
                                may provide visual cues.  This method sets up
                                observers on the SpecTcl side that
                                detect appropriate changes and communicate
                                with the selected displayer so that this
                                information is updated by the displayer..
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>void </type>
                                <methodname>SetupTestDataSource</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                SpecTcl has a test data source.  If analysis
                                is started, prior to attaching to a data source,
                                the test source will supply data.  The
                                test data source is, by default, a
                                <classname>CMlutiTestSource</classname> which
                                is can be a container for several types of
                                data sources.  
                            </para>
                            <para>
                                This method establishes that data source
                                and selects its default data source.
                                The default data source delivers fixed sized
                                events that contain several parameters of
                                gaussian distributed parameters.
                            </para>
                            <para>
                                The SpecTcl skeleton files can analyze data
                                from the default test source without modification.
                                This is one way to use and become familiar with
                                SpecTcl.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>void </type>
                                <methodname>CreateAnalyzer</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>CEventSink* </type>
                                   <parameter>pSink</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Creates and attaches the analyzer to the system.
                                The analyzer is the object that controls the
                                flow of data from a data source through the
                                analysis pipeline and to the event sink
                                pipeline.
                            </para>
                            <para>
                                By default a <classname>CTclAnalyzer</classname>
                                is instantiated and hooked in to SpecTcl.
                                A pointer to the analyzer object is stored
                                in <varname>gpAnalyzer</varname> as well
                                as in the attribute
                                <varname>m_pAnalyzer</varname>.  Both should
                                be updated to change the analyzer, if that's
                                desired.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>void </type>
                                <methodname>SelectDecoder</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>CAnalyzer&amp; </type>
                                   <parameter>rAnalyzer</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets the initial buffer decoder. Note that
                                in most cases, SpecTcl's
                                <command>attach</command> command will
                                select a new buffer decoder object to match the
                                <option>-format</option> value, implied by
                                or explicit in the command.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>void </type>
                                <methodname>CreateAnalysisPipeline</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>CAnalyzer&amp; </type>
                                   <parameter>rAnalyzer</parameter>
                                   <initializer>0</initializer>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This is a pure virtual method and therefore
                                must be implemented by any subclass that
                                can be instantiated.  The code in this
                                method should create and add elements
                                to the event processing pipeline.                         
                            </para>
                            <para>
                                <methodname>RegisterEventProcessor</methodname>
                                is provided as a convenience method for
                                adding event processors to the analyzer.
                                Note that event processors are a property
                                of the <classname>CTclAnalyzer</classname>
                                class and its descendents.  
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>void </type>
                                <methodname>AddCommands</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>CTCLInterpreter&amp; </type>
                                   <parameter>rInterp</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Adds SpecTcl specific commands to the
                                Tcl interpreter
                                <parameter>rInterp</parameter>.
                                The base class method creates and adds
                                all of the command packages that hold most
                                of SpecTcl's commands.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void </type>
                                <methodname>SetupRunControl</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Not virtual and therefore cannot be overridden,
                                this method creates a new
                                <classname>CTkRunControl</classname>
                                object, stores a pointer to it in 
                                <varname>gpRunControl</varname> which
                                establishes it as the run control object
                                that SpecTcl uses.  The object's pointer is
                                also stored in the attribute
                                <varname>m_pRunControl</varname>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>void </type>
                                <methodname>SourceFunctionalScripts</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>CTCLInterpreter&amp; </type>
                                   <parameter>rInterp</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sources functional setup scripts into
                                <parameter>rInterp</parameter>.  The
                                functional setup scripts are those named
                                <filename>SpecTclRC.tcl</filename>.  SpecTcl
                                will first run any script by this name that
                                exists in the user's home directory.  Next it
                                will run any script by that name that exists in
                                the current working directory.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>int </type>
                                <methodname>operator()</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Entry point.  This method invokes all of the
                                initialization methods in turn.
                                It should return
                                <literal>TCL_OK</literal> if successful
                                and <literal>TCL_ERROR</literal> on
                                any failure.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    The remainder of the methods we'll document are
                    utility functions.  These are protected and therefore
                    can only be called from methods in this class or a
                    class derived from this class
                    (e.g. <classname>MySpecTclApp</classname>).
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>static</modifier>
                                <type> void </type>
                                <methodname>UpdateUInt</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>CTCLVariable&amp; </type>
                                   <parameter>rVar</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t&amp;</type>
                                   <parameter> rValue</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This utility method accepts a
                                Tcl variable object
                                (<parameter>rVar</parameter>) which is
                                supposed to hold an
                                unsigned integer and sets
                                <parameter>rValue</parameter> to the value
                                of that integer.  If the variable does not
                                exist in the Tcl interpreter, no error
                                is thrown and the <parameter>rValue</parameter>
                                is un-modified.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>static</modifier>
                                <type> void </type>
                                <methodname>UpdateString</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>CTCLVariable&amp; </type>
                                   <parameter>rVar</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string&amp; </type>
                                   <parameter>rString</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Similiar to
                                <methodname>UpdateUInt</methodname>
                                but the Tcl variable is an arbitrary
                                string.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>static </modifier>
                                <type>std::string </type>
                                <methodname>SourceOptionalFile</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>CTCLInterpreter&amp; </type>
                                   <parameter>rInterp</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type>
                                   <parameter>filename</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This method attempts to source the file
                                <parameter>filename</parameter> into the
                                interpreter <parameter>rInterp</parameter>.
                                It is not an error for the file to not exist.
                                That's the meaning of the
                                "optional" part of this method's name.
                            </para>
                            <para>
                                The return value from this method is an empty
                                string on success (including missing file)
                                and an error message string if an error occured
                                (such as the script failing).
                            </para>
                        </listitem>
                    </varlistentry>

                </variablelist>
            </refsect1>
        </refentry>
<refentry>
    <refmeta>
        <refentrytitle>CHistogrammer</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CHistogrammer</refname>
        <refpurpose>SpecTcl histogramming core</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>

class <classname>CHistogrammer</classname> : public <classname>CEventSink</classname> {

  typedef std::list&lt;CGateObserver*&gt;   GateObserverList;
  typedef std::list&lt;CGatingObserver*&gt; GatingObserverList;

  ParameterDictionary m_ParameterDictionary;
  SpectrumDictionary  m_SpectrumDictionary;
  CGateDictionary     m_GateDictionary; 
  GateObserverList    m_gateObservers;  
  GatingObserverList  m_gatingObservers;


  CFlattenedGateList*   m_pGateList;
  CSpectrumByParameter* m_pSpectrumLists;


 public:

  const ParameterDictionary&amp; getParameterDictionary() const ;

  const SpectrumDictionary&amp; getSpectrumDictionary() const ;

 protected:

  void setParameterDictionary(const ParameterDictionary&amp; am_ParameterDictionary);

  void setSpectrumDictionary(const SpectrumDictionary&amp; am_SpectrumDictionary) ;

 public:

  virtual void operator() (const CEvent&amp;     rEvent);
  virtual void operator() (CEventList&amp; rEventList);


  CParameter* AddParameter (const std::string&amp; sName,
			    UInt_t nId,
			    const char* pUnits);
  CParameter* AddParameter (const std::string&amp; sName,
			    UInt_t nId,
			    UInt_t  nScale);
  CParameter* AddParameter (const std::string&amp; sName,
			    UInt_t nId, UInt_t nScale,
			    Float_t nLow, Float_t nHi,
			    const std::string&amp; sUnits);
  CParameter* RemoveParameter (const std::string&amp; sName);
  CParameter* FindParameter (const std::string&amp; rName);
  CParameter* FindParameter (UInt_t nPar);
  ParameterDictionaryIterator ParameterBegin();
  ParameterDictionaryIterator ParameterEnd();
  UInt_t ParameterCount();


  void AddSpectrum(CSpectrum&amp; rSpectrum);
  CSpectrum* RemoveSpectrum(const std::string sName);
  void ClearSpectrum(const std::string&amp; rsName);
  void ClearAllSpectra();
  CSpectrum* FindSpectrum(const std::string&amp; rName);
  CSpectrum* FindSpectrum(UInt_t id);
  SpectrumDictionaryIterator SpectrumBegin();
  SpectrumDictionaryIterator SpectrumEnd();
  UInt_t SpectrumCount();
  void addSpectrumDictionaryObserver(SpectrumDictionaryObserver* observer);
  void removeSpectrumDictionaryObserver(SpectrumDictionaryObserver* observer);

  void UnGate(const std::string&amp; rSpectrum); 

  void AddGate(const std::string&amp; rName, UInt_t nId, CGate&amp; rGate);
  void DeleteGate(const std::string&amp; rGateName);
  void ReplaceGate(const std::string&amp; rGateName, CGate&amp; rGate);
  void ApplyGate(const std::string&amp; rGateName,  const std::string&amp; rSpectrum);
  CGateContainer* FindGate(const std::string&amp; rGate);
  CGateContainer* FindGate(UInt_t nId);
  CGateDictionaryIterator GateBegin();
  CGateDictionaryIterator GateEnd();
  UInt_t GateCount();

  void addGateObserver(CGateObserver* observer);
  void removeGateObserver(CGateObserver* observer);

  void addGatingObserver(CGatingObserver* observer);
  void removeGatingObserver(CGatingObserver* observer);

};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Histogramming core of SpecTcl.  In addition to performing the
            actual histogramming, this class encapsulates SpecTcl's dictionaries.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            The first set of methods get and set attributes.  The getter methods
            are public while the setters are all protected.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>const </modifier>
                        <type>ParameterDictionary&amp;</type>
                        <methodname> getParameterDictionary</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a reference to the SpecTcl parameter dictionary.
                        This is a dictionary that contains all of the
                        parameter definitions known to SpecTcl. Note that
                        the <classname>SpecTcl</classname> API class
                        provides the access to this dictionary that most
                        applications need and should be used instead rather than
                        directly accessing the dictionary.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>const </modifier>
                        <type>SpectrumDictionary&amp; </type>
                        <methodname>getSpectrumDictionary</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a reference to the Spectrum dictionary.
                        This contains all of the objects that define the
                        spectra the histogrammer increments.  Note that
                        the <classname>SpecTcl</classname> API class
                        provides the access to this dictionary that most
                        applications need and should be used instead rather than
                        directly accessing the dictionary.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>protected:</modifier>
                        <type>void </type>
                        <methodname>setParameterDictionary</methodname>
                        <methodparam>
                           <modifier>const</modifier>
                           <type> ParameterDictionary&amp;</type>
                           <parameter> am_ParameterDictionary</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Allows derived classes to replace the parameter dictionary.
                        This is only useful in the unlikely event you've
                        derived a new dictionary class from the
                        <classname>ParameterDictionary</classname> class.
                    </para>
                    <para>
                        This method should be called early in the lifetime of
                        the derived class to ensure you don't lose existing definitions
                        when replacing the object.  The constructor would be
                        a good place to do this.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>protected</modifier>
                        <type>  void </type>
                        <methodname>setSpectrumDictionary</methodname>
                        <methodparam>
                           <modifier>const </modifier>
                           <type>SpectrumDictionary&amp; </type>
                           <parameter>am_SpectrumDictionary</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Provides a replacement for a spectrum dictionary.
                        Most of the comments associated with
                        <methodname>setParameterDictionary</methodname>
                        apply here.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            The next set of methods are invoked externally to perform histogramming.
            Normally the analyzer object invokes these after building an
            event list from the results of the analysis pipeline.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                           <modifier>const</modifier>
                           <type> CEvent&amp;     </type>
                           <parameter>rEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Resets all of the gates and histograms the
                        <parameter>rEvent</parameter>, a single event.
                        Note that the histograms check the gates needed to
                        be incremented so there's no separate pass taken to
                        check all gates.  Furthermore, gates cache their
                        results so the actual gate computation is not only
                        performed only on the gates needed but at most once per
                        gate.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>operator() </methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CEventList&amp;</type>
                           <parameter> rEventList</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Iterates over each event in <parameter>rEventlist</parameter>
                        invoking the previous overloaded <methodname>operator()</methodname>
                        for each element in that list.   This is the method
                        invoked by the analyzer object to process events from
                        the event processing pipeline.
                    </para>
                </listitem>
            </varlistentry>

        </variablelist>
        <para>
            The next set of methods mainpulate the parameter dictionary.
            Note that the
            <classname>SpecTcl</classname>
            API provides methods to accomplish
            everything these methods accomplish.  I recommend
            using the API singleton to do parameter manipulation or,
            even simpler, use <classname>CTreeParameter</classname>
            objects instead of directly working with SpecTcl low level
            parameters.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CParameter* </type>
                        <methodname>AddParameter</methodname>
                        <methodparam>
                           <modifier>const</modifier>
                           <type> std::string&amp;</type>
                           <parameter> sName</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>nId</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier>const </modifier>
                           <type>char*</type>
                           <parameter> pUnits</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>                  
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CParameter* </type>
                        <methodname>AddParameter</methodname>
                        <methodparam>
                           <modifier>const</modifier>
                           <type> std::string&amp; </type>
                           <parameter>sName</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t</type>
                           <parameter> nId</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t  </type>
                           <parameter>nScale</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CParameter* </type>
                        <methodname>AddParameter </methodname>
                        <methodparam>
                           <modifier>const</modifier>
                           <type> std::string&amp; </type>
                           <parameter>sName</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>nId</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>nScale</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Float_t</type>
                           <parameter> nLow</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Float_t </type>
                           <parameter>nHi</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier>const </modifier>
                           <type>std::string&amp; </type>
                           <parameter>sUnits</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        These methods create a new parameter and
                        add it to the parameter dictionary.
                    </para>
                    <para>
                        <parameter>sName</parameter> is the name of the new parameter.
                        If a parameter with that name already exists,
                        a <classname>CDictionaryException</classname> is thrown.
                        <parameter>nId</parameter> is the parameter's id which
                        is the slot in the <classname>CEvent</classname> array
                        like object in which parameter values are put.
                        A <classname>CDictionaryException</classname> is
                        also thrown
                        if a parameter with that Id already exists.
                    </para>
                    <para>
                        <parameter>nScale</parameter> determines the
                        resolution of the parameter in bits. When creating
                        a spetrum on a parameter, consider being informed
                        by this value when determining the binning for axes
                        involving this parameter.
                    </para>
                    <para>
                        <parameter>nLow</parameter> and <parameter>nHigh</parameter>
                        are soft limits on the values stored in the parameter.
                        Spectra created with axes defined on this parameter
                        should use these values to inform decisions about the
                        limits on those axes.
                    </para>
                    <para>
                        <parameter>sUnits</parameter> is the units of measure
                        for the parameter.   Spectra can label axes with that as
                        a unix of meausre appropriately.
                    </para>
                    <para>
                        On successful return, a pointer to the new
                        <classname>CParameter</classname> object is returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CParameter*</type>
                        <methodname> RemoveParameter </methodname>
                        <methodparam>
                           <modifier>const </modifier>
                           <type>std::string&amp; </type>
                           <parameter>sName</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes the parameter identified by
                        <parameter>sName</parameter> from the parameter
                        dictionary. The parameter object is copy constructed
                        into a dynamically allocated <classname>CParameter</classname>
                        object whose pointer is returned.  The return value
                        must therefore be <literal>delete</literal>d in order
                        to prevent memory leaks.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CParameter* </type>
                        <methodname>FindParameter</methodname>
                        <methodparam>
                           <modifier>const</modifier>
                           <type> std::string&amp; </type>
                           <parameter>rName</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CParameter* </type>
                        <methodname>FindParameter </methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>nPar</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to a <classname>CParameter</classname>
                        object in the parameter dictionary.  The parameter
                        returned either has a name equal to
                        <parameter>rName</parameter> or a parameter id
                        equal to <parameter>nPar</parameter> depending on which
                        actual method is called.
                    </para>
                    <para>
                        If there is no matching parameter a null pointer is returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>ParameterDictionaryIterator </type>
                        <methodname>ParameterBegin</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an iterator to the first element of the
                        parameter dictionary.  Parameter dictionary Iterators
                        act like pointers that point to an
                        <classname>std::pair&lt;std::string, CParameter&gt;</classname>.
                        The first element of this pair is the name of the
                        parameter while the second is the parameter itself.
                    </para>
                    <para>
                        Incrementing an iterator points to the next element
                        of the container.  Incrementing an iterator that points
                        to the last container element returns
                        the same value as returned by
                        <methodname>ParameterEnd</methodname>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>ParameterDictionaryIterator </type>
                        <methodname>ParameterEnd</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an value that is no longer in the container.
                        Typical iteration over the parameter dictionary follows
                        this pattern:
                    </para>
                    <programlisting>
CHistogrammer* pH;                     // Assume this points to the histogrammer.
for (auto p = pH->ParameterBegin(); p != pH->ParameteEnd(); p++) {
        // do something with p->first and p->second.
        ...
}

                    </programlisting>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>UInt_t </type>
                        <methodname>ParameterCount</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of elements in the parameter
                        dictionary.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            The next methods manipulate the spectrum dictionary. The
            <classname>SpecTcl</classname> API singleton class
            provides these services as well and we recommend you use it rather
            than relyingo n these methods.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>AddSpectrum</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CSpectrum&amp; </type>
                           <parameter>rSpectrum</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a new spectrum object to the spectrum dictionary.
                        The Spectrum's  name is used as the dictionary key.
                        The spectrum's id is used as the spectrum number.
                    </para>
                    <para>
                        If a spectrum matches either the name or the id,
                        a <classname>CDictionaryException</classname>
                        is thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CSpectrum* </type>
                        <methodname>RemoveSpectrum</methodname>
                        <methodparam>
                           <modifier>const</modifier>
                           <type> std::string </type>
                           <parameter>sName</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes a spectrum with the name
                        <parameter>sName</parameter> from the spectrum dictionary.
                        A pointer to the removed spectrum is returned to the
                        caller.  If there is no matching spectrum,
                        a null pointer is returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>ClearSpectrum</methodname>
                        <methodparam>
                           <modifier>const </modifier>
                           <type>std::string&amp; </type>
                           <parameter>rsName</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Locates the spectrum in the spectrum dictionary
                        that is named <parameter>rsName</parameter>.  That
                        spectrum's <methodname>clear</methodname> method is
                        called.  Normally that method sets all of the channels of
                        the spectrum to <literal>0</literal>.
                    </para>
                    <para>
                        If there is no matching spectrum, a
                        <classname>CDictionaryException</classname> is thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>ClearAllSpectra</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Iterates through the spectrum dictionary invoking each
                        <classname>CSpectrum</classname> object's
                        <methodname>clear</methodname> method.  This sets all
                        channels for all spectra to zero (assuming that's what
                        the <methodname>clear</methodname> method does for all
                        subclasses of <classname>CSpectrum</classname>).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CSpectrum* </type>
                        <methodname>FindSpectrum</methodname>
                        <methodparam>
                           <modifier>const </modifier>
                           <type>std::string&amp; </type>
                           <parameter>rName</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CSpectrum* </type>
                        <methodname>FindSpectrum</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>id</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        The return value of <methodname>FindSpectrum</methodname>
                        is a pointer to the <classname>CSpectrum</classname> object
                        in the spectrum dictionary that matches the search criterion
                        passed in as an argument.
                        <parameter>rName</parameter> is the name of the spectrum
                        that must match exactly. <parameter>id</parameter> is the
                        spectrum id.
                    </para>
                    <para>
                        If there is no matching spectrum in the dictionary,
                        a null pointer is returned.  Note that the dictionary
                        management methods ensure that there can be at most
                        one match.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>SpectrumDictionaryIterator </type>
                        <methodname>SpectrumBegin</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>SpectrumDictionaryIterator </type>
                        <methodname>SpectrumEnd</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        These methods can be used to iterate over all of the
                        entries in the spectrum dictionary.  Both methods return
                        a <classname>SpectrumDictionaryIterator</classname>. This
                        object acts like a pointer to a
                        <classname>std::pair&lt;std:;string, CSpectrum*&gt;</classname>
                        object.  The first element of the pair is the name of an
                        entry in the dictinoary (spectrum name), the second a pointer
                        to the spectrum with that name.
                    </para>
                    <para>
                        <methodname>SpectrumBegin</methodname> provides an iterator
                        that points to information about the first entry in the
                        dictionary.
                        Incrementing an iterator via its <methodname>operator++</methodname>
                        points it to the next entry in the dictionary.  Incremeting
                        the  iterator when it points to the last entry of the
                        container makes it equal to the value returned from
                        <methodname>SpectrumEnd</methodname>.  
                    </para>
                    <para>
                        Typical spectrum dictionary iteration can use the
                        STL algorithm std::for_each if you have a functor it can call,
                        or can express your operation as a C++ lambda or, without
                        being fancy looks something like (<varname>pHisto</varname>
                        is a pointer to the histogrammer object).
                    </para>
                    <programlisting>
    for (auto p = pHisto-&gt;SpectrumBegin(); p != pHisto-&gt;SpectrumEnd(); p++) {
        std::string name = p-&gt;first;
        CSpectrum*   pSpec= p-&gt;second;
        
        // Do something with the spectrum or name or both.
    }
                    </programlisting>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>UInt_t </type>
                        <methodname>SpectrumCount</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of spectra in the spectrum dictionary.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>addSpectrumDictionaryObserver</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>SpectrumDictionaryObserver* </type>
                           <parameter>observer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>removeSpectrumDictionaryObserver</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>SpectrumDictionaryObserver* </type>
                           <parameter>observer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        These methods control <firstterm>observers</firstterm> of
                        the spectrum dictionary.  For information about the
                        observer programming pattern see:
                        <ulink url='https://en.wikipedia.org/wiki/Observer_pattern' />.
                        For information about the
                        <classname>SpectrumDictionaryObserver</classname> abstract
                        base class, see <literal>DATA TYPES</literal> below.
                    </para>
                    <para>
                        <methodname>addSpectrumDictionaryObserver</methodname>
                        adds an observer whose methods will be called when
                        changes are made to the spectrum dictionary (adding or
                        removing spectra).  <methodname>removeSpectrumObserver</methodname>
                        removes an existing observer (<parameter>observer</parameter>).
                        If the specified <parameter>observer</parameter> has not
                        been established,
                        <methodname>removeSpectrumObserver</methodname>
                        does nothing.
                    </para>
                    <para>
                        It is possible to register a single observer object more
                        than once.  This is considered a pathology but no
                        effort is made to stop you from doing that.  If an
                        observer has been multiply registered,
                        <methodname>removeSpectrumObserver</methodname> will
                        remove all instances of that observer object.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            The Next group of methods are used to mainpulate gates.  In addition
            to adding and replacing gates in the gate dictionary, this set of
            methods can apply gates to a spectrum as well as remove any
            gate application from a spectrum (called <firstterm>ungating</firstterm>).
        </para>
        <para>
            A couple of words about why gates can't actually
            be removed/deleted from
            the gate dictionary.  Many gate types are compound gates.
            Compound gates are formed from logical combinations of othe gates.
            For example an <literal>and</literal> gate is true if all of its
            constituent gates (some of which might also be compound) are
            true.
        </para>
        <para>
            It's very hard, therefore to get a good definition of the effect
            on a compound gate when a gate it depends on (directly or indirectly)
            is destroyed.  Therefore SpecTcl's commands, normally "deletes" a gate not
            by destroying it but by replacing it with a False gate.  This has a
            consistent well defined behavior with respect not only to gates
            that directly depend on the 'deleted' gate but also indirectly
            dependent gates.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>AddGate</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>const std::string&amp; </type>
                           <parameter>rName, UInt_t nId</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>CGate&amp; </type>
                           <parameter>rGate</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a new gate to the gate dictionary.
                        <parameter>rName</parameter> is the name that is given
                        to the gate.  It must be unique or else a
                        <classname>CDictionaryException</classname> will be thrown.
                    </para>
                    <para>
                        <parameter>nId</parameter> is a gate id number.  It's value
                        is not actually important to SpecTcl's processing but
                        it too must be unique, or else a
                        <classname>CDictionaryException</classname> will be thrown
                    </para>
                    <para>
                        <parameter>rGate</parameter> is a reference to the
                        gate that will be added.  The  object is cloned
                        so that a dynamically created copy is actually stored.
                    </para>
                </listitem>
            </varlistentry>          
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>ReplaceGate</methodname>
                    <methodparam>
                       <modifier></modifier>
                       <type>const std::string&amp; </type>
                       <parameter>rGateName, </parameter>
                    </methodparam>
                    <methodparam>
                       <modifier></modifier>
                       <type>CGate&amp;</type>
                       <parameter> rGate</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>           
            </term>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>DeleteGate</methodname>
                    <methodparam>
                       <modifier>const</modifier>
                       <type> std::string&amp; </type>
                       <parameter>rGateName</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    These methods both actually replace the definition of
                    an existing gate.  <methodname>ReplaceGate</methodname>
                    replaces the defintion of the gate named
                    <parameter>rGateName</parameter> with the gate
                    <parameter>rGate</parameter>. The previous gate
                    definition object is deleted (recall that
                    <methodname>addGate</methodname> makes a dynamic clone).
                </para>
                <para>
                    <methodname>DeleteGate</methodname> simply calls
                    <methodname>ReplaceGate</methodname> with a false gate.
                    SpecTcl's commands understand that such gates are actually
                    deleted when listing gates.
                </para>
                <para>
                    If no gate named <parameter>rGateName</parameter>
                    is defined in the gate dictionary, a
                    <classname>CDictionaryException</classname> is thrown.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>CGateContainer* </type>
                    <methodname>FindGate</methodname>
                    <methodparam>
                       <modifier></modifier>
                       <type>const std::string&amp; </type>
                       <parameter>rGate</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>CGateContainer* </type>
                    <methodname>FindGate</methodname>
                    <methodparam>
                       <modifier></modifier>
                       <type>UInt_t </type>
                       <parameter>nId</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Locates a gate either by its
                    name (<parameter>rGate</parameter>) or integer gate
                    id (<parameter>nId</parameter>).  If no matching gate
                    is found in the gate dictionary; a nul pointer is returned.
                </para>
                <para>
                    The return value is a pointer to a <classname>CGateContainer</classname>.
                    For all purposes, you can treat a <classname>CGateContainer</classname>
                    as a pointer to the gate itself.  The gate container is what
                    dependent gates actually use as this allows gate definitions
                    to be modified transparently.
                </para>
                <para>
                    Note that for any specific matched gate, SpecTcl
                    gaurantees that a subsequent search for the same gate
                    (by name or id) will return the same
                    <classname>CGateContainer</classname>.  Furthermore
                    a search for the same gate either by id or by name
                    will, when matched both return the same gate container pointer.
                </para>
            </listitem>
        </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CGateDictionaryIterator </type>
                        <methodname>GateBegin</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CGateDictionaryIterator </type>
                        <methodname>GateEnd</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        These methods iteration over thee gate dictionary.  A
                        <classname>CGateDictionaryIterator</classname>
                        is like a pointer to a
                        <classname>std::pair&lt;std::string, CGateContainer*&gt;</classname>.
                        The first element of the pair is a gate name.  The second a
                        gate container that points to the gate that's currently
                        bound to  that name.
                    </para>
                    <para>
                        <methodname>GateBegin</methodname> returns an iterator that
                        points to the first element in the gate dictionary.
                        Incrementing this iterator points to the next element of the
                        dictionary.  Incrementing the iterator when it points to the
                        last element of the dictionary results in the value
                        returned by <methodname>GetEnd</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>UInt_t </type>
                        <methodname>GateCount</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of entries in the gate dictionary.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>addGateObserver</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CGateObserver* </type>
                           <parameter>observer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>              
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>removeGateObserver</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CGateObserver* </type>
                           <parameter>observer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        These methods manage observers on the gate dictionary.
                        For information about the
                        observer programming pattern see:
                        <ulink url='https://en.wikipedia.org/wiki/Observer_pattern' />.
                        For information about the
                        <classname>CGateObserver</classname> abstract
                        base class, see <literal>DATA TYPES</literal> below.
                    </para>
                    <para>
                        <methodname>addGateObserver</methodname> adds a new
                        <parameter>observer</parameter>
                        to the end of the list of observers of the
                        gate dictionary.  <methodname>removeGateObserver</methodname>
                        removes the <parameter>observer</parameter> from the
                        set of observers established on the gate dictionary.
                    </para>
                    <para>
                        While establishing the same observer more than once is
                        pathalogical, nothing is done to prevent that.  If
                        <methodname>removeGateObserver</methodname> is passed
                        an <parameter>observer</parameter> that has been
                        added more than once, all instances of that observer
                        are removed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>ApplyGate</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>const std::string&amp; </type>
                           <parameter>rGateName</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier>const </modifier>
                           <type>std::string&amp; </type>
                           <parameter>rSpectrum</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term> 
                <listitem>
                    <para>
                        Applies the gate named
                        <parameter>rGateName</parameter> to the spectrum
                        named <parameter>rSpectrum</parameter>.  If either the
                        gate or the spectrum are not in their respective
                        dictionaries, a <classname>CDictionaryException</classname>
                        is thrown.
                    </para>
                    <para>
                        Any previously applied gate remains defined but no longer
                        affects when the spectrum is incremented.  If successful,
                        the spectrum can only be incremented if the
                        gate named by <parameter>rGateName</parameter> evaluates
                        to true for the event.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>UnGate</methodname>
                        <methodparam>
                           <modifier>const </modifier>
                           <type>std::string&amp; </type>
                           <parameter>rSpectrum</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This is like doing a call to
                        <methodname>ApplyGate</methodname> to the spectrum named
                        <parameter>rSpectrum</parameter> passing a gate that is
                        a true gate.  
                    </para>
                    <para>
                        If <parameter>rSpectrum</parameter> does not name
                        a spectrum that is defined in the spectrum dictionary
                        a <classname>CDictionaryException</classname> is thrown.
                        If successful, <parameter>rSpectrum</parameter> is incremented
                        whenever all of the parameters required are present and
                        inside the spectrum's axis bounds.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>addGatingObserver</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CGatingObserver* </type>
                           <parameter>observer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>removeGatingObserver</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CGatingObserver* </type>
                           <parameter>observer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Manage the gating observers.  Gating observers
                        observe the application of gates to spectra as well
                        as the ungating of spectra.
                        For infoirmation about the observer pattern see
                        <ulink url='https://en.wikipedia.org/wiki/Observer_pattern' />.
                        For information about
                        <classname>CGatingObserver*</classname> objects
                        see <literal>DATA TYPES</literal> below.
                    </para>
                    <para>
                        <methodname>addGatingObserver</methodname> adds a new
                        <parameter>observer</parameter> to the end of the list of
                        observers that will be invoked when gate applications/removals
                        are done.  <methodname>removeGatingObserver</methodname>
                        removes the observer <parameter>observer</parameter>
                        from the list of gating observers.
                    </para>
                    <para>
                        While it is pathalogical to add the same observer more
                        than once, no steps are taken to block this.   Furthermore,
                        if <methodname>removeGatingObserver</methodname> is asked
                        to remove a gating observer that has been multiply added,
                        <emphasis>all</emphasis> instances of it in the observer
                        list are removed.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        
    </refsect1>
    <refsect1>
        <title>DATA TYPES</title>
        <para>
            The <classname>CHistogrammer</classname> methods use a number
            of data types.  These will be documented in full later in this
            part of the manual.  A brief overview of some of them is given here.
        </para>
        <para>
            Let's start with dictionaries.  The <filename>Dictionary.h</filename>
            is a templated class that wraps an <classname>std::map</classname>
            object that is indexed by a string.  The actual object contained
            by the map is templated.  The functionality added by
            <classname>Dictionaries</classname> is support for observation.
        </para>
        <para>
            Observation, or the observer pattern, is an object oriented
            programming pattern that allows external objects (observers)
            to be notified
            of state changes in another objecdt (the observed objecdt).
            <classname>Dictionary</classname> objects maintain a list of
            observers.  
        </para>
        <para>
            Each observer is an object from  class that is derived from
            <classname>DictionaryObserver</classname>.  This is, inn turn
            a templated class, templated by the type of object contained by
            the <classname>Dictionary</classname>  it observers.
        </para>
        <para>
            The observer base class provides an interface that looks like:
        </para>
        <programlisting>
template &lt;class T&gt;
class DictionaryObserver 
{
public:
  virtual void onAdd(std::string   name,   T&amp; item) {}
  virtual void onRemove( std::string name,    T&amp; item) {}

};            
        </programlisting>
        <para>
            Provided a do nothing implementation for each observer method
            allows useful observers to only implement the methods they care about.
        </para>
        <para>
            <methodname>onAdd</methodname> is called whenever <parameter>item</parameter>
            is added to the dictionary with the name <parameter>name</parameter>.
            This observer method is called after <parameter>item</parameter>
            has been successfullly added to the dictionary.
        </para>
        <para>
            <methodname>onRemove</methodname> is invoked whenever the
            <parameter>item</parameter> associated with <parameter>name</parameter>
            is removed from the dictionary.  It is called just prior to
            <parameter>item</parameter>'s erasure from the map.
        </para>
        <para>
            All observers form an ordered list and are called in the order in which
            they were registered.
        </para>
        <para>
            While we are talking about <classname>Dictionary</classname> observers,
            let's look as well at <classname>GatingObserver</classname> objects.
            These allow code to observer the application of gates to spectra
            and the ungating of a spectrum.  As such they don't actually
            fit well into the dictionary observers described.
        </para>
        <para>
            Here's the interface presented by a <classname>GatingOBserver</classname>:
        </para>
        <programlisting>
class CGatingObserver
{
public:
    virtual void onApply(const CGateContainer&amp; rGate, CSpectrum&amp; rSpectrum,
                         CHistogrammer&amp; rSorter) = 0;
    virtual void onRemove(const CGateContainer&amp; rGate, CSpectrum&amp; rSpectrum,
                          CHistogrammer&amp; rSorter) = 0;

};

        </programlisting>
        <para>
            As you can guess, <methodname>onApply</methodname> is invoked when
            <parameter>rGate</parameter> is applied to
            <parameter>rSpectrum</parameter>.  Similarly,
            <methodname>onRemove</methodname> is applied when
            <parameter>rSpectrum</parameter> is un-gated. In that case,
            <parameter>rGate</parameter> is the gate that used to be applied
            to that spectrum.  Note that in all cases,
            <parameter>rSorter</parameter> is a reference to the histogrammer
            object itself.
        </para>
        <para>
            Next let's look at the type of dictinoaries
            <classname>CHistogrammer</classname> maintains.  Each dictionary
            represents a name indexed store of one of the fundamental
            classes SpecTcl defines:
        </para>
        <variablelist>
            <varlistentry>
                <term><classname>ParameterDictionary</classname></term>
                <listitem>
                    <para>
                        The objects contained by this dictionary are
                        <classname>CParameter</classname> objects.
                        Note that
                        this class is a final class; no subclasses are defined.
                        The class supports copy construction allowing
                        <classname>ParameterDictionary</classname> to
                        contains <classname>CParameter</classname> objects rather
                        than pointers or references.
                    </para>
                    <para>
                        Once created  a <classname>CParameter</classname> object
                        is considered immutable.
                        See the <classname>CParameter</classname> reference
                        page for more information about that object.  Normal code,
                        however should strongly consider using
                        <classname>CTreeParameter</classname> and
                        <classname>CTreeParameterArray</classname> objects
                        as front ends to the <classname>CParameter</classname>
                        objects SpecTcl's guts use.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>SpectrumDictionary</classname></term>
                <listitem>
                    <para>
                        This dictionary contains pointers to
                        <classname>CSpectrum</classname> objects.  The
                        <classname>CSpectrum</classname> class is an
                        abstract base class for concrete classes that
                        implement the rich variety of spectra SpecTcl supports.
                    </para>
                    <para>
                        Therefore, spectrum objects must be created and then
                        added to the dictionary in a separate step.
                        
                    </para>
                    <para>
                        In parallel with the spectrum dictionary, SpecTcl maintains
                        data structures that facilitate parameter driven
                        histogramming.  Those structures are maintained using the
                        dictionary observer mechanism.  Their purpose is to restrict
                        the number of histograms that must be asked to increment
                        themselves for each event to those that depend on at least
                        one parameter present in that event.  For sparse events,
                        this results in significant performance improvements.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>CGateDictionary</classname></term>
                <listitem>
                    <para>
                        Contains pointers to <classname>CGateContainer</classname>
                        objects.  <classname>CGateContainer</classname> objects
                        are wrappers for pointers to <classname>CGate</classname>
                        objects.  When they were developed the various
                        pointer like objects in the standard C++ library had not
                        yet been defined and implemented.
                    </para>
                    <para>
                        A <classname>CGateContainer</classname> object is a fixed
                        object that can be handed to a user of a gate that is
                        invariant, although the gate it points to may vary with time.
                        If, for example, spectra contained a pointer to their gate,
                        each time the definition of that gate changed, the
                        value of that pointer would need to change too.
                        You can think of a <classname>CGateContainer</classname>
                        as a hidden pointer the gate pointer with methods that
                        allow it to look like the gate pointer itself.
                    </para>
                    <para>
                        By handing gated spectra a pointer to their gate's
                        <classname>CGateContainer</classname> object the
                        underlying gate pointer can be transparently modified
                        with respect to the gate clients.
                    </para>
                    <para>
                        <classname>CGate</classname> objects, which are what
                        <classname>CGateContainers</classname> appear to point at,
                        implement SpecTcl Gates.  <classname>CGate</classname>
                        is an abstract base class for the class hierarchy that
                        represents the rich set of gates SpecTcl defines.
                    </para>
                    <para>
                        See reference information  on gate classes and
                        the gate container for more information.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>Dictionaries</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>Dictionaries</refname>
        <refpurpose>Describe dictionaries used by SpecTcl</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;Dictionary.h&gt;
template &lt;class T&gt;
class DictionaryObserver 
{
public:
  virtual void onAdd(std::string   name,   T&amp; item) {}
  virtual void onRemove( std::string name,    T&amp; item) {}

};

template &lt;class T&gt;
class CDictionaryObserverManager 
{
  void addObserver(DictionaryObserver&lt;T&gt;* observer);
  void removeObserver(DictionaryObserver&lt;T&gt;* observer);
  void invokeAdd(const std::string name, T&amp; item);
  void invokeRemove(const std::string name, T&amp; item);

};

template &lt;class T&gt;
class CDictionary      
{
  DictionaryIterator Lookup(std::string sName);
  ConstDictionaryIterator Lookup(std::string sName);
  template&lt;class Predicate&gt;
    DictionaryIterator FindMatch(Predicate p);
  template&lt;class Predicate&gt;
    ConstDictionaryIterator FindMatch(Predicate p);
  void Enter(std::string sName, T&amp; Item);
  void Remove(std::string rsName);

  DictionaryIterator begin();
  ConstDictionaryIterator begin() const;
  DictionaryIterator end();
  ConstDictionaryIterator end() const ;

  UInt_t size() const;
  void addObserver(DictionaryObserver&lt;T&gt;* observer);
  void removeObserver(DictionaryObserver&lt;T&gt;* observer);
};

        </synopsis>
        <synopsis>
#include &lt;DictionaryException&gt;
class CDictionaryException  : public CException        
{
public:
  enum {
    knDuplicateKey,
    knDuplicateId,
    knNoSuchId,
    knNoSuchKey,
    knWrongGateType
  };
  
public:
  CDictionaryException(Int_t nReason, const char* pDoing, 
		       const char* pName);
  CDictionaryException(Int_t nReason, const char* pDoing, 
		       const std::string&amp; rName);
  CDictionaryException(Int_t nReason, const std::string&amp; rDoing,
		       const char* pName);
  CDictionaryException(Int_t nReason, const std::string&amp; rDoing,
		       const std::string&amp; rName);
  CDictionaryException(Int_t nReason, const char* pDoing,
		       UInt_t nId) ;
  CDictionaryException(Int_t nReason, const std::string&amp; rDoing,
		       UInt_t nId) ;

  virtual   const char* ReasonText ()  const;
  virtual   Int_t ReasonCode () const  ;
};

        </synopsis>
        <synopsis>
#include &lt;CFitDictionary.h&gt;
class CFitDictionary {
public:
  typedef std::map&lt;std::string, CSpectrumFit*&gt; FitMap;
  typedef FitMap::iterator      iterator;

  class CObserver {
  public:
    virtual void Add(CSpectrumFit&amp; fit) =0;
    virtual void Delete(CSpectrumFit&amp; fit) = 0;
    virtual void Update(CSpectrumFit&amp; fit) = 0;

  };

  typedef std::list&lt;CObserver*&gt; ObserverList;

  static CFitDictionary&amp; getInstance();

  void add(CSpectrumFit&amp; fit);
  void addOrReplace(CSpectrumFit&amp; fit);
  void Delete(std::string name);

  iterator begin();
  iterator end();
  size_t   size();
  iterator find(std::string name);
  void     erase(iterator here);
  void     erase(iterator first, iterator last);

  void updateFits(std::string name=std::string("*")); 

  void addObserver(CObserver&amp; obs);
  void removeObserver(CObserver&amp; obs);
 
};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This page describes SpecTcl dictionaries and their related classes.
        </para>
        <para>
            The <classname>CDictionary</classname> class is a templated
            class that associates names with arbitrary objects.  It adds to the
            <classname>std::map</classname> class the ability to maintain
            a set of <firstterm>observers</firstterm>.  Observers are objects
            that are informed of changes in the dictionary (specifically
            the addition and removal of items from the dictionary).
        </para>
        <para>
            Closely related to the <classname>CDictionary</classname> class,
            therefore are <classname>DictionaryObserver</classname>, the
            templated base class of observers.  Applications will subclass this
            and provide the appropriate template arguments for the dictionary
            used to make use of them.  Note that in most cases where SpecTcl
            uses a dictionary, it provides a typedef for the observer base class
            that already has provided the template parameters.
        </para>
        <para>
            <classname>CDictionaryObserverManager</classname> is actually
            usable by wrapers of any name/value container (e.g. hashes and
            multimaps).  It maintains a list of observer and provides
            methods to invoke the observers it maintains.
        </para>
        <para>
            The <classname>CDictionaryException</classname> class provides
            an exception derived from <classname>CException</classname>
            SpecTcl throws for many dictionary use violations.  These
            are not normally thrown by the dictionary itself but by SpecTcl
            code that provides a higher level API to specific dictionaries.
        </para>
        <para>
            For example, the <classname>CHistogrammer</classname> throws these
            if there is an attempt to duplicate the name or id of a dictionary
            entry.
        </para>
        <para>
            The <classname>CFitDictionary</classname> provides a dictionary
            that manages SpecTcl fit objects.  In addition, the observers
            maintained by fit dictionaries, contain a callback that is invoked
            if a fit is modified, as well as if it is added or removed
            from the dictionary.
        </para>
    </refsect1>
    <refsect1>
        <title>CDictionaryObserverManager</title>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>addObserver</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>DictionaryObserver&lt;T&gt;* </type>
                           <parameter>observer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds an <parameter>observer</parameter>
                        to the list of observers managed by
                        this object.  Observers are an ordered list.  The
                        new <parameter>observer</parameter> is added to the
                        end of the list.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>removeObserver</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>DictionaryObserver&lt;T&gt;* </type>
                           <parameter>observer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes an <parameter>observer</parameter> from the
                        list of observers managed by this object.  Note that
                        while it is pathalogical, it is legal to register
                        the same observer object more than once.  If
                        <methodname>removeObserver</methodname> is asked to
                        remove an observer that is multiply registered,
                        all instances of that observer are removed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>invokeAdd</methodname>
                        <methodparam>
                           <modifier>const </modifier>
                           <type>std::string </type>
                           <parameter>name</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>T&amp; </type>
                           <parameter>item</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Iterates over the list of observer objects this object
                        maintains.  For each observer, the
                        <methodname>onAdd</methodname> method is invoked
                        with the parameters passed to <methodname>invokeAdd</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>invokeRemove</methodname>
                        <methodparam>
                           <modifier>const </modifier>
                           <type>std::string </type>
                           <parameter>name</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>T&amp; </type>
                           <parameter>item</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Same as <methodname>invokeAddd</methodname>
                        but each object's <methodname>onRemove</methodname>
                        is called instead.
                    </para>
                </listitem>
            </varlistentry>
             
        </variablelist>
    </refsect1>
    <refsect1>
        <title>CDictionaryObserver</title>
        <para>
            Note that this is a base class.  Real observers are classes
            that inherit from this one.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>onAdd</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string  </type>
                           <parameter> name</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>T&amp; </type>
                           <parameter>item</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is invoked when an item is added to a
                        dictionary.  <parameter>name</parameter> is the name of
                        the item (dictionary key), <parameter>item</parameter>
                        refers to the item about to be added.  Note that
                        the base class implementation does nothing.  If you
                        don't need to observe dictionary additions simply don't
                        override this method.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>onRemove</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string</type>
                           <parameter> name</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>T&amp; </type>
                           <parameter>item</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is invoked when an item is about to be
                        removed from a dictionary.  <parameter>name</parameter>
                        is the name (dictionary index) of the item and
                        <parameter>item</parameter> refers to the item.
                    </para>
                    <para>
                        At the time this method is called, the item is still
                        in the dictionary.  The item is only removed from the
                        dictionary after all observers have been invoked.
                    </para>
                    <para>
                        The base class implementation is empty.  Therefore if your
                        observer does not need to observer dictionary
                        removals, simply don't override the implementation
                        of this method.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title>CDictionary</title>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>DictionaryIterator </type>
                        <methodname>Lookup</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string </type>
                           <parameter>sName</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>ConstDictionaryIterator </type>
                        <methodname>Lookup</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string </type>
                           <parameter>sName</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a <classname>DictionaryIterator</classname>
                        that points to a
                        <classname>std::pair&lt;std::string, T&gt;</classname>
                        object that has a name that is the same as
                        <parameter>sName</parameter>.  The first item of the
                        pair should be equal to <parameter>sName</parameter>
                        and is the name of the item in the dictionary.
                        The second item of the pair should be the item which is
                        associated with that key.
                    </para>
                    <para>
                        This method requires that <classname>T</classname>
                        have a copy constructor or be trivially copy constructable.
                        If there is no match for <parameter>sName</parameter>
                        in the dictionary, the value returned by
                        <methodname>end</methodname> is returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>template&lt;class Predicate&gt;</modifier>
                        <type>DictionaryIterator </type>
                        <methodname>FindMatch</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>Predicate</type>
                           <parameter> p</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier>template&lt;class Predicate&gt;</modifier>
                        <type>ConstDictionaryIterator </type>
                        <methodname>FindMatch</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>Predicate</type>
                           <parameter> p</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Performs an search using an arbitrary predicate;
                        <parameter>p</parameter> as the matching criterion.
                        The return value is a dictionary iterator as
                        described in <methodname>Lookup</methodname> above.
                    </para>
                    <para>
                        <parameter>p</parameter> is any class that implements
                        the <methodname>operator()</methodname> taking as a
                        single parameter a
                        <classname>std::pair&lt;std::string, T&gt;</classname>
                        object.  The first item of the pair is the name of some
                        entry in the dictionary.  The second is the entry with
                        that name.  The predicate must return a
                        value that can be converte to <type>bool</type>.  If
                        the return is <literal>true</literal>, the item
                        is treated as satisfying the match.  If not iteration
                        continues with different pairs until either the entire
                        container has been checked or a match is found.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>Enter</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string </type>
                           <parameter>sName</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>T&amp; </type>
                           <parameter>Item</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds <parameter>Item</parameter> to the dictionary indexed
                        by <parameter>sName</parameter>.  If an item already
                        exists with that name it's overwitten. If
                        <type>T</type> is a pointer to dynamically allocated
                        objets, this results in memory leaks unless the
                        dictionary is encapsulated by a derived class or front-ended
                        by an API.
                    </para>
                    <para>
                        Many SpecTcl dictionaries live privately in enclosing
                        classes like <classname>CHistogram</classname>.
                        In some cases (e.g. the parameter and spectrum
                        dictionaries), these classes impose an API that throws
                        errors if duplicate entries are attempted.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>Remove</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string </type>
                           <parameter>rsName</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes the entry whose index is
                        <parameter>rsName</parameter>.  This does nothing
                        if there is no entry with the index
                        <parameter>rsName</parameter>.
                    </para>
                    <para>
                        Many SpecTcl dictionaries are encapsulated by other classes.
                        In some cases those classes throw exceptions if attempts are
                        made to remove nonexistent objects.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>DictionaryIterator </type>
                        <methodname>begin</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>ConstDictionaryIterator </type>
                        <methodname>begin </methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>DictionaryIterator </type>
                        <methodname>end</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>ConstDictionaryIterator</type>
                        <methodname> end </methodname>
                        <void />
                        <modifier>const </modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        These methods support iteration over dictionary contents.
                        <classname>DictionaryIterator</classname> and
                        <classname>ConstDictionaryIterator</classname> are
                        pointer like objects.  They 'point' to
                        <classname>std::pair&lt;std::string, T&gt;</classname>
                        objects. The first item of the pair is a dictionary
                        key.  The second, the object stored at that key.
                    </para>
                    <para>
                        <methodname>begin</methodname> returns an iterator
                        to the first element of the container.  Currently,
                        this is the one with the  key that collates earliest.
                        Incrementing an iterator points it to another element
                        of the container.   Currently, the iterator traverses
                        the container in increasing collation order with respect
                        to the key.
                    </para>
                    <para>
                        If an iterator points to the last element of the
                        dict, incrementing it results in the same value
                        returned from the <methodname>end</methodname>
                        method.  The iterators returned by these methods
                        are compatible with the C++ standard library algorithms
                        that accept container iterators.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>UInt_t </type>
                        <methodname>size</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of elements stored in the dictionary.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>addObserver</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>DictionaryObserver&lt;T&gt;* </type>
                           <parameter>observer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>removeObserver</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>DictionaryObserver&lt;T&gt;* </type>
                           <parameter>observer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        These methods support observation of the dictionary.
                        <methodname>addObserver</methodname> adds an
                        <parameter>observer</parameter>
                        that will be called when items are added
                        or removed from the dictionary.  Observers have been
                        previously described.
                    </para>
                    <para>
                        <methodname>removeObserver</methodname> removes the
                        <parameter>observer</parameter> from the list of
                        observers that monitor the dictionary.
                        While it is pathalogical, <methodname>addObserver</methodname>
                        does not prevent you from adding the same observer object
                        more than once.  If have added a specific observer more
                        than onece, <methodname>removeObserver</methodname>
                        removes all instances of that observer from
                        the dictionary's <classname>CDictionaryObserverManager</classname>
                        object.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>              
        <programlisting>
             
        </programlisting>
    </refsect1>
    <refsect1>
        <title>CDictionaryException</title>
        <para>
            Before providing reference material to <classname>CDictionaryException</classname>,
            Let's first look at the public enum that provides the valid
            values for the reason code in the destructor:
        </para>
        <programlisting>
  enum {
    knDuplicateKey,
    knDuplicateId,
    knNoSuchId,
    knNoSuchKey,
    knWrongGateType
  };
            
        </programlisting>
        <para>
            Not all values are used by the APIs in front of all dictionaries.
            These values have the following meanings:
        </para>
        <variablelist>
            <varlistentry>
                <term><literal>knDuplicateKey</literal></term>
                <listitem>
                    <para>
                        An attempt was made to insert an entry with a key that
                        already exists in the dictionary.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>knDuplicateId</literal></term>
                <listitem>
                    <para>
                        For dictionaries whose entries have
                        unique integer ids
                        stored in their objects:  This value indicates an
                        attempt to add an entry that has an id that matches
                        an existing element of the dictionary.  For example;
                        Adding two parameters  with the same Id throws this error.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>knNoSuchId</literal></term>
                <listitem>
                    <para>
                        This reason is used after a search by id results in no
                        matching items.  Note that other dictionary APIs
                        may indicate without an error that there is no match
                        (e.g. returning a null pointer or an end iterator)
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>knNoSuchKey</literal></term>
                <listitem>
                    <para>
                        Similar to <literal>knNoSuchId</literal> this is thrown
                        when a search for an item by name fails to locate
                        a match.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>knWrongGateType</literal></term>
                <listitem>
                    <para>
                        This is not used in SpecTcl.  It is intended for use
                        when a gate of an incompatible type for some operation
                        is selected.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            <classname>CDictionaryException</classname> is essentially an
            <classname>CException</classname> class whose
            <methodname>ReasonText</methodname> and
            <methodname>ReasonCode</methodname> interpret the
            <parameter>nReason</parameter> code used to construct it as
            a member of the enum described above.
        </para>
        <para>
            The class has as rich set of constructors. For the most part
            these match the constructors available for
            <classname>CException</classname>.  The parameters
            <parameter>nReason</parameter> should be chosen from the
            reason enum described above.  The <parameter>pName</parameter>
            and <parameter>rName</parameter> parameters are names of items
            <parameter>nId</parameter> parameters are relevant object Ids.
        </para>
    </refsect1>
    <refsect1>
        <title>CFitDictionary></title>
        <para>
            <classname>CFitDictionary</classname> is a specialized dictionary
            that holds fits.  It also provides an extended observer as
            a nested class; <classname>CFitDictionary::CObserver</classname>.
            The observer base class for fit dictionaries have the following
            pure virtual methods.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>Add</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CSpectrumFit&amp; </type>
                           <parameter>fit</parameter>
                        </methodparam>
                        <modifier>=0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when a fit is added to the dictionary.  <parameter>fit</parameter>
                        is the object that was added.  Note that this object
                        provides the needed methods to get the name of the
                        fit as well as the  name of the spectrum on which the
                        fit is defined.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>Delete</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CSpectrumFit&amp; </type>
                           <parameter>fit</parameter>
                        </methodparam>
                        <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when a fit is deleted (removed from the
                        dictionary).  This is called prior to the actual
                        removal of the <parameter>fit</parameter> from
                        the dictionary.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>Update(</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CSpectrumFit&amp; </type>
                           <parameter>fit</parameter>
                        </methodparam>
                        <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when a fit is updated.  Updating a fit means
                        that its parameters are recomputed based on the current
                        data in  a spectrum.  If a
                        <parameter>fit</parameter> was created and then
                        additional or new data were acquired, updating the
                        fit is necessary to make the fit reflect the new
                        channel values in the region of interest.
                    </para>
                    <para>
                        This method is called just after the update has been
                        computed.  One use is to maintain the display of a fit
                        on a spectrum by a displayer.
                    </para>
                </listitem>
            </varlistentry>
    
    
        </variablelist>
        <para>
            Note that the fit dictionary is also a singleton class and therefore
            has private constructors and destructors.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>CFitDictionary&amp; </type>
                        <methodname>getInstance</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the singleton instance of this class.  If the
                        dictionary has not yet been created, this will create it.
                        If it has, a reference to the existing dictionary
                        is returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>add</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CSpectrumFit&amp; </type>
                           <parameter>fit</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a new fit to the dictionary.  Note that if the
                        dictionary already has a fit named the same as
                        <parameter>fit</parameter>, a
                        <classname>CDictionaryException</classname> is thrown
                        with the reason
                        <literal>CDictionaryException::knDuplicateKey</literal>.
                    </para>
                    <para>
                        See <methodname>addOrReplace</methodname> below as well.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>addOrReplace</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CSpectrumFit&amp; </type>
                           <parameter>fit</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds <parameter>fit</parameter> to the dictionary.  If
                        a fit with that name already exists it is replaced
                        by this new fit.  In that case observer
                        <methodname>Delete</methodname> methods are called.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>Delete</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string </type>
                           <parameter>name</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Delets any fit with the name
                        <parameter>name</parameter>.  If there is no such
                        fit, <classname>CDictionaryException</classname>
                        with the reason
                        <literal>CDictionaryException::knNoSuchkey</literal>
                        is thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>iterator</type>
                        <methodname> begin</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>    
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>iterator </type>
                        <methodname>end</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
  

                <listitem>
                    <para>
                        These methods support iteration over the container
                        that holds the fit dictionary.
                        <classname>CFitDictionary::iterator</classname>
                        is an pointer like object that points at
                        <classname>std::pair&lt;std::string, CSpectrumFit*&gt;</classname>
                        objects.  The first element of the pair is the name of the
                        fit while the second is  a pointer to the fit object.
                    </para>
                    <para>
                        <methodname>begin</methodname> returns an iterator that
                        points to the first element of the dictionary.  Incrementing
                        an iterator results in an interator that points at the next
                        element of the dictionary.  If the iterator points to
                        the last element of the dictionary, incrementing it
                        produces the value returned by
                        <methodname>end</methodname>
                    </para>
                    <para>
                        These iterators are suitable for use in any of the
                        C++ standard library algorithms that require iterators.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>size_t   </type>
                        <methodname>size</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of elements in the dictionary.
                    </para>
                </listitem>
            </varlistentry>
        
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>iterator </type>
                        <methodname>find</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string</type>
                           <parameter> name</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an iterator to the dictionary entry
                        pair with the index <parameter>name</parameter>.
                        If <parameter>name</parameter> is not found,
                        the value returned from
                        <methodname>end</methodname> is returned:
                    </para>
                    <programlisting>
CFitDictionary&amp; fitDict(CFitDictionary::getInstance());

CFitDictionary::iterator p = fitDict->find("foo");
if (p != fitDict.end()) {

std::string name = p-&gt;first;
CSpectrumFit* fit = p-&gt;second;

// Do something with what was found.
} else {
j  // Item was not found.
}
                    </programlisting>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void     </type>
                        <methodname>erase</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>iterator </type>
                           <parameter>here</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void     </type>
                        <methodname>erase</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>iterator </type>
                           <parameter>first</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>iterator </type>
                           <parameter>last</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes items from the dictionary based on iterators.
                        <parameter>here</parameter> is an iterator that points to
                        the item to remove> <parameter>first</parameter> and
                        <parameter>last</parameter> are iterators that define a
                        range of items to remove.  All items from <parameter>first</parameter>
                        up to but not including <parameter>last</parameter>
                        are removed.
                    </para>
                    <para>
                        Note that <methodname>erase</methodname> invalidates
                        the iterator(s) it receives as parameters.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>updateFits</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string </type>
                           <parameter>name</parameter>
                           <initializer>std::string("*")</initializer>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Recomputes fits with current spectrum data for all
                        fit names that match the glob pattter
                        <parameter>name</parameter>.  Note that the default
                        value for this parameter, <literal>*</literal>,
                        matches all fits.
                    </para>
                    <para>
                        Fits are defined on regions of interest in spectra.
                        As spectra accumulate or are cleared and a new data
                        set analyzed, they can be recomputed on the current data.
                        SpecTcl establishes observers that propagate the changes
                        to the fit information to its displayers so that the fitlines
                        displayed on those spectra also automatically update.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>addObserver</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CObserver&amp;</type>
                           <parameter>obs</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>removeObserver</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CObserver&amp; </type>
                           <parameter>obs</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        These methods manage observers that are monitoring
                        the fit dictionary.   <methodname>addObserver</methodname>
                        adds the observer <parameter>obs</parameter> to end of the
                        list of observers.  <methodname>removeObserver</methodname>
                        removes all instances of <parameter>ojbs</parameter> from
                        the list of observers maintained by the dictionary.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CAnalyzer</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CAnalyzer</refname>
        <refpurpose>Analyzer base class and classic analyzer</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;Analyzer.h&gt;

class CAnalyzer
{
public:
  virtual void OnBuffer(UInt_t nBytes, Address_t pData);
  virtual void OnStateChange(UInt_t nType, CBufferDecoder&amp; rDecoder);
  virtual void OnPhysics(CBufferDecoder&amp; rDecoder);
  virtual void OnScaler(CBufferDecoder&amp; rDecoder);
  virtual void OnOther(UInt_t nType, CBufferDecoder&amp; rDecoder);
  virtual void OnEndFile();
  virtual void OnInitialize();

  CEventList&amp; getEventList();
  CBufferDecoder* getDecoder() ;
  CEventSink* getSink() ;

  CBufferDecoder* AttachDecoder(CBufferDecoder&amp; rDecoder);
  CBufferDecoder* DetachDecoder();
  CEventSink*     AttachSink(CEventSink&amp; rSink);
  CEventSink*     DetachSink();
  void            entityNotDone();

  
protected:
  virtual UInt_t OnEvent(Address_t pRawData, CEvent&amp; anEvent);

  void           AbortEvent();

  void CopyEventList(const CEventList&amp; rhs);
  void CopyEventPool(const CEventList&amp; rhs);
  void DetachAll();
  CEvent* CreateEvent();
  void ReturnEvent(CEvent* pEvent);
  void ClearEventList();
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This class is currently used as the base class for the
            <classname>CTclAnalyzer</classname> class used as the analyzer
            in modern SpecTcl.  In the original SpecTcl version, this
            <emphasis>was</emphasis>
            the analyzer. 
        </para>
    </refsect1>
    <refsect1>
        <title>PUBLIC METHODS</title>
        <para>
            The public interfaces to <classname>CAnalyzer</classname>
            come in groups.  The first group defines the interface to the
            analyzer used when handling data from an event source.  New analyzers
            (such as <classname>CTclAnalyzer</classname>) can be built
            by deriving a new class from these and overriding the
            desired methods.
        </para>
        <para>
            The second group of methods are public utilities.  These
            provide methods that are related to the configuration of the
            analyzer.  External entities may also call them but they
            are not, strictly speaking, behavioral methods.
        </para>
        <para>
            Let's look at the set of virtual public  methods that implement
            the behavior of the analyzer first.  Note that 
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnBuffer</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>nBytes</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Address_t </type>
                           <parameter>pData</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is invoked by the event input subsystem
                        when a block of data is available on the data source.
                        It will typically pass the block to the
                        buffer decoder.  The buffer decoder will locate
                        items within the block and make appropriate calls
                        back to the analyzer to analyze those items.
                    </para>
                    <para>
                        <parameter>nBytes</parameter> are the number
                        of bytes of data in the block pointed to by
                        <parameter>pData</parameter>.
                    </para>
                    <para>
                        Typically derived classes don't need to override this
                        method or at least can call it as part of their
                        override.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnStateChange</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>nType</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>CBufferDecoder&amp; </type>
                           <parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called by the buffer decoder when a state change item
                        has been detected in the data block it was passed
                        by <parameter>OnBuffer</parameter>.  State change
                        items indicate that a run has changed state.
                    </para>
                    <para>
                        <parameter>nType</parameter> is the item type from
                        <filename>bufftypes.h</filename>.  It should normally
                        be one of the following values.
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term><literal>BEGRUNBF</literal></term>
                            <listitem>
                                <para>
                                    The state change indicates the beginning
                                    of a new run.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <literal>ENDRUNBF</literal>
                            </term>
                            <listitem>
                                <para>
                                    The state change indicates the end of the
                                    active run
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>PAUSEBF</literal></term>
                            <listitem>
                                <para>
                                    The state change indicates a pause in data taking.
                                    Note that it is perfectly legal for this to be
                                    immediately followed by an end of run.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>RESUMEBF</literal></term>
                            <listitem>
                                <para>
                                    The state change indicates a paused run
                                    is being resumed.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                    <para>
                        <parameter>rDecoder</parameter>, on the other hand
                        refers to the buffer decoder that is calling this method.
                        This is provided because the buffer decoder may have
                        stashed items from the run state method that can be
                        retrieved via some of its methods.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type> void </type>
                        <methodname>OnPhysics</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CBufferDecoder&amp; </type>
                           <parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when one or more physics events is received.
                        <parameter>rDecoder</parameter> is a reference to the
                        decoder that called us.
                    </para>
                    <para>
                        Looking at this method you might rightfully wonder
                        where the data is hiding.  The answer is that
                        the decoder; <parameter>rDecoder</parameter>
                        has methods that can be used to get several pieces of
                        information:
                    </para>
                    <itemizedlist>
                        <listitem>
                            <para>
                                The number of physics events being made available.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                The number of bytes of data required to store
                                these events.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                A pointer to the first of those events.
                            </para>
                        </listitem>
                    </itemizedlist>
                    <para>
                        Note that the buffer decoder is not responsible for
                        telling you where the boundaries between events are.
                        That's the responsibility of the event processor.
                        Pushing that responsibility off to the event processor
                        allows for the possibility that the DAQ system might
                        be able to produce <firstterm>superevents</firstterm>, that
                        is events that actually contain more than one single
                        SpecTcl event.
                    </para>
                    <para>
                        The base class method calls the
                        <methodname>OnEvent</methodname> method for each
                        event in the run of events.  
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type> void </type>
                        <methodname>OnScaler</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CBufferDecoder&amp; </type>
                           <parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called if the buffer decoder locates a scaler event.
                        In this case, the buffer decoder is supposed to supply
                        the number of scalers and a pointer to the body of the
                        scaler item.  The shape of a scaler item varies depending
                        on the data acquisition system that created it.
                        This implies that specialized user software is required
                        to process scalers.
                    </para>
                    <para>
                        If old versions of SpecTcl were used, the analysis of
                        scaler data would have required subclassing
                        <classname>CAnalyzer</classname> with a class that
                        understood the specific scaler format and replacing
                        the standard analyzer with an instance of this subclass.
                        With current versions of SpecTcl, the understanding of
                        scaler data is handled by the event processor.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type> void </type>
                        <methodname>OnOther</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>nType</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>CBufferDecoder&amp; </type>
                           <parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when the decoder finds items in a buffer that
                        don't fit into the catagories handled by the other
                        types.  <parameter>nType</parameter> should be an
                        item type from <filename>buftypes.h</filename>.
                        for example <literal>STATEVARBF</literal> for an item
                        containing state variables. <parameter>rDecoder</parameter>,
                        once more, is a reference to the decoder object.
                    </para> 
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnEndFile</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when by the input handlers when an end file has
                        been detected on the event source.    At present this
                        invokes the decoder's <methodname>OnEnd</methodname>
                        giving it a chance to flush out any unprocessed items.
                        Unprocessed items can result from data sources that don't
                        produce fixed size blocks of data (e.g. NSCLDAQ-10.x and later).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnInitialize</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called after SpecTcl is fully initialized and
                        is about to start processing commands.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            Now let's look at the methods that are not functional in  nature.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventList&amp; </type>
                        <methodname>getEventList</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        SpecTcl's event processing builds lists of
                        <classname>CEvent</classname> objects produced
                        by the <methodname>OnPhysics</methodname> method.
                        When the event list has been sufficiently filled,
                        the event sink is called to, among other things
                        histogram the event.
                    </para>
                    <para>
                        This method returns a reference to the list of events
                        that have not yet been processed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodsynopsis>
                    <modifier></modifier>
                    <type>CBufferDecoder* </type>
                    <methodname>getDecoder</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis></term>
                <listitem>
                    <para>
                        Returns a pointer to the analyzer's current buffer
                        decoder.  
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventSink* </type>
                        <methodname>getSink</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the event sink.  When this
                        analyzer is used (usually not), this should
                        return the histogrammer object. This analyzer does
                        not pipeline the event sink, holding filters as
                        a separate set of objects (another reason to use
                        <classname>CTCLAnalyzer</classname>.
                    </para>
                    
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CBufferDecoder* </type>
                        <methodname>AttachDecoder</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CBufferDecoder&amp; </type>
                           <parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Attach a new buffer decoder to the analyzer.
                        If there is already a buffer decoder its
                        <methodname>OnDetach</methodname> method is invoked.
                        <parameter>rDecoder</parameter>'s
                        <methodname>OnAttach</methodname> is invoked.
                    </para>
                    <para>
                        The return value is a pointer to the previous buffer
                        decoder (NULL if there is none).  It is the
                        responsibility of the caller to <literal>delete</literal>
                        this decoder if it was dynamically allocated.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CBufferDecoder* </type>
                        <methodname>DetachDecoder</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Detaches the current buffer decoder from the
                        analyzer.  The current buffer decoder, if any
                        will have its <methodname>OnDetach</methodname>
                        method invoked.  A pointer to that decoder
                        will be returned.
                    </para>
                    <para>
                        If there was no current buffer decoder, a null pointer
                        is returned.  If the buffer decoder returned was
                        dynamically allocated its up to the caller to
                        <literal>delete</literal> it.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventSink*     </type>
                        <methodname>AttachSink</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CEventSink&amp; </type>
                           <parameter>rSink</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Replaces the current event sink (normall the histogrammer)
                        with <parameter>rSink</parameter>.  If there's a
                        prior event sink its <methodname>OnDetach</methodname>
                        is called.  <parameter>rSink</parameter>'s
                        <methodname>OnAttach</methodname> method is called.
                    </para>
                    <para>
                        A pointer to the previous event sink is returned.
                        If there is none, a null pointer is returned.
                        If the previous event sink was dynamically created the
                        caller must <literal>delete</literal> it.
                    </para>
                    <para>
                        Since most SpecTcls use a <classname>CTCLAnalyzer</classname>,
                        which supports a pipeline of event sinks, there's
                        not a reason to call this in a modern SpecTcl.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventSink*     </type>
                        <methodname>DetachSink</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Detaches the current event sink from the analyzer.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>entityNotDone</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This can be called from an event processor handling
                        physics events.  When that event processor returns,
                        the pointer will advance through the buffer, but
                        the remaining entity count won't be decremented.
                    </para>
                    <para>
                        The intent of this method is to provide support for
                        <firstterm>superevent</firstterm>.  A superevent
                        is an entity that appears to the buffer decoder like
                        a single event, but actually contains several
                        events.
                    </para>
                    <para>
                        This has been used for high performance singles experiments,
                        when muli-event ADC's are used.   In those experiments,
                        the ADC's were allowed to use VME interrupts to signal
                        they had some number of events to readout.  The
                        ADCs were then drained completely for each of these
                        'triggers'.  The result was an event from the standpoint
                        of NSCLDAQ which contained several singles events.
                    </para>
                </listitem>
            </varlistentry>
          
        </variablelist>
    </refsect1>
    <refsect1>
        <title>PROTECTED METHODS</title>
        <para>
            These methods are used by derived classes.  They provide services
            as well as a behavioral method (<methodname>OnEvent</methodname>).
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type> UInt_t </type>
                        <methodname>OnEvent</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>Address_t </type>
                           <parameter>pRawData</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>CEvent&amp; </type>
                           <parameter>anEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called by the anaylzer for each event.
                        <parameter>pRawData</parameter> is a pointer to the
                        event body while <parameter>anEvent</parameter> is
                        the <classname>CEvent</classname> 'array' this method
                        should fill in.  The  method must return the
                        number of bytes processed.
                    </para>
                    <para>
                        This version <classname>CAnalyzer</classname> base class
                        is used by creating a derived class that implements an
                        appropriate <methodname>OnEvent</methodname> method and
                        registering an instance of the derived class as the
                        analyzer.  Modern SpecTcl's, register a
                        <classname>CTCLAnalyzer</classname> instance which
                        implements an <methodname>OnEvent</methodname> method
                        that executes an event processing pipeline instead.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void  </type>
                        <methodname>AbortEvent</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called frrom <methodname>OnEvent</methodname> to prevent
                        an  event from being histogrammed.  This can be called
                        either as a software trigger on the event or, if a
                        structural problem was detected with the event that makes
                        the data untrustworthy.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void CopyEventList</type>
                        <methodname></methodname>
                        <methodparam>
                           <modifier>const </modifier>
                           <type>CEventList&amp; </type>
                           <parameter>rhs</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        The event list are the set of events that have been
                        unpacked by <methodname>OnPhysics</methodname> but not yet
                        passed to the event sink.  This method makes a copy of
                        the event list into <parameter>rhs</parameter>.
                    </para>
                    <para>
                        This is primarily used by the assignment operator and
                        copy constructor.  In other words, if you find yourself
                        using this method, you're probably doing something
                        very odd.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>CopyEventPool</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>const CEventList&amp; </type>
                           <parameter>rhs</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        When <classname>CEvent</classname> objects have
                        been analyzed by the event sink, they are
                        invalidated and returned to an
                        <firstterm>event pool</firstterm>.  This allows them
                        to be recycled, removing the overhead of deletion and
                        re-creation (an event serial is used so that the
                        invalidation is short constant time as well).
                    </para>
                    <para>
                        This method copies the contents of the current
                        event pool to the <parameter>rhs</parameter>.
                        This method is used by the assignment operator and
                        copy constructor.  If you find yourself using this
                        method for other purposes, you're probably doing something
                        odd.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void</type>
                        <methodname> DetachAll</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Detaches both  the event sink and the buffer decoder.
                        Note that this will leak memory if either of those
                        objects was dynamically created.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEvent* </type>
                        <methodname>CreateEvent</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Provides a new invalidated event. Invalidated, in this
                        context means any parameters in the array have not
                        yet been assigned a value.
                    </para>
                    <para>
                        If there are entries in the event pool, on eis removed
                        and a pointer to it is returned.  If not, <literal>new</literal>
                        is used to create a new event.  
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>ReturnEvent</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CEvent* </type>
                           <parameter>pEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Puts the event pointed to by <parameter>pEvent</parameter>
                        back into the event pool.  Normally the event is
                        invalidated first.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>ClearEventList</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        All events in the eventl ist are put into the event pool.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CTclAnalyzer</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTclAnalyzer</refname>
        <refpurpose>Analyzer integrated with Tcl supporting pipeline</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;TCLAnalyzer.h&gt;

class CTclAnalyzer {
public:
  typedef std::pair&lt;std::string, CEventProcessor*&gt; PipelineElement;
  typedef std::list&lt;PipelineElement&gt; EventProcessingPipeline;
  typedef EventProcessingPipeline::iterator EventProcessorIterator;
  typedef std::vector&lt;CTCLVariable*&gt;  VariableArray;
  
public:
  CTclAnalyzer(CTCLInterpreter&amp; rInterp, UInt_t nP, UInt_t nBunch);
  CTCLInterpreter* getInterpreter();
  
  virtual void OnStateChange(UInt_t nType, CBufferDecoder&amp; rDecoder);
  virtual void OnPhysics(CBufferDecoder&amp; rDecoder);
  virtual void OnOther(UInt_t nType, CBufferDecoder&amp; rDecoder);
  virtual void OnScaler(CBufferDecoder&amp; rDecoder);
  virtual void OnEndFile();
  
  virtual void OnBegin(CBufferDecoder* rDecoder);
  virtual void OnEnd(CBufferDecoder*   rDecoder);
  virtual void OnPause(CBufferDecoder* rDecoder);
  virtual void OnResume(CBufferDecoder* rDecoder);
  virtual void OnInitialize();

  void AddEventProcessor(CEventProcessor&amp; rProcessor,
			 const char* pName = 0); // Append to pipe.
  EventProcessorIterator FindEventProcessor(std::string name);
  EventProcessorIterator FindEventProcessor(CEventProcessor&amp; processor);
  void InsertEventProcessor(CEventProcessor&amp; processor, 
			    EventProcessorIterator here, 
			    const char* name = 0);
  CEventProcessor* RemoveEventProcessor(std::string name);
  CEventProcessor* RemoveEventProcessor(EventProcessorIterator here);
  UInt_t size();
  EventProcessorIterator begin();
  EventProcessorIterator end();

  void IncrementCounter(Counter eSelect, UInt_t incr = 1);
  void ClearCounter(Counter eSelect);

  void SetEventSize(UInt_t nSize);
  void IncrementEventSize(UInt_t nIncr=2) ;
  UInt_t GetEventSize() ;
  
};
enum Counter {
  RunsAnalyzed          = 0,
  EventsAnalyzed        = 1,
  EventsAnalyzedThisRun = 2,
  EventsAccepted        = 3,
  EventsAcceptedThisRun = 4,
  EventsRejected        = 5,
  EventsRejectedThisRun = 6
};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
             The <classname>CTclAnalyzer</classname> class is a SpecTcl analyzer
             that extends the base class by:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Maintaining statistical counters that can be retrieved from
                    Tcl
                </para>
            </listitem>
            <listitem>
                <para>
                    Supporting a list of event processors, rather than a single
                    one.  The list is called the
                    <firstterm>Event processing pipeline</firstterm>. 
                </para>
            </listitem>
        </itemizedlist>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CTclAnalyzer</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CTCLInterpreter&amp; </type>
                           <parameter>rInterp</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>nP</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>nBunch</parameter>
                        </methodparam>
                    </constructorsynopsis>
   
                </term>
                <listitem>
                    <para>
                        The constructor sets up several variables that
                        are defined in 
                        <parameter>rInterp</parameter>.  This interpreter
                        should be the SpecTcl command interpreter so that these
                        variables will be visible to commands executed by SpecTcl.
                    </para>
                    <para>
                        <parameter>nP</parameter> is the initial number of parameters
                        for each <classname>CEvent</classname> object
                        constructed by the base class.  Since these objects are
                        recycled from event to event, the value of this
                        has no effect on performance.
                        <parameter>nBunch</parameter> is the size of the bunch
                        of events that will be accumulated before invoking the
                        event sink pipeline.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CTCLInterpreter* </type>
                        <methodname>getInterpreter</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the interpreter in which this analyzer
                        maintains its statistics variables.  Normally, this is
                        the SpecTcl command processing interpreter.  
                    </para>
                    <para>
                        Note that the return value is a pointer to a
                        <classname>CTCLInterpreter</classname> object.  The
                        reference documentation on the Tcl++ library describes
                        this and related classes.  The
                        <link linkend='manpage.CTCLInterpreter'
                              endterm='manpage.CTCLInterpreter.title' /> manpage
                              provides details about this specific claass.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnStateChange</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>nType</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>CBufferDecoder&amp; </type>
                           <parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Overrides the base class's method that processes
                        state change operations.  After calling the base
                        class's <methodname>OnStateChange</methodname> method,
                        this method fans out
                        the state change processing for the following
                        item types:
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term><literal>BEGRUNBF</literal></term>
                            <listitem>
                                <para>
                                    Invokes <methodname>OnBegin</methodname>
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>ENDRUNBF</literal></term>
                            <listitem>
                                <para>
                                    Invokes
                                    <methodname>OnEnd</methodname>.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>PAUSEBF</literal></term>
                            <listitem>
                                <para>
                                    Invokes <methodname>OnPause</methodname>
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>RESUMEBF</literal></term>
                            <listitem>
                                <para>
                                    Invokes <methodname>OnResume</methodname>
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnPhysics</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CBufferDecoder&amp; </type>
                           <parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier>

                        </modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        After invoking the base class <methodname>OnPhysics</methodname>
                        method, increments statistics variables that
                        indicate the number of items analyzed and the
                        sequence number of the last item analyzed. For
                        NSCLDAQ-8.x and earlier, the decoder gets the
                        sequence number from the buffer header.  For
                        NSCLDAQ-10.0 and later, this sequence number is
                        number of triggers from the most recently seen
                        <literal>PHYSICS_EVENT_COUNT</literal> item.
                    </para>
                    <para>
                        Note that no effort is made to actually analyze the
                        data in this method.  The Tcl analyzer establishes
                        an event processor for the base class that contains
                        an ordered list of event processors.   When the
                        base class <methodname>OnPhysics</methodname>
                        method
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnOther</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>nType</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type> CBufferDecoder&amp; </type>
                           <parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Iterates over the event processors in the
                        event processing pipeline invoking their
                        <methodname>OnOther</methodname> methods.
                        If an event processor returns a false value
                        (<literal>kfFALSE</literal>), iteration is aborted
                        after that stage of the pipeline.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnScaler</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CBufferDecoder&amp; </type>
                           <parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when a scaler item is received.  This
                        invokes <methodname>OnOther</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnEndFile</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when an end file is encountered on a data source.
                        For file data sources this happens when there's no
                        more data in the file.  For pipe data sources this
                        happens when the program feeding the pipeline
                        exits.
                    </para>
                    <para>
                        The event processors in the pipeline are iterated
                        calling <methodname>OnEventSourcEOF</methodname>.
                        If one of the event processors returns
                        false, event processor pipeline processing is terminated.
                    </para>
                    <para>
                        Regardless, the <varname>RunState</varname> Tcl variable
                        is set to <literal>Halted</literal> indicating that
                        SpecTcl is no longer processing event data. 
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnEnd</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CBufferDecoder*   </type>
                           <parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when an end run item is encounterd.  Sets the
                        <varname>RunState</varname> variable to
                        <literal>Halted</literal> indicating analysis is no longer
                        active and then calls the <methodname>OnEnd</methodname>
                        method of each event processor in the event processing
                        pipeline.
                    </para>
                    <para>
                        If an event processor returns false, no more event
                        processors will be called.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnPause</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CBufferDecoder* </type>
                           <parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>                  
                </term>
                <listitem>
                    <para>
                        Called when a pause run item is received. The
                        <varname>RunState</varname> variable is set to
                        <literal>Paused</literal> and the
                        <methodname>OnPause</methodname> method is
                        called for each element of the event processing pipeline.
                    </para>
                    <para>
                        If an event processing pipeline element returns
                        false, no futher event processors are called.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnResume</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CBufferDecoder* </type>
                           <parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when a resume item is received.  The
                        <varname>RunState</varname> variable is set to
                        <literal>Active</literal> indicating data is being
                        analyzed.  The 
                        <methodname>OnResume</methodname> method is invoked
                        for each element of the event processing pipeline.
                        If an element  of the pipeline returns false,
                        no more event processors are invoked.
                    </para>
                    <para>
                        Note that when analyzing a file data source, the
                        <varname>RunState</varname> variable will flip quickly
                        between <literal>Paused</literal> and
                        <literal>Active</literal> for a run that is paused and
                        resumed.  For a pipe data source connected to live data,
                        however, this variable will remain in the
                        <literal>Paused</literal> state until the user
                        resumes the run.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                    <modifier>virtual </modifier>
                    <type>void </type>
                    <methodname>OnInitialize</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called after SpecTcl's initialization is complete.
                        The <methodname>OnInitialize</methodname> method
                        of each element of the event processign pipeline is
                        called.  If any element returns false, no more elements
                        are called.
                    </para>
                    <para>
                        This is intended for use when initialization requires
                        knowing that all of SpeTcl's services are available.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void</type>
                        <methodname> AddEventProcessor</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CEventProcessor&amp; </type>
                           <parameter>rProcessor</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier>const </modifier>
                           <type>char* </type>
                           <parameter>pName</parameter><initializer> 0</initializer>
                        </methodparam>
			 
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds <parameter>rProcessor</parameter> as to the
                        end of the event processing pipeline.  The object
                        must be live as long as it is in the event processing
                        pipeline.
                    </para>
                    <para>
                        If provided, <parameter>pName</parameter> is used to name
                        the event processor.  If this is not provided, a unique
                        name of the form <literal>Anonymous::</literal><replaceable>number</replaceable>
                        is assigned where <replaceable>number</replaceable>
                        is a sequentially assigned integer number.
                    </para>
                </listitem>
            </varlistentry>          
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>EventProcessorIterator </type>
                        <methodname>FindEventProcessor</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string </type>
                           <parameter>name</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an iterator to the element of the event processing
                        pipeline that has the name <parameter>name</parameter>.
                        If no such element exists, the value returned is the
                        same as that returned from
                        <methodname>end</methodname>.
                    </para>
                    <para>
                        Event processor iterators can be treated as if they
                        were pointers to an
                        <classname>std::pair&lt;std::string, CEventProcessor*&gt;</classname>.
                        The first element of the pair is the name of an event processor.
                        The second, a pointer to the event processor itself.
                    </para>
                    <para>
                        Incrementing an iterator points it to the next pipeline
                        element.  Incrementing the iterator when it points to the
                        last element of the pipeline returns
                        the same value as that returned from
                        <methodname>end</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>EventProcessorIterator </type>
                        <methodname>FindEventProcessor</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CEventProcessor&amp; </type>
                           <parameter>processor</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Locates an event processor given a reference to it.
                        The use case for this is to delete an anonymous event
                        processor from the eventprocessing pipeline.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>InsertEventProcessor</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CEventProcessor&amp;</type>
                           <parameter> processor</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>EventProcessorIterator </type>
                           <parameter>here</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier>const</modifier>
                           <type> char* </type>
                           <parameter>name</parameter><initializer>0</initializer>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Provides the ability to insert an event processor anywhere
                        in the event processing pipeline.  The event processor
                        is inserted just prior  to the item pointed to by
                        <parameter>here</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventProcessor* </type>
                        <methodname>RemoveEventProcessor</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string</type>
                           <parameter> name</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes the named event processor
                        <parameter>name</parameter>.    The return value
                        is a pointer to the event processor removed from
                        the list.  No steps are taken to destroy that processor so
                        if it has been dynamically created with <literal>new</literal>
                        it must be destroyed with <literal>delete</literal>
                    </para>
                    <para>
                        If there is no event processor in the event processing
                        pipeline, the return value is a null pointer. It is up
                        to the caller to decide if this represents an error.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventProcessor* </type>
                        <methodname>RemoveEventProcessor</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>EventProcessorIterator</type>
                           <parameter> here</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes the event processor pointed to by the iterator
                        <parameter>here</parameter>.  The return value is
                        a pointer to the event processor that was removed.
                        It is up to the caller to destroy that event processor,
                        if desired.
                    </para>
                    <para>
                        Note this method invalidates the iterator <parameter>here</parameter>.
                        Destruction and assignment become the only operatiosn with
                        defined meaning.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>UInt_t </type>
                        <methodname>size</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of elements in the event procesing
                        pipeline.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>EventProcessorIterator </type>
                        <methodname>begin</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an iterator that points to the first element of
                        the event processing pipeline. See
                        <methodname>find</methodname> above for a description of
                        <classname>EventProcessorIterator</classname> objects.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>EventProcessorIterator </type>
                        <methodname>end</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an end of iteration iterator.  This is the value of
                        the iterator that results from incrementing an iterator
                        that points to the last <classname>PipelineElement</classname>
                    </para>
                    <para>
                        Here is sample code that might list the names of all
                        event processors:
                    </para>
                    <programlisting>
CAnalyzer* pA;
...                       // Assume pA got set to point at the analyzer:

for (auto p = pA->begin(), p != pA->end(); p++) {
    std::cout &lt;&lt; p-&gt;first &lt;&lt; std::endl;
}
                    </programlisting>
                    <para>
                        The code above is intended just to show a typical use of
                        <methodname>begin</methodname> and
                        <methodname>end</methodname> to iterate over the entire
                        event processing pipeline.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                     <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>IncrementCounter</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>Counter </type>
                           <parameter>eSelect</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>incr </parameter>
                           <initializer>1</initializer>
                        </methodparam>
                        <modifier></modifier>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Increments one of the Tcl statistics counters
                        maintained by this object.  <parameter>eSelect</parameter>
                        selects which counter to increment.  It is described
                        in <literal>DATA TYPES</literal> below.  
                    </para>
                    <para>
                        Unless <parameter>incr</parameter> is supplied, the
                        counter is incremented by <literal>1</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>ClearCounter</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>Counter </type>
                           <parameter>eSelect</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Clears the counter selected by
                        <parameter>eSelect</parameter>.  This values this
                        enumerated parameter can have are described
                        in <literal>DATA TYPES</literal> below.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>SetEventSize</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>nSize</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        At least one event processor must invoke this.
                        The event size in bytes is set to be <parameter>nSize</parameter>.
                        This is used to determine where the next event in a run of
                        events is.  
                    </para>
                    <para>
                        Note that if a supervent has been declared this will
                        be used to point to the next event in the superevent.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>IncrementEventSize</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>nIncr</parameter><initializer>2</initializer>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds <parameter>nIncr</parameter> to the size of the
                        event. 
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>UInt_t</type>
                        <methodname> GetEventSize</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the current understanding of the size
                        of this event.
                    </para>
                </listitem>
            </varlistentry>
  
           
        </variablelist>
    </refsect1>
    <refsect1>
        <title>DATA TYPES</title>
        <para>
            The header <filename>TCLAnalyzer.h</filename> defines both nested
            and global level data types.  This section will first describe the
            globally defined data types and then the nested type.
        </para>
        <para>
            One globally defined data type <classname>Counter</classname>
            is defined.  This is an enumerated type whose values select the
            Tcl counter operated on by e.g. <methodname>IncrementCounter</methodname>.
            These statistics are maintained in the Tcl array
            <varname>Statistics</varname>.
            The type can have any of the following values.  
        </para>
        <variablelist>
            <varlistentry>
                <term><literal>RunsAnalyzed</literal></term>
                <listitem>
                    <para>
                        Increments the <literal>RunsAnalyzed</literal> element
                        of <varname>Statistics</varname>.  This counter
                        is incremented by the analyzer whenever it
                        executes its
                        <methodname>OnBegin</methodname> method.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>EventsAnalyzed </literal></term>
                <listitem>
                    <para>
                        Selects the element
                        <literal>EventsAnalyzed</literal> from the
                        <varname>Statistics</varname> array.  This counter
                        is incremented every time
                        <methodname>OnEvent</methodname> is executed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>EventsAnalyzedThisRun </literal></term>
                <listitem>
                    <para>
                        Selects <literal>EventsAnalyzedThisRun</literal>.
                        Same as <literal>EventsAnalyzed</literal> but
                        additionally, this counter is also cleared by
                        <methodname>OnBegin</methodname>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>EventsAccepted</literal></term>
                <listitem>
                    <para>
                        Selects <literal>EventsSelected</literal>.  This
                        counts the number of events that made it through
                        the entire event processing pipeline without
                        any element returning false.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>EventsAcceptedThisRun</literal></term>
                <listitem>
                    <para>
                        Selects <literal>EventsAcceptedThisRun</literal>.
                        Same as <literal>EventsAccepted</literal> but is also
                        cleared by <methodname>OnBegin</methodname>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>EventsRejected</literal></term>
                <listitem>
                    <para>
                        Selects <literal>EventsRejected</literal>.  Incremented
                        for each event for which the event processing  pipeline was aborted
                        because an event processor returned false.  Note that
                        exceptions thrown by an event processor caught by the
                        <classname>CTclAnalyzer</classname> object are
                        treated as pipeline aborts for the purpose
                        of this counter.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <literal>EventsRejectedThisRun</literal>
                </term>
                <listitem>
                    <para>
                        Selects <literal>EventsRejectedThisRun</literal>. This
                        is the same as <literal>EventsRejected</literal> but
                        is also cleared by
                        <methodname>OnBegin</methodname>.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            Several data types are defined within the <classname>CTclAnalyzer</classname>
            class.  These are mostly related to the event processing pipeline.
            These types are defined via <literal>typedef</literal>.  To specify
            these types in your code you'll need to use the scope resolution
            operator.  For example, <classname>PipelineElement</classname>
            must be referred to as a <classname>CTclAnalyzer::PipelineElement</classname>.
        </para>
        <variablelist>
            <varlistentry>
                <term><classname>PipelineElement</classname></term>
                <listitem>
                    <para>
                        This is an element of the list that contains
                        an event processing pipeline element. It associates
                        an event processor with a name and places it in an ordered
                        container of event processors.
                    </para>
                    <para>
                        The actual type is:
                        <classname>std::pair&lt;std::string, CEventProcessor*&gt;</classname>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>EventProcessingPipeline</classname></term>
                <listitem>
                    <para>
                        The actual event processing pipeline.  This is actually a
                        <classname>std::list&lt;PipelineElement&gt;</classname>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>EventProcessorIterator</classname></term>
                <listitem>
                    <para>
                        Represents an iterator into the event processing
                        pipeline container.  This is actually a
                        <classname>EventProcessingPipeline::iterator</classname>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>VariableArray</classname></term>
                <listitem>
                    <para>
                        Defines a vector that contains TCL variables:
                        <classname>std::vector&lt;CTCLVariable*&gt;</classname>
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>   
        
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CBufferDecoder</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CBufferDecoder</refname>
        <refpurpose>Base class for SpecTcl buffer decoders</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;BufferDecoder.h&gt;

class CBufferDecoder {
 protected:
  UInt_t    m_nSize;    // Number of bytes in buffer.

 public:
  CBufferDecoder(); 
  virtual ~CBufferDecoder();
  int operator==(const CBufferDecoder&amp; aCBufferDecoder);
  const Address_t getBuffer();
 protected:
  void setBuffer (Address_t am_pBuffer);
 public:
  virtual BufferTranslator* getBufferTranslator();
  virtual const Address_t getBody() = 0;
  virtual UInt_t getBodySize() = 0;
  virtual UInt_t getRun() = 0;
  virtual UInt_t getEntityCount() = 0;
  virtual UInt_t getSequenceNo() = 0;
  virtual UInt_t getLamCount() = 0;
  virtual UInt_t getPatternCount() = 0;
  virtual UInt_t getBufferType() = 0;
  virtual void getByteOrder(Short_t&amp; Signature16,
			    Int_t&amp; Signature32) = 0;
  virtual std::string getTitle() = 0;
  virtual void operator() (UInt_t nBytes,
			   Address_t pBuffer,
			   CAnalyzer&amp; rAnalyzer);

  virtual void OnAttach(CAnalyzer&amp; rAnalyzer);
  virtual void OnDetach(CAnalyzer&amp; rAnalyzer);
  virtual bool blockMode();	
  virtual void OnSourceAttach();
  virtual void OnSourceDetach();
  virtual void OnEndFile();

 protected:
  void ThrowIfNoBuffer(const char* pszWhatImDoing);
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This class is an abstract base class for the set of buffer decoders.
            Buffer decoders are responsible for taking a block of data received
            from a data source and breaking it up into items.  These items are
            then passed to the appropriate analyzer methods for
            detailed processing.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CBufferDecoder</methodname>
                        <void />
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        The base class constructor is a default constructor.
                        It has no parameters.  Typically, the state of a
                        buffer decoder is meaningless until data arrives.
                        This is because only when data arrives does the
                        buffer decoder do anything.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>const </modifier>
                        <type>Address_t </type>
                        <methodname>getBuffer</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the data most recently received.
                        If, for some pathalogical reason, data has not yet
                        been received, a null pointer is received.
                    </para>
                    <para>
                        Note that it is possible that derived classes will have
                        their own book-keeping for buffers of data received from
                        the data source.  Those decoders should, nonetheless
                        use <methodname>setBuffer</methodname> to set the
                        buffer member data of their base class to ensure
                        this methiod works.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>BufferTranslator* </type>
                        <methodname>getBufferTranslator</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to a buffer translator for this
                        block of data.  A buffer translator is an object
                        that knows how to perform byte order translations between
                        the byte ordering of the source system and the system
                        SpecTcl is executing on.
                    </para>
                    <para>
                        In most cases the default implementation will not be
                        useful as it was written with NSCLDAQ-7.x/8.x
                        buffer formats in mind.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual const </modifier>
                        <type>Address_t </type>
                        <methodname>getBody</methodname>
                        <void />
                        <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the body of the block of data
                        the decoder is currently working on.  Normally, this is
                        a pointer to the next item, or run of items the
                        analyzer should process.  For NSCLDAQ-10.x and later,
                        for example, this will be a pointer to the body
                        of a ring item.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getBodySize</methodname>
                        <void />
                        <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of bytes in the body.  This will
                        be the number of bytes of data in the block pointed
                        to by the pointer returned from
                        <methodname>getBody</methodname>.  Note that actually
                        this will be the number of bytes from that body to be
                        processed by the analyzer and may, in fact, be smaller
                        than the storage pointeed to by
                        <methodname>getBody</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getEntityCount</methodname>
                        <void />
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of items in the block of data
                        pointed to by <methodname>getBody</methodname>.  This is
                        mostly intended for use with blocks containing runs of
                        events from physics triggers.  
                    </para>
                    <para>
                        The analyzer's
                        <methodname>OnPhysics</methodname> can use this and
                        <methodname>getBodySize</methodname> to know how much
                        data to process and to double check the
                        event processor does  not over step the boundaries of
                        the block or leave data unprocessed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getSequenceNo</methodname>
                        <void />
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the sequence number of the last item processed.
                        Note that this may not be precisely determined for
                        some DAQ systems, and may not even be available.
                    </para>
                    <para>
                        This value is maintained by SpecTcl in Tcl variables
                        so that the GUI can display the analysis efficiency
                        (which maybe less than 1 for online analysis).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getLamCount</methodname>
                        <void />
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        From the traditional nscldaq, returns the number of LAM
                        registers.  This comes from the tradition of CAMAC where LAM bit masks
                        show the set of modules with data available in a crate.
                        This is vestigial; allowing NSCLDAQ-7.x/8.x to report
                        the number of CAMAC crates in a 'larger' experiment.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getPatternCount</methodname>
                        <void />
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Vestigial method from when readouts were pattern register
                        driven.  This method used to return the number
                        of pattern registers used to drive the readout pattern.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getBufferType</methodname>
                        <void />
                        <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the item type in the block of data currently
                        being processed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>getByteOrder</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>Short_t&amp;</type>
                           <parameter> Signature16</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Int_t&amp; </type>
                           <parameter>Signature32</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns byte order signatures that describe the order
                        of bytes in the data.  <parameter>Signature16</parameter>
                        will be written with the value <literal>0x0102</literal>
                        in the byte ordering of the creating system.
                        <parameter>Signature32</parameter>, will similarly be written
                        with <literal>0x01020304</literal> in the byte ordering
                        of the originating system.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>std::string </type>
                        <methodname>getTitle</methodname>
                        <void />
                        <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the title from the most recently received
                        begin run information.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type> UInt_t </type>
                           <parameter>nBytes</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Address_t </type>
                           <parameter>pBuffer</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>CAnalyzer&amp; </type>
                           <parameter>rAnalyzer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when a new chunk of data comes in.  <parameter>nBytes</parameter>
                        is the number of bytes of data received. <parameter>pBuffer</parameter>
                        is pointer to the data received. <parameter>rAnalyzer</parameter>
                        refers to the analyzer that should be called back
                        to handle specific items and runs of items.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnAttach</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CAnalyzer&amp; </type>
                           <parameter>rAnalyzer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is called when a decoder object is
                        attached to SpecTcl. This can happen at startup time, but
                        also can happen when the
                        <command>attach</command> command specifies a format
                        that selects a specific decoder object type.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnDetach</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CAnalyzer&amp; </type>
                           <parameter>rAnalyzer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when the buffer decoder is detached from SpecTcl.
                        This will happen when a new one is attached.  Typically
                        this will be because the <command>attach</command>
                        command is used to start taking data from a source
                        that has a different format than the prior source.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>bool </type>
                        <methodname>blockMode</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If this method returns <literal>true</literal>,
                        SpecTcl will require that a full fixed size block
                        of data be read before invoking the decoder.  If,
                        however <literal>false</literal> is returned,
                        the buffer decoder is invoked on the successful
                        completion of any read from the data source.
                    </para>
                    <para>
                        This only has any impact on how pipe data sources
                        are handled.  Note that there's still no guarantee
                        the  a block read is a clean multiple of the
                        data items
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnSourceAttach</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Invoked when a new data source is attached to SpecTcl.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnSourceDetach</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when a data source is detached from SpecTcl.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnEndFile</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when an end file is encountered on the current
                        data source.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>protected: </modifier>
                        <type>void </type>
                        <methodname>setBuffer </methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>Address_t </type>
                           <parameter>am_pBuffer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Sets the value returned from
                        <methodname>getBuffer</methodname> to be
                        <parameter>am_pBuffer</parameter>.  This can be used
                        by a derived class when it needs to do its oown buffer
                        management to keep this base class apprised of the data
                        it is operating on.  
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>protected: </modifier>
                        <type>void </type>
                        <methodname>ThrowIfNoBuffer</methodname>
                        <methodparam>
                           <modifier>const </modifier>
                           <type>char*</type>
                           <parameter> pszWhatImDoing</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        To use this a derived class must use
                        <methodname>setBuffer</methodname> to always maintain
                        the a valid buffer pointer.  If this is called and
                        either <methodname>setBuffer</methodname> last
                        set a null pointer or was never called, a
                        <classname>CEventFormatError</classname> exception
                        is called with a reason code of
                        <literal>CEventFormatError::knNoCurrentBuffer</literal>
                        and a was doing text of <parameter>pszWhatImDoint</parameter>.
                    </para>
                </listitem>
            </varlistentry>     
        </variablelist>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
            (3SpecTcl)CNSCLBufferDecoder,
                    (3SpecTcl)CNSCLJumboBufferDecoder, (3SpecTcl)CRingBufferDecoder,
        </para>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CNSCLBufferDecoder</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CNSCLBufferDecoder</refname>
        <refpurpose>Decode fixed sized event buffers from NSCLDAQ-7.x/8.x</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;NSCLBufferDecoder.h&gt;

class CNSCLBufferDecoder : public CBufferDecoder {
public:
  CNSCLBufferDecoder();
  virtual ~CNSCLBufferDecoder();
  virtual const Address_t getBody();
  virtual UInt_t getBodySize();
  virtual UInt_t getRun();
  virtual UInt_t getEntityCount();
  virtual UInt_t getSequenceNo();
  virtual UInt_t getLamCount();
  virtual UInt_t getPatternCount();
  virtual UInt_t getBufferType();
  virtual void getByteOrder(Short_t&amp; Signature16, Int_t&amp; Signature32);
  virtual std::string getTitle();
  virtual void operator()(UInt_t nBytes, Address_t pBuffer, CAnalyzer&amp; rAnalyzer);
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This buffer decoder decodes fixed length event bufers from
            NSCLDAQ-7.x/8.x.  These buffers are typically 8Kbytes long, however
            they may be longer or shorter as long as the total number of bytes
            per buffer is no larger than 128K-2 bytes.
        </para>
        <para>
            See CNSCLJumboBufferDecoder for larger bufer sizess.
        </para>
        <para>
            This data format uses homogeneous buffers.  Typically, non event buffers
            have a single item.  Event buffers, however are packed with as
            many items as will fit.  This means that buffers that contain non
            event data are typically very space wasteful.  Fortunately in most
            cases they are also not frequently emitted compared with event
            data buffers.
        </para>
        <para>
            This class is concrete.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CNSCLBufferDecoder</methodname>
                        <void />
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructor. 
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual const </modifier>
                        <type>Address_t </type>
                        <methodname>getBody</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        NSCLDAQ 7.x/8.x buffers have a header of 32 bytes
                        (16 uin16_t).  This method returns a pointer to the
                        first byte after this header.  
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getBodySize</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of words used in the body of the
                        buffer.  Note that not all words of the buffer
                        may be used.  THe first 16 bits of the buffer contain
                        the number of used 16 bit words  in the buffer;
                        <varname>nwds</varname>.  This method,
                        therefore returns
                        <literal>(nwds - 16) * sizeof(uint16_t)</literal> 
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getRun</methodname>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        The header of NSCLDAQ 7.x/8.x buffers contains
                        the run number.  This method returns the run number
                        from the most recently received buffer.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getEntityCount</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>               
                </term>
                <listitem>
                    <para>
                        Returns the number of entities in the buffer.
                        For physics buffers, this is the number of events in the
                        buffer.  For scaler events, this is the number of
                        scaler channels present in the buffer.  For all other
                        item typesm, this is <literal>1</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getSequenceNo</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        NSCLDAQ 7.x/8.x buffers have sequence numbers.  These,
                        together with a count of the number of buffers seen
                        can be used to approximate the sampling fraction for
                        online analysis (when SpecTcl may not be able to
                        keep up with the data rate).
                    </para>
                    <para>
                        This method returns the sequence number from the last
                        buffer received.  Note that sequence numbers start from
                        zero at the beginning of each run.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getLamCount</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        The header of NSCLDAQ 7.x/8.x buffers includes a
                        word that contains the number of lam masks in an event.
                        This actually is vestigial dating back to K500 days
                        when events has a much more fixed format that include
                        a set of pattern registers and a set of LAM registers.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getPatternCount</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Same as for <methodname>getLamCount</methodname> but the
                        method returns the header field containing the pattern
                        register count.  This too is vestigial.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getBufferType</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>getByteOrder</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>Short_t&amp; </type>
                           <parameter>Signature16</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Int_t&amp; </type>
                           <parameter>Signature32</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the byte order signatures that describe the
                        byte ordering of the system that generated the
                        most recent data buffer.  Note that these values
                        are header members for buffers from
                        NSCLDAQ 7.x/8.x
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>std::string </type>
                        <methodname>getTitle</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the title of the current run.  In
                        NSCLDAQ 7.x/8.x run titles are stored in state
                        transition buffers.  The value returnes is the
                        value from the most recently received state transition
                        buffer.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>nBytes</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Address_t </type>
                           <parameter>pBuffer</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type> CAnalyzer&amp; </type>
                           <parameter>rAnalyzer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Processes a new buffer of data.
                        <parameter>nBytes</parameter> is the physical size
                        of the buffer.  The header of the buffer determines how
                        much of the physical buffer contains useful data.
                        <parameter>pBuffer</parameter> points to the data and
                        <parameter>rAnalyzer</parameter> is a reference
                        to the analyzer we must call back for item processing.
                    </para>
                </listitem>
            </varlistentry>           
        </variablelist>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CNSCLJumboBufferDecoder</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CNSCLJumboBufferDecoder</refname>
        <refpurpose>Decode NSCLDAQ 7.x/8.x buffers bigger than 128Kbytes.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CNSCLJumbBufferDecoder&gt;

class CNSCLJumboBufferDecoder : public CBufferDecoder {
public:
  CNSCLJumboBufferDecoder();
  virtual ~CNSCLJumboBufferDecoder() ;
  virtual const Address_t getBody();
  virtual UInt_t getBodySize();
  virtual UInt_t getRun();
  virtual UInt_t getEntityCount();
  virtual UInt_t getSequenceNo();
  virtual UInt_t getLamCount();
  virtual UInt_t getPatternCount();
  virtual UInt_t getBufferType();
  virtual void getByteOrder(Short_t&amp; Signature16, Int_t&amp; Signature32);
  virtual std::string getTitle();
  virtual void operator()(UInt_t nBytes, Address_t pBuffer, CAnalyzer&amp; rAnalyzer);

        </synopsis>        
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This decoder is a special version of the
            <classname>CNSCLBufferDecoderr</classname> class.  An unused
            header words is repurposed to hold the top bits of a 32 bit buffer
            size.  Furthermore;  events in physics buffers have a 32 bit event
            size as their header.  This allows both for buffers bigger than
            64Kwords and for events larger than 64Kwords.
        </para>
        <para>
            The motivation for this type of buffer was a series of experiments
            that used a waveform capture device capable of delivering
            events much larger than 64Kwords of data.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CNSCLJumboBufferDecoder</methodname>
                        <void />
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructor for objects of this class.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>const Address_t</type>
                        <methodname> getBody</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Operates the same as for <classname>CNSCLBufferDecoder</classname>;
                        returns a pointer tot he first byte after the 32 byte
                        header.
                    </para>
                </listitem>
            </varlistentry>          
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t</type>
                        <methodname> getBodySize</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of bytes used in the buffer.
                        The jumbo buffer format holds the low
                        16 bit of the used buffer size (words) in the first
                        element of the buffer header.   A previously unused
                        word in the buffer (<structfield>nwdsHigh</structfield>)
                        is used to hold the top 16 bits of the used buffer size.
                    </para>
                    <para>
                        The decoder combines these to form a 32 bit value
                        and subtracts the size of the buffer header from that
                        to get the final size.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getRun</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        As with <classname>CNSCLBufferDecoder</classname>, returns
                        the run number from the buffer header.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getEntityCount</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        As with <classname>CNSCLBufferDecoder</classname>,
                        returns the number of entities in the buffer.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getSequenceNo</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        As with <classname>CNSCLBufferDecoder</classname>,
                        returns the sequence number of the last buffer.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t</type>
                        <methodname> getLamCount</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        As for <classname>CNSCLBufferDecoder</classname>,
                        returns the lam count from the buffer header.
                        This is deprecated as LAM register counts have not
                        been part of typical NSCL events for decades.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getPatternCount</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        As with <classname>CNSCLBufferDecoder</classname>,
                        returns the pattern register count from the
                        buffer header.  This is deprecated as most
                        events, these days, don't actually have any pattern
                        registers, thanks to the ability of digitizers
                        to auto-zero suppress.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t</type>
                        <methodname> getBufferType</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the type of data in the buffer.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>getByteOrder</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>Short_t&amp; </type>
                           <parameter>Signature16</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Int_t&amp; </type>
                           <parameter>Signature32</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        As with <classname>CNSCLBufferDecoder</classname>,
                        returns the byte order signatures in
                        <parameter>Signature16</parameter> and
                        <parameter>Signature32</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>std::string </type>
                        <methodname>getTitle</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns title from the most recent run state
                        transition buffer.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>nBytes</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Address_t </type>
                           <parameter>pBuffer</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>CAnalyzer&amp; </type>
                           <parameter>rAnalyzer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called for each block of data received from the data
                        source.  This is a fixed block sized buffer decoder
                        so the value of <parameter>nBytes</parameter> should
                        always be the same within a run.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CRingBufferDecoder</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CRingBufferDecoder</refname>
        <refpurpose>Decode data from ring buffers</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CRingBufferDecoder&gt;
 
class CRingBufferDecoder : public CBufferDecoder
{
public:
  CRingBufferDecoder();
  virtual ~CRingBufferDecoder();

  virtual void operator()(UInt_t nBytes, Address_t pBuffer, CAnalyzer&amp; rAnalyzer);

  virtual const Address_t getBody();
  virtual UInt_t getBodySize();
  virtual UInt_t getRun();
  virtual UInt_t getEntityCount();
  virtual UInt_t getSequenceNo();
  virtual UInt_t getLamCount();
  virtual UInt_t getBufferType();
  virtual UInt_t getPatternCount();
  virtual void   getByteOrder(Short_t&amp; signature16,
			      Int_t&amp;   signature32);
  virtual std::string    getTitle();
  virtual BufferTranslator* getBufferTranslator();

  virtual bool blockMode();	// True if data source must deliver fixed sized blocks.
  
  // Format helpers and stuff that gets you at what they know.
  

  bool  hasBodyHeader();
  void* getBodyHeaderPointer();
  void* getItemPointer();

  void  setFormatHelper(CRingFormatHelper* pHelper);
  void  setDefaultFormatHelper(CRingFormatHelper* pHelper);
  CRingFormatHelper* getCurrentFormatHelper();
  CRingFormatHelper* getDefaultFormatHelper();
  
  CRingFormatHelperFactory* getFormatFactory();
  
  // Members called that can invalidate the format helper:
  
  virtual void OnSourceAttach();
  virtual void OnSourceDetach();
  virtual void OnEndFile();
};       
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This class decodes data from NSCLDAQ 10.x and above.  Since the
            format of ring items differs between NSCLDAQ 10.x and NSCLDAQ 11.0 and
            above (11.0 introduces body headers to better support event building),
            this decoder relies on a <classname>CRingFormatHelper</classname>
            to deal with these differences.
        </para>
        <para>
            When a data source is first opened with <option>-format</option> ring,
            you can use the <command>ringformat</command> command to specify
            the NSCLDAQ version used.  Alternatively, if you are certain
            that the data source will see the beginning of a run
            (not joining a run in progress on an online system), the
            class will use the presence (or absence) of a ring format item
            to select the appropriate format helper.   The absence of a ring
            format item selects the 10.x helper, while the version information
            in a ring format item will select the proper helper, if present.
        </para>
        <para>
            Finally, the format helper can be set programmatically
            via the <methodname>setFormatHelper</methodname> and
            <methodname>setDefaultFormatHelper</methodname> methods, depending
            on what you are trying to do.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CRingBufferDecoder</methodname>
                        <void />
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructor.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void</type>
                        <methodname>operator()</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>nBytes</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type> Address_t</type>
                           <parameter> pBuffer</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>CAnalyzer&amp; </type>
                           <parameter>rAnalyzer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called whenever data has been received from the source.
                        This method breaks the <parameter>nBytes</parameter> bytes
                        of data in <parameter>pBuffer</parameter> into ring items.
                        Each item is then passed to the appropriate
                        method of <parameter>rAnalyzer</parameter>.
                    </para>
                    <para>
                        Note that since SpecTcl does fixed sizedd reads and
                        ring items are inherently variable sized, it is possible
                        for ring items to span from one buffer to the next.
                        This decoder recognizes this and mates partial ring items
                        at the end of each buffer with partial ring items at the
                        beginning of the next buffer.
                    </para>
                    <para>
                        Since ring items are atomically read from the ring buffer,
                        it must be possible to reconstruct ring items that have
                        been split across buffer boundaries as sampling is done
                        at the ring item leve, not the buffer level.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual const </modifier>
                        <type>Address_t </type>
                        <methodname>getBody</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the body of the ring item being processed.  Note
                        that if the nscldaq-11.x helper has been selected,
                        this will be a pointer to the data <emphasis>following</emphasis>
                        the body header.  Otherwise it will point just after
                        the ring item header, as 10.x does not have body headers.
                    </para>
                    <para>
                        The 11.x helper knows about the potential for zero length
                        body headers.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type> UInt_t </type>
                        <methodname>getBodySize</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the size of the ring item body.  Note that this
                        is the amount of data pointed to by the return value
                        from <methodname>getBody</methodname>.
                    </para>
                    <para>
                        To clarify, for the nscldaq 11.x helper, this value does
                        not include the size of the body header.  This choice was
                        made because the purpose of this method is to return
                        the number of bytes that must be processed by the
                        analyzer for data returned by
                        <methodname>getBody</methodname>.  The decoder
                        treats body headers as ancillary metadata for events that
                        can be retrieved by user code via special methods
                        provided by this class.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getRun</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the last run number seen.  Note that in
                        ring buffer NSCLDAQ systems, the run number is only
                        present in state change ring items.  If one of those
                        has not yet been seen, because SpecTcl is joining an
                        online run in progress, the run number returned will
                        be zero, or the most recent run from the prior data source,
                        if there was one.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getEntityCount</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of items in the data pointed to
                        by <methodname>getBody</methodname>.   Normally this
                        will be <literal>1</literal>, however for scaler items,
                        this will be the number of scaler channels present in
                        the item.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type> UInt_t </type>
                        <methodname>getSequenceNo</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an approximation of the number of triggers seen.
                        NSCLDAQ 10.x don't maintain sequence numbers in ring items.
                        Instead periodically a ring item is emitted with trigger
                        statistics.  The value of this method is the
                        number of triggers for which data was emitterd for
                        this run, from the most recently received trigger count
                        item.  As the run evolves in time, this allows a
                        reasonable estimate of the analysis efficiency since
                        the percent error in the number of triggers will
                        go towards zero in the limit as the run time goes to
                        infinity.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getLamCount</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>0</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getBufferType</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the SpecTcl type of the item type currently
                        being processed.  For historical reasons these differ
                        from ring item types and are mapped as follows from
                        types in <filename>dataformat.h</filename> in NSCLDAQ
                        to <filename>buftypes.h</filename>:
                    </para>
                    <itemizedlist>
                        <listitem>
                            <para>
                                <literal>BEGIN_RUN</literal> maps to
                                <literal>BEGRUNBF</literal>.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <literal>END_RUN</literal> maps to
                                <literal>ENDRUNBF</literal>.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <literal>PAUSE_RUN</literal> maps to
                                <literal>PAUSEBF</literal>.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <literal>RESUME_RUN</literal> maps to
                                <literal>RESUMEBF</literal>.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <literal>PACKET_TYPES</literal> maps to
                                <literal>PKTDOCBF</literal>.  Though I should
                                point out that these items are rare in
                                NSCLDAQ-10.x and later readouts.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <literal>MONITORED_VARIABLES</literal>
                                maps to <literal>RUNVARBF</literal>.  This
                                is mostly used by NSCLDAQ 10.x and later
                                when injection of EPICS data into the data stream
                                is done as that's the known use-case now
                                for these item types.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <literal>PERIODIC_SCALERS</literal> this
                                NSCLDAQ-11 type maps to
                                <literal>SCALERBF</literal>.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <literal>NSCLDAQ10::INCREMENTAL_SCALERS</literal>
                                This NSClDAQ-10 type maps to
                                <literal>SCALERBF</literal>.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <literal>PHYSICS_EVENT</literal> maps to
                                <literal>DATABF</literal>
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                Any other type is not modified and will, therefore,
                                cause <methodname>OnOther</methodname> to be
                                called in the analyzer.
                            </para>
                        </listitem>
                    </itemizedlist>
                    
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type> UInt_t </type>
                        <methodname>getPatternCount</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>0</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void   </type>
                        <methodname>getByteOrder</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>Short_t&amp; </type>
                           <parameter>signature16</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Int_t&amp;   </type>
                           <parameter>signature32</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns byte order signatures for the current ring item.
                        Each ring item type is a 16 bit value in a 32 bit word
                        with the most significant bits (in the generating system)
                        zero.  This allows consuming systems to determine the
                        relative byte ordering and, therefore, generate
                        accurate generating byte order signatures.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>std::string    </type>
                        <methodname>getTitle</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the title from the last state change item.  If
                        no state change items have been seen yet (can happen
                        if SpecTcl starts analyzing on line data in the
                        middle of an active run), an empty string is returned.,
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>BufferTranslator* </type>
                        <methodname>getBufferTranslator</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the buffer translator being used
                        to perform any byte order manipulations to transform
                        the data into the format used by the host executing
                        SpecTcl.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>bool </type>
                        <methodname>blockMode</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>false</literal>.  Ring buffer data
                        can  accept data buffers shorter than the requested
                        read size and this can (and probably will) happen at
                        the end of a run.
                    </para>
                </listitem>
            </varlistentry>          
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier> </modifier>
                        <type>bool </type>
                        <methodname>hasBodyHeader</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If the item has a body header <literal>true</literal>
                        is returned, otherwise, <parameter>false</parameter>
                        is returned.  See also <methodname>getBodyHeaderPointer</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void* </type>
                        <methodname>getBodyHeaderPointer</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the body header of a ring item.
                        If the ring item has no body header (NSCLDAQ 10.x) or has
                        a body header length of zero (NSCLDAQ 11.x item with no
                        body header), then a null pointer is returned.
                    </para>
                </listitem>
            </varlistentry>  
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void* </type>
                        <methodname>getItemPointer</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the ring item being processed.
                        In all versions this returns a pointer to the ring item
                        header.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void  </type>
                        <methodname>setFormatHelper</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CRingFormatHelper* </type>
                           <parameter>pHelper</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Replaces the current ring format helper with
                        <parameter>pHelper</parameter>.
                        <parameter>pHelper</parameter> must have been
                        created with <literal>new</literal>
                        
                    </para>
                    <para>
                        Note that if
                        a ring format item is seen after this is called, the
                        ring format helper is destroyed and replaced by the
                        appropriate one.  Therefore it's recommended, instead,
                        to use <methodname>setDefaultFormatHelper</methodname>
                        to set a default ring format helper.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void  </type>
                        <methodname>setDefaultFormatHelper</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CRingFormatHelper* </type>
                           <parameter>pHelper</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Sets the default format helper to use for a new run
                        until (or unless) a format item is seen.  If a format
                        item is seen, that is used to select a (potentially)
                        new format helper.
                    </para>
                    <para>
                        Since NSCLDAQ 10 does not have ring format items,
                        it is wise to use the format helper
                        <classname>CRingFormatHelper10</classname> unless
                        you have good reason to believe that the software
                        will be analyzing NSCLDAQ 11.0 and later and will be
                        joining runs online in the middle of the run.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CRingFormatHelper* </type>
                        <methodname>getCurrentFormatHelper</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the format helper currently being
                        used by the decoder.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CRingFormatHelper* </type>
                        <methodname>getDefaultFormatHelper</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the default format helper currently
                        in effect.  Note that it is possible that the this does
                        not represent the active format helper, especially if
                        a ring format item was encountered that indicates a different
                        format helper should be u7sed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CRingFormatHelperFactory* </type>
                        <methodname>getFormatFactory</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the ring format
                        helper factory
                        being used by this object.  The ring format
                        factory is responsible for selecting and creating
                        a ring format helper compatible with the data
                        that has been seen by the decoder.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnSourceAttach</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when a new data source is attached.  The
                        current buffer format helper is deleted and, for now,
                        the decoder falls back on the default buffer format
                        helper.
                    </para>
                    <para>
                        Once a ring format item is seen, (or rather if one
                        is seen), the ring format helper factory is used
                        to select an appropriate helper for the current
                        data source.  Furthermore, the format helper can be
                        set programmatically by calling
                        <methodname>setFormatHelper</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void</type>
                        <methodname> OnSourceDetach</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when  data source is detached. This invalidates
                        the current buffer format helper in much the same manner
                        as <methodname>OnSourceAttach</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnEndFile</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when an end file is encountered on a data source.
                        This also invalidates the ring format helper.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CRingFormatHelper</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CRingFormatHelper</refname>
        <refpurpose>ABC for4 ring buffer format helpers</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;RingFormatHelper.h&gt;

class CRingFormatHelper
{
public:
    CRingFormatHelper();
    virtual ~CRingFormatHelper();
    CRingFormatHelper(const CRingFormatHelper&amp;);
    CRingFormatHelper&amp; operator=(const CRingFormatHelper&amp;);
    int operator==(const CRingFormatHelper&amp;) const;
    int operator!=(const CRingFormatHelper&amp;) const;
    
public:
    virtual bool hasBodyHeader(void* pItem) const   = 0;
    virtual void* getBodyPointer(void* pItem)       = 0;
    virtual void* getBodyHeaderPointer(void* pItem) = 0;
    
    virtual std::string getTitle(void* pItem) = 0;
    virtual unsigned    getRunNumber(
        void* pItem, BufferTranslator* pTranslator) = 0;
    
    virtual unsigned getStringCount(
        void* pItem, BufferTranslator* pTranslator) = 0;
    
    virtual unsigned getScalerCount(
        void*  pItem, BufferTranslator* pTranslator) = 0;
    
    virtual uint64_t getTriggerCount(
        void* pItem, BufferTranslator* pTranslator) = 0;

    uint16_t itemType(void* pItem);

};

#include &lt;RingFormatHelper10.h&gt;

class CRingFormatHelper10;

#include &lt;RingFormatHelper11.h&gt;
class CRingFormatHelper11;


        </synopsis>    
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Ring buffer data comes in more than one format, depending on the
            actual version of NSCLDAQ that emitted it.  Ring format helpers
            are classes that know how to untangle data from specific versions
            of NSCL Ring buffer data acquisition systems.
        </para>
        <para>
            <classname>CRingFormatHelper</classname> is an abstract base class
            that provides the interface that the
            <classname>CRingBufferDecoder</classname> class expects these helpers
            to implement.
        </para>
        <para>
            SpecTcl provides two concrete implementations of this class:
            <itemizedlist>
                <listitem>
                    <para>
                        <classname>CRingFormatHelper10</classname> which
                        helps the Ring buffer decoder handle NSCLDAQ10 data (data)
                        that has no provision for body headers. 
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <classname>CRingFormatHelper11</classname> which
                        helps with data from NSCLDAQ11, which does have a provision
                        for body headers that can assist the event builder.
                    </para>
                </listitem>
            </itemizedlist>
        </para>
        <para>
            These helper classes offer no additional public methods beyond those
            specified by <classname>CRingFormatHelper</classname>.  Therefore
            we will not document them further.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            For brevity, only the non-canonicals are described here.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>bool </type>
                        <methodname>hasBodyHeader</methodname>
                        <methodparam>
                            <type>void*</type>
                             <parameter>pItem</parameter>
                        </methodparam>
                        <modifier>const   = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Determines if the ring item pointed to by
                        <parameter>pItem</parameter> contains a body header.
                        Body headers contain additional fixed format data prior
                        to the body of the ring item but after the ring item header
                        itself.  
                    </para>
                    <para>
                        For example in NSCLDAQ 11.x, body headers, if present,
                        contain a timestamp for the item, the source id of the
                        item and a barrier type.  NSCLDAQ 11.x may also emit
                        ring items without body headers.
                    </para>
                    <para>
                        Note that if the version of NSCLDAQ emitting this
                        item does not support body headers, this always returns
                        <literal>false</literal>
                    </para>
                </listitem>
            </varlistentry>        
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void* </type>
                        <methodname>getBodyPointer</methodname>
                        <methodparam>
                            <type>void*</type><parameter>pItem</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the ring item body for the
                        item pointed to by <parameter>pItem</parameter>.
                        Note that
                        in the presence of body headers, this pointer will
                        point past the body header to the actual body data itself.
                    </para>
                </listitem>
            </varlistentry>        
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void* </type>
                        <methodname>getBodyHeaderPointer</methodname>
                        <methodparam>
                            <type>void*</type><parameter> pItem</parameter>
                        </methodparam>
                        <modifier>= 0;</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the body header of the
                        ring item:
                        <parameter>pItem</parameter>.
                        If <parameter>pItem</parameter> does not have a body
                        header (<methodname>hasBodyHeader</methodname> returns
                        <literal>false</literal>), this will return a
                        <literal>nullptr</literal>.
                    </para>
                </listitem>
            </varlistentry>        
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>std::string </type>
                        <methodname>getTitle</methodname>
                        <methodparam>
                            <type>void* </type><parameter>pItem</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If <parameter>pItem</parameter> points to a state
                        transition item, the title is returned from that item.
                        If <parameter>pItem</parameter> does not point to
                        a state transition item, a
                        <type>std::string</type> exception is thrown containing
                        an appropriate error message.
                    </para>
                </listitem>
            </varlistentry>        
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual    </modifier>
                        <type>unsigned </type>
                        <methodname>getRunNumber</methodname>
                        <methodparam>
                            <type>void* </type><parameter>pItem</parameter>
                        </methodparam>
                        <methodparam>
                            <type>BufferTranslator* </type>
                            <parameter>pTranslator</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If <parameter>pItem</parameter> points to a
                        state transition ring item, this method returns
                        the run number from that item.  If not a
                        <type>std::string</type> exception
                        is thrown.  The contents of that string are
                        a human readable error message.
                    </para>
                    <para>
                        <parameter>pTranslator</parameter> points to the
                        appropriate buffer translator and is used to transform
                        the run number in the byte ordering of the producing
                        system to that of the system running SpecTcl.
                    </para>
                </listitem>
            </varlistentry>        
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>unsigned </type>
                        <methodname>getStringCount</methodname>
                        <methodparam>
                            <type>void*  </type><parameter>pItem</parameter>
                        </methodparam>
                        <methodparam>
                            <type> BufferTranslator* </type><parameter>pTranslator</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If the ring item pointed to by
                        <parameter>pItem</parameter> is a Text item
                        ring item, method returns the number of strings
                        this item has.
                        If the item is not a text ring item, a
                        <type>std::string</type> exception is thrown
                        containing a human readable error message.
                    </para>
                    <para>
                        <parameter>pTranslator</parameter> is used to translate
                        any string count from the byte ordering of the
                        producing system to the byte order of the system
                        running SpecTcl.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>unsigned </type>
                        <methodname>getScalerCount</methodname>
                        <methodparam>
                            <type>void*  </type><parameter>pItem</parameter>
                        </methodparam>
                        <methodparam>
                            <type>BufferTranslator*</type><parameter>pTranslator</parameter>
                        </methodparam>
                        <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If <parameter>pItem</parameter> points to a scaler item,
                        this method returns the number of counters in that
                        item.  If
                        <parameter>pItem</parameter> does not point to a
                        scaler item, a <type>std::string</type> exception is
                        thrown.
                    </para>
                    <para>
                        <parameter>pTranslator</parameter> is used to transform
                        the count from the byte order of the producing system
                        to they byte order of the system that is running SpecTcl.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>uint64_t </type>
                        <methodname>getTriggerCount</methodname>
                        <methodparam>
                            <type>void* </type><parameter>pItem</parameter>
                        </methodparam>
                        <methodparam>
                            <type>BufferTranslator* </type><parameter>pTranslator</parameter>
                        </methodparam>
                        <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If <parameter>pItem</parameter> points to a physics
                        event count item, this method returns the number
                        of triggers accepted by the run so far. If
                        <parameter>pItem</parameter> is not a physics event
                        count item, a <type>std::string</type> exception is
                        thrown.
                    </para>
                    <para>
                        <parameter>pItem</parameter> is used to convert
                        the trigger count from the byte order of the
                        producing system to the byte order of the system
                        running SpecTcl.
                    </para>
                </listitem>
            </varlistentry>        
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>uint16_t </type>
                        <methodname>itemType</methodname>
                        <methodparam>
                            <type>void* </type><parameter>pItem</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the ring item type for the ring item pointed
                        to by <parameter>pItem</parameter>.
                    </para>
                </listitem>
            </varlistentry>        
                    
                
                    
            
        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CNamedItem</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CNamedItem</refname>
        <refpurpose>Base class for items with names and ids.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;NamedItem.h&gt;

class CNamedItem      
{
 public:
  CNamedItem();
  CNamedItem (  std::string am_sName,  UInt_t am_nNumber  );

 public:
  std::string getName() const;
  UInt_t getNumber() const;
  void ChangeName(const std::string&amp; rNewName);
};

class CMatchNamedItemId {
 public:
  CMatchNamedItemId(UInt_t id);
  Bool_t operator()(CNamedItem&amp; item);
};

class CMatchNamedItem {
 public:
  CMatchNamedItem(const std::string&amp; rName);
  Bool_t operator()(CNamedItem&amp; item)
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Several SpecTcl objects have names and identifying numbers.  The
            <classname>CNamedItem</classname> class provides a convenient base
            class for those classes.  In addition to the methods shown, named items
            can be copy constructed, assigned and compared for equality.  Those
            methods have standard signatures and, therefore, are not described.
        </para>
        <para>
            Often bits of SpecTcl have to search for named items, either by id
            or by name in C++ standard library container objects (typically
            but not exclusively maps organized by object name).  The
            <classname>CMatchNamedItemId</classname> and
            <classname>CMatchNamedItem</classname> provide predicates for
            C++ algorithms that require matching predicates. 
        </para>
        <para>
            <classname>CMatchNamedItemId</classname> matches item(s) that
            have the same id as the one it is constructed with, while
            <classname>CMatchNamedItem</classname> matches those named
            the same as the string it is constructed with.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            We're only going to document the <classname>CNamedItem</classname>
            classes as the predicates are straightforward to use if you understand
            how predicates are used in the C++ standard library algorithms.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CNamedItem</methodname>
                        <void />
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Parameter-less constructor.   This creaets an object
                        with a name that is an empty string and an id of
                        <literal>0</literal>.  Typically this is used to create
                        an object that will be used as the target of an assignment.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CNamedItem </methodname>
                        <methodparam>
                            <type>std::string  </type><parameter>am_sName</parameter>
                        </methodparam>
                        <methodparam>
                            <type> UInt_t </type><parameter>am_nNumber</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Fully parameterized constructor.  The object will have
                        the name provided by <parameter>am_sName</parameter> and
                        the id provided by <parameter>am_nNumber</parameter>.
                    </para>
                    <para>
                        Note that any attempt to maintain unique naming or id
                        assignement is the responsibility of either the
                        derived class (e.g. through a registry it maintain) or
                        the code that manages the containers used to organize
                        the derived objects.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>std::string </type>
                        <methodname>getName() </methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the name associated with this object.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>UInt_t </type>
                        <methodname>getNumber</methodname>
                        <void />
                        <modifier> const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the id (integer) associated with this object.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>ChangeName</methodname>
                        <methodparam>
                            <modifier>const </modifier><type>std::string&amp; </type>
                            <parameter>rNewName</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        In some cases it's useful to change the name of a named item.
                        This method provides that capability.
                        The object's name is changed to <parameter>rNewName</parameter>.
                    </para>
                </listitem>
            </varlistentry>
           
        </variablelist>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CParameter</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CParameter</refname>
        <refpurpose>Parameter definition.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;Parameter.h&gt;

class CParameter : public CNamedItem {

 public:
  CParameter();

  CParameter(const std::string&amp; rName,
	     UInt_t nId,
	     const char* pUnits);
  CParameter(UInt_t am_nScale, 
	     const std::string&amp; rName, UInt_t nNumber);

  CParameter(UInt_t am_nScale,
	     const std::string&amp; rName, UInt_t nNumber,
	     Float_t nLow, Float_t nHigh, std::string am_sUnits) ;
         
 public:
  Bool_t hasScale() const;
  UInt_t getScale() const;
  Float_t getLow() const;
  Float_t getHigh() const;
  std::string getUnits() const;
  Float_t RawToMapped(Float_t Raw);
  Float_t MappedToRaw(Float_t Mapped);

};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <classname>CParameter</classname> objects contain parameter definitions.
            Parameter definitions are named objects where the name is used to
            refer to the parameter in SpecTcl commands and Tree parameter
            definitions while the id is an index into the
            <classname>CEvent</classname> into which that parameter's values
            for each event should be stored
        </para>
        <para>
            Parameter definitions also include metadata that is used to provide
            hints to users defining spectra about how to define the axes of spectra
            on those parameters.  An optional units metadata provides the units
            of measure for a parameter
        </para>
        <para>
            Because of SpecTcl's long developmental history,
            axis rang information comes in several orthogonal forms.  
        </para>
        <para>
            Originally, SpecTcl parameters were integer values and scaling
            to spectrum axes was done via simple shifting.  Metadata on
            parameter ranges from that epoch is called a scale and represents
            the number of bits of range of the parameter.  For example
            a scale of <literal>10</literal> means the parameter runs
            in the range of <literal>[0, 1024)</literal>.
        </para>
        <para>
            In the second phase of parameter history, SpecTcl parameters were
            still integers but the spectrum axes were labeled in an arbitrary
            range.  This sort of a parameter is called a <firstterm>mapped parameter</firstterm>
            because while it remains an integer, when looking at a spectrum,
            the spectrum axis can be mapped to some arbitrary range.
        </para>
        <para>
            Finally, SpecTcl parameters are full double precision values.
            These values are passed through a set of linear functions to map them from
            raw parameter space to axis space in the spectra in which they are
            used.
        </para>
        <para>
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            In addition to the methods described, parameter objects can be
            copy constructed, assigned and compared for equality.  These
            canonical methods will not be described further here.
        </para>
        <variablelist>
            <varlistentry>
                <term><constructorsynopsis>
                    <methodname>CParameter</methodname>
                    <void />
                </constructorsynopsis></term>
                <listitem>
                    <para>
                        Constructs a parameter with an id of
                        <literal>UINT_MAX</literal> and a name of
                        <literal>Undefined</literal>.  The scale low and high
                        values are set to <literal>0.0</literal> and the
                        units to an empty string
                    </para>
                    <para>
                        The metadata initialization of this sort of parameter
                        makes it quite useless.  This constructor is intended
                        to produce a parameter definition that will eventually
                        be on the left hand side of an assignemnt from a
                        more meaningful parameter definition object.
                    </para>
                    <para>
                        The id of <literal>UINT_MAX</literal> will make adding
                        this parameter to the parameter dictionary and then actually
                        attempting to assign it a value via e.g. a tree parameter
                        cause SpecTcl to fail with a memory allocation as it
                        tries to expand the active <classname>CParameter</classname>
                        value to accommodate this parameter.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CParameter</methodname>
                        <methodparam>
                            <modifier>const</modifier><type> std::string&amp; </type>
                            <parameter>rName</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t</type><parameter>nId</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>char* </type><parameter>pUnits</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs a parameter named <parameter>rName</parameter>.
                        The parameter Id of the 
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CParameter</methodname>
                        <methodparam>
                            <type>UInt_t </type><parameter>am_nScale</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier>const</modifier><type> std::string&amp;</type>
                            <parameter>rName</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type>
                            <parameter>nNumber</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs a parameter that is <parameter>am_nScale</parameter>
                        bits wide.  The name of the parameters is
                        <parameter>rName</parameter> and the id is
                        <parameter>nNumber</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CParameter(</methodname>
                        <methodparam>
                            <type>UInt_t </type><parameter>am_nScale</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier>const </modifier><type>std::string&amp; </type>
                            <parameter>rName</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type><parameter>nNumber</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t </type><parameter>nLow</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t </type><parameter>nHigh</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::string </type><parameter>am_sUnits</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates a parameter with metadata that indicates the
                        range of values the parameter may senisbly take.
                        <parameter>am_nScale</parameter> is obsolete in modern
                        times.  In the past, when mapped spectra existed,
                        this parameter was the number of bits of range of the
                        parameter.  Now, only <parameter>nLow</parameter>
                        and <parameter>nHigh</parameter> matter.
                        They are the recommended low and high limits
                        for an axis on this parameter.
                    </para>
                    <para>
                        As before, <parameter>rName</parameter> is the
                        name of the parameter and <parameter>nNumber</parameter>
                        is the parameter's id.  <parameter>am_sUnits</parameter>
                        are the units of measure string.  If this makes no sense,
                        simply provide an empty string.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Bool_t </type>
                        <methodname>hasScale</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>kfTRUE</literal> if the parameter
                        was constructed with a non-zero scale value.
                        Otherwise returns <literal>kfFALSE</literal> indicating
                        that the parameter range should be gotten from the
                        low and high range values or, may not have been supplied
                        at all (in which case low == high == 0.0).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>UInt_t </type>
                        <methodname>getScale</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the scale value.  This is only meaningful
                        if <methodname>hasScale</methodname> returns
                        <literal>kfTRUE</literal>.   While you an probably
                        guess what this returns when that's not the case
                        I'm not going to gaurantee you're correct either now
                        or in the future, so don't use that value instead of
                        <methodname>hasScale</methodname>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Float_t </type>
                        <methodname>getLow</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the low limit metadata for this parameter.
                        If limits were not provided,
                        both this and <methodname>getHigh</methodname> below
                        will return <literal>0.0</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Float_t </type>
                        <methodname>getHigh</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the high limit metadata for thsi parameter.
                        If limits were not provided, this and
                        <methodname>getLow</methodname> above will return
                        <literal>0.0</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>std::string </type>
                        <methodname>getUnits</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the units of measure string metadata for
                        this parameter.  If no units of measure were provided,
                        this returns an empty string.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Float_t </type>
                        <methodname>RawToMapped</methodname>
                        <methodparam>
                            <type>Float_t </type><parameter>Raw</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Float_t </type>
                        <methodname>MappedToRaw</methodname>
                        <methodparam>
                            <type>Float_t </type>
                            <parameter>Mapped</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        These methods are left over from the days  of
                        mapped spectra/parameters and should not be used
                        in new SpecTcl code.
                    </para>
                </listitem>
            </varlistentry>
  
  
        </variablelist>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CEvent</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CEvent</refname>
        <refpurpose>Destination for decoded event data.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;Event.h&gt;

typedef DFloat_t ParamType;
typedef std::vector&lt;DopedValidValue&lt;ParamType&gt; &gt; CParameterVector;
typedef DopedValidValue&lt;ParamType&gt;                     CParameterValue;
typedef CParameterVector::iterator                           CEventIterator;

class CEvent {
 public:
  CEvent();
  virtual ~CEvent() ;
  CEvent(UInt_t nInitialSize);
  CEvent(const CEvent&amp; aEvent);

  CEvent&amp; operator=(const CEvent&amp; aEvent);
  int operator==(const CEvent&amp; aEvent);
  int operator!=(const CEvent&amp; anEvent);
  
  CParameterValue&amp; operator[](UInt_t nParam);

  CEventIterator begin();
  CEventIterator end();
  UInt_t size() const;
  void clear();

  DopeVector&amp; getDopeVector();
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <classname>CEvent</classname> objects are the base level object
            produced by the application of the event processing pipeline to
            a raw event.  The object looks very  much like a vector except
            that it expands as needed to allow the largest index to fit.
        </para>
        <para>
            The elements of a <classname>CEvent</classname> object are valid
            values.  Valid values know when they've been assigned to.  Event
            serial numbers are used to allow clearing the assignment status
            of the event in O(1) time.
        </para>
        <para>
            The first time a parameter has been assigned, its index is
            added to a <parameter>Dope Vector</parameter>.  The purpose of the
            dope vector is to improve histogramming efficiency.
            Where the spectrum type allowed, the histogrammer organizes
            histogrammers in lists of histograms that require a specific parameter
            id.  All such histograms for which this is not possible (e.g. summary
            spectra) make up a separate list.
        </para>
        <para>
            This organization means that rather than iterating over all
            defined histograms, the histogrammer can use the dope vector
            contents to restrict iteration to the set of histograms that
            require parameters that have been given values, and those
            histograms for which a required parameter does not exist.
            When events are sparse (typically) and many histograms have
            been defined, this provides a significant performance
            improvement.
        </para>
        <para>
            SpecTcl further recycles events after clearing them.  Over the long run,
            this means that events will no longer require costly expansion but
            will reach equilbrium lengths long enough to hold the highest parameter
            id.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            This class suppports assignment, copy  construction, and
            comparison for both equality and inequality.  Those
            methods are not documented in this section
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CEvent</methodname>
                        <void />
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs an event with an initial sizeof
                        <literal>0</literal> elements.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CEvent</methodname>
                        <methodparam>
                            <type>UInt_t</type><parameter>nInitialSize</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs an event with an initial size
                        specified by <parameter>nInitialSize</parameter>.
                        Given that SpecTcl recycles events it uses in the
                        event processing and event sink pipelines; any
                        non zero value has no amortized performance impact
                        on SpecTcl.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CParameterValue&amp; </type>
                        <methodname>operator[]</methodname>
                        <methodparam>
                            <type>UInt_t </type><parameter>nParam</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a reference to the element at index
                        <parameter>nParam</parameter> in the event.  If
                        the event is not yet big enough to provide that element,
                        it is expanded with unset (not valid) elements until
                        it is.
                    </para>
                    <para>
                        The fact that a reference is returned allows this
                        to occur as an lvalue or rvalue.  If used as an
                        rvalue, an exception is thrown if the value has not
                        yet been assigned a value.  The exception is of
                        type <type>std::string</type> and is the value
                        "Attempted getValue of unset ValidValue object".
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventIterator </type>
                        <methodname>begin</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventIterator</type>
                        <methodname>end</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>UInt_t </type>
                        <methodname>size</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        The <methodname>begin</methodname> and
                        <methodname>end</methodname> methods provide iteration
                        over the full event vector at its current size.
                        Iteration is supported in the same sense as it is
                        for C++ standard library iterators.
                        <methodname>size</methodname> returns the number
                        of elements currently in the vector.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>clear</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Sets all values in the event to invalid (not assigned).
                        This is done by SpecTcl after an event filled in by the
                        event processing pipeline has been passed though the
                        elements of the event sink pipeline.
                    </para>
                    <para>
                        This also clears the dope vector of the event.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>DopeVector&amp; </type>
                        <methodname>getDopeVector</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a reference to the current dope vector for
                        this event.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title>DATA TYPES</title>
        <variablelist>
            <varlistentry>
                <term>
                    <type>ParamType</type>
                </term>
                <listitem>
                    <para>
                        Defines the data type that is used for parameters
                        in the event object.  At this time ths is a double
                        precision real value.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <type>CParameterVector</type>
                </term>
                <listitem>
                    <para>
                        At any time, this is the data type that holds
                        the parameter values.  Currently this is a
                        <classname>std::Vector&lt;DopedValidValue&lt;Paramtype&gt; &gt;</classname>.
                    </para>
                    <para>
                        That is a valid value vector that has an associated dope vector.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <type>CParameterValue</type>
                </term>
                <listitem>
                    <para>
                        This is a doped valid value of type <type>ParamType</type>.
                        Doped value values have an associated dope vector and
                        an id.  When first assigned after being constructed or
                        reset they append their id to the dope vector.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>CEventIterator </type></term>
                <listitem>
                    <para>
                        Iterator through the <classname>CParameterVector</classname>
                        in a <classname>CEvent</classname> object.
                    </para>
                </listitem>
            </varlistentry>

        </variablelist>
    </refsect1>
</refentry>
        <chapter>
            <title>Stuff to do</title>
        <itemizedlist>
            <listitem>
                <para>
                    Spectrum classes
                    CSpectrum,
BitSpectrumL.h
BitSpectrumW.h
CGammaSpectrum.h
CGammaSummarySpectrum.h
CSpectrum2DmB.h
CSpectrum2Dm.h
CSpectrum2DmL.h
CSpectrum2DmW.h
MSpectrum1DL.h
MSpectrum1DW.h
MSpectrum2DB.h
MSpectrum2DW.h
NSCLAsciiSpectrumFormatter.h
NSCLBinarySpectrumFormatter.h
SnapshotSpectrum.h
Spectrum1DL.h
Spectrum1DW.h
Spectrum2DB.h
Spectrum2DL.h
Spectrum2DW.h
SpectrumS.h
SummarySpectrumB.h
SummarySpectrumL.h
SummarySpectrumW.h

                </para>
            </listitem>
            <listitem>
                <para>
                    Gate Classes, and CGateContainer, Gate observer
                </para>
            </listitem>
            <listitem>
                <para>
                    Fitting subsystem
                </para>
            </listitem>
            <listitem>
                <para>
                    Filter subsystem
                </para>
            </listitem>
        </itemizedlist>
        </chapter>
    </part>
</book>