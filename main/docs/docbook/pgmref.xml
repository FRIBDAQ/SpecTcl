<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                      "file:///usr/share/xml/docbook/schema/dtd/4.5/docbookx.dtd
"
>
<book>
    <bookinfo>
      <title>SpecTcl Programming Reference.</title>
      <author><firstname>Ron</firstname><surname>Fox</surname></author>
      <revhistory>
          <revision>
             <revnumber>1.0</revnumber>
             <date>July 24, 2017 and following</date>
             <authorinitials>RF</authorinitials>
             <revremark>Original Release</revremark>
          </revision>
      </revhistory>
    </bookinfo>
    <chapter>
        <title>Introduction</title>
        <para>
            This manual provides reference pages for classes, scripts and
            file formats for the NSCL SpecTcl histogramming program.  Command
            reference information is explicitly not given here but in a separate
            command reference manual.
        </para>
        <para>
            The reference information is divided into the following parts:
        </para>
        <orderedlist>
            <listitem>
                <para>
                    The SpecTcl API provides a reference page for the
                    SpecTcl API class <classname>SpecTcl</classname>.  This
                    is sort of a stovepipe class that provides access to the
                    rest of the public API used by SpecTcl.
                </para>
            </listitem>
            <listitem>
                <para>
                    The Tree parameter/TreeVariable API provide structure as well
                    as metadata on top of SpecTcl's flat parameter array.
                    Authors of  event processors should write in terms of this API.
                </para>
            </listitem>
            <listitem>
                <para>
                    Tcl++ is a separate package, however it is so much an integral
                    part of the SpecTcl interface, that reference information
                    for that package is provided here as well.
                </para>
            </listitem>
            <listitem>
                <para>
                    Core SpecTcl classes include parameters, histograms,
                    and gates.  This part documents these core classes as well
                    as the methods of the <classname>CHistogrammer</classname>
                    class intended to be available for extension programs.
                </para>
            </listitem>
            <listitem>
                <para>
                    File formats.  This part describes the format of filter files
                    as well as both the binary and ASCII format of spectrum
                    files written by the <command>swrite</command> command.
                </para>
            </listitem>
        </orderedlist>
    </chapter>
    <part>
        <title>SpecTclAPI class</title>
        <chapter>
            <title>SpecTcl</title>
            <para>
                The <classname>SpecTcl</classname> class should be the starting
                point for any application needing services from SpecTcl.
                You should use it rather than any knowledge of the internals of
                SpecTcl when writing programs that extend or tailor SpecTcl.
            </para>
        </chapter>
        <refentry >
            <refmeta>
                <refentrytitle >SpecTcl</refentrytitle>
                <manvolnum>3spectcl</manvolnum>
            </refmeta>
            
            <refnamediv>
                <refname>SpecTcl</refname>
                <refpurpose>API Singleton class.</refpurpose>
            </refnamediv>
            
            <refsynopsisdiv>
                <synopsis>
#include <filename>&lt;SpecTcl.h&gt;</filename>
<classname>SpecTcl</classname>
{
public:
  static SpecTcl* getInstance();
  void addBufferDecoder(std::string                      type,
                        CAttachCommand::CDecoderCreator* creator);
  UInt_t AssignParameterId();
  CParameter* AddParameter(std::string name,
                           UInt_t Id,
                           std::string Units);
  CParameter* AddParameter(std::string name,
                           UInt_t id,
                           UInt_t scale);
  CParameter* AddParameter(std::string name,
                           UInt_t id,
                           UInt_t scale,
                           Float_t low, Float_t high,
                           std::string units);
  CParameter* RemoveParameter(std::string name);
  CParameter* FindParameter(std::string name);
  CParameter* FindParameter(UInt_t Id);
  ParameterDictionaryIterator BeginParameters();
  ParameterDictionaryIterator EndParameters();
  UInt_t ParameterCount();
  CSpectrum* CreateSpectrum(std::string Name,
                            SpectrumType_t type,
                            DataType_t dataType,
                            std::vector&lt;std::string&gt; parameters,
                            std::vector&lt;UInt_t&gt; channels,
                            std::vector&lt;Float_t&gt;* pLows,
                            std::vector&lt;Float_t&gt;* pHighs);
  CSpectrum* CreateSpectrum(std::string Name,
                            SpectrumType_t type,
                            DataType_t     dataType,
                            std::vector&lt;std::string&gt; xParameters,
                            std::vector&lt;std::string&gt; yParameters,
                            std::vector&lt;UInt_t&gt;      channels,
                            std::vector&lt;Float_t&gt;*    pLows,
                            std::vector&lt;Float_t&gt;*    pHighs);

  CSpectrum* CreateSpectrum(std::string           Name,
                            SpectrumType_t        type,
                            DataType_t            dataType,
                            std::vector&lt;std::vector&lt;std::string&gt; &gt; parameters,
                            std::vector&lt;UInt_t&gt;   channels,
                            std::vector&lt;Float_t&gt;* lows,
                            std::vector&lt;Float_t&gt;* highs);

  CSpectrum* CreateGammaSummary(std::string                      Name,
                                DataType_t                       dataType,
                                std::vector&lt;std::vector&lt;std::string&gt; &gt; parameters,
                                UInt_t                           nChannels,
                                std::vector&lt;Float_t&gt;*            low,
                                std::vector&lt;Float_t&gt;*            high);

  CSpectrum* CreateG2DDeluxe(std::string Name,
                        DataType_t     dataType,
                        std::vector&lt;std::string&gt; xParameters,
                        std::vector&lt;std::string&gt; yParameters,
                        std::vector&lt;UInt_t&gt;      channels,
                        std::vector&lt;Float_t&gt;*    pLows,
                        std::vector&lt;Float_t&gt;*    pHighs);

  CSpectrum* Create1D(std::string name,
                      DataType_t dataType,
                      CParameter&amp; parameter,
                      UInt_t channels);
  CSpectrum* Create1D(std::string name,
                      DataType_t dataType,
                      CParameter&amp; parameter,
                      UInt_t channels,
                      Float_t lowLimit, Float_t hiLimit);
  CSpectrum* Create2D(std::string name,
                      DataType_t dataType,
                      CParameter&amp; xParameter,
                      CParameter&amp; yParmaeter,
                      UInt_t xChannels, UInt_t yChannels);
  CSpectrum* Create2D(std::string name,
                      DataType_t dataType,
                      CParameter&amp; xParameter, CParameter&amp; yParameter,
                      UInt_t xChannels, Float_t xLow, Float_t xHigh,
                      UInt_t yChannels, Float_t yLow, Float_t yHigh);
  CSpectrum* CreateG1D(std::string name,
                       DataType_t dataType,
                       std::vector&lt;CParameter&gt; parameters,
                       UInt_t channels);
  CSpectrum* CreateG1D(std::string name,
                       DataType_t dataType,
                       std::vector&lt;CParameter&gt; parameters,
                       UInt_t channels,
                       Float_t lowLimit,
                       Float_t hiLimit);
  CSpectrum* CreateG2D(std::string name,
                       DataType_t dataType,
                       std::vector&lt;CParameter&gt; parameters,
                       UInt_t xChannels, UInt_t yChannels);
  CSpectrum* CreateG2D(std::string name,
                       DataType_t dataType,
                       std::vector&lt;CParameter&gt; parameters,
                       UInt_t xChannesl, Float_t xLow, Float_t xHigh,
                       UInt_t yChannesl, Float_t yLow, Float_t yHigh);
  CSpectrum* CreateBit(std::string name,
                       DataType_t dataType,
                       CParameter&amp; parameter,
                       UInt_t channels);
  CSpectrum* CreateBit(std::string name,
                       DataType_t dataType,
                       CParameter&amp; parameter,
                       UInt_t channels, UInt_t lowBit);
  CSpectrum* CreateSummary(std::string name,
                           DataType_t dataType,
                           std::vector&lt;CParameter&gt; parameters,
                           UInt_t channels);
  CSpectrum* CreateSummary(std::string name,
                           DataType_t dataType,
                           std::vector&lt;CParameter&gt; parameters,
                           UInt_t nChannels, Float_t low, Float_t high);


  CSpectrum* CreateGamma2DD(std::string name,
                            DataType_t dataType,
                            std::vector&lt;CParameter&gt; xParameters,
                            std::vector&lt;CParameter&gt; yParameters,
                            UInt_t xChannels, Float_t xLow, Float_t xHigh,
                            UInt_t yChannels, Float_t yLow, Float_t yHigh);
  CSpectrum* Create2DSum(std::string name,
                         DataType_t  dataType,
                         std::vector&lt;CParameter&gt; xParameters,
                         std::vector&lt;CParameter&gt; yParameters,
                         UInt_t xChans, Float_t xLow, Float_t xHigh,
                         UInt_t yChans, Float_t yLow, Float_t yHigh);
  CSpectrum* CreateStripChart(std::string name,
                              DataType_t  dataType,
                              CParameter  counts,
                              CParameter  time,
                              UInt_t      channels, Float_t xLow, Float_t xHigh);


  // Manipulate the spectrum dictionary:

  void AddSpectrum(CSpectrum&amp; spectrum);
  CSpectrum* RemoveSpectrum(std::string name);
  CSpectrum* FindSpectrum(std::string name);
  CSpectrum* FindSpectrum(UInt_t id);
  SpectrumDictionaryIterator SpectrumBegin();
  SpectrumDictionaryIterator SpectrumEnd();
  UInt_t SpectrumCount();

  void addSpectrumDictionaryObserver(SpectrumDictionaryObserver* observer);
  void removeSpectrumDictionaryObserver(SpectrumDictionaryObserver* observer);

  // Misc spectrum utilities:

  void ClearSpectrum(std::string name);
  void ClearAllSpectra();

  // Create gates of various types:

  CGate* CreateGate(CGateFactory::GateType gateType,
                    std::vector&lt;std::string&gt; names);
  CGate* CreateGate(CGateFactory::GateType gateType,
                    std::vector&lt;std::string&gt; parameters,
                    std::vector&lt;FPoint&gt; points);
  CGate* CreateGate(CGateFactory::GateType   gateType,
                    std::vector&lt;FPoint&gt;      points,
                    std::vector&lt;UInt_t&gt; parameters);
  CGate* CreateGate(CGateFactory::GateType gateType,
                    std::vector&lt;std::string&gt; rparameters,
                    long comparison);
  CGate* CreateTrueGate();
  CGate* CreateFalseGate();
  CGate* CreateBand(std::string xparameter, std::string yparameter,
                    std::vector&lt;FPoint&gt; points);
  CGate* CreateContour(std::string xParameter, std::string yParameter,
                       std::vector&lt;FPoint&gt; points);
  CGate* CreateBandContour(std::string firstBand, std::string secondBand);
  CGate* CreateNotGate(std::string name);
  CGate* CreateAndGate(std::vector&lt;std::string&gt; gateNames);
  CGate* CreateOrGate(std::vector&lt;std::string&gt; gateNames);
  CGate* CreateCut(std::string parameter, Float_t low, Float_t high);
  CGate* CreateGammaCut(Float_t low, Float_t high, std::vector&lt;std::string&gt; constituents);
  CGate* CreateGammaBand(std::vector&lt;FPoint&gt; points,
                         std::vector&lt;std::string&gt; constituents);
  CGate* CreateGammaContour(std::vector&lt;FPoint&gt; points,
                            std::vector&lt;std::string&gt; constituents);
  CGate* CreateMaskEqualGate(std::vector&lt;std::string&gt; rParameterName,
                             long Compare);
  CGate* CreateMaskAndGate(std::vector&lt;std::string&gt; rParameterName,
                             long Compare);
  CGate* CreateMaskNotGate(std::vector&lt;std::string&gt; rParameterName,
                             long Compare);


  // Gate dictionary manipulation:

  void AddGate(std::string name, CGate* gate);
  void DeleteGate(std::string gateName);
  void ReplaceGate(std::string gateName, CGate&amp; newGate);
  CGateContainer* FindGate(std::string gateName);
  CGateDictionaryIterator GateBegin();
  CGateDictionaryIterator GateEnd();
  UInt_t GateCount();

  void addGateDictionaryObserver(CGateObserver* observer);
  void removeGateDictionaryObserver(CGateObserver* observer);



  void ApplyGate(std::string gateName, std::string spectrumName);

  // Manipulating the event processor pipeline.

  void AddEventProcessor(CEventProcessor&amp; eventProcessor,
                         const char* name = 0);
  CTclAnalyzer::EventProcessorIterator FindEventProcessor(std::string name);
  CTclAnalyzer::EventProcessorIterator FindEventProcessor(CEventProcessor&amp; processor);
  void InsertEventProcessor(CEventProcessor&amp; processor,
                            CTclAnalyzer::EventProcessorIterator where,
                            const char*  name = 0);
  void RemoveEventProcessor(std::string name);
  void RemoveEventProcessor(CTclAnalyzer::EventProcessorIterator here);
  UInt_t ProcessingPipelineSize();
  CTclAnalyzer::EventProcessorIterator ProcessingPipelineBegin();
  CTclAnalyzer::EventProcessorIterator ProcessingPipelineEnd();

  void AddSpectrumFormatter(std::string name, CSpectrumFormatter&amp; formatter);

  void AddEventSink(CEventSink&amp; sink, const char* name = 0);
  CEventSinkPipeline::EventSinkIterator FindEventSink(std::string sinkName);
  CEventSinkPipeline::EventSinkIterator FindEventSink(CEventSink&amp; sink);
  void InsertEventSink(CEventSink&amp; sink, CEventSinkPipeline::EventSinkIterator here,
                       const char* name = 0);
  CEventSink* RemoveEventSink(std::string name);
  CEventSink* RemoveEventSink(CEventSinkPipeline::EventSinkIterator here);
  UInt_t EventSinkPipelineSize();
  CEventSinkPipeline::EventSinkIterator EventSinkPipelineBegin();
  CEventSinkPipeline::EventSinkIterator EventSinkPipelineEnd();

  void               createFilter(std::string name, CGatedEventFilter* pFilter);
  CGatedEventFilter* findFilter(std::string name);
  bool               filterExists(CGatedEventFilter* pFilter);
  void               deleteFilter(CGatedEventFilter* pFilter);
  void               deleteFilter(std::string filterName);
  void               addFilterOutputFormat(CFilterOutputStageCreator&amp; creator);


  // Expose the guts for the really curious and those who need more
  // than we can offer.

  CTCLInterpreter*    getInterpreter();
  CHistogrammer*      GetHistogrammer();
  CTclAnalyzer*       GetAnalyzer();
  CEventSinkPipeline* GetEventSinkPipeline();
  CDisplayInterface *GetDisplayInterface();
  void SetDisplayInterface(CDisplayInterface&amp; rInterface);
  std::vector&lt;UInt_t&gt;      parameterIds(std::vector&lt;std::string&gt; names);


};

                </synopsis>
            </refsynopsisdiv>
            
            <refsect1>
                <title>DESCRIPTION</title>
                <para>
                    <classname>SpecTcl</classname> is a singleton class that
                    provides an application programming interface to the
                    functions SpecTcl considers public.  While every method in
                    this class is available in some way as a public method
                    in some other SpecTcl class, this set of interfaces is
                    gauranteed to remain avaiable through modifications to
                    SpecTcl's internal structures and algorithms.
                </para>
                <para>
                    As a singleton, the constructor and destructor of this
                    class are declared as <literal>private</literal>.  Use
                    the <methodname>getInstance</methodname> method to
                    obtain a pointer to the single instance of this class.
                </para>
            </refsect1>
            
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>static </modifier>
                                <type>SpecTcl* </type>
                                <methodname>getInstance</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns a pointer to the singleton instance
                                of this class.   This is the only supported
                                way to get an instance of this class.
                                Any two calls to <methodname>getInstance</methodname>
                                will return the same value.
                            </para>
                            <para>
                                There is no gaurantee that an instance of this
                                class will exist until the first call to this
                                method.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void </type>
                                <methodname>addBufferDecoder</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>type</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>CAttachCommand::CDecoderCreator* </type>
                                   <parameter>creator</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Adds a new buffer decoder to SpecTcl.
                                <parameter>type</parameter> is a format type
                                value that can be given to
                                <command>attach</command> <option>-format</option>.
                                <parameter>creator</parameter> is an instance
                                of a class that knows how to create a
                                buffer decoder that can unravel the data in
                                event files of the form specified by
                                <parameter>type</parameter>
                            </para>
                            <para>
                                The programming guide contains a chapter
                                that describes buffer decoders, what they are
                                for, how to write one and add it to the
                                SpecTcl <command>attach</command> command.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>UInt_t </type>
                                <methodname>AssignParameterId</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Each SpecTcl parameter must have a unique id.
                                This id is an integer index into the
                                flat parameter array that SpecTcl uses
                                to drive its gate checking and histogramming.
                                This method allocates a new, unique parameter
                                id.
                            </para>
                            <para>
                                This method should never return the same
                                integer twice. You can not gaurantee that
                                values from this method will be sequential
                                although they mostly will be.  Specifically,
                                <methodname>AssignParameterId</methodname>
                                will not assign a parameter Id that's already
                                been assigned. 
                            </para>
                            <para>
                                Imagine, for example, that this method just
                                returned <literal>1234</literal>.  Suppose
                                further a SpecTcl command or script line looked like:
                                <command>parameter somename 1235</command>.
                                The next call to <methodname>AssignParameterId</methodname>
                                will not return <literal>1235</literal> but an
                                integer that has not already been associated with
                                a parameter.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CParameter* </type>
                                <methodname>AddParameter</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>name</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>Id</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>Units</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Adds a new parameter definition to SpecTcl.
                                This method is the simplest way to add a parameter.
                                <parameter>name</parameter> is the name to be
                                givent to the new parameter.  It is an
                                error to assign the same name to two parameters.
                            </para>
                            <para>
                                <parameter>Id</parameter> is the new parameter's
                                id.  This usually should be a value  gotten
                                from a call to <methodname>AssignParameterId</methodname>.
                            </para>
                            <para>
                                <parameter>Units</parameter> are the units of
                                measure to assign to assign to the parameter.
                                This can be an empty string if the parameter
                                does not have an appropriate unit of measure
                                (e.g. a raw ADC value).
                            </para>
                            <para>
                                The method's return value is a pointer to the
                                new <classname>CParameter</classname>
                                object created and entered in the SpecTcl
                                parameter dictionary.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CParameter* </type>
                                <methodname>AddParameter</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>name</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>id</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>scale</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Adds a new parameter definition.  All of the
                                parameters are the same as the previous overload
                                for this method except that <parameter>scale</parameter>
                                is the number of bits used by the parameter.  This
                                is suitable for use with e.g. raw ADC values.
                            </para>
                            <para>
                                As with all <methodname>AddParameter</methodname>
                                overloads, the return value is a pointer
                                to the new <classname>CParameter</classname>
                                object that was created and entered in the
                                parameter dictionary.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CParameter* </type>
                                <methodname>AddParameter</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>name</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>id</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>scale</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>Float_t</type><parameter> low</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>Float_t </type><parameter>high</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>units</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Another overload that adds a new parameter
                                to SpecTcl.  <parameter>low</parameter> and
                                <parameter>high</parameter> define range
                                limits for the parameter.    These
                                define a mapping from raw parameter space to some
                                world coordinate space.  The value <literal>0</literal>
                                maps to <parameter>low</parameter> and the
                                value <literal>2**scale - 1</literal> maps
                                to <parameter>high</parameter>.
                            </para>
                            <para>
                                In general, it is better to use tree parameters
                                and compute the actual value of the parameter
                                than to use this confusing mapped parameter
                                scheme.  This scheme came into being for
                                SpecTcl-2.0 and is only retained for
                                compatibility with existing SpecTcl code.
                                It is normally used in conjunction with
                                <firstterm>Mapped spectra</firstterm>.
                            </para>
                            <para>
                                As with all overloads of
                                <methodname>AddParameter</methodname>, the
                                return value is a pointer to the
                                <classname>CParameter</classname> object
                                this call created.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CParameter* </type>
                                <methodname>RemoveParameter</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>name</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                If a parameter named <parameter>name</parameter>
                                has been defined it is removed from SpecTcl's
                                parameter dictionary and a pointer to a dynamically
                                allocated copy of that <classname>CParameter</classname>
                                object is returned.   The caller must
                                <literal>delete</literal> that object to
                                prevent memory leaks.
                            </para>
                            <para>
                                If there is no parameter named <parameter>name</parameter>
                                in the parameter dictionary, a null pointer is
                                returned from this method.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CParameter* </type>
                                <methodname>FindParameter</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>name</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Locates and returns a pointer to the parameter
                                object named <parameter>name</parameter>.  If there
                                is no matching parameter, a null pointer is returned.
                                Note that this is a pointer to the actual parameter
                                in the SpecTcl parameter dictionary and any
                                changes to it are reflected in the analysis
                                SpecTcl performs.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CParameter* </type>
                                <methodname>FindParameter</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t</type><parameter> Id</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns a pointer to a parameter given its
                                <parameter>Id</parameter>.  If no parameter
                                has that id, the method returns a null pointer.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                            <modifier></modifier>
                            <type>ParameterDictionaryIterator </type>
                            <methodname>BeginParameters</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>ParameterDictionaryIterator </type>
                                <methodname>EndParameters</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                These two methods support iteration of the
                                SpecTcl parameter dictionary.
                                <methodname>BeginParameters</methodname>
                                returns an iterator that acts like a pointer
                                to the first element of the parameter
                                dictionary. <type>ParameterDictionaryIterator</type>
                                objects support being incremented.  When incremented,
                                the "point" to the next dictionary element.
                                When the last element in the dict has been
                                pointed to, incrementing an iterator
                                gives it the value returned by
                                <methodname>EndParameters</methodname>.
                            </para>
                            <para>
                                The <type>ParameterDictionaryIterator</type>
                                is an STL <type>std::pair&lt;std::string, CParameter&gt;</type>
                                where the first element of the pair is the name of the
                                parameter and the second is a copy of the
                                <classname>CParameter</classname> with that
                                name.
                            </para>
                            <para>
                                Iteration is only good for read-only access to the
                                parameters as iterators 'point' to copies rather
                                than references or pointers to the actual
                                items in the dictionary.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>UInt_t </type>
                                <methodname>ParameterCount</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CSpectrum* </type>
                                <methodname>CreateSpectrum</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>Name</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>SpectrumType_t </type><parameter>type</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>DataType_t </type><parameter>dataType</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::vector&lt;std::string&gt; </type><parameter>parameters</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::vector&lt;UInt_t&gt; </type><parameter>channels</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::vector&lt;Float_t&gt;* </type><parameter>pLows</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::vector&lt;Float_t&gt;*</type><parameter> pHighs</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Creats a new histogram and returns a pointer to it.
                                The new spectrum has been dynamically created and
                                must, eventually, be destroyed with
                                <literal>delete</literal>.  
                            </para>
                            <para>
                                For SpecTcl's histogramming core and
                                command set to know about the new spectrum
                                it must be passed to
                                <methodname>AddSpectrum</methodname> (see below).
                                If this is not done, the caller has created
                                a spectrum that can be used by them but is
                                invisible to SpecTcl.
                            </para>
                            <para>
                                <parameter>Name</parameter> specifies a new name
                                to give to the spectrum.  If the spectrum will
                                be entered in the spectrum dictionary, this name
                                must not have been given to any other spectrum
                                in the spectrum dictionary.
                            </para>
                            <para>
                                <parameter>type</parameter> is the type  of
                                the spectrum.  This can be any value that
                                the enumerated type <type>SpectrumType_t</type>
                                can take and determines the type of the spectrum.
                                Note that we recommend that rather than using
                                this method to create a spectrum you use one of
                                the more specific creators documented below.
                            </para>
                            <para>
                                <parameter>type</parameter>, is the data type
                                for each channel of the spectrum.  This
                                can be one of <literal>keLong</literal> (recommended),
                                <literal>keWord</literal> or <literal>keByte</literal>,
                                and determines how many counts a spectrum channel
                                can have before the channel rolls over.
                            </para>
                            <para>
                                <parameter>parameters</parameter> is a vector
                                of the names of parameters that will be used
                                by the spectrum.  Note that some spectrum
                                types may need to specify x and y parameter lists,
                                see below.
                            </para>
                            <para>
                                <parameter>parameters</parameter> specifies the
                                parameters used by the spectrum.  The use of only
                                a single parameter list means this can only be used
                                to create spectra that don't need to differentiate
                                between X and Y parameters, such as 1D, gamma-1,
                                gamma-2, summary spectra etc.                                
                            </para>
                            <para>
                                <parameter>channels</parameter> is a vector
                                of one or two channel counts for the x and optional
                                y axis.
                            </para>
                            <para>
                                <parameter>pLows</parameter> and
                                <parameter>pHighs</parameter> are pointers to
                                vectors of the low and high limits for each
                                axis respectively.  There must be the same
                                number of <parameter>pHighs</parameter>
                                as <parameter>pLows</parameter>.
                            </para>
                            
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CSpectrum* </type>
                                <methodname>CreateSpectrum</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>Name</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>SpectrumType_t </type><parameter>type</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>DataType_t     </type><parameter>dataType</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::vector&lt;std::string&gt; </type><parameter>xParameters</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::vector&lt;std::string&gt; </type><parameter>yParameters</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::vector&lt;UInt_t&gt; </type><parameter>channels</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::vector&lt;Float_t&gt;* </type><parameter> pLows</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::vector&lt;Float_t&gt;*</type><parameter> pHighs</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Anothr method to create a generic spectrum.  The
                                difference between this and the previous overload
                                is that <parameter>xParameters</parameter> and
                                <parameter>yParameters</parameter> allow specification
                                of a set of parameters for the X and Y axes as are
                                needed for e.g. 2-d Spectra, 2-d Sum spectra or
                                Gamma Deluxe (particle-gamma) spectra.
                            </para>
                            <para>
                                Similarly, <parameter>pLows</parameter> and
                                <parameter>pHighs</parameter> provides a
                                set of limits for all axes.  The <parameter>channels</parameter>
                                vector can have channel counts for both axes.  These
                                are vectors to allow for future expansion in the
                                SpecTcl spectrum types
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CSpectrum* </type>
                                <methodname>CreateSpectrum</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string           </type><parameter>Name</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>SpectrumType_t        </type><parameter>type</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>DataType_t   </type><parameter>dataType</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::vector&lt;std::vector&lt;std::string&gt; &gt;</type><parameter> parameters</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::vector&lt;UInt_t&gt; </type><parameter>channels</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::vector&lt;Float_t&gt;* </type><parameter>lows</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::vector&lt;Float_t&gt;* </type><parameter>highs</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Provides a spectrum creator for when parameters
                                must come as a vector of vectors.  For example
                                for a gamma summary spectrumw where each X
                                channel of the spectrum may require more than
                                one parameter.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    The next several methods create specific types of spectra.
                    They are the recommended way to create spectra.  Usually
                    the generic methods above are a bit harder to use.
                </para>
                <variablelist>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>CreateGammaSummary</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string</type><parameter>Name</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier></modifier>
                                <type>DataType_t</type><parameter>dataType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;std::vector&lt;std::string&gt; &gt; </type><parameter>parameters</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter> nChannels</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;Float_t&gt;* </type><parameter>low</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;Float_t&gt;*  </type><parameter>high</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a gamma summary spectrum.  A gamma summary
                            spectrum, is a two dimensional spectrum whose
                            vertical channel strips are each a gamma spectrum.
                            <parameter>parameters</parameter> are a vector of
                            parameters for each X channel (vertical strip).
                            The outer vector index is a channel number and
                            the inner vector the set of parameters on that
                            strip.
                        </para>
                        <para>
                            The <parameter>nChannels</parameter> parameter is
                            the number of parameters in the Y direction
                            as the number of X channels is determined by the
                            size of the outer vector of
                            <parameter>parameters</parameter>.  The
                            <parameter>low</parameter> and
                            <parameter>high</parameter> vectors are the low and
                            high limits of each vertical strip in the parameter
                            space of the parameters that are histogrammed
                            on it.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>CreateG2DDeluxe</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>Name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>DataType_t </type><parameter>dataType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;std::string&gt; </type><parameter>xParameters</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;std::string&gt; </type><parameter>yParameters</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;UInt_t&gt;</type><parameter>channels,</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;Float_t&gt;* </type><parameter>pLows</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;Float_t&gt;* </type><parameter>pHighs</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a gamma deluxe spectrum.  This is a spectrum
                            multiply incremented spectrum with separate x and
                            y parameters sets.  The spectrum is incremented
                            for each pair of parameters present in the spectrum.
                            <parameter>channels</parameter> is a two element
                            vector containing, in order, the number
                            of channels on the X and Y axis.
                        </para>
                        <para>
                            <parameter>pLows</parameter> and
                            <parameter>pHighs</parameter> are both two
                            element vectors that specify, in order, the low
                            and high parameter space limits of the X and Y axis.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>Create1D</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>DataType_t </type><parameter>dataType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>CParameter&amp; </type><parameter>parameter</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>channels</parameter>
                            </methodparam>
                      
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a 1-d spectrum.  <parameter>parameter</parameter>
                            is the parmeter histogrammed and the
                            X axis will have <parameter>channels</parameter>
                            channels.  In this overload, the range of
                            the parameter histogrammed will be
                            <literal>[0, <parameter>channels)</parameter></literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>Create1D</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>DataType_t </type><parameter>dataType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>CParameter&amp; </type><parameter>parameter</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>channels</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>lowLimit</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>hiLimit</parameter>
                            </methodparam>
                            
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a 1-D spectrum where <parameter>lowLimit</parameter>
                            <parameter>hiLimit</parameter> and <parameter>channels</parameter>
                            define a transformation between parameter and spectrum
                            channel space.
                            This transformation is:
                            <literal>channel = ((parameter- lowLimit)*channels(hiLimit-lowLimit))</literal>.
                            This provides a uniform mapping of the interval
                            <literal>[lowLimit, hiLimit)</literal> to 
                            <literal>[0, channels)</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>Create2D</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>DataType_t </type><parameter>dataType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>CParameter&amp; </type><parameter>xParameter</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>CParameter&amp; </type><parameter>yParmaeter</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>xChannels</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>yChannels</parameter>
                            </methodparam>
                       
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a 2-d spectrum with 1:1 parameter:channel
                            space mapping.  <parameter>xParameter</parameter>
                            is on the X axis and <parameter>yParameter</parameter>
                            on the Y.  There are <parameter>xChannels</parameter>
                            on the X axis that map to the <parameter>xParameter</parameter>
                            value range <literal>[0, xChannels)</literal>.
                            There are <parameter>yChannels</parameter> on the
                            Y axis that map the <parameter>yParameter</parameter>
                            value range <literal>[0, yChannels)</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>Create2D</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>DataType_t </type><parameter>dataType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>CParameter&amp; </type><parameter>xParameter</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>CParameter&amp; </type><parameter>yParameter</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>xChannels</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>xLow</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>xHigh</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>yChannels</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>yLow</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>yHigh</parameter>
                            </methodparam>
                       
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a 2-d spectrum with parameter to channel
                            mappings that are not identities.
                            <parameter>xChannels</parameter>,
                            <parameter>xLow</parameter> and
                            <parameter>xHigh</parameter> determine the
                            mapping of the X parameter to channels on the
                            X axis.
                            <parameter>yChannels</parameter>,
                            <parameter>yLow</parameter> and
                            <parameter>yHigh</parameter> determine the
                            mapping of the Y parameter to channels on the
                            Y axis.
                        </para>
                        <para>
                            The mapping is linear for both parameters.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>CreateG1D</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>DataType_t </type><parameter>dataType</parameter>
                            </methodparam>
                           <methodparam>
                                <modifier></modifier>
                                <type>std::vector&lt;CParameter&gt; </type><parameter>parameters</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>channels</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a gamma-1d spectrum.  The spectrum
                            increments for all <parameter>parameters</parameter>
                            present in the event.  This method creates a
                            spectrum with a unit mapping between parameter
                            and X axis channel space.  Thus values from
                            <literal>[0, <parameter>channels</parameter>)</literal>
                            are histogrammed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>CreateG1D</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>DataType_t </type><parameter>dataType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;CParameter&gt; </type><parameter>parameters</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>channels</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>lowLimit</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>hiLimit</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a gamma-1D spectrum with potentially non
                            unit mappings between the parameter coorinates
                            and spectrum channels.
                            <parameter>lowLimit</parameter>, <parameter>hiLimit</parameter>
                            and <parameter>channels</parameter> define a uniform
                            mapping between parameter coordinates in the
                            range <literal>[lowLimit, hiLimit)</literal>
                            and the channel coordinates
                            <literal>[0, channels)</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>CreateG2D</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>DataType_t </type><parameter>dataType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;CParameter&gt; </type><parameter>parameters</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>xChannels</parameter>
                            </methodparam>
                             <methodparam>
                                <modifier></modifier>
                                <type>UInt_t </type><parameter>yChannels</parameter>
                             </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a 2-d gamma spectrum with unit mapping
                            between the parameters for both the X and Y
                            axis.
                            <parameter>xChannels</parameter> is the n umber
                            of axes on the X axis and
                            <parameter>yChannels</parameter> the number of
                            channels
                            on the Y axis. 
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>CreateG2D</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>DataType_t </type><parameter>dataType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;CParameter&gt; </type><parameter>parameters</parameter>
                            </methodparam>
                            <methodparam>
                          <modifier></modifier>
                          <type>UInt_t </type><parameter>xChannels</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Float_t </type><parameter>xLow</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Float_t </type><parameter>xHigh</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type><parameter>yChannels</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Float_t</type><parameter> yLow</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type> Float_t </type><parameter>yHigh</parameter>
                        </methodparam>
                       
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a gamma 2d spectrum with potentially non
                            unit mappings between parameter and spectrum
                            axis space.  The mapping on the X axis is
                            determined by
                            <parameter>xChannels</parameter>,
                            <parameter>xLow</parameter> and
                            <parameter>xHigh</parameter> such that the
                            parameter space
                            <literal>[xLow, xHigh)</literal> is mapped linearly
                            to <literal>[0, xChannels)</literal>.
                            The mapping on the Y axis is similarly determined by
                            <parameter>yChannels</parameter>,
                            <parameter>yLow</parameter> and
                            <parameter>yHigh</parameter>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>CreateBit</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>DataType_t </type><parameter>dataType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>CParameter&amp; </type><parameter>parameter</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>channels</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a bit map spectrum.  Bit map spectra are
                            incremented once for every bit set in the
                            <parameter>parameter</parameter>.   There
                            are <parameter>channels</parameter> channels in the
                            spectrum, one for each bit that you want monitored.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>CreateBit</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>DataType_t </type><parameter>dataType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>CParameter&amp; </type><parameter>parameter</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>channels</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>lowBit</parameter>
                            </methodparam>
                        
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a bit map spectrum that covers
                            <parameter>channels</parameter> bits of the
                            parameters beginning with the low bit
                            designated by <parameter>lowBit</parameter>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>CreateSummary</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>DataType_t </type><parameter>dataType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;CParameter&gt; </type><parameter>parameters</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>channels</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a summary spectrum. A summary spectrum is
                            a 2-d spectrum whose vertical strips (defined by
                            a single x channel) are 1-d spectra.  Summary
                            spectra make monitoring a set of similar detectors
                            easy.  <parameter>parameters</parameter> are
                            the set of parameters to histogram and define the
                            number of x channels (one for each parameter).
                            <parameter>channels</parameter> defines the
                            number of y channels.  This method defines
                            a unit mapping between parameter values and
                            Y channels.
                        </para>
                        
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>CreateSummary</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam> 
                            <methodparam>
                               <modifier></modifier>
                               <type>DataType_t </type><parameter>dataType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;CParameter&gt; </type><parameter>parameters</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>nChannels</parameter>
                            </methodparam>
                             <methodparam>
                                <modifier></modifier>
                                <type>Float_t </type><parameter>low</parameter>
                             </methodparam>
                             <methodparam>
                                <modifier></modifier>
                                <type>Float_t </type><parameter>high</parameter>
                             </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a summary spectrum on the <parameter>parameters</parameter>.
                            This spectrum will have a mapping from parameter to
                            spectrum y channel coordinates that is a linear map
                            from parameter coordinates in the range
                            <literal>[<parameter>low</parameter>, <parameter>high</parameter>)</literal>
                            to channel coordinates
                            <literal>[0, <parameter>nChannels</parameter>)</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>CreateGamma2DD</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>DataType_t </type><parameter>dataType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;CParameter&gt; </type><parameter>xParameters</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;CParameter&gt; </type><parameter>yParameters</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>xChannels</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>xLow</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>xHigh</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>yChannels</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>yLow</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>yHigh</parameter>
                            </methodparam>  
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a gamma 2d deluxe spectrum.  This type of
                            spectrum increments for all combinations of pairs of
                            <parameter>xParameters</parameter> and
                            <parameter>yParameters</parameter> that are
                            defined in the event.
                            The mapping between parameter and channel coordinates
                            is lineary but not necessarily unity.
                        </para>
                        <para>
                            <parameter>xChannels</parameter>,
                            <parameter>xLow</parameter>, and
                            <parameter>xHigh</parameter> define a linear
                            mapping between parameter
                            X parameter values in the range
                            <literal>[<parameter>xLow</parameter>, <parameter>xHigh)</parameter></literal>
                            and <literal>[0, <parameter>xChannels</parameter>)</literal>
                            on the X axis.
                            On the Y axis a similar mapping is defined by:
                            <parameter>yChannels</parameter>,
                            <parameter>yLow</parameter>, and
                            <parameter>yHigh</parameter>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>Create2DSum</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>DataType_t  </type><parameter>dataType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;CParameter&gt; </type><parameter>xParameters</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;CParameter&gt; </type><parameter>yParameters</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>xChans</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>xLow</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>xHigh</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>yChans</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>yLow</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t</type><parameter> yHigh</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a 2-d sum spectrum.  This spectrum is
                            essentially the spectrum that would result from
                            summing 2-d spectra on
                            <parameter>xParameters[0]</parameter>,
                            <parameter>yParameters[0]</parameter>, ...
                            The mapping from parameter to channel space
                            in both X and Y is
                            defined in the usual way using the low, high and
                            channel count parameters.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodsynopsis>
                        <modifier></modifier>
                        <type>CSpectrum* </type>
                        <methodname>CreateStripChart</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string </type><parameter>name</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>DataType_t  </type><parameter>dataType</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>CParameter</type><parameter>counts</parameter>
                        </methodparam>      
                        <methodparam>
                           <modifier></modifier>
                           <type>CParameter</type><parameter>time</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type><parameter>channels</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Float_t </type><parameter>xLow</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Float_t </type><parameter>xHigh</parameter>
                        </methodparam>
                               
                        <modifier></modifier>
                    </methodsynopsis></term>
                    <listitem>
                        <para>
                            Creates a strip chart spectrum.  Strip chart spectra
                            plot the <parameter>time</parameter> parameter value
                            against the accumulated <parameter>counts</parameter>
                            parameter.  <parameter>xLow</parameter> and
                            <parameter>xHigh</parameter> are an initial range
                            the X axis covers in the <parameter>time</parameter>
                            parameter.  
                        </para>
                        <para>
                            If the <parameter>time</parameter>
                            parameter value is outside the range of the
                            current X axis limits, the X axis will be shifted
                            to cover that new value.    The range covered will
                            be the same as before, however.
                            This shift provides the strip chart functionality
                            that gives this spectrum its name.  Note that
                            currently, there's no command or user interface
                            method to shift the spectrum back to its original
                            range, however the axis can shift backwards
                            if the time value is before the
                            current left limit of the spectrum, which effectively
                            provides this functionality automatically.
                        </para>
                        <para>
                            Note that data shifted off the edge of the spectrum
                            is  lost. Note as well that data are cumulative, thus
                            if the binning is such that two time values fall
                            in the same channel, the resulting channel value
                            will be the sum of the two <parameter>counts</parameter>
                            parameters for those two events (summed with any prior
                            value that channel might have).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>AddSpectrum</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>CSpectrum&amp; </type><parameter>spectrum</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Adds a spectrum to SpecTcl's spectrum dictionary.
                            There cannot be a spectrum with this name
                            in the dictionary else an exception will be thrown.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>RemoveSpectrum</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string</type><parameter> name</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Remove the spectrum named <parameter>name</parameter>
                            from the SpecTcl spectrum dictionary.  The spectrum
                            no longer exists from SpecTcl's point of view.
                            If the spectrum was produced by one of the methods
                            above, you need to <literal>delete</literal> to free
                            it to avoid memory leaks.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>FindSpectrum</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CSpectrum* </type>
                            <methodname>FindSpectrum</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t</type><parameter> id</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Attemts to locate the spectrum named <parameter>name</parameter>,
                            or has the id <parameter>id</parameter>,
                            in SpecTcl's spectrum dictionary.   A pointer to the
                            spectrum object is returned if found or a null
                            pointer is returned if there no spectrum
                            matching the name.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>SpectrumDictionaryIterator </type>
                            <methodname>SpectrumBegin</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>SpectrumDictionaryIterator </type>
                            <methodname>SpectrumEnd</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            These methods support iteration through the
                            SpecTcl spectrum dictionary.
                            <classname>SpectrumDictionaryIterator</classname>
                            objects are pointer like objecs.  They
                            'point' to a
                            <classname>std::pair&lt;td::string, CSpectrum*&gt;</classname>.
                        </para>
                        <para>
                            The first item of each pair is the name of the spectrum.
                            The second itesm is a pointer to the
                            spectrum with that name.
                        </para>
                        <para>
                            <classname>SpectrumDictionaryIterator</classname>
                            objects can be incremented (<methodname>operator++</methodname>).
                            Incrementing an iterator 'points' it to the next
                            object in the container.
                        </para>
                        <para>
                            <function>SpectrumBegin</function> points  to the first
                            object in the dictionary.  Iterating through the dictionary
                            has finishe when incrementing produces the value
                            returned by
                            <methodname>SpectrumEnd</methodname>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>UInt_t </type>
                            <methodname>SpectrumCount</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the numbr of entries in the SpecTcl
                            spectrum dictionary.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>addSpectrumDictionaryObserver</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>SpectrumDictionaryObserver* </type><parameter>observer</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Adds a new observer to the spectrum dictionary.
                            See e.g. <ulink url='https://en.wikipedia.org/wiki/Observer_pattern' />
                            for information about the observer pattern and observers.
                        </para>
                        <para>
                            Spectrum dictionary observers derived from the
                            <classname>CDictionaryObserver</classname> templated
                            class (defined in <filename>Dictionary.h</filename>).
                            They have a <methodname>onAdd</methodname>, called
                            when a new entry is added to the dictionary, and
                            a method called <methodname>onRemove</methodname>
                            called when an entry is removed from the
                            dictionary.
                        </para>
                        <para>
                            Both obserer entries are passed two parameters.
                            The first is an <classname>std::string</classname>
                            that holds the name of the spectrum being
                            added or removed/  The secod i a a
                            <classname>CSpectrum</classname> reference which is
                            a reference to the spectrum being added or removed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>removeSpectrumDictionaryObserver</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>SpectrumDictionaryObserver* </type><parameter>observer</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Removes a spectrum dictinoary observer from the list
                            of observer methods.  The <methodname>observer</methodname>
                            object is no longer called.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>ClearSpectrum</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Clears the spectrum named <parameter>name</parameter>.
                            If there is no spectrum named <parameter>name</parameter>,
                            an exception (<classname>CDictionaryException</classname>).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void</type>
                            <methodname>ClearAllSpectra</methodname>
                            
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Iterates through the spectrum dictionary
                            zeroing the spectra.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                The next set of methods manipulate gates and the gate dictionary.
                Note that as with Spectra, the act of creating a gate is
                separate from the act of making it known to SpecTcl's
                commands and histogramming core by entering it into a gate
                dictionary.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateGate</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>CGateFactory::GateType </type><parameter>gateType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;std::string&gt; </type><parameter>names</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a new compound gate whose dependent
                            gates are <parameter>names</parameter>.   Legal gate
                            types for this method are
                            <literal>And</literal>, <literal>bandcontour</literal>,
                            <literal>Not</literal>, <literal>Or</literal>,
                            <literal>trueg</literal>, <literal>falseg</literal>
                            or <literal>deleted</literal>.
                        </para>
                        <para>
                            Note that for
                            <literal>trueg</literal>, <literal>falseg</literal>
                            or <literal>deleted</literal>,
                            the <parameter>names</parameter> vector must be empty.
                        </para>
                        <para>
                            Note that the gate has no name.  It is given its name
                            when <methodname>AddGate</methodname>.
                        </para>
                        <para>
                            The method returns a pointer to the new,
                            dynamically create gate object.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateGate</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>CGateFactory::GateType </type><parameter>gateType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;std::string&gt; </type><parameter>parameters</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;FPoint&gt; </type><parameter>points</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateGate</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>CGateFactory::GateType</type><parameter>gateType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;FPoint&gt; </type><parameter>points</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type> std::vector&lt;UInt_t&gt;</type><parameter> parameters</parameter>
                            </methodparam>
                            <modifier></modifier>
                            
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a primitive gate.  <parameter>parameters</parameter>
                            are the names of the parameters the gate is defined on.
                            <parameter>points</parameter> are x/y points that define
                            the gate.  <parameter>gateType</parameter> can be any
                            gate that requires a set of points.
                        </para>
                        <para>
                            The second form of this method provides the
                            <parameter>parameters</parameter> vector as a vector
                            of parameter ids rather than names.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateGate</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>CGateFactory::GateType </type><parameter>gateType</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;std::string&gt; </type><parameter>rparameters</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>long</type><parameter> comparison</parameter>
                            </methodparam>
                    
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a bit mask gate of the type
                            specified by <parameter>gateType</parameter>.
                            <parameter>rparameters</parameter> specifies the
                            parameters required for the gate.
                            <parameter>comparison</parameter> is the type
                            of comparison to perform.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateTrueGate</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a true gate. A true gate is true for
                            every event regardless of the set of parameters
                            defined by that event or their values.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateFalseGate</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a false gate.  False gates are false
                            for all events regardless of the parameters
                            defined by an event and its values.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* CreateBand</type>
                            <methodname></methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>xparameter</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>yparameter</parameter>
                            </methodparam>
                             <methodparam>
                                <modifier></modifier>
                                <type>std::vector&lt;FPoint&gt; </type><parameter>points</parameter>
                             </methodparam>
                    
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines a band gate.  A band gate is defined on
                            a pair of parameters.  <parameter>xparameter</parameter>
                            defines the x coordinate of a point in two dimensional
                            space while <parameter>yparameter</parameter> defines
                            the y coordinate.  Both parameters must be present and
                            the point defined by them must be below the polyline
                            defined by the array of <parameter>points</parameter>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateContour</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>xparameter</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>yparameter</parameter>
                            </methodparam>
                             <methodparam>
                                <modifier></modifier>
                                <type>std::vector&lt;FPoint&gt; </type><parameter>points</parameter>
                             </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines a contour gate.  The parameters have the
                            same meaning as for <parameter>CreateBand</parameter>,
                            however the gate is true for events only if both
                            <parameter>xparameter</parameter> and
                            <parameter>yparameter</parameter> are present and
                            the resulting point falls inside the closed shape
                            defined by <parameter>pointts</parameter>
                        </para>
                        <para>
                            For pathalogical closed shapes, note that
                            inside-ness is defined by the
                            <firstterm>odd crossing rule</firstterm>.
                            This means that if you draw a  ray from the point
                            defined by the event in any direction, the point is
                            inside if an odd number of edges of the shape are
                            crossed and outside if an even number are crossed.
                            This provides a consistent definition of inside-ness
                            reagardless of how pathalogically shaped the
                            contour is.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateBandContour</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>firstBand</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>secondBand</parameter>
                            </methodparam>
                             
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a contour by joining together the endpoints
                            of the two band <parameter>firstBand</parameter>
                            and <parameter>secondBand</parameter>.  An exception
                            is thrown if these two gates are not bands.
                            The resulting gate is really a contour and not
                            a compound gate.
                        </para>
                        <para>
                            This gate is useful for detectors that produce a
                            particle id spectrum that looks like a set of
                            hyperbolae.  One can draw bands between each of the
                            particle groups an then form particle ID groups
                            by creating contours from adjacent gates.
                        </para>
                        <para>
                            The intent is that if <parameter>firstBand</parameter>
                            is upper and <parameter>secondBand</parameter> lower,
                            the resulting gate is essentially
                            <literal>firstBand and not secondBand</literal>, however
                            the joining of the end points together may slightly
                            violate that expression near the gate edges.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateNotGate</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a not gate using <parameter>name</parameter>
                            as the dependent gate.  The resulting gate is true
                            only for events for which the gate <parameter>name</parameter>
                            is false.  For all other events it is false.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateAndGate</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>gateNames</type><parameter>gateNames</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates an And gate using <parameter>gateNames</parameter>
                            as the gate's dependent gates.  This gate is only true
                            if <emphasis>all</emphasis> of the gates in
                            <parameter>gateNames</parameter> are true.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateOrGate</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;std::string&gt; </type><parameter>gateNames</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates an or gate whose dependent gates are
                            <parameter>gateNames</parameter>.  This gate
                            is only true for events in which
                            <emphasis>at least</emphasis> of the
                            gates in <parameter>gateNames</parameter> is also
                            true.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>  CGate* </type>
                            <methodname>CreateCut</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>parameter</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t</type><parameter> low</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>high</parameter>
                            </methodparam>  
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a gate that is a cut on 
                            <parameter>parameter</parameter>.   The cut is
                            defined by the x coorinates of
                            <parameter>low</parameter> and
                            <parameter>high</parameter>.  The gate is true
                            only if it defines <parameter>parameter</parameter>
                            and the value is between <parameter>low</parameter>
                            and <parameter>high</parameter>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateGammaCut</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>low</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>Float_t </type><parameter>high</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;std::string&gt; </type><parameter>parameters</parameter>
                            </methodparam>
                              
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a gamma cut.  The cut is defined by
                            <parameter>low</parameter> and
                            <parameter>high</parameter>.   The parameters
                            involved in the gate are
                            <parameter>parameters</parameter>.
                        </para>
                        <para>
                            The gamma cut is intended to be applied to a gamma
                            spectrum as a fold.  Folds are a mechanism to untangle
                            sequential decay cascades.  If this gate is applied
                            as a fold to a gamma spectrum, the spectrum is incremented
                            if at least one parameter satisfies the gate and
                            is incremented for all parameters that are not
                            in the gate.  The resulting histogram's peaks
                            are those gamma rays that are emitted in coincidence
                            with the gamma ray energy in the peak the gate is
                            set on.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateGammaBand</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;FPoint&gt; </type><parameter>points</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;std::string&gt; </type><parameter>parameters</parameter>
                            </methodparam>
                         
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a gamma band.  This is also intended to be
                            used as a fold in which case the spectrum
                            is incremented only for pairs of parameters
                            that do not satisfy the gate.   Gamma bands
                            are probably not as useful as gamma contours since
                            2-d Gamma spectra tend to make lumps out of
                            pairs of gamma rays that are emitted in coincidence.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateGammaContour</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;FPoint&gt; </type><parameter>points</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;std::string&gt; </type><parameter>parameters</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a gamma contour from the
                            <parameter>points</parameter> defined on the
                            <parameter>parameters</parameter> parameters.
                            This is intended to be used as a fold.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateMaskEqualGate</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;std::string&gt; </type><parameter>rParameterName</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>long </type><parameter>Compare</parameter>
                            </methodparam>
                             
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a mask-equality gate.  The gate will
                            be true for events that define
                            <parameter>rParameterName</parameter> and for which
                            the value of that parameter will be equal to
                            <parameter>Compare</parameter>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateMaskAndGate</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;std::string&gt; </type><parameter>rParameterName</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>long </type><parameter>Compare</parameter>
                            </methodparam>
                             
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a mask and gate.  The gate will be true
                            for events that define <parameter>rParameterName</parameter>
                            and for which the value of that parameter, when bitwise anded
                            with <parameter>Compare</parameter> is the same as
                            <parameter>Compare</parameter>.  That is, the parameter
                            has (among others) all bits set that <parameter>Compare</parameter>
                            has set.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGate* </type>
                            <methodname>CreateMaskNotGate</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::vector&lt;std::string&gt; </type><parameter>rParameterName</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>long </type><parameter>Compare</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a Mask not gate.  This gate is defined
                            for all events that define
                            <parameter>rParameterName</parameter> but for
                            which the value of that parameter has all bits
                            set which are not set in <parameter>Compare</parameter>.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                The next set of methods manipulate the gate dictionary.
                Note that the gate creation methods above create the gate but
                don't enter it into the gate dictionary.  To  make the gate
                known to SpecTcl, you must do this by invoking
                <methodname>AddGate</methodname> below.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>AddGate</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>CGate* </type><parameter>gate</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Associates the gate name <parameter>name</parameter>
                            with the gate <parameter>gate</parameter> and tries
                            to add it to the gate dictionary.  If a gate
                            by this name already exists; the method throws
                            a <classname>CDictionaryException</classname>
                            exception.
                        </para>
                        <para>
                            Note that once a gate is known to exist, its
                            definition can be modified by
                            <methodname>ReplaceGate</methodname> below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void DeleteGate</type>
                            <methodname></methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>gateName</parameter>
                            </methodparam>
                            
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Deletes the gate named <parameter>gateName</parameter>
                            from the gate dictionary.    Note that in order
                            for objects that depend on the gate to behave
                            in a well determined manner, the gate is not
                            actually deleted, but replaced with a
                            false gate.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>ReplaceGate</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>gateName</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>CGate&amp; </type><parameter>newGate</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Replaces the gate <parameter>gateName</parameter> with
                            a new gate definition <parameter>newGate</parameter>.
                            The use of <classname>CGateContainer</classname> objects
                            allows this replacement to happen transparently with
                            respect to dependent gates, spectra to which the
                            gate is applied and spectra folded on the gate.
                        </para>
                        <para>
                            If <parameter>gateName</parameter> does not
                            exist a <classname>CDictionaryException</classname>
                            is thrown.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGateContainer*</type>
                            <methodname> FindGate</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>gateName</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Finds the gate <parameter>gateName</parameter>
                            in the gate dictionary.  If found, a pointer
                            to its gate container is returned.   If not found,
                            a null pointer is returned.
                        </para>
                        <para>
                            A <classname>CGateContainer</classname> is a pointer
                            like object that acts like a pointer to an underlying
                            gate.  Gate containers are an additional level of
                            indirection that allow spectra and other gates that
                            depend on a gate to be blissfully unaware of when
                            their gate definitions change.
                        </para>
                        <para>
                            You can think of the gate container as encapsulating
                            the real gate.  What methods like
                            <methodname>DeleteGate</methodname> and
                            <methodname>ReplaceGate</methodname> do is replace
                            the gate that is encapsulated by the gate container.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CGateDictionaryIterator </type>
                            <methodname>GateBegin</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>GateDictionaryIterator</type>
                            <methodname>GateEnd</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Supports iteration in the gate dictionary. The
                            <classname>CGateDictionaryIterator</classname>
                            is a pointer like object that points to an
                            <classname>std::pair&lt;std::string, CGateContainer&gt;</classname>
                            object.
                        </para>
                        <para>
                            The first element of the pair is the name of the gate
                            while the second element is the gate container for
                            the gate.  Iteration is accomplished by getting
                            an iterator to the first dictionary element
                            via a call to <methodname>GateBegin</methodname>.
                            Successive elements of the dictionary are visited
                            by incrementing the iterator.  When the last
                            element is visited, incrementing the iterator
                            returns the value returned by
                            <methodname>GateEnd</methodname>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>UInt_t </type>
                            <methodname>GateCount</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns a count of the number of elements in the
                            gate dictionary.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>addGateDictionaryObserver</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>CGateObserver* </type><parameter>observer</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void removeGateDictionaryObserver</type>
                            <methodname></methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>CGateObserver* </type><parameter>observer</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            These two methods provide an observer interface
                            to the Gate dictionary.
                            See e.g. <ulink url='https://en.wikipedia.org/wiki/Observer_pattern' />
                            for information about the observer pattern and observers.
                        </para>
                        <para>
                            <methodname>addGateDictionaryObserver</methodname>
                            adds the specfied <parameter>observer</parameter>
                            to the list of gate observers called by the
                            gate dictionary while
                            <methodname>removeGateDictionaryObserver</methodname>
                            removes <parameter>observer</parameter> from that list.
                        </para>
                        <para>
                            A <classname>CGateObserver</classname> object has
                            the following methods:
                        </para>
                        <variablelist>
                            <varlistentry>
                                <term>
                                    <methodsynopsis>
                                        <modifier>virtual </modifier>
                                        <type>void </type>
                                        <methodname>onAdd</methodname>
                                        <methodparam>
                                           <modifier></modifier>
                                           <type>std::string </type><parameter>name</parameter>
                                        </methodparam>
                                        <methodparam>
                                           <modifier></modifier>
                                           <type>CGateContainer&amp; </type><parameter>item</parameter>
                                        </methodparam>
                                          
                                        <modifier></modifier>
                                    </methodsynopsis>
                                </term>
                                <listitem>
                                    <para>
                                        Called when an entry is added to the dictionary.
                                        <parameter>name</parameter> is the name
                                        of the new gate and
                                        <parameter>item</parameter>
                                        is the gate container for the new item
                                        being added.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>
                                    <methodsynopsis>
                                        <modifier>virtual </modifier>
                                        <type>void </type>
                                        <methodname>onRemove</methodname>
                                        <methodparam>
                                           <modifier></modifier>
                                           <type>std::string </type><parameter>name</parameter>
                                        </methodparam>
                                        <methodparam>
                                           <modifier></modifier>
                                           <type>CGateContainer&amp; </type><parameter>item</parameter>
                                        </methodparam>
                                        <modifier></modifier>
                                    </methodsynopsis>
                                </term>
                                <listitem>
                                    <para>
                                        Called if an entry is removed from the
                                        dictionary.  In normal use this is never
                                        invoked as gates are never deleted,
                                        only modified.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>
                                    <methodsynopsis>
                                        <modifier>virtual</modifier>
                                        <type> void</type>
                                        <methodname> onChange</methodname>
                                        <methodparam>
                                           <modifier></modifier>
                                           <type>std::string</type><parameter> name</parameter>
                                        </methodparam>
                                        <methodparam>
                                           <modifier></modifier>
                                           <type>CGateContainer&amp; </type><parameter>gateContainer</parameter>
                                        </methodparam>
                                        <modifier></modifier>
                                    </methodsynopsis>
                                </term>
                                <listitem>
                                    <para>
                                        Called when a gate has been changed.
                                        <parameter>gateContainer</parameter>
                                        is the new gate container.
                                    </para>
                                </listitem>
                            </varlistentry> 
                        </variablelist>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>ApplyGate</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>gateName</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>spectrumName</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                The next set of methods are responsible for managing the event
                processor pipeline.  The event processing pipeline is a sequence
                of objects that are responsible for taking a raw event
                and transforming it into a set of parameteres that can be
                analyzed by the event sink pipeline.  Each stage of the pipeline
                has access to the raw event as well as the set of parameters
                previous stages have unpacked.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void AddEventProcessor</type>
                            <methodname></methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>CEventProcessor&amp; </type><parameter>eventProcessor</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier>const </modifier>
                               <type>char* </type><parameter>name</parameter>
                               <initializer> 0</initializer>
                            </methodparam>
                         
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Adds an event processor
                            <parameter>eventProcessor</parameter>to the end of the
                            event processing pipeline.  If <parameter>name</parameter>
                            is not a null pointer, it is used as the name of
                            the event processor.  If it is null (not recommended but
                            supported for backwards compatibility), a unique
                            event processor name will be assigned.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CTclAnalyzer::EventProcessorIterator </type>
                            <methodname>FindEventProcessor</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string</type><parameter> name</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Given the <parameter>name</parameter> of an event
                            processor, returns an iterator to it.  If the
                            <parameter>name</parameter> is not found,
                            the value that is normally returned
                            from <methodname>ProcessingPipelineEnd</methodname>
                            is returned (see below).
                        </para>
                        <para>
                            A <classname>CTclAnalyzer::EventprocessorIterator</classname>
                            is a pointer like object.  We'll say more about it
                            when we look at support for iteration.  At this
                            point in time it suffices to know that it can be
                            treated as if it were a pointer to
                            a <classname>std::pair&lt;std::atring, CEventProcessor*&gt;</classname>
                            where the first element of the pair is the name of the event
                            processor pointed to by the second element
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CTclAnalyzer::EventProcessorIterator </type>
                            <methodname>FindEventProcessor</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>CEventProcessor&amp; </type><parameter>processor</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Finds an event processor in the event processing
                            pipeline given a reference to the event
                            processor object itself.  
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>InsertEventProcessor(</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>CEventProcessor&amp; </type><parameter>processor</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>CTclAnalyzer::EventProcessorIterator </type><parameter>where</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier>const </modifier>
                               <type>char*  </type><parameter>name </parameter>
                               <initializer>0</initializer>
                            </methodparam>
                            
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Inserts an event processor
                            (<parameter>processor</parameter>) in the event
                            processing pipeline at the position prior to that
                            indicated by <parameter>where</parameter>.  The
                            event processor will be called <parameter>name</parameter>
                            unless that parameter is a null pointer in which
                            case a unique name will be assigned to it.
                        </para>
                        <para>
                            Note that <parameter>where</parameter> is
                            a <classname>CTclAnalyzer::EventProcessorIterator</classname>,
                            an iterator in the STL sense of the term.  For more
                            information about it, see
                            <methodname>ProcessingPipelineBegin</methodname>
                            and <methodname>ProcessingPipelineEnd</methodname>
                            below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>RemoveEventProcessor</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Removes the event processor named <parameter>name</parameter>.
                            IF there's no event processor named
                            <parameter>name</parameter>, this is a silent
                            no-op.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>RemoveEventProcessor</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>CTclAnalyzer::EventProcessorIterator </type><parameter>here</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Removes the event processor 'pointed to'
                            by <parameter>here</parameter>.  The iterator
                            could have been returned from a call to
                            <methodname>FindEventProcessor</methodname> or
                            have been the result of iteration (see below).
                        </para>
                        <para>
                            This operation invalidates the iterator.
                            The results of dereferencing
                            it in the future are undefined.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>UInt_t </type>
                            <methodname>ProcessingPipelineSize</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the number of elements in the event
                            processing pipeline.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CTclAnalyzer::EventProcessorIterator </type>
                            <methodname>ProcessingPipelineBegin</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CTclAnalyzer::EventProcessorIterator </type>
                            <methodname>ProcessingPipelineEnd</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Supports the iteration protocol.
                            <methodname>ProcessingPipelineBegin</methodname>
                            returns an iterator that 'points' to the
                            first element of the event processing pipeline.
                            The
                            <methodname>FindEventProcessor</methodname>
                            documentation describes exactly what this
                            'points' to.
                        </para>
                        <para>
                            Iterators can be incremented in which case they
                            point to the next element of the pipeline (in
                            processing order).  Once the last element of the
                            pipeline has been reached by the iterator,
                            an additional increment returns a value
                            identical to the value that is returned by
                            <methodname>ProcessingPipelineEnd</methodname>.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                The next set of methods manipulate the event sink pipeline.
                The event sink pipeline gains control after the the event
                processing pipeline has processed one or more events.
                it the event sink pipeline initially comes stocked with the
                histogrammer (<classname>CHistogrammer</classname>).
                Filters are also added at the end of the event processing
                pipeline.
            </para>
            <para>
                This  portion of the API supports additional event
                sink pipeline element types.
            </para>
            <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>AddEventSink</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CEventSink&amp; </type><parameter>sink</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier>const </modifier>
                           <type>char* </type><parameter>name </parameter>
                           <initializer>0</initializer>
                        </methodparam>
                        
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a new event <parameter>sink</parameter> to the
                        end of the event sink pipeline.  If
                        <parameter>name</parameter> is not a null pointer,
                        it will be the name of the processing element.
                        If it is a null pointer, a unique name
                        will be supplied by SpecTcl.
                    </para>
                    <para>
                        The histogrammer registers itself as
                        <literal>::Histogrammer</literal>.  Event filters
                        register themselves with their filter name.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventSinkPipeline::EventSinkIterator </type>
                        <methodname>FindEventSink</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string </type><parameter>sinkName</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an iterator to the event sink
                        <parameter>sinkName</parameter>.  If no such event sink
                        pipeline element exists, the return value will be
                        the same as that returned by
                        <methodname>EventSinkPipelineEnd</methodname>.
                    </para>
                    <para>
                        The iterator returned is a pointer like object.
                        The objects it points to are
                        <classname>std::pair&lt;std::string, CEventSink*&gt;</classname>
                        where the first element of the pair is the name of the event
                        sink pointed to by the second element of the pair.
                    </para>   
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventSinkPipeline::EventSinkIterator </type>
                        <methodname>FindEventSink</methodname>
                        <methodparam>
                            <type>CEventSink&amp; </type><parameter>sink</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an iterator 'pointing' to the event sink
                        pipeline element whose reference is p[assed in
                        to to the method as <parameter>sink</parameter>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>InsertEventSink</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CEventSink&amp; </type><parameter>sink</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>CEventSinkPipeline::EventSinkIterator </type><parameter>here</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier>const </modifier>
                           <type>char* </type><parameter>name</parameter>
                           <initializer>0</initializer>
                        </methodparam> 
                       
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds the event sink <parameter>sink</parameter> to the
                        event sink pipeline prior to the position indicated
                        by <parameter>here</parameter>, an iterator.
                        If not a null pointer, the parameter <parameter>name</parameter>
                        is used to name the pipeline element.  Otherwise
                        a unique name is assigned to the element.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventSink* </type>
                        <methodname>RemoveEventSink</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string </type><parameter>name</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes an event sink named <parameter>name</parameter>
                        from the event sink pipeline.  A pointer to the
                        removed sink is returned on success.  If no
                        event sink with <parameter>name</parameter> exists,
                        a null pointer is returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventSink* </type>
                        <methodname>RemoveEventSink</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CEventSinkPipeline::EventSinkIterator </type><parameter>here</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes an event sink from the pipeline given an
                        iterator that points to the std::pair containing the
                        specific sink.  Returns a pointer to the event sink
                        that was removed.   
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Int_t </type>
                        <methodname>EventSinkPipelineSize</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of elements in the event sink pipeline.
                        Just after SpecTcl starts, this will return
                        at least <literal>1</literal>
                        as the event sink pipeline is initialized with a
                        <classname>CHistogrammer</classname> as an event
                        sink.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventSinkPipeline::EventSinkIterator </type>
                        <methodname>EventSinkPipelineBegin</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventSinkPipeline::EventSinkIterator </type>
                        <methodname>EventSinkPipelineEnd</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        These methods support iteration over the event sink
                        pipeline.  <methodname>EventSinkPipelineBegin</methodname>
                        returns an iterator that 'points' to the first item
                        in the pipeline (usually the histogrammer).  
                    </para>
                    <para>
                        <classname>CEventSinkPipeline::EventSinkIterator</classname>
                        objects can be thought of as pointers.  They point to
                        a
                        <classname>std::pair&lt;std::string, CEvetnSink*&gt;</classname>.
                        The first element of that pair is the name assigned to the
                        event sink.  The second element is a pointer to an
                        event sink that was assigned that name.
                    </para>
                    <para>
                        <classname>CEventSinkPipeline::EventSinkIterator</classname>
                        objects can be incremented.  Each increment points
                        the iterator to the next object in the pipeline.
                        Incrementing an iterator that points to the last item
                        in the pipeline makes it equal to the object
                        returned by
                        <methodname>EventSinkPipelineEnd</methodname>.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            Filters are the most common type of non histogrammer elements
            in the event processing pipeline.  SpecTcl has command line
            mechanisms for creating, configuring and enabling filters.
            The next several methods provide the same functionality for
            C++ extensions to SpecTcl as well as providing a method for
            extending the set of output formats supported by standard filters.
        </para>
        <para>
            Naturally, for special needs, programmers can extend the
            <classname>CGatedEventFilter</classname> class and use
            the resulting filters in these API elements.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void  </type>
                        <methodname>createFilter</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string </type><parameter>name</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>CGatedEventFilter* </type><parameter>pFilter</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a new filter, <parameter>pFilter</parameter> to the
                        event sink pipeline.  The filter will be given the name
                        <parameter>name</parameter>.  The filter is also
                        entered into the filter dictionary so that it is
                        visible to and can be manipulated with SpecTcl
                        commands.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CGatedEventFilter* </type>
                        <methodname>findFilter</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string </type><parameter>name</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Locates returns a pointer to the event filter
                        <parameter>name</parameter>.  If no filter with that
                        name has been created a null pointer is returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodsynopsis>
                    <modifier></modifier>
                    <type>bool  </type>
                    <methodname>filterExists</methodname>
                    <methodparam>
                       <modifier></modifier>
                       <type>CGatedEventFilter* </type><parameter>pFilter</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis></term>
                <listitem>
                    <para>
                        Given a pointer to an event filter <parameter>pFilter</parameter>,
                        determines if a filter with the same address exists in
                        the filter dictionary.  Returns <literal>true</literal>
                        if so and <literal>false</literal> if not.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void  </type>
                        <methodname>deleteFilter</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CGatedEventFilter* </type><parameter>pFilter</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes the filter pointed to by <parameter>pFilter</parameter>
                        from the filter dictionary.  If <parameter>pFilter</parameter>
                        is not in the filter dictionary, no action is taken.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void  </type>
                        <methodname>deleteFilter</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string </type><parameter>filterName</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes a filter from the filter dictionary.    If the
                        filter is not in the dictionary, this is a silent No-op.
                    </para>
                    <para>
                        Neither this method, nor the previous one actually delete
                        the storage associated with a filter, they only
                        remove it from the filter dictionary.  To perform
                        a full deletion would require something like:
                    </para>
                    <informalexample>
                        <programlisting>
                            
// Delete by pointer.
                            
CGatedFilter* pFilter=makeSomeFilter();
...
SpecTcl* pApi = SpecTcl::getInstance();
pApi-&gt;deleteFilter(pFilter);
delete pFilter;

// Delete by name with full deletion.

CGatedFilter *pSomeFilter = pApi-&gt;findFilter("someName");
if (pSomeFilter) {
    pApi-&gt;deleteFilter("someName");
    delete pSomeFilter;
}
                        </programlisting>
                    </informalexample>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void  </type>
                        <methodname>addFilterOutputFormat</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CFilterOutputStageCreator&amp; </type><parameter>creator</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a new filter output format to the filter subsystem.
                        <parameter>creator</parameter>, when given its output
                        format name, recognizes it and returns the appropriate
                        output formatter.  The programming guide provides
                        a worked example that shows how to add filter
                        formats to the system.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            The remainder of the API are miscellaneous methods that don't really
            fit well into any of the method categories above.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>AddSpectrumFormatter</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string</type><parameter> name</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>CSpectrumFormatter&amp; </type><parameter>formatter</parameter>
                        </methodparam>
                        
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Associates the <parameter>formatter</parameter> with
                        outputting spectra (via the <command>swrite</command> command)
                        for the format type <parameter>name</parameter>.
                        The actual <parameter>formatter</parameter> must be in scope
                        for the lifetime of SpecTcl.   Therefore it's recommended
                        that it either be statically allocated at a file scope
                        or alternatively dynamically allocated via <literal>new</literal>
                        and never destroyed with <literal>delete</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CTCLInterpreter* </type>
                        <methodname>getInterpreter</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the object encapsulated
                        Tcl interpreter that SpecTcl is using to execute its
                        commands.  This can be used to add commands to SpecTcl,
                        or anything else that may require a Tcl interpreter.
                        See the Tcl++ section of this manual for more information
                        about how to use this and other classes in the
                        Tcl++ C++ encapsulation of libTcl.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CHistogrammer*</type>
                        <methodname>GetHistogrammer</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to SpecTcl's histogrammer object.
                        Note that most of the things you'd want to do with the
                        <classname>CHistogrammer</classname> are possible
                        directly from the API methods above.  Those are
                        considered 'sacred with respect to modification' while
                        the methods of the histogrammer can be modified in
                        function and signature.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CTclAnalyzer* </type>
                        <methodname>GetAnalyzer</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the current SpecTcl analyzer.
                        The <classname>CAnalyzer</classname> is the method
                        that directs the flow of control within SpecTcl's analysis
                        of data.  Normally, the SpecTcl analyzer is actually a
                        <classname>CTclAnalyzer</classname> object
                        (see <filename>TCLAnalyzer.h</filename> for the class
                        definition).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventSinkPipeline* </type>
                        <methodname>GetEventSinkPipeline</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the event sink pipeline object.
                        Note that other methods in this API provide essentially
                        all of the operations you'll need to perform on this object.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CDisplayInterface* </type>
                        <methodname>GetDisplayInterface</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        SpecTcl 5.0 decouples SpecTcl from its traditional
                        displayer (Xamine), and provides an new Root based
                        displayer (Display).  The interaction between the
                        displayer and SpecTcl is mediate by a
                        <classname>CDisplayerInterface</classname> object
                        that is specific to the displayer type.  This
                        method obtains a pointer to the specific
                        displayer interface object in use.
                    </para>
                    <para>
                        I anticipate that later in the development of SpecTcl 5,
                        we'll see the <classname>SpecTcl</classname> class
                        augmented to provide a stable API to the displayer.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void SetDisplayInterface</type>
                        <methodname>CDisplayInterface&amp; rInterface</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Provides a new display interface to SpecTcl;
                        <parameter>rInterface</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>std::vector&lt;UInt_t&gt;  </type>
                        <methodname>parameterIds</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::vector&lt;std::string&gt; </type><parameter>names</parameter>
                        </methodparam>
                        
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Given a list of parameter <parameter>names</parameter>,
                        Returns a vector of the parameter ids associated with those
                        names.  The 0'th element of the result is the
                        id of the 0'th element of <parameter>names</parameter>
                        and so on.
                    </para>
                    <para>
                        If any of the parameters in <parameter>names</parameter>
                        does not exist a <classname>std::vector&lt;std::string&gt;::iterator</classname>
                        exception is thrown which 'points' to the element of
                        <parameter>names</parameter> that failed its lookup.
                    </para>
                </listitem>
            </varlistentry>

                </variablelist>
            </refsect1>

        </refentry>    
    </part>
    <part>
        <title>Tree Parameter, Tree Variable API</title>
        <chapter>
            <title>Tree parametr, tree variable API</title>
            <para>
                The Tree parameter subsystem was originally developed by
                Daniel Bazin.  It has since been reimplemented  and incorporated
                into SpecTcl.  The tree parameter subsystem provides two facilities
                for SpecTcl parameters and Tcl variables;
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        The ability to structure parameter space in to more
                        convenient organizations than the flat array that
                        SpecTcl uses internally, as well as to associate metadata
                        with SpecTcl parameters.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The ability to bind Tcl variables to metadata (e.g.
                        units of measurement) and to allow access to those data
                        without the need to understand how to program
                        the Tcl or Tcl++ libraries.  This, along with the user
                        interface elements that support tree parameters makes
                        steering computation performed by event pipeline elements
                        much simpler than it otherwise might be.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                In this part we will provide reference information for the
                tree parameter subsystem.  This information will be limited to the
                public interfaces of the classes intended for use by SpecTcl
                programmers.
            </para>
        </chapter>
        <refentry >
            <refmeta>
                <refentrytitle >CTreeParameter</refentrytitle>
                <manvolnum>3treeparam</manvolnum>
            </refmeta>
            
            <refnamediv>
                <refname>CTreeParameter</refname>
                <refpurpose>Parameter object 'independent' of rEvent</refpurpose>
            </refnamediv>
            
            <refsynopsisdiv>
            <synopsis>
#include &lt;TreeParameter.h&gt;

class <classname>CTreeParameter</classname>
{
 CTreeParameter();
  CTreeParameter(std::string name);
  CTreeParameter(std::string name, std::string units);
  CTreeParameter(std::string name, double lowLimit, double highLimit, 
		 std::string units);
  CTreeParameter(std::string name, UInt_t channels, 
		 double lowLimit, double highLimit, std::string units);
  CTreeParameter(std::string name, UInt_t resolution);
  CTreeParameter(std::string name, UInt_t resolution, 
		 double lowLimit, double widthOrHigh, 
		 std::string units, bool widthOrHighGiven);
  CTreeParameter(std::string name, const CTreeParameter&amp; Template);
  CTreeParameter(const CTreeParameter&amp; rhs);
  ~CTreeParameter();
  
  
  void Initialize(std::string name, UInt_t resolution);
  void Initialize(std::string name, UInt_t resolution, 
		  double lowLimit, double highOrWidth, std::string units, 
		  bool highOrWidthGiven);
  void Initialize(std::string name);
  void Initialize(std::string name, std::string units);
  void Initialize(std::string name, UInt_t channels, 
		  double lowLimit, double highLimit, std::string units);
  
  
  static void BindParameters();
  static void setEvent(CEvent&amp; rEvent);
  bool isBound();
  
	// Arithmetic operations...
  
  operator double();
  CTreeParameter&amp; operator= (double newValue);
  CTreeParameter&amp; operator= (CTreeParameter&amp; rhs);
  CTreeParameter&amp; operator+=(double rhs);
  CTreeParameter&amp; operator-=(double rhs);
  CTreeParameter&amp; operator*=(double rhs);
  CTreeParameter&amp; operator/=(double rhs);
  double          operator++(int dummy);
  CTreeParameter&amp; operator++();
  double          operator--(int dummy);
  CTreeParameter&amp; operator--();
  
  
  std::string getName();
  int    getId();
  double getValue();
  void   setValue(double newValue);
  UInt_t getBins();
  void   setBins(UInt_t channels);
  double getStart();
  void   setStart(double low);
  double getStop();
  void   setStop(double high);
  double getInc();
  void   setInc(double channelWidth);
  std::string getUnit();
  void   setUnit(std::string units);
  bool   isValid();
  void   setInvalid();
  void   Reset();
  void   clear();
  bool   hasChanged();
  void   setChanged();
  void   resetChanged();
  static void ResetAll();
  
  
  static std::multimap&lt;std::string, CTreeParameter*&gt;::iterator begin();
  static std::multimap&lt;std::string, CTreeParameter*&gt;::iterator end();
  static std::multimap&lt;std::string, CTreeParameter*&gt;::iterator find(std::string name);
  void Bind();
  
  
  
};
            </synopsis>
            </refsynopsisdiv>
            
            <refsect1>
                <title>DESCRIPTION</title>
                <para>
                    A <classname>CTreeParameter</classname> object is an alias
                    for an element of an event array.  By providing this independent
                    alias:
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            <classname>CTreeParameter</classname> objects
                            can be organized into arbitrary structures
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Additional metadata can be associated with the
                            parameter that's held by the <classname>CTreeParameter</classname>
                            object.
                        </para>
                    </listitem>
                </itemizedlist>
                <para>
                    The life cycle of a tree parameter is that it is
                    constructed and initialized.  Some of the constructors
                    provide for one step construction/initialization.
                    
                </para>
                <para>
                    Once initialized the tree parameters need to be bound to
                    the underlying parameters.  This binding is many to one in the
                    sense that  two tree parameters may have the same name and
                    will bind to the same underlying parameter.  Binding involves
                    associating a parameter id with the tree parameter object.
                    If the parameter is already known to SpecTcl the existing
                    Id is used.  If not, a new parameter is created with an
                    Id allocated by SpecTcl and the resulting Id is used
                    to bind the tree parameter.  SpecTcl will perform this binding
                    late in its initialization process.
                </para>
                <para>
                    For each event SpecTcl processes, a <classname>CEvent</classname>
                    object must associated with the tree parameter subsystem.
                    This association tells the tree parameter exactly which element
                    of which <classname>CEvent</classname> object to fetch
                    when referenced or to set when assigned or modified.
                </para>
            </refsect1>
            
            <refsect1>
                <title>METHODS</title>
                <para>
                    The tree parameter methods are divided  into several
                    categories.  The first set we will describe are constructors
                    and initialization methods:
                </para>
                <variablelist>
                <varlistentry>
                    <term><constructorsynopsis>
                        <methodname>CTreeParameter</methodname>
                        <void />
                    </constructorsynopsis></term>
                    <listitem>
                        <para>
                            Default constructor.  This constructor requires
                            two phase initialization.  That is at some point
                            opne of the <methodname>Initialize</methodname>
                            methods must be called to make this a usable
                            object.
                        </para>
                        <para>
                            Note that a constructed tree parameter
                            <emphasis>can</emphasis> be reinitialized
                            at any time, though if its name changes it must
                            be bound again.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>CTreeParameter</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Constructs a tree parameter with a name and no
                            metadata.  The metadata can be added later either by
                            invoking a <methodname>Initialize</methodname>
                            method or by invoking individual metadata setters.
                        </para>
                        <para>
                            Note if <methodname>Initialize</methodname>
                            is called with a different name after the object
                            has been bound, it must be bound again.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>CTreeParameter</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>units</parameter>
                            </methodparam> 
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Constructs a tree parameter specifying its
                            <parameter>name</parameter> and the
                            <parameter>units</parameter> of measure metadata.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>CTreeParameter</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>double </type><parameter>lowLimit</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>double </type><parameter>highLimit</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>units</parameter>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Constructs a tree parameter named
                            <parameter>name</parameter>.  Metadata is provided
                            that sets the range of the parameter to a low limit
                            of
                            <parameter>lowLimit</parameter> and high limit of
                            <parameter>highLimit</parameter>.  The
                            <parameter>units</parameter> parameter specifies the
                            units of measure.
                        </para>
                        <para>
                            Note that parameter limits are always advisory limits.
                            Nothing happens if the parameter is given a value outside
                            those limits.  Portions of the SpecTcl user interface,
                            however, do use those limits to inform default
                            choices for spectrum axis limits.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>CTreeParameter</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>channels</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>double </type><parameter>lowLimit</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>double </type><parameter>highLimit</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string</type><parameter> units</parameter>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This constructor provides not only the parameter's name,
                            limits and units but also recommends that spectra
                            with this parameter on an axis allocate
                            <parameter>channels</parameter> channels for that axis.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>CTreeParameter</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>resolution</parameter>
                            </methodparam>
                             
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            In this constructor, the metadata for the
                            tree parameter is the <parameter>resolution</parameter>.
                            This is well suited for a tree parameter that
                            reflects raw digitizer value.
                            The <parameter>resolution</parameter> specifies the
                            number of bits of data the digitizer provides.
                        </para>
                        <para>
                            This implies a parameter range of
                            <literal>[0, 2^<parameter>resolution</parameter>)</literal>
                            with a suggested channel count for a unit mapping
                            between parameter and spectrum coordinates.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>CTreeParameter</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>resolution</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>double </type><parameter>lowLimit</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>double </type><parameter>widthOrHigh</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>units</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>bool </type><parameter>widthOrHighGiven</parameter>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Constructs a tree parameter with a rather complex
                            set of metadata that depends on the value of
                            the <parameter>widthOrHeightGiven</parameter> flag.
                            <parameter>resolution</parameter> specifies that the
                            spectrum channel recommendation is for
                            <literal>2^<parameter>resolution</parameter></literal>
                            channels to be allocated on the axis.
                        </para>
                        <para>
                            The parameter (axis) low limit is recommended to
                            be <parameter>lowLimit</parameter>.  The
                            <parameter>widthOrHigh</parameter> meaning depends
                            on the <parameter>widthOrHighGiven</parameter>.
                            If this is <literal>false</literal>,
                            <parameter>widthOrHigh</parameter> is the
                            recommended high limit for the parameter.
                            If <parameter>true</parameter> <parameter>widthOrHigh</parameter>
                            represents the width of each channel.  The high limit
                            will be computed from <parameter>widthOrHigh</parameter>
                            and the <parameter>resolution</parameter> as follows:
                            <literal><parameter>lowLimit</parameter> + <parameter>widthorHigh</parameter> * 2^<parameter>resolution</parameter></literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>CTreeParameter</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>const CTreeParameter&amp; </type><parameter>Template</parameter>
                            </methodparam>
                             
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Constructs a new tree parameter that is a copy of
                            <parameter>Template</parameter>, except that it has
                            the name <parameter>name</parameter>.  This can be
                            used to construct several parameters with the same
                            properties where a <classname>CTreeParameterArray</classname>
                            is not really appropriate for example:
                        </para>
                        <informalexample>
                            <programlisting>
                                ...
// Define PPAC L,R, U,D parameters

CTreeParameter left("ppac.left", 0.0, 4095.0, "channels");
CTreeParameter right("ppac.right", left);
CTreeParameter up("ppac.up", left);
CTreeParameter down("ppac.down", left);
                                ...
                            </programlisting>
                        </informalexample>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type></type>
                            <methodname>CTreeParameter</methodname>
                            <methodparam>
                               <modifier>const </modifier>
                               <type>CTreeParameter&amp; </type><parameter>rhs</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Tree parameter copy constructor.  Among other things,
                            this allows a tree parameter to be passed by value
                            to methods.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>Initialize</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t</type><parameter> resolution</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>Initialize</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>resolution</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>double </type><parameter>lowLimit</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>double </type><parameter>highOrWidth</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string</type><parameter> units</parameter>
                            </methodparam>                          
                            <methodparam>
                               <modifier></modifier>
                               <type>bool </type><parameter>highOrWidthGiven</parameter>
                            </methodparam>  
                            <modifier></modifier>
                        </methodsynopsis>                        
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>Initialize</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>Initialize</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>units</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>Initialize</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>UInt_t </type><parameter>channels</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>double </type><parameter>lowLimit</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>double </type><parameter>highLimit</parameter>
                            </methodparam>
                            <methodparam>
                               <modifier></modifier>
                               <type>std::string </type><parameter>units</parameter>
                            </methodparam>
  
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            These initialization methods support two stage
                            construction.  The idea is that you could
                            construct a tree parameter using the default
                            constructor and then later complete construction
                            using the appropriate <methodname>Initialize</methodname>
                            method above.  Note that with the exception
                            of the default constructor, each constructor has a
                            corresponding <methodname>Initialize</methodname>
                            method with arguments that have the same meaning
                            as in the construcor.  Refer to the constructor
                            documentation for more information.
                        </para>
                    </listitem>
                </varlistentry>
                </variablelist>
                <para>
                    A <classname>CTreeParameter</classname> can be used
                    mostly as if it were a double precision
                    floating point value.  Specifically, it has
                    a <methodname>double</methodname> method which can
                    convert the object into a double.  It also supports
                    several types of arithmetic operations of the
                    compute-and-assign variety.
                </para>
                <para>
                    Note that those which require a right hand side parameter
                    (e.g. <methodname>operator+=</methodname>) take a
                    <type>double</type>.  This in conjuntion with the
                    conversion operator alows the use of tree parameters
                    as well on the righ hand side.
                </para>
                <para>
                    Note as well that a <classname>CException</classname>
                    will be thrown if a method needs the value of the parameter
                    prior to it having been given a value.
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type></type>
                                <methodname>operator double</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This is a conversion operator that extracts
                                extracts and returns the <type>double</type>
                                value of the parameter to which the object
                                is bound for the current event.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeParameter&amp; </type>
                                <methodname>operator= </methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>newValue</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Gives the underlying parameter in the current
                                event the double precision value
                                <parameter>newValue</parameter>.  Note that
                                <classname>CTreeParameter</classname> objects
                                or any other object with conversion operators
                                to doubles can also be on the right hand side
                                of this operator.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeParameter&amp; </type>
                                <methodname>operator+=</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>rhs</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Adds the double value on the right hand side of
                                the <literal>+=</literal> operator to the
                                object's parameter in the current event.
                                Returning a reference to the parameter allows
                                operator chaining such as
                                
                            </para>
                            <programlisting>
                                tp1  = tp2 += 1234.0; 
                            </programlisting>
                            <para>
                                Where both <varname>tp1</varname> and
                                <varname>tp2</varname> are tree parameters.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeParameter&amp; </type>
                                <methodname>operator-=(double rhs</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>rhs</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Subtracts the <parameter>rhs</parameter>
                                from the object and returns a reference to the
                                object.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                            <modifier></modifier>
                            <type>CTreeParameter&amp; </type>
                                    <methodname>operator*=</methodname>
                                    <methodparam>
                                       <modifier></modifier>
                                       <type>double</type><parameter> rhs</parameter>
                                    </methodparam>
                                    <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Multiplies the object by the
                                <parameter>rhs</parameter> and returns a
                                reference to the object.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                           <methodsynopsis>
                            <modifier></modifier>
                            <type>CTreeParameter&amp; </type>
                            <methodname>operator/=</methodname>
                            <methodparam>
                               <modifier></modifier>
                               <type>double</type><parameter> rhs</parameter>
                            </methodparam>
                            <modifier></modifier>
                           </methodsynopsis> 
                        </term>
                        <listitem>
                            <para>
                                Divides the value of the object by
                                <parameter>rhs</parameter>.  A reference
                                to the object is returned.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>double</type>
                                <methodname>operator++</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>int </type><parameter>dummy</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Provides a post decrement operator.  Because
                                of the semantics of tree parameters, this is
                                not exactly possible.  The <emphasis>value</emphasis>
                                of the parameter prior to incrementing it is
                                returned.  That's why the return is a
                                <type>double</type> not a
                                <classname>CTreeParameter&amp;</classname>
                            </para>
                            <programlisting>
double f = tp++;   // tp a tree parameter.
                            </programlisting>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeParameter&amp; </type>
                                <methodname>operator++</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Increments the value of the tree parameter
                                object then returns a reference to that object.
                                This is the normal pre-decrement semantics.
                            </para>
                            <programlisting>
tp2 = ++tp1;      // Both tp2 and tp1 tree parameters.
                            </programlisting>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>double</type>
                                <methodname>operator--</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>int </type><parameter>dummy</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Post decrement operator.  Note that like the
                                post increment operator, a double is returned,
                                not a reference to the object or a copy of it.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeParameter&amp; </type>
                                <methodname>operator--</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                predecrement operator.  The reference to the
                                object is returned, after it is decremented.
                            </para>
                        </listitem>
                    </varlistentry>
                      
                </variablelist>
                <para>
                    Note that many of the arithmetic operations are not inplemented.
                    For example, there is no <methodname>operator+</methodname>.
                    This is because the <methodname>operator double</methodname>
                    makes those operations unecessary.  For example, given
                    tree parameters <varname>tp1, tp2</varname>
                </para>
                <programlisting>
                    tp1 = tp2 * 100 + 3.1416;
                </programlisting>
                <para>
                    Is perfectly legal and does the right thing.
                    <varname>tp2</varname> is replaced by its  value due to the
                    <methodname>operator double</methodname>.  The computation
                    produces  a double and that is assigned to <varname>tp1</varname>
                    via <methodname>operator=(double)</methodname>.
                </para>
                <para>
                    The next clump of methods are non arithmetic methods.
                    These includes getters and setter for the metata
                    the object has as well as tests that might be needed
                    either to support some Tcl level commands or computation
                    during an event processor.
                </para>
                <variablelist>
                    <varlistentry>
                        <term><methodsynopsis>
                            <modifier></modifier>
                            <type>std::string </type>
                            <methodname>getName</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis></term>
                        <listitem>
                            <para>
                                Returns the name of the tree parameter.
                                
                            </para>
                            <para>
                                While it is possible to change the name of
                                a tree parameter and then bind it to a different
                                underlying parameter, that's not considered the
                                way to do things (why not just instantiate a
                                different tree parameter instead of flopping
                                around the meaning of an existing one).
                                Therefore, there is no method that directly
                                just changes the name of a tree parameter.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>int    </type>
                                <methodname>getId</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the Id of the underlying parameter.
                                If the tree parameter has not yet been bound
                                to its parameter, this will throw a
                                <classname>CTreeException</classname>
                                (defined in <filename>CTreeException.h</filename>).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>double </type>
                                <methodname>getValue</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This is identical to the <methodname>operator double</methodname>
                                method.  The value of the parameter is fetched.
                                <classname>CTreeException</classname> is thrown
                                if there is no current event
                                <classname>std::string</classname> is thrown if
                                the parameter has not yet been given a value
                                in the processing of this event.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void</type>
                                <methodname>setValue</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>newValue</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets the underlying parameter value to
                                <parameter>newValue</parameter>.  This is identical
                                to <methodname>operator=(double)</methodname>.
                                Note that <classname>CTreeException</classname>
                                is thrown if the object has not yet been bound
                                or there's no current event to get the value from.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>UInt_t </type>
                                <methodname>getBins</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void  </type>
                                <methodname> setBins</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>channels</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets/Gets the number of recommended bins for an axis
                                on this parameter.  <parameter>channels</parameter>
                                is the new suggested number of bins.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>double </type>
                                <methodname>getStart</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void   </type>
                                <methodname>setStart</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>low</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Gets/Sets the suggested low limit for spectrum
                                axes on the parameter.  <parameter>low</parameter>
                                will be the new suggested low limit.
                            </para>
                            <para>
                                Note that this and all parameter metadata can be
                                set before the parameter is bound.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>double </type>
                                <methodname>getStop</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void   </type>
                                <methodname>setStop</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double</type><parameter> high</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis> 
  
                        </term>
                        <listitem>
                            <para>
                                Gets/Sets the  suggested high limit
                                for spectrum axes on the parameter.
                                <parameter>high</parameter> will be the new
                                suggested high limit.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>double </type>
                                <methodname>getInc</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void   </type>
                                <methodname>setInc</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>channelWidth</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Gets/Sets the channel width if the suggested
                                channel count, low and high limits are used for
                                spectrum parameters.  The channel width is
                                in parameter coordinates.  <parameter>channelWidth</parameter>
                                is a new channel width.
                            </para>
                            <para>
                                Note that this is computed metadata.  The primitive
                                metadata are the low limit, high limit and
                                number of channels.  There fore,
                                <methodname>setInc</methodname> is actually
                                modifying the suggested number of channels to
                                get the requested channel width.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>std::string </type>
                                <methodname>getUnit</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void  </type>
                                <methodname>setUnit</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>units</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Gets/Sets the units of measure for the parameter.
                                <parameter>units</parameter> is the new
                                units of measure string for the parameter.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>bool  </type>
                                <methodname>isValid</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns <literal>true</literal> if, for this
                                event, the parameter has been given a value.
                                This means that the parameter can be used
                                 in situations where it is an rvalue without
                                 throwing an exception
                            </para>
                            <para>
                                For this method to work, the parameter must be
                                bound and there must be a current event.
                                If either of these conditions is not met,
                                a <classname>CTreeException</classname> is
                                thrown.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void   </type>
                                <methodname>setInvalid</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void  </type>
                                <methodname>Reset</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void  </type>
                                <methodname>clear</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Invalidates the parameter for the current
                                event.  Once invalidated, the parameter
                                will throw an <classname>std::string</classname>
                                exception if used as an r value prior to being
                                used as an l value.
                            </para>
                            <para>
                                <classname>CTreeException</classname> is thrown
                                if the parameter as either not been bound or
                                there is no current event.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>bool   </type>
                                <methodname>hasChanged</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void   </type>
                                <methodname>setChanged</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void   </type>
                                <methodname>resetChanged</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Each tree parameter has a flag that is set
                                whenever any of the metadata for the parameter are
                                modified. <methodname>hasChanged</methodname>
                                returns the value of this boolean flag.
                                <methodname>setChanged</methodname> sets the flag
                                to <literal>true</literal>
                                and <methodname>resetChanged</methodname>
                                set the flag to <literal>false</literal>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodsynopsis>
                            <modifier>static</modifier>
                            <type> void </type>
                            <methodname>ResetAll</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis></term>
                        <listitem>
                            <para>
                                This is normally called by SpecTcl's event
                                processing subsystem before starting to
                                process each event.  It iterates through
                                all tree parameters that have been defined and
                                invokes their <methodname>Reset</methodname>
                                method, which marks them as invalid.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    Creating a <classname>CTreeParameter</classname> object
                    registers it with a static registry.  This registry is
                    used by SpecTcl to, e.g. bind the tree parameters to
                    base parameters after initialization, and to
                    reset the validity on all parameters.
                </para>
                <para>
                    The following methods deal with this registry and parameter
                    binding.
                </para>
                <variablelist>
                    <varlistentry>
                        <term><methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>Bind</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis></term>
                        <listitem>
                            <para>
                                Binds this tree parameter to the underlying parameter.
                                If no underlying parameter with the tree
                                parameter's name exists, one is created and
                                assigned a unique id.
                            </para>
                            <para>
                                Binding a tree parameter that has not been
                                given a name yet binds the tree parameter to
                                a parameter with an empty name string.  This
                                is perfectly legal but probably not what you
                                want.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>static </modifier>
                                <type>void </type>
                                <methodname>BindParameters</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Iterates through all registered
                                <classname>CTreeParameter</classname> objects
                                binding them to underlying parameters.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>static </modifier>
                                <type>void </type>
                                <methodname>setEvent</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>CEvent&amp; </type><parameter>rEvent</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets the event that all tree parameters are
                                working on.  All tree parameters share this
                                object.  Parameter bindings supply each tree
                                parameter with a parameter id.  When the value
                                of a parameter is retrieved/set/modified, that id
                                is the index into <parameter>rEvent</parameter>
                                that is accessed.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>bool </type>
                                <methodname>isBound</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                If the object has been bound to its underlying
                                parameter, this returns <literal>true</literal>.
                                If not it returns <literal>false</literal>.
                                Many tree parameter operations require tht the object
                                be bound.  Some also require there be
                                a current event.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>static </modifier>
                                <type>std::multimap&lt;std::string, CTreeParameter*&gt;::iterator </type>
                                <methodname>begin</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier>static </modifier>
                                <type>std::multimap&lt;std::string, CTreeParameter*&gt;::iterator </type>
                                <methodname>end</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Supports iteration through the tree parameter
                                registry by providing a start  of iteration
                                iterator.  Note that using an
                                <classname>std::multimap</classname> for the
                                registry cleanly supports the many to one mapping
                                of tree parameters to underlying parameters.
                            </para>
                            <para>
                                An iterator is a pointer like object.
                                In this case these pointer point to
                                <classname>std::pair&lt;std::string, CTreeParameter*&gt;</classname>
                                objects where the first element of the par is the
                                name of the tree parameter and the second is a
                                pointer to the tree parameter itself.
                            </para>
                            <para>
                                Iterators can be incremented. When incremented
                                they point to the next item in the container.
                                Note that multimap iterators will step through the
                                map in key (parameter name) sort order.
                                This means that all of the tree parameters
                                that share the same name will be clumped together.
                            </para>
                            <para>
                                If an iterator points to the last item in the
                                collection, incrementing it will produce
                                an iterator that is equal to the iterator
                                returned from <methodname>end</methodname>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>static </modifier>
                                <type>std::multimap&lt;std::string, CTreeParameter*&gt;::iterator </type>
                                <methodname>find</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>name</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns an iterator to an element of the registry
                                that has the indicated <parameter>name</parameter>.
                                Note that more than one tree parameter can have
                                this name.  In that case, this iterator will
                                point to the first of them.  Incrementing the
                                iterator will get successive tree parameters
                                with the same name until either the end of the
                                multimap is reached or a tree parameter with a
                                different name is reached.
                            </para>
                            <para>
                                In practice this iteration over identically
                                named tree parameters is not necessary because
                                like named tree parameters share underlying metadata
                                and data and parameter bindings make each
                                such object interchangeable with the others.
                            </para>
                        </listitem>
                    </varlistentry>                 
                </variablelist>
            </refsect1>
        </refentry>
        <refentry >
            <refmeta>
                <refentrytitle >CTreeParameterArray</refentrytitle>
                <manvolnum>3spectcl</manvolnum>
            </refmeta>
            
            <refnamediv>
                <refname>CTreeParameterArray</refname>
                <refpurpose>Arrays of tree parameters</refpurpose>
            </refnamediv>
            
            <refsynopsisdiv>
                <synopsis>
#include &lt;TreeParameter.h&gt;

class <classname>CTreeParameterArray</classname>
{
CTreeParameterArray();
CTreeParameterArray(std::string baseName, 
          UInt_t resolution, UInt_t numElements, Int_t baseIndex);
CTreeParameterArray(std::string baseName, 
          UInt_t resolution, 
          double lowLimit, double highOrWidth, 
          std::string units, bool widthOrHighGiven, 
          UInt_t elements, Int_t firstIndex);
CTreeParameterArray(std::string baseName, UInt_t elements, Int_t baseIndex);
CTreeParameterArray(std::string baseName, std::string units, 
          UInt_t elements, Int_t firstIndex);
CTreeParameterArray(std::string baseName, 
          double low, double high, std::string units, 
          UInt_t elements, Int_t firstIndex);
CTreeParameterArray(std::string baseName, UInt_t channels, 
          double low, double high, std::string units, 
          UInt_t elements, Int_t firstIndex);

void Initialize(std::string baseName, UInt_t resolution, 
      UInt_t elements, Int_t baseIndex);
void Initialize(std::string baseName, UInt_t resolution, 
      double lowLimit, double widthOrHeight,
      std::string units, bool widthOrHeightGiven, 
      UInt_t elements, Int_t firstIndex);
void Initialize(std::string baseName, UInt_t elements, Int_t firstIndex);
void Initialize(std::string baseName, std::string units, UInt_t elements, 
      Int_t firstIndex);
void Initialize(std::string baseName, double lowLimit, double highLimit, 
      std::string units, UInt_t elements, Int_t firstIndex);
void Initialize(std::string baseName, UInt_t channels, 
      double lowLimit, double highLimit, std::string units, 
      UInt_t elements, Int_t firstIndex);

CTreeParameter&amp; operator[](Int_t nIndex);
void Reset();
std::vector&lt;CTreeParameter*&gt;::iterator begin();
std::vector&lt;CTreeParameter*&gt;::iterator end();
UInt_t size();
Int_t lowIndex();
};
                </synopsis>
            </refsynopsisdiv>
            
            <refsect1>
                <title>DESCRIPTION</title>
                <para>
                    The <classname>CTreeParameterArray</classname> provides
                    support for creating arrays of tree parameters.
                    <classname>CTreeParameterArray</classname> objects can
                    be treated like arrays programmatically but, in parameter
                    space, create a subtree of parameters.
                </para>
                <para>
                    By convention, parameters managed by the tree parameters
                    occupy a hierarcy.  The name of a parameter is a
                    dot (<literal>.</literal>) separated string.  Each
                    dot represents a path separator.  Thus the name
                    <literal>top.raw.adc.01</literal> represents the
                    parameter <literal>01</literal> that has the parent
                    <literal>adc</literal> which in turn has the parent
                    <literal>raw</literal> which in turn is parented by
                    <literal>top</literal>.
                </para>
                <para>
                    Tree parameter array objects create a subtree below
                    a parent name.  The names of the subtree are indices into
                    the tree parameter array.  In the example above, the
                    parent name might have been <literal>top.raw.adc</literal>
                    and the index <literal>01</literal>.  To facilitate
                    sorting, in parameter name space, indices are zero filled
                    to the left to accomodate the number of digits needed by
                    the largest index.
                </para>
                <para>
                    Tree parameter indices are not constrained to start from
                    zero but can start from any integer value (including
                    negative integers).
                </para>
                <para>
                    The main method a <classname>CTreeParameter</classname>
                    has, is of course, the index operator
                    (<methodname>operator[]</methodname>).  If the
                    index provided to it is out of range a
                    <classname>CTreeException</classname> is thrown,
                    otherwise, this method returns a reference to the
                    indexed tree parameter in the array.
                </para>
            </refsect1>
            
            <refsect1>
                <title>METHODS</title>
                <para>
                    Construction and initialization methods;  Like
                    the <classname>CTreeParameter</classname> class,
                    <classname>CTreeParameterArray</classname>
                    supports either one step or two step construction.
                    Two step construction is supported via a
                    default constructor and a set of
                    <methodname>Initialize</methodname> methods
                    that provide the actual properties of the object.
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <constructorsynopsis>
                                <methodname>CTreeParameterArray</methodname>
                                <void />
                            </constructorsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Default constructor.  This is used with
                                two step construction.  After constructing
                                the array, one of the
                                <methodname>Initialize</methodname> methods
                                below needs to be called to define the
                                characteristics of the array.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <constructorsynopsis>
                                <methodname>CTreeParameterArray</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>baseName</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>resolution</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t</type><parameter> numElements</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>Int_t </type><parameter>baseIndex</parameter>
                                </methodparam>                                    
                            </constructorsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Constructs and defines a tree parameter
                                array.  <parameter>baseName</parameter>
                                is used to derive the names of the parameters
                                in the array (see <literal>DESCRIPTION</literal>
                                above).  <parameter>numElements</parameter>
                                and <parameter>baseIndex</parameter>
                                define the number of array elements and the
                                base index for the array.
                                Array indices are in the range
                                <literal>[<parameter>baseName</parameter>, <parameter>baseName</parameter>+<parameter>numElements</parameter>)</literal>.
                            </para>
                            <para>
                                <parameter>resolution</parameter> describes
                                the suggested number of channels and the
                                range of values a spectrum axis on these
                                parameters should have as a number of bits
                                occupied by the parameter.  This form
                                of the constructor is best used for raw
                                digitizer values.
                            </para>
                            <para>
                                All tree parameters in the array
                                will be constructed with the same
                                <parameter>resolution</parameter>, it is
                                unusual, but possible to retrieve individual
                                elements of the array and reconfigure them.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <constructorsynopsis>
                                <methodname>CTreeParameterArray</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>baseName</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>resolution</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>lowLimit</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>highOrWidth</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>units</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>bool </type><parameter>widthOrHighGiven</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>elements</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>Int_t </type><parameter>firstIndex</parameter>
                                </methodparam>
                            </constructorsynopsis>
                        </term>
                        <listitem>
                            <para>
                                <parameter>The additional</parameter>
                                parameters define the limits of the
                                parameter.  <parameter>lowLimit</parameter>
                                is the recommended low limit of axes
                                that are defined on these parameters.
                                The meaning of
                                <parameter>highOrWidth</parameter> depends
                                 on the value of the flag
                                 <parameter>widthOrHighGiven</parameter>.
                            </para>
                            <para>
                                If <parameter>widthOrHighGiven</parameter>
                                is <literal>true</literal>,
                                <parameter>highOrWidth</parameter> defines
                                the suggested high limit of axes on these
                                parameters.  If <literal>false</literal>,
                                the paramete represents the width of each
                                channel in parameter coordinates.  It, along
                                with <parameter>resolution</parameter>
                                (which define the number of channels)
                                are used to compute the high limit recommended
                                for spectrum axes on these parameters.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <constructorsynopsis>
                                <methodname>CTreeParameterArray</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string baseName</type><parameter></parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>elements</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>Int_t </type><parameter>baseIndex</parameter>
                                </methodparam>
                            </constructorsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This constructor does not supply any metadata
                                for the tree parameters it creates.
                                If metadata are desired, they can be supplied
                                later either by a call ot the appropriate
                                <methodname>Initialize</methodname>
                                method or by iterating through the array
                                setting metadata for each element.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <constructorsynopsis>
                                <methodname>CTreeParameterArray</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>baseName</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>units</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>elements</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>Int_t </type><parameter>firstIndex</parameter>
                                </methodparam>
           
                            </constructorsynopsis>
                        </term>
                        <listitem>
                            <para>
                                The <parameter>units</parameter> parameter
                                defines the units of measure for the tree
                                parameters in the array.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <constructorsynopsis>
                                <methodname>CTreeParameterArray</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>baseName</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>low</parameter>
                                </methodparam>                      
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>high</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>units</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t</type><parameter> elements</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>Int_t </type><parameter>firstIndex</parameter>
                                </methodparam>
                            </constructorsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Provides the suggested 
                                <parameter>low</parameter> and
                                <parameter>high</parameter> limits on axes
                                defined on these parameters.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <constructorsynopsis>
                                <methodname>CTreeParameterArray</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>baseName</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>channels</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>low</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double</type><parameter> high</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string</type><parameter> units</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>elements</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>Int_t </type><parameter>firstIndex</parameter>
                                </methodparam>
                            </constructorsynopsis>
                        </term>
                        <listitem>
                            <para>
                                In this case <parameter>channels</parameter>
                                specifies the suggested number of bins
                                on an axis on this parameter where
                                the axis will run between
                                <parameter>low</parameter> and <parameter>high</parameter>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void </type>
                                <methodname>Initialize</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>baseName</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>resolution</parameter>
                                </methodparam>
                                 <methodparam>
                                    <modifier></modifier>
                                    <type>UInt_t </type><parameter>elements</parameter>
                                 </methodparam>
                                 <methodparam>
                                    <modifier></modifier>
                                    <type>Int_t </type><parameter>baseIndex</parameter>
                                 </methodparam>
       
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void </type>
                                <methodname>Initialize</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>baseName</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>resolution</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>lowLimit</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>widthOrHeight</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>units</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>bool </type><parameter>widthOrHeightGiven</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>elements</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>Int_t </type><parameter>firstIndex</parameter>
                                </methodparam>
                                
       
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void </type>
                                <methodname>Initialize</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string</type><parameter> baseName</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>elements</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>Int_t </type><parameter>firstIndex</parameter>
                                </methodparam>
                                  
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void </type>
                                <methodname>Initialize</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>baseName</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>units</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>elements</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>Int_t </type><parameter>firstIndex</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void </type>
                                <methodname>Initialize</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>baseName</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>lowLimit</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>highLimit</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>units</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>elements</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>Int_t </type><parameter>firstIndex</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>    
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void </type>
                                <methodname>Initialize</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>baseName</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>channels</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>lowLimit</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>highLimit</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>units</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>elements</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>Int_t </type><parameter>firstIndex</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>  
                        <listitem>
                            <para>
                                These methods are called as the second
                                step in a two step construction.  The
                                meaning of their parameters is the same
                                as the constructors with corresponding
                                parameters.  See the documentation
                                of the constructors above for more
                                information.
                            </para>
                        </listitem>
                    </varlistentry>

                
                </variablelist>
                <para>
                    The remainder of the methods, besides
                    <methodname>operator[]</methodname> are miscellaneous.
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeParameter&amp; </type>
                                <methodname>operator[]</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>Int_t </type><parameter>nIndex</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns a reference to the tree parameter
                                in the array indexed by
                                <parameter>nIndex</parameter>.
                                A <classname>CTreeException</classname>
                                is thrown if the index is out of range.
                            </para>
                            <para>
                                Since a reference is returned the tree
                                parameter can be modified as well as set
                                or inspected.
                            </para>
                        </listitem>
                    </varlistentry>
                
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void </type>
                                <methodname>Reset</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Invokes the <methodname>Reset</methodname>
                                method on each element of the array.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>std::vector&lt;CTreeParameter*&gt;::iterator </type>
                                <methodname>begin</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>std::vector&lt;CTreeParameter*&gt;::iterator </type>
                                <methodname>end</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Supports iteration of the
                                <classname>std::vector</classname> used to
                                maintain the tree parameters in the object.
                                <methodname>begin</methodname> returns
                                an iterator that can be used as if it were
                                a pointer to <classname>CTreeParameter*</classname>
                                pointer that points to the first element
                                of the vector.  This will be the tree
                                parameter with the lowest index.
                            </para>
                            <para>
                                Incrementing the iterator points to the item with
                                the next index in the container.  Incrementing
                                the iterator when it points to the last
                                tree parameter results in a value that is
                                equal to that returned from
                                <methodname>end</methodname>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>UInt_t </type>
                                <methodname>size</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Retrurns the number of tree parameters in the
                                array.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>Int_t </type>
                                <methodname>lowIndex</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the smallest allowed index into the
                                tree parameter array.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
            
        </refentry>
        <refentry>
            <refmeta>
                <refentrytitle >CTreeVariable</refentrytitle>
                <manvolnum>3spectcl</manvolnum>
            </refmeta>
            
            <refnamediv>
                <refname>CTreeVariable</refname>
                <refpurpose>Access to Tcl variables with metadata</refpurpose>
            </refnamediv>
            
            <refsynopsisdiv>
                <synopsis>
#include &lt;TreeParameter.h&gt;

class <classname>CTreeVariable</classname>
{
  CTreeVariable();
  CTreeVariable(std::string name, double value, std::string units);
  CTreeVariable(const CTreeVariable&amp; rhs);

  void Initialize(std::string name, double value, std::string units);

  operator double() const;
  CTreeVariable&amp; operator=(double rhs);
  CTreeVariable&amp; operator=(const CTreeVariableamp; rhs);
  CTreeVariable&amp; operator+=(double rhs);
  CTreeVariable&amp; operator-=(double rhs);
  CTreeVariable&amp; operator*=(double rhs);
  CTreeVariable&amp; operator/=(double rhs);
  double operator++(int dummy);
  CTreeVariable&amp; operator++();
  double operator--(int dummy);
  CTreeVariable&amp; operator--();
  
  
  std::string getName();
  double getValue();
  std::string getUnit();
  bool hasChanged();
  bool valueChanged();
  void resetChanged();
  
  void Bind();
  static void BindVariables(CTCLInterpreter&amp; rInterp);
  static TreeVariableIterator begin();
  static TreeVariableIterator end();
  static TreeVariableIterator find(std::string name);
  static int size();
  
};
                </synopsis>
            </refsynopsisdiv>
            
            <refsect1>
                <title>DESCRIPTION</title>
                <para>
                    The <classname>CTreeVariable</classname>  class provides
                    simplified access to Tcl intepreter variables.  These
                    variables are globally scoped variables in Tcl and
                    are defined in the interpreter that executes
                    SpecTcl commands.
                </para>
                <para>
                    The operations provided by the class are sufficient
                    to allow you to treat the tree variable as if it were
                    a simple <type>double</type> value, transparently fetching or
                    storing the underlying Tcl variable as needed.
                </para>
                <para>
                    Tree variables also have metadata.  Specifically each tree
                    variable can have a unit of measure property.
                </para>
            </refsect1>
            
            <refsect1>
                <title>METHODS</title>
                <para>
                    Constructors and initializers.  As with tree parameters,
                    tree variables support both one and two step
                    construction.
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <constructorsynopsis>
                                <methodname>CTreeVariable</methodname>
                                <void />
                            </constructorsynopsis>                          
                        </term>
                        <listitem>
                            <para>
                                This default constructor will require that
                                you later invoke
                                <methodname>Initialize</methodname>
                                to complete the two step construction of the
                                object.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <constructorsynopsis>
                                <methodname>CTreeVariable</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>name</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>value</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>units</parameter>
                                </methodparam>
                                  
                            </constructorsynopsis>
                        </term>
                        <listitem>
                            <para>
                                <parameter>name</parameter> is the name of
                                the Tcl variable this object is
                                associated with.  <parameter>value</parameter>
                                is an initial value the variable will be given.
                                <parameter>units</parameter> are the units
                                of measure metadata to be associated
                                with this variable.
                            </para>
                            <para>
                                If there is already a Tcl variable, this does
                                not affect it.  The variable will need to be bound.
                                first.  If there is already a tree variable,
                                The previously established
                                initial value and units override the value and
                                units in this constructor.
                            </para>
                            <para>
                                A bit of information about how all this works
                                that will help you to understand some of the
                                pathalogical cases.  Tcl supports linking
                                a C/C++ variable to a Tcl variable.  We
                                use this, however we have to do some fancy
                                footwork to support many to one mappings from
                                tree variables to Tcl variables.
                            </para>
                            <para>
                                Associated with a tree variable name and,
                                therefore, with all tree variable objects
                                with the same name, is a properties object.
                                The properties object contains the name,
                                value and units metadata, shared between
                                all tree variables objects with the same name.
                                Binding at least one of the objects links the
                                C++ variable containing the value with the
                                Tcl variable with the same name as the
                                tree variable's name.
                            </para>
                            <para>
                                Thus, unlike tree parameters, once a
                                tree variable is constructed, it can be set,
                                gotten, modified and queried without error.
                                What does not happen is for anything done to the
                                value of the tree variable to affect the
                                Tcl variable.  Binding the tree variable
                                links the data containing the value with the
                                Tcl variable and ensures that the Tcl variable
                                has the current value of the tree variable.
                            </para>
                            <para>
                                A short code segment may be useful.
                            </para>
                            <programlisting>
CTreeVariable t1("myvar", 1234, "arb");           // Tcl variable unchanged
CTreeVariable t2("myvar", 456, "inch");           // Tcl and tree variable unchanged.

t1 = 777;        // T1 and T2 are now 777, Tcl variable unchanged.
t2.Bind();       // Tcl variable now 777.

t1 = 0;          // Tcl, t1, and t2 vars are now 0.
                            </programlisting>
                        </listitem>
                    </varlistentry>
                
                    <varlistentry>
                        <term>
                            <constructorsynopsis>
                                <methodname>CTreeVariable</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>const CTreeVariable&amp; </type><parameter>rhs</parameter>
                                </methodparam>
                            </constructorsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Copy construction.  This allows tree variables
                                to be passed by value.  Since, however all like named
                                tree variables use the same underlying data,
                                Changes to the copy constructed object will be
                                reflected in all other like named tree variables and,
                                if the variable is bound, in the Tcl variable.
                            </para>
                            <para>
                                Thus, while pass by value is legal, it has the
                                semantics of pass by reference.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void </type>
                                <methodname>Initialize</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>name</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>value</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>units</parameter>
                                </methodparam>
                                 
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Second step of two step initialization. The
                                parameters have the same meaning as in the one-step
                                construction constructor.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    The next set of methods are provided so that, for the most part,
                    you can treat a <classname>CTreeVariable</classname> as if it
                    were a Double precision variable.  The main contributor to this
                    is the <methodname>operator double</methodname> conversion
                    operator.  This operator allows a <classname>CTreeVariable</classname>
                    variable in an expression to be converted to a double, supporting
                    its use on the right hand side (as an r-value) of assignments.
                </para>
                    
                <variablelist>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type></type>
                                <methodname>operator double</methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                In C++ this sort of method is called a
                                conversion operator, or casting operator.
                                It provides a method that allows
                                <classname>CTreeVariable</classname>
                                objects to be treated as double variables
                                wherever appropriate.
                                The method returns the value of the
                                underlying variable.  Note that if the
                                object has not yet been bound, the value
                                returned is the most recently set value of
                                the object, which can differ from the
                                Tcl variable's value.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeVariable&amp; </type>
                                <methodname>operator=</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>rhs</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Assignment operator.  This is one of the
                                operators that allows
                                <classname>CTreeVariable</classname> objects
                                top be used on the left hand side of
                                assignment operations (as an l-value).
                                The method assigns the
                                double <parameter>rhs</parameter>
                                to the value of the variable. If the
                                object has been bound, this will be the new
                                value of the Tcl variable.  If not, this value
                                will be held in the variable and will become
                                the value of the Tcl variable when it is bound.
                            </para>
                            <para>
                                By returning a reference to the object, assignment
                                chaining is supported,  e.g. like
                            </para>
                            <programlisting>
CTreeVariable t1("avar", 1.234, "arbitrary");
double        d1;

d1  = t1 = 5.6;             // d1 is 5.6 as is t1.
                            </programlisting>
                            <para>
                                The best way to read the last statement is
                                right to left.  First the tree variable is
                                given the value 5.6 and that assignment can be
                                thought of as being replaced by the
                                <varname>t1</varname>  tree variable reference.
                            </para>
                            <para>
                                To accomplish the assignment to <varname>d1</varname>,
                                the <methodname>operator double</methodname>
                                is used to returne the value of
                                <varname>t1</varname> to assign to
                                <varname>d1</varname>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeVariable&amp; </type>
                                <methodname>operator=</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>const CTreeVariableamp; </type><parameter>rhs</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Assigns the value of the <parameter>rhs</parameter>
                                tree variable to the value of this variable.
                                Once more returning a reference to the object
                                allows operator chaining.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeVariable&amp; </type>
                                <methodname>operator+=</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double</type><parameter> rhs</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Like assignment, but <parameter>rhs</parameter>
                                is added to the variable's value.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeVariable&amp; </type>
                                <methodname>operator-=</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>rhs</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Like assignment but
                                <parameter>rhs</parameter> is subtracted
                                from the value of the object.
                            </para>
                        </listitem>
                    </varlistentry>                  
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeVariable&amp; </type>
                                <methodname>operator*=</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>rhs</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>                          
                        </term>
                        <listitem>
                            <para>
                                Like assignment but
                                <parameter>rhs</parameter> multiplies the
                                object's value.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeVariable&amp; </type>
                                <methodname>operator/=</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>rhs</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Like assignment but the value of the object is
                                divided by the <parameter>rhs</parameter>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>double </type>
                                <methodname>operator++</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>int </type><parameter>dummy</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This operator is the post-increment operator.
                                The value of the object prior to the increment
                                is returned.  Because of the binding to an underlying
                                Tcl variable, the normal semantics of  predecrementing
                                are not possible.
                            </para>
                            <para>
                                Specifically  normally post-increments ill return
                                a copy of the object prior to the increment, while
                                here a double is returned instead.  In most cases
                                you won't notice the difference.
                            </para>
                                  
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeVariable&amp; </type>
                                <methodname>operator++</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Pre-increment operator.  The variable's value is incremented
                                and then a reference to the object is returned.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>double </type>
                                <methodname>operator--</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>int </type><parameter>dummy</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Post decrement operator.  The value of the object
                                is decremented but the value returned is the
                                <type>double</type> value prior to the increment.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeVariable&amp; </type>
                                <methodname>operator--</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Pre decrement operator.  The object's value is
                                decremented after which a reference to the
                                decremented object is returned.
                            </para>
                        </listitem>
                    </varlistentry>  
                </variablelist>
                <para>
                    The next set of operations can be best described as
                    queries about the object.
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>std::string </type>
                                <methodname>getName</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>                          
                        </term>
                        <listitem>
                            <para>
                                Returns the name of the object, and hence
                                the Tcl variable the object represents.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>double </type>
                                <methodname>getValue</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                The same as <methodname>operator double</methodname>.
                                The value of the object is returned.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>std::string </type>
                                <methodname>getUnit</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the units of measure metadata for the
                                object.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>bool </type>
                                <methodname>hasChanged</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Each tree variable has an associated flag
                                that is set <literal>true</literal>
                                when the definition of that variable
                                has changed.  This method returns the
                                value of that flag.
                            </para>
                            <para>
                                The main purpose is to control which parameter
                                definitions might need to be written
                                to file during a state save operation.
                            </para>
                        </listitem>
                    </varlistentry>                  
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>bool </type>
                                <methodname>valueChanged</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>                  
                        </term>
                        <listitem>
                            <para>
                                Each variable has a value changed
                                flag as well that is modified when the
                                value of the variable is modified.
                                This is normally used to fire traces
                                on a variable in Tcl.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void </type>
                                <methodname>resetChanged</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Resets both changed flags described above and
                                fires any value changed Tcl traces.  Traces are
                                used by Tk widgets to know when to update
                                values they contain via <option>-variable</option>
                                and <option>-textvariable</option> options.
                                It is therefore important to ensure that
                                these traces get fired after C++ changes
                                to these values if there are user interface
                                elements that display these variables.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    The remainder of the methods primarily relate to bindings,
                    the registry of variables,
                    and the interface of the variable to its Tcl counterpart.
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void </type>
                                <methodname>Bind</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Binds this variable to the Tcl variable of the
                                same name, creating it if necessary.  The
                                object's value will be put into the Tcl variable.
                                If the object is already bound this is a silent
                                No-op.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>static </modifier>
                                <type>void </type>
                                <methodname>BindVariables</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>CTCLInterpreter&amp; </type><parameter>rInterp</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                A registry is maintained of all tree variable
                                objects.  This method iterates this registry
                                and binds all tree variables to their underlying
                                Tcl variables.  You can think of this as
                                invoking <methodname>Bind</methodname> on every
                                tree parameter.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>static</modifier>
                                <type> TreeVariableIterator </type>
                                <methodname>begin</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier>static</modifier>
                                <type> TreeVariableIterator </type>
                                <methodname>end</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier>static</modifier>
                                <type> TreeVariableIterator </type>
                                <methodname>find</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>name</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Return pointer like objects that can be
                                used to iterate the tree varaible registry.
                                When dereferenced, the object returns a
                                <classname>std::pair&lt;std::string, CTreeVariableProperties*&gt;</classname>
                                The first item of each pair is the name of the
                                tree variable.  The second are the set of
                                properties that are shared between all
                                variables of the same name.
                            </para>
                            <para>
                                <classname>CTreeVariableProperties</classname>
                                will be described later in this reference section.
                            </para>
                            <para>
                                <methodname>begin</methodname> returns the
                                iterator 'pointing' to the first object in the
                                container.
                                Incrementing an iterator  'points' it to the
                                next tree variable in the container.  Incrementing
                                the iterator pointing at the last object in the
                                container returns a value equal to that returned
                                by <methodname>end</methodname>.
                            </para>
                            <para>
                                <methodname>find</methodname> returns an iterator
                                that points to the item in  the container named
                                <parameter>name</parameter>.  Note that since
                                the registry contains <classname>CTreeVariableProperties</classname>
                                objects, there won't be duplication.
                                I there is no entry in the registry with the
                                <parameter>name</parameter>, the value
                                returned from <methodname>end</methodname>
                                is returned.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>static </modifier>
                                <type>int </type>
                                <methodname>size</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the number of entries in the
                                registry.  Note that since the registry
                                contains
                                <classname>CTreeVariablePropertiew</classname>
                                objects, the number of entries in the registry
                                may be less than the number of
                                <classname>CTreeVariable</classname> objects that
                                have been created.
                            </para>
                        </listitem>
                    </varlistentry>
                    
                </variablelist>

            </refsect1>
        </refentry>
        <refentry >
            <refmeta>
                <refentrytitle >CTreeVariableProperites</refentrytitle>
                <manvolnum>3spectcl</manvolnum>
            </refmeta>
            
            <refnamediv>
                <refname>CTreeVariableProperties</refname>
                <refpurpose>Shared properties of CTreeVariable</refpurpose>
            </refnamediv>
            
            <refsynopsisdiv>
                <synopsis>
#include &lt;CTreeVariableProperties.h&gt;

class <classname>CTreeVariableProperties</classname>
{
public:
  CTreeVariableProperties&amp; operator=(double value);
  CTreeVariableProperties&amp; operator=(const CTreeVariableProperties&amp; rhs);
  CTreeVariableProperties&amp; operator=(const CTreeVariable&amp; rhs);
  operator double();

  bool    definitionChanged();
  std::string  getName();  
  std::string  getUnits();
  bool    valueChanged();
  
  void    setUnits(std::string units);
  void    resetDefinitionChanged();
  void    fireTraces();
  void    Link(CTCLInterpreter&amp; rInterp);
};
                </synopsis>
            </refsynopsisdiv>
            
            <refsect1>
                <title>DESCRIPTION</title>
                <para>
                    Unless you are iterating the tree variable dictionary, this
                    class can be completely ignored as internal to the
                    tree parameter subsystem.  A <classname>CTreeVariableProperties</classname>
                    object contains the properties shared between several instances
                    of a <classname>CTreeVariable</classname> that have
                    the same name.
                </para>
                <para>
                    Furthermore, it is the <classname>CTreeVariableProperties</classname>
                    object that carries the binding between the variable and the
                    associated Tcl variable.   
                </para>
                <para>
                    Each tree variable holds the following information in this
                    object:
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            The variable's name.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            The variable's units.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            The variable's value.  This is linked to a
                            Tcl variable with the same name as this object.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Definition and value changed flags.
                        </para>
                    </listitem>
                </itemizedlist>
            </refsect1>
            
            <refsect1>
                <title>METHODS</title>
                <para>
                    Note that since these objects are typically constructed
                    by <classname>CTreeVariable</classname> objects, we're not
                    going to document the class constructors.
                </para>
                <para>
                    The first set of methods we document are those used
                    by <classname>CTreeVariable</classname> to mimic
                    a <type>double</type>L
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeVariableProperties&amp; </type>
                                <methodname>operator=</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>value</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeVariableProperties&amp; </type>
                                <methodname>operator=</methodname>
                                <methodparam>
                                   <modifier>const </modifier>
                                   <type>CTreeVariableProperties&amp; </type><parameter>rhs</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeVariableProperties&amp; </type>
                                <methodname>operator=</methodname>
                                <methodparam>
                                   <modifier>const </modifier>
                                   <type>CTreeVariable&amp; </type><parameter>rhs</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Assigns the <parameter>rhs</parameter> or its
                                value to the value of the object.
                                Returning a reference to the object supports
                                assignment chaining.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type></type>
                                <methodname>operator double</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the value of the object.  This
                                allows the object to be treated like
                                a <type>double</type> for many purposes.
                            </para>
                        </listitem>
                    </varlistentry>
                  </variablelist>
                    <para>
                        The next set of methods are used to query various
                        aspects of the object:
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term>
                                <methodsynopsis>
                                    <modifier></modifier>
                                    <type>bool    </type>
                                    <methodname>definitionChanged</methodname>
                                    <void />
                                    <modifier></modifier>
                                </methodsynopsis>
                            </term>
                            <listitem>
                                <para>
                                    Returns <literal>true</literal> if the
                                    definition has changed either since construction
                                    or since the change flags were reset last.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <methodsynopsis>
                                    <modifier></modifier>
                                    <type>std::string  </type>
                                    <methodname>getName</methodname>
                                    <void />
                                    <modifier></modifier>
                                </methodsynopsis>
                            </term>
                            <listitem>
                                <para>
                                    Returns the name of the variable.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <methodsynopsis>
                                    <modifier></modifier>
                                    <type>std::string  </type>
                                    <methodname>getUnits</methodname>
                                    <void />
                                    <modifier></modifier>
                                </methodsynopsis>
                            </term>
                            <listitem>
                                <para>
                                    Returns the units of measure associated
                                    with the variable.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <methodsynopsis>
                                    <modifier></modifier>
                                    <type>bool    </type>
                                    <methodname>valueChanged</methodname>
                                    <void />
                                    <modifier></modifier>
                                </methodsynopsis>
                            </term>
                            <listitem>
                                <para>
                                    Returns <literal>true</literal> if the
                                    value of the object was changed either since
                                    it was constructed or since the flag
                                    that keeps track of this was last reset.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                    <para>
                        These methods perform actions on the object:
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term>
                                <methodsynopsis>
                                    <modifier></modifier>
                                    <type>void    </type>
                                    <methodname>setUnits</methodname>
                                    <methodparam>
                                       <modifier></modifier>
                                       <type>std::string </type><parameter>units</parameter>
                                    </methodparam>
                                    <modifier></modifier>
                                </methodsynopsis>
                            </term>
                            <listitem>
                                <para>
                                    Sets the units of measure for the object
                                    to <parameter>units</parameter>.  This
                                    also sets the definition modified flag
                                    to <literal>true</literal>.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <methodsynopsis>
                                    <modifier></modifier>
                                    <type>void    </type>
                                    <methodname>resetDefinitionChanged</methodname>
                                    <void />
                                    <modifier></modifier>
                                </methodsynopsis>
                            </term>
                            <listitem>
                                <para>
                                    Resest the definition changed flag to
                                    <literal>false</literal>.
                                    Normally this is done after finding the
                                    flag was <literal>true</literal> and
                                    taking appropriate action.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <methodsynopsis>
                                    <modifier></modifier>
                                    <type>void    </type>
                                    <methodname>fireTraces</methodname>
                                    <void />
                                    <modifier></modifier>
                                </methodsynopsis>
                            </term>
                            <listitem>
                                <para>
                                    Calls <function>Tcl_UpdateLinkedVar</function>
                                    to ensure the Tcl variable is updated and traces are fired.
                                    for that variable.  This is necessary after
                                    changes have been made to the value and the
                                    variable is quiescent again.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <methodsynopsis>
                                    <modifier></modifier>
                                    <type>void    </type>
                                    <methodname>Link</methodname>
                                    <methodparam>
                                       <modifier></modifier>
                                       <type>CTCLInterpreter&amp; </type><parameter>rInterp</parameter>
                                    </methodparam>
                                    <modifier></modifier>
                                </methodsynopsis>
                            </term>
                            <listitem>
                                <para>
                                    Actually links the data in this object
                                    to the Tcl variable of the same name.  The
                                    current value of the variable is refreshed
                                    so that the Tcl variable is assured to be
                                    have the same value as the object's
                                    value prior to this method call.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                    
            </refsect1>
        </refentry>
        <refentry >
            <refmeta>
                <refentrytitle >CTreeVariableArray</refentrytitle>
                <manvolnum>3SpecTcl</manvolnum>
            </refmeta>
            
            <refnamediv>
                <refname>CTreeVariableArray</refname>
                <refpurpose>Container for an array of tree variables.</refpurpose>
            </refnamediv>
            
            <refsynopsisdiv>
                    <synopsis>
#include &lt;TreeParameter.h&gt;

class <classname>CTreeVariableArray</classname>
{
public:
  CTreeVariableArray();
  CTreeVariableArray(std::string baseName, double initialValue, 
		     std::string units, UInt_t size, int firstIndex = 0);
  CTreeVariableArray(const CTreeVariableArray&amp; rhs);
  
  void Initialize(std::string baseName, double initialValue, 
		  std::string units, UInt_t size, Int_t firstElement);

  CTreeVariable&amp; operator[](Int_t index);
  CTreeVariableArray&amp; operator=(const CTreeVariableArray&amp; rhs);
  
  UInt_t size();
  Int_t  firstIndex();
};
                    </synopsis>
            </refsynopsisdiv>
            
            <refsect1>
                <title>DESCRIPTION</title>
                <para>
                    Objects of type <classname>CTreeVariableName</classname>
                    are built to act programmatically like arrays of tree
                    parameters with identical definitions and a common base name.
                    Tree variables in a tree variable name are given names
                    of the form <replaceable>basename.n</replaceable>
                    where <replaceable>n</replaceable> is a multidigit
                    fixed length number.  
                </para>
                <para>
                    The number of digits is chosen so
                    that the largest index will fit.  The use of fixed
                    sized integers makes sorting with alphabetic keys work properly
                    for these indices. For example, a tree variable with 16
                    elements starting at element zero and with a base name
                    of tv, will have names <literal>tv.00</literal>,
                    <literal>tv.01</literal>... <literal>tv.15</literal>.
                </para>
                <para>
                    
                </para>
            </refsect1>
            
            <refsect1>
                <title>METHODS</title>
                <para>
                    The first set of methods we're going to document are
                    associated with construction and initialization.
                    A tree parameter array can be constructred in either one
                    or two steps. 
                </para>
                <para>
                    One step construction uses one of the parameterized constructors.
                    Two step construction uses the default constructor and
                    the special <methodname>Initialize</methodname> method.
                    <methodname>Initialize</methodname> should be invoked prior
                    to the completion of initialization so that the variables
                    are properly bound.  If this is not done, the variables
                    that make up the object will need to be bound manually
                    after <methodname>Initialize</methodname> has been
                    called.
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <constructorsynopsis>
                                <methodname>CTreeVariableArray</methodname>
                                <void />
                            </constructorsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Default constructor.  After this is called,
                                initialization must be completed by invoking
                                <methodname>Initialize</methodname>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <constructorsynopsis>
                                <methodname>CTreeVariableArray</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>baseName</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>initialValue</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>units</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>size</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>int </type><parameter>firstIndex</parameter>
                                   <initializer>0</initializer>
                                </methodparam>
                            </constructorsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Full one-step construction.  <parameter>baseName</parameter>
                                is the base name for the variables this creates.
                                <parameter>initialValue</parameter> is the value
                                initially given to all of the created variables.
                                <parameter>units</parameter> will be the units of measure.
                                The array will have <parameter>size</parameter>
                                elements and the first index will be
                                <parameter>firstIndex</parameter>.
                            </para>
                        </listitem>
                    </varlistentry>                  
                    <varlistentry>
                        <term>
                            <constructorsynopsis>
                                <methodname> CTreeVariableArray</methodname>
                                <methodparam>
                                   <modifier>const</modifier>
                                   <type> CTreeVariableArray&amp;</type><parameter> rhs</parameter>
                                </methodparam>
                            </constructorsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Copy construction creates a copy of the
                                array that can be used in pass by value
                                parmeters in function/method calls.
                                The <literal>const</literal>  The
                                copy is a copy in name only as the
                                resulting tree variables will be bound to the
                                same Tcl variables as the original.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void</type>
                                <methodname>Initialize</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>baseName</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>double </type><parameter>initialValue</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type><parameter>units</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t </type><parameter>size</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>int </type><parameter>firstIndex</parameter>
                                   <initializer>0</initializer>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Performs the second step in two phase initialization.
                                The first was performed by invoking the default
                                constructor.
                            </para>
                        </listitem>
                    </varlistentry>        
                </variablelist>
                <para>
                    The remaining methods are methods associated with the
                    ability to treat <classname>CTreeVariableArray</classname>
                    objects like arrays:
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeVariable&amp; </type>
                                <methodname>operator[]</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>Int_t </type><parameter>index</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                The indexing operator returns a reference to the
                                tree variable at the specified
                                <parameter>index</parameter>. Note again
                                that the object's initial index may be
                                non zero.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTreeVariableArray&amp; </type>
                                <methodname>operator=</methodname>
                                <methodparam>
                                   <modifier>const </modifier>
                                   <type>CTreeVariableArray&amp; </type><parameter>rhs</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Assigns to the object from
                                <parameter>rhs</parameter>.  Note that
                                because of how tree variables work, the left
                                and right hand sides of the assignment will
                                then refer to the same underlying tree variables
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>UInt_t </type>
                                <methodname>size</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the number of elements in the array.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>Int_t  </type>
                                <methodname>firstIndex</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the lowest legal index value for
                                the array.  This will be the
                                value of the
                                <parameter>firstIndex</parameter> parameter
                                to the costructor or the call to
                                <methodname>Initialize</methodname> or,
                                if the object was assignedvia
                                <methodname>operator=</methodname> the
                                number of elements in the right hand
                                side tree variable
                            </para>
                        </listitem>
                    </varlistentry>
      
  
  
                </variablelist>
            </refsect1>
        </refentry>
        
    </part>
    <part>
        <title>Tcl++ classes</title>
        <chapter>
            <title>
                Tcl++ classes
            </title>
            <para>
                The Tcl++ class library is an object oriented wrapper on
                libtcl, the Tcl API.  It can be used either as an application
                framework, to create new specialized interpreters (SpecTcl
                does this), or as a library for existing applications and
                extensions.
            </para>
            <para>
                This manual section (3tcl++) provides documentation for the
                classes in the library.  The main base classes are:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        <classname>CTCLInterpreter</classname> wraps an
                        interpreter with methods to manipulate it.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <classname>CTCLInterpreterObject</classname>
                        wraps a Tcl API object along with its interpreter
                        and the appropriate methods to manipulate it.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <classname>CTCLObject</classname> wraps a
                        <type>Tcl_Obj*</type> in an object oriented shell.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <classname>CTCLObjectProcessor</classname> wraps a
                        command processor that uses the
                        <type>Tcl_Obj</type> array interface.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <classname>CTCLProcessor</classname> wraps a
                        command processor that uses the old argc/argv
                        interface.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <classname>CTCLVariable</classname> wraps a Tcl
                        variable.  
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                Several other classes either extensions of theses or
                utility classes in their own right are defined.
            </para>
        </chapter>

<refentry id="manpage.CTCLInterpreter">
    <refmeta>
        <refentrytitle id='manpage.CTCLInterpreter.title'>CTCLInterpreter</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLInterpreter</refname>
        <refpurpose>
            Encapsulate a Tcl interpreter.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;TCLInterpreter.h&gt;

class CTCLInterpreter
{
public:
  CTCLInterpreter ();
  CTCLInterpreter (Tcl_Interp* am_pInterpreter  );

  Tcl_Interp* getInterpreter()
  std::string Eval (const char* pScript) ;
  std::string Eval(const CTCLString&amp; rScript);
  std::string Eval(const std::string&amp; rScript);
  std::string EvalFile (const char* pFilename)   ;
  std::string EvalFile(const CTCLString&amp; rFilename);
  std::string EvalFile(const std::string&amp; rFilename);

  std::string GlobalEval (const char* pScript)   ;
  std::string GlobalEval (const CTCLString&amp; rScript) ;
  std::string GlobalEval(const std::string&amp; rScript) ;

  std::string RecordAndEval (const char* pScript, Bool_t fEval=kfFALSE);
  std::string RecordAndEval(const CTCLString&amp; rScript,
                            Bool_t fEval=kfFALSE);
  std::string RecordAndEval(const std::string&amp; rScript,
                            Bool_t fEval = kfFALSE);

  std::string ExprString (const char* pExpression)   ;
  std::string ExprString(const CTCLString&amp; rExpr);
  std::string ExprString(const std::string&amp; rExpr);

  Long_t ExprLong (const char* pExpression)   ;
  Long_t ExprLong (std::string&amp; rExpression);
  Long_t ExprLong (const CTCLString&amp; rExpr);

  DFloat_t ExprDouble (const char* pExpression)   ;
  DFloat_t ExprDouble (const CTCLString&amp; rExpression);
  DFloat_t ExprDouble(const std::string&amp; rExpression);

  Bool_t ExprBoolean (const char*  pExpression)   ;
  Bool_t ExprBoolean (const CTCLString&amp; rExpression);
  Bool_t ExprBoolean(const std::string&amp; rExpression);

  std::string TildeSubst (const char* pFilename) const  ;
  std::string TildeSubst (const CTCLString&amp; rName) const;
  std::string TildeSubst (const std::string&amp; rName) const;
  std::string EvalFile (const char* pFilename)   ;
  std::string EvalFile(const CTCLString&amp; rFilename);
  std::string EvalFile(const std::string&amp; rFilename);

  std::string GlobalEval (const char* pScript)   ;
  std::string GlobalEval (const CTCLString&amp; rScript) ;
  std::string GlobalEval(const std::string&amp; rScript) ;

  std::string RecordAndEval (const char* pScript, Bool_t fEval=kfFALSE);
  std::string RecordAndEval(const CTCLString&amp; rScript,
                            Bool_t fEval=kfFALSE);
  std::string RecordAndEval(const std::string&amp; rScript,
                            Bool_t fEval = kfFALSE);

  std::string ExprString (const char* pExpression)   ;
  std::string ExprString(const CTCLString&amp; rExpr);
  std::string ExprString(const std::string&amp; rExpr);

  Long_t ExprLong (const char* pExpression)   ;
  Long_t ExprLong (std::string&amp; rExpression);
  Long_t ExprLong (const CTCLString&amp; rExpr);

  DFloat_t ExprDouble (const char* pExpression)   ;
  DFloat_t ExprDouble (const CTCLString&amp; rExpression);
  DFloat_t ExprDouble(const std::string&amp; rExpression);

  Bool_t ExprBoolean (const char*  pExpression)   ;
  Bool_t ExprBoolean (const CTCLString&amp; rExpression);
  Bool_t ExprBoolean(const std::string&amp; rExpression);

  std::string TildeSubst (const char* pFilename) const  ;
  std::string TildeSubst (const CTCLString&amp; rName) const;
  std::string TildeSubst (const std::string&amp; rName) const;
  Tcl_Interp* operator-&gt; ();
  operator Tcl_Interp* ();
  
  
  void setResult(const char* resultString);
  void setResult(std::string resultString);
  void setResult(Tcl_Obj*    resultObj);
  void setResult(CTCLObject&amp; resultObj);

};



    </programlisting>
    </refsynopsisdiv>


    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <classname>CTCLInterpreter</classname>
            encapsulates a <type>Tcl_Interp*</type> in an object.
            Method invocations on that object provide access to many of the
            Tcl interpreter. See METHODS below for more information about htis.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            <function>CTCLInterpreter () </function>
        </para>
        <para>
            <function>CTCLInterpreter</function> (
                <type>Tcl_Interp</type>* <parameter>pInterp</parameter>)
        </para>
        <para>
            Constructs an interpreter object.  The first form of this
            constructor creates a new <type>Tcl_Interp*</type> using
            <function>Tcl_CreateInterp()</function> and wraps the object
            around it.  All members of the object will operate on that
            newly created interpreter.  The second form, wraps an object
            around <parameter>pInterp</parameter>,
            a previously created <type>Tcl_Interp*</type>.
            Note that in either case on destruction, <function>Tcl_DeleteInterp()</function>
            is called on the wrapped interpreter.
        </para>
        <para>
            <type>Tcl_Interp</type>* <function>getInterpreter</function>()
        </para>
        <para>
            Returns the interpreter that is being wrapped by this object.
            This interpreter can be used as an <parameter>interp</parameter>
            parameter for any <function>Tcl_xxxxxx</function> call in the Tcl
            API.
        </para>
        <para>
            <programlisting>
<type>std::string</type> <function>Eval</function>(<type>const char</type>* <parameter>pScript</parameter>) ;
<type>std::string</type> <function>Eval</function>(<type>const CTCLString</type>&amp; <parameter>rScript</parameter>);
<type>std::string</type> <function>Eval</function>(<type>const std::string</type>&amp; <parameter>rScript</parameter>);
            </programlisting>
        </para>
        <para>
            Evaluates the script passed as a parameter.  The only differences between
            these functions is the form of the script parameter.  Each function will
            return the result of the script.  If there is an error in the script,
            a <classname>CTCLException</classname> will be thrown that will describe
            what happened.  For example:
            <programlisting>
    std::string commands;
    CTCLInterpreter interp;     // New intepreter.
    ...
    // after commands has been built up:

    string result
    try {
        result = interp.Eval(commands);
        cout &lt;&lt; "Eval of " &lt;&lt; commands &lt;&lt; " was "
             &lt;&lt;  result &lt;&lt; endl;
    }
    catch (CTCLException &amp;e) {
        cerr &lt;&lt; "Eval of " &lt;&lt; commands &lt;&lt; " failed: "
             &lt;&lt; e.ReasonText() &lt;&lt; endl;
    }
    // If no exception, result is usable as the output of the eval.

            </programlisting>
        </para>
        <para>
        <programlisting>
  <type>std::string</type> <function>EvalFile</function>(<type>const char</type>* <parameter>pFilename</parameter>)   ;
  <type>std::string</type> <function>EvalFile</function>(<type>const CTCLString</type>&amp; <parameter>rFilename</parameter>);
  <type>std::string</type> <function>EvalFile</function>(<type>const std::string</type>&amp; <parameter>rFilename</parameter>);
        </programlisting>
        </para>
        <para>
            Sources the specified file in and executes it as a script in the interpreter that
            is wrapped by the object.  The only difference between these functions is
            how the name of the file is passed.  The return value is the script result.
            A <classname>CTCLException</classname> will be thrown in the event the script
            reports an error.  See the example in
            <classname>CTCLInterpreter</classname>::<function>Eval</function>
            to see how to catch and report this kind of exception.
        </para>
        <para>
            <programlisting>
  <type>std::string</type> <function>GlobalEval</function>(<type>const char</type>* <parameter>pScript</parameter>);
  <type>std::string</type> <function>GlobalEval</function>(<type>const CTCLString</type>&amp; <parameter>rScript</parameter>);
  <type>std::string</type> <function>GlobalEval</function>(<type>const std::string</type>&amp; <parameter>rScript</parameter>);
            </programlisting>
        </para>
        <para>
            This function evaluates a script at the global level.  Note that
            <classname>CTCLInterpreter</classname>::<function>Eval</function>,
            and <classname>CTCLInterpreter></classname>::<function>EvalFile</function>
            evaluates the script at whatever call level the interpreter is currently
            executing at.
            The only difference between the methods above is how the script is passed.
            The functions all return the interpreter result after the script executes.
            If the script reports an error, a <classname>CTCLException</classname> will
            be thrown.
        </para>
        <para>
            <programlisting>
  <type>std::string</type> <function>RecordAndEval</function> (<type>const char</type>* <parameter>pScript</parameter>,
                       <type>Bool_t</type> <parameter>fEval</parameter>=<literal>kfFALSE</literal>);
  <type>std::string</type> <function>RecordAndEval</function>(<type>const CTCLString</type>&amp; <parameter>rScript</parameter>,
                       <type>Bool_t</type> <parameter>fEval</parameter>=<literal>kfFALSE</literal>);
  <type>std::string</type> <function>RecordAndEval</function>(<type>const std::string</type>&amp; <parameter>rScript</parameter>,
                      <type>Bool_t</type> <parameter>fEval</parameter>=<literal>kfFALSE</literal>);
            </programlisting>
        </para>
        <para>
            Records a script in the Tcl interpreter history and, if <parameter>fEval</parameter>
            is <literal>kfTRUE</literal>, evaluates it as well.  The
            return value is the interpreter result, which is only meaningful if the
            script was evalutated.  If the script reports an error, a
            <classname>CTCLException</classname> is thrown.
        </para>
        <para>
            <programlisting>
  <type>std::string</type> <function>ExprString</function>(<type>const char</type>* <parameter>pExpression</parameter>);
  <type>std::string</type> <function>ExprString</function>(<type>const CTCLString</type>&amp; <parameter>rExpr</parameter>);
  <type>std::string</type> <function>ExprString</function>(<type>const std::string</type>&amp; <parameter>rExpr</parameter>);
            </programlisting>
        </para>
        <para>
            Evaluates an expression (as if with the <command>expr</command>
            Tcl command), and returns the result
            of the evaluation as a string.  If the expression has an error,
            a <classname>CTCLException</classname> will be thrown.
            The only difference between these functions is how the expression is passed.
        </para>
        <para>
            <programlisting>
  <type>Long_t</type> <function>ExprLong</function>(<type>const char</type>* <parameter>pExpression</parameter>)   ;
  <type>Long_t</type> <function>ExprLong</function>(<type>std::string</type>&amp; <parameter>rExpression</parameter>);
  <type>Long_t</type> <function>ExprLong</function>(<type>const CTCLString</type>&amp; <parameter>rExpr</parameter>);
            </programlisting>
        </para>
        <para>
            Evaluates an expression (as if with the <command>expr</command>
            Tcl command).  If the result
            can be converted into an integer, it is returned as a <type>Long_t</type>.
            If the expression either cannot be converted to an integer (e.g. it's a non-numerical
            expression), or if the expression contains an error, a <classname>CTCLException</classname>
            will be
            thrown.
        </para>
        <para>
            <programlisting>
  <type>DFloat_t</type> <function>ExprDouble</function>(<type>const char</type>* <parameter>pExpression</parameter>)   ;
  <type>DFloat_t</type> <function>ExprDouble</function>(<type>const CTCLString</type>&amp; <parameter>rExpression</parameter>);
  <type>DFloat_t</type> <function>ExprDouble</function>(<type>const std::string</type>&amp; <parameter>rExpression</parameter>);
            </programlisting>
        </para>
        <para>
            Evaluates the parameter as an expression (as if with the <command>expr</command> Tcl command).
            If the result can be converted to a floating point value it is returned as
            the function value.  If not, or if there is an error in the expression,
            a <classname>CTCLException</classname> is thrown.
        </para>
        <para>
            <programlisting>
  <type>Bool_t</type> <function>ExprBoolean</function>(<type>const char</type>*  <parameter>pExpression</parameter>)   ;
  <type>Bool_t</type> <function>ExprBoolean</function>(<type>const CTCLString</type>&amp; <parameter>rExpression</parameter>);
  <type>Bool_t</type> <function>ExprBoolean</function>(<type>const std::string</type>&amp; <parameter>rExpression</parameter>);
            </programlisting>
        </para>
        <para>
            Evaluates the parameter as an expression (as if with the <command>expr</command>
            Tcl command).  If the result can be interpreted as a boolean, it is returned
            as the function value.  If not, or if there is an error in the expression,
            a <classname>CTCLException</classname> is thrown.
        </para>
        <para>
            <programlisting>
  <type>std::string</type> <function>TildeSubst</function>(<type>const char</type>* <parameter>pFilename</parameter>) const  ;
  <type>std::string</type> <function>TildeSubst</function>(<type>const CTCLString</type>&amp; <parameter>rName</parameter>) const;
  <type>std::string</type> <function>TildeSubst</function>(<type>const std::string</type>&amp; <parameter>rName</parameter>) const;
            </programlisting>
        </para>
        <para>
            Performs tilde substitution on its parameter.   Tilde substitution means that leading
            &#152; characters are expanded to the current user's home directory path, while
            a leading &#152; followed by a word that is a username will be expanded to the
            home directory path of that user.  The expanded value is returned.
            Note thatthe use of this member is deprecated as the underlying Tcl library
            function is also deprecated.
        </para>
        <para>
        <programlisting>
  <type>Tcl_Interp</type>* <function>operator-&gt;</function>();
  <function>operator Tcl_Interp* </function>();
        </programlisting>
        </para>
        <para>
            These two functions allow objects that are <classname>CTCLInterpreter</classname>
            objects to be treated as if they were <type>Tcl_Interp*</type>'s.
            <function>operator-&gt;</function> supports dereferncing to fields of the
            wrapped interpreter (note that this is now deprecated within Tcl itself).
            <function>operator Tcl_Interp*</function> supports dynamic type conversion from
            a <classname>CTCLInterpreteter</classname> object and a <type>Tcl_Interp*</type>
            pointer.
        </para>
        <programlisting>
  <type>void</type>
  <function>setResult</function>(<type>const char*</type> <parameter>resultString</parameter>)            
  <type>void</type>
  <function>setResult</function>(<type>std::string</type> <parameter>resultString</parameter>);
  <type>void</type>
  <function>setResult</function>(<type>Tcl_Obj*</type>    <parameter>resultObj</parameter>);
  <type>void</type>
  <function>setResult</function>(<type>CTCLObject&amp;</type> <parameter>resultObj</parameter>);
        </programlisting>
        <para>
            This set of overloaded methods sets the result of the interpreter.
            The result is the value returned by a command on success or an
            error message on failure.
        </para>
    </refsect1>
    <refsect1>
        <title>DEFECTS</title>
        <para>
            It is not possible to avoid destroying the interpreter when the
            object is destroyed.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
        CTCLException, CTCLApplication, CTCLChannel, CTCLCommandPackage,
        CTCLFileHandler, CTCLList, CTCLObject, CTCLObjectProcessor, CTCLTimer,
        CTCLVariable
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLInterpreterObject">
    <refmeta>
        <refentrytitle>CTCLInterpreterObject </refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLInterpreterObject</refname>
        <refpurpose>
            Base class for objects that are associated with a Tcl Interpreter.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <programlisting>
#include &lt;CTCLInterpreterObject.h&gt;
...
class CTCLInterpreterObject
{
public:
  CTCLInterpreterObject ();
  CTCLInterpreterObject (CTCLInterpreter* pInterp );
  CTCLInterpreterObject (const CTCLInterpreterObject&amp; src );

  CTCLInterpreterObject&amp; operator=
                        (const CTCLInterpreterObject&amp; rhs);
  int operator== (const CTCLInterpreterObject&amp; rhs) const;


  CTCLInterpreter* getInterpreter() const;
  CTCLInterpreter* Bind (CTCLInterpreter&amp; rBinding);
  CTCLInterpreter* Bind (CTCLInterpreter* pBinding);

};


        </programlisting>

    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <classname>CTCLInterpreterObject</classname>
            is a base class for any object that requires a <type>CTCLInterpreter</type>
            (Tcl interpreter) to operate.  Almost  all objects in the Tcl++ library are
            derived from this base class.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            <function>CTCLInterpreterObject()</function>
        </para>
        <para>
            Constructor for an interpreter object that will be bound to an underlying
            interpreter at a later time.  See the <function>Bind</function> functions
            for more information about binding interpreters. More normally, if you
            already have an interpreter you will construct using that interpreter.
        </para>
        <para>
            <function>CTCLInterpreterObject</function>
                       (<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>)
        </para>
        <para>
            Constructs a <classname>CTCLInterpreterObject</classname> given
            that <parameter>pInterp</parameter> is an existing
            interpreter encapsulated in a <classname>CTCLInterpreter</classname>.
        </para>
        <para>
            <function>CTCLInterpreterObject</function>
                    (<type>const CTCLObject</type>&amp; <parameter>src</parameter>)
        </para>
        <para>
            Constructs a new <classname>CTCLInterpreterObject</classname>
            that is an exact copy of <parameter>src</parameter>.
        </para>
        <para>
            <classname>CTCLInterpreterObject</classname>&amp;
            <function>operator=</function>
                (const <type>CTCLInterpreterObjectd</type>&amp; <parameter>rhs</parameter>)
        </para>
        <para>
            Provides a mechanism for assigning a <classname>CTCLInterpreterObject</classname>
            a copy of the <parameter>rhs</parameter> <classname>CTCLInterpreterObject</classname>.
            The return value is just a reference to the left hand side of the assignment.  This
            permits operator chaining.
        </para>
        <para>
            <type>int</type> <function>operator==</function>(
                            const <type>CTCLInterpreterObject</type>&amp; rhs)
        </para>
        <para>
            Compares a <classname>CTCLInterpreterObject</classname> to another
            (<parameter>rhs</parameter>).  If the underlying interpreters are the
            same, the objects are said to be equal and <literal>1</literal> is
            returned.  If not, <literal>0</literal> is returned.
        </para>
        <para>
            <type>CTCLInterpreter</type>* <function>getInterpreter</function>() const
        </para>
        <para>
            Returns a pointer to the underlying <classname>CTCLInterpreter</classname>
            object.  See the <classname>CTCLInterpreter</classname>(3) manpage for
            more information about the services offered by that class.
        </para>
        <para>
            <type>CTCLInterpreter</type>* <function>Bind</function>(
                        <type>CTCLInterpreter</type>&amp; <parameter>rBinding</parameter>
                                                          )
        </para>
        <para>
            <type>CTCLInterpeter</type>* <function>Bind</function>(
                        <type>CTCLInterpreter</type>* <parameter>pBinding</parameter>)
        </para>
        <para>
            Binds the object to a new interpreter.  Typically this will only be
            called when the object was constructed without an initial interpreter.
            This is because most objects really are related to some interpreter and cannot
            be willy-nilly rebound.  The return value is  a pointer to the
            <classname>CTCLInterpreter</classname> the object was previously
            bound to.  This will be <literal>NULL</literal> if the object was not
            initially bound.
        </para>
    </refsect1>
    <refsect1>
        <title>DEFECTS</title>
        <para>
            No <function>operator!=</function> was defined.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
        CTCLInterpreter, CTCLApplication, CTCLChannel, CTCLCommandPackage,
        CTCLFileHandler, CTCLList, CTCLObject, CTCLObjectProcessor, CTCLTimer,
        CTCLVariable
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLResult">
    <refmeta>
        <refentrytitle>CTCLResult</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLResult</refname>
        <refpurpose>
            Provide an object oriented interace to the Tcl interpreter result.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLResult.h&gt;
...
class CTCLResult  : public CTCLObject
{
  CTCLResult (CTCLInterpreter* pInterp, bool reset=true );
  CTCLResult (const CTCLResult&amp; aCTCLResult );
  virtual ~CTCLResult ( );

  CTCLResult&amp; operator= (const CTCLResult&amp; aCTCLResult);
  CTCLResult&amp; operator= (const char* rhs);
  CTCLResult&amp; operator=(std::string    rhs);

  int operator== (const CTCLResult&amp; aCTCLResult) ;
  int operator!= (const CTCLResult&amp; rhs);

  CTCLResult&amp; operator+= (const char* pString);
  CTCLResult&amp; operator+= (const std::string&amp; rString);

  void Clear ()  ;
  void AppendElement (const char* pString)  ;
  void AppendElement (const std::string&amp; rString);
  void commit() const;
  std::string getString();
};

    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Each Tcl command can return <firstterm>result string</firstterm>
            the result string can be used by subsequent commands in the event
            the command operated successfully, or by <command>catch</command>
            commands if the command failed.  <classname>CTCLResult</classname>
            provides an extension of the <classname>CTCLObject</classname>
            class that builds up a string which can then be comitted to the
            result.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
<function>CTCLResult</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
           <type>bool</type> <parameter>reset</parameter>=<literal>true</literal> );
<function>CTCLResult</function>(const <type>CTCLResult</type>&amp; <parameter>aCTCLResult</parameter>);
          </programlisting>
          </para>
          <para>
            Constructs a Tcl interpreter result string.  <parameter>pInterp</parameter> is the interpeter
            that will be associated with this result. <parameter>reset</parameter> controls
            whether or not the result string is reset when constructed, or if it is loaded
            with the current value of the result string.  In the case of copy construction,
            the interpreter associated with <parameter>aCTCLResult</parameter> is used.
            <parameter>aCTCLResult</parameter> is committed to the interpreter result, and
            the object under construction is then loaded from that interpreter's result.
          </para>
          <para>
          <programlisting>
  <type>CTCLResult</type>&amp; <function>operator=</function> (const <type>CTCLResult</type>&amp; <parameter>rhs</parameter>);
  <type>CTCLResult</type>&amp; <function>operator=</function> (const <type>char</type>* <parameter>rhs</parameter>);
  <type>CTCLResult</type>&amp; <function>operator=</function>(<type>std::string</type>    <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            Assigns a value to the result from <parameter>rhs</parameter>.
            If the <parameter>rhs</parameter> is a <classname>CTCLResult</classname>, then the
            <parameter>rhs</parameter> is first committed to its interpreter result,
            the left hand object is then bound to the same interpreter as <parameter>rhs</parameter>
            and loaded with the result string of that interpreter.
        </para>
        <para>
        <programlisting>
  <type>int</type> <function>operator==</function> (const <type>CTCLResult</type>&amp; <parameter>rhs</parameter>) ;
  <type>int</type> <function>operator!=</function> (const <type>CTCLResult</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            These functions suport comparison. Equality comparison is true
            (<function>operator==</function>) if the interpreters match as the assumption
            is that the user is working to maintain coherency if several <classname>CTCLResult</classname>
            objects are simultaneously live on a single interpreter.
            Inequality (<function>operator!=</function>) is defined as true when
            <function>operator==</function> is false.
        </para>
        <para>
        <programlisting>
<type>CTCLResult</type>&amp; <function>operator+=</function> (const <type>char</type>* <parameter>rhs</parameter>);
<type>CTCLResult</type>&amp; <function>operator+=</function>(const <type>std::string</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            <parameter>rhs</parameter> is textually appended to the result string being built
            up.   Note that the semantics of this are different than for the base class
            where <function>operator+=</function> is a list append.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>Clear</function>()  ;
          </programlisting>
          </para>
          <para>
            Clears the result string being built up as well as clearing the
            underlying interpreter's result.
          </para>
          <para>
          <programlisting>
  <type>void</type> <function>AppendElement</function>(const <type>char</type>* <parameter>item</parameter>)  ;
  <type>void</type> <function>AppendElement</function>(const <type>std::string</type>&amp; <parameter>item</parameter>);
          </programlisting>
          </para>
          <para>
            Appends <parameter>item</parameter> to the result string being built up as a
            list element.  This means that under some circumstances extra quoting may be
            done to ensure that the result will be maintained as a valid list.
          </para>
          <para>
          <programlisting>
  <type>void</type> <function>commit</function>() const;
  <type>std::string</type> <function>getString</function>();
        </programlisting>
        </para>
        <para>
            <function>commit</function> sets the interpreter result string equal
            to the string being built up in the object.  <function>getString</function>
            does a commit and then returns the string.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLObject(3)
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLException">
    <refmeta>
        <refentrytitle>CTCLException</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLException</refname>
        <refpurpose>
            Class for reporting exceptional conditions in Tcl applications
            via the C++ try/catch mechanism.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLException.h&gt;
...
class CTCLException  : public CTCLInterpreterObject ,public CException
{
public:
  CTCLException (CTCLInterpreter&amp; am_rInterpreter,
                 Int_t am_nReason,
                 const char* pString);
  CTCLException(CTCLInterpreter&amp; am_rInterpreter,
                Int_t am_nReason,
                const std::string&amp; rString);
  CTCLException (const CTCLException&amp; aCTCLException );
  virtual ~CTCLException ( );

  CTCLException operator= (const CTCLException&amp; aCTCLException);
  int operator== (const CTCLException&amp; aCTCLException);

  void AddErrorInfo (const char* pMessage)  ;
  void AddErrorInfo(const std::string&amp; rMessage);
  void AddErrorInfo(const CTCLString&amp; rMessage);

  void SetErrorCode (const char* pMessage,
                     const char* pMnemonic="???",
                     const char* pFacility="TCL",
                     const char* pSeverity="FATAL")  ;
  void SetErrorCode(const std::string rMessage,
                    const std::string &amp;rMnemonic=std::string("???"),
                    const std::string &amp;rFacility=std::string("TCL"),
                    const std::string &amp;rSeverity=std::string("FATAL"));

  virtual   const char* ReasonText () const;
  virtual   Int_t ReasonCode () const  ;
};

    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The <classname>CTCLException</classname> class allows you to
            instantiate and throw exceptions that are distinguishable as coming
            from the TCL library and its extensions.   In most cases the
            TclPlus library itself will convert error conditions detected by the
            Tcl API and intantiate and throw an appropriate exception.
        </para>
        <para>
            The following example shows how to execute code that is aware of
            these exceptions.  In this case, the code just reports the error
            message and continues.
            <informalexample>
            <programlisting>
    try {
        // In here is TclPlus invoking code.
    }
    catch (CTCLException&amp; e) {
        cerr &lt;&lt; "TclPlus error caught: " &lt;&lt; e.ReasonText() &lt;&lt; endl;
    }
            </programlisting>
            </informalexample>
        </para>
        <para>
            The following example shows a typical code segment that throws a
            <classname>CTCLException</classname>:
                <programlisting>
    int status = Tcl_xxxxxxx(pInterp-&gt;getInterpreter()....); // Some Tcl call.
    if (status != TCL_OK) {
        throw CTCLException(*pInterp, status,
                            "Call to Tcl_xxxxxx returned an error");
    }
                </programlisting>
        </para>
        <para>
            Note that constructing a <classname>CTCLException</classname> object
            incorporates the Tcl result string at the time into the
            text returned by the <function>ReasonText()</function> member function.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
  <function>CTCLException</function> (<type>CTCLInterpreter</type>&amp; <parameter>rInterpreter</parameter>,
                 <type>Int_t</type> <parameter>nReason</parameter>,
                 const <type>char</type>* <parameter>pString</parameter>);
  <function>CTCLException</function>(<type>CTCLInterpreter</type>&amp; <parameter>rInterpreter</parameter>,
                <type>Int_t</type> <parameter>nReason</parameter>,
                const <type>std::string</type>&amp; <parameter>rString</parameter>);
  <function>CTCLException</function> (const <type>CTCLException</type>&amp; <parameter>aCTCLException</parameter> );
        </programlisting>
        </para>
        <para>
            These construct a <classname>CTCLException</classname>.
            <parameter>rInterpreter</parameter> is a reference to the intepreter that was
            used in the operation that resulted in the error.  The result string of that
            interpreter will be saved as part of the text returned by the
            <function>ReasonText</function> member function.
        </para>
        <para>
            The <parameter>nReason</parameter> is a reason for the exception.  Typically
            this will be <literal>TCL_ERROR</literal> however other error codes can be
            created and used for application specific problems.  This is the value that will
            be returned by the <function>ReasonCode</function> member function.
        </para>
        <para>
            <parameter>rString</parameter> and <parameter>pString</parameter> are intended to provide
            information about the context of the error, and will be incorporated into the
            text strin greturned from <function>ReasonText</function>.
        </para>
        <para>
            <parameter>aCTCLException</parameter> is a reference for the sourc object of
            the copy constructor.
        </para>
        <para>
        <programlisting>
  <type>CTCLException</type> <function>operator=</function> (const <type>CTCLException</type>&amp; <parameter>rhs</parameter>);
  <type>int</type> <function>operator==</function>(const <type>CTCLException</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            These two functions provide a mechanism to assign exceptions and to compare
            them for equality.  <parameter>rhs</parameter> is the object that is the source
            of the assignment or the object to which <varname>this</varname> is being compared.
            Equality is defined as the two exceptions having the same underlying interpreter,
            and same reason text.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>AddErrorInfo</function> (const <type>char</type>* <parameter>pMessage</parameter>)  ;
  <type>void</type> <function>AddErrorInfo</function>(const <type>std::string</type>&amp; <parameter>rMessage</parameter>);
  <type>void</type> <function>AddErrorInfo</function>(const <type>CTCLString</type>&amp; <parameter>rMessage</parameter>);
        </programlisting>
        </para>
        <para>
            These functions are wrapperf ro the API function <function>Tcl_AddErrorInfo</function>
            the <parameter>pMessage</parameter>, and <parameter>rMessage</parameter>
            parameters provide the message that is added to the <parameter>errorInfo</parameter>
            variable.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>SetErrorCode</function> (const <type>char</type>* <parameter>pMessage,</parameter>
                     const <type>char</type>* <parameter>pMnemonic</parameter>=<literal>"???"</literal>,
                     const <type>char</type>* <parameter>pFacility</parameter>=<literal>"TCL"</literal>,
                     const <type>char</type>* <parameter>pSeverity</parameter>=<literal>"FATAL"</literal>)  ;
  <type>void</type> <function>SetErrorCode</function>(const <type>std::string</type> <parameter>rMessage</parameter>,
                    const <type>std::string</type>&amp; <parameter>rMnemonic</parameter>=<type>std::string</type>(<literal>"???"</literal>),
                    const <type>std::string</type>&amp; <parameter>rFacility</parameter>=<type>std::string</type>(<literal>"TCL"</literal>),
                    const <type>std::string</type>&amp; <parameter>rSeverity</parameter>=<type>std::string</type>(<literal>"FATAL</literal>"));
        </programlisting>
        </para>
        <para>
            These function set the <varname>errorCode</varname> Tcl interpreter variable.
            The convention these function support is to set the error code to a list that
            consists of a message (<parameter>pMessage</parameter> and <parameter>rMessage</parameter>,
            mnemonic for the message (<parameter>pMnemonic</parameter> or <parameter>rMnemonic</parameter>, the
            Facility (<parameter>pFacility</parameter> or <parameter>rFacility</parameter>)that is throwing
            the error and the severity (<parameter>pSeverity</parameter> or <parameter>rSeverity</parameter>)
            of the error.
        </para>
        <para>
            <programlisting>
virtual   const <type>char</type>* <function>ReasonText</function> () const;
virtual   <type>Int_t</type> <function>ReasonCode</function> () const  ;
        </programlisting>
        </para>
        <para>
            These two functions are intended for use by exception catch blocks.
            <function>ReasonText</function> provides human readable text that
            describes the exception.  <function>ReasonCode</function> provides a
            numerical code that describes the exception.  Often this just has the
            value <literal>TCL_ERROR</literal>
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
Tcl_AddErrorInfo(3tcl),
Tcl_SetErrorCode(3tcl)
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLObjectProcessor">
    <refmeta>
        <refentrytitle>CTCLObjectProcessor</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLObjectProcessor</refname>
        <refpurpose>
            Abstract base class to encapsulate the Tcl object command interface exposed by
            <function>Tcl_CreateObjCommand</function>.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLObjectProcessor.h&gt;
...
class CTCLObjectProcessor : public CTCLInterpreterObject
{
public:
  CTCLObjectProcessor(CTCLInterpreter&amp; interp,
                      std::string      name,
                      bool             registerMe=true);
  virtual ~CTCLObjectProcessor();

  void Register();              // Register command on the interpreter.
  void unregister();            // Unregister command from the interp.
  std::string getName() const;  // Return the name of the object.
  Tcl_CmdInfo getInfo() const;  // Return info about the command.

protected:
  virtual int operator()(CTCLInterpreter&amp; interp,
                         std::vector&lt;CTCLObject&gt;&amp; objv) = 0;
  virtual void onUnregister();

protected:
  void bindAll(CTCLInterpreter&amp; interp, std::vector&lt;CTCLObject&gt;&amp; objv);
  void requireAtLeast(std::vector&gt;CTCLObject&lt;&amp; objv, unsigned n, const char* msg=0) const;
  void requireAtMost(std::vector&lt;CTCLObject&gt;&amp; objv, unsigned n, const char* msg=0) const;
  void requireExactly(std::vector&lt;CTCLObject&gt;&amp; objv, unsigned n, const char* msg=0) const;



};

    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Tcl supports the addition of commands to the interpreter.  <classname>CTCLObjectProcessor</classname>
            supports an object oriented encapsulation of this part of the API.
            To add a command to an interpreter, write a subclass of
            <classname>CTCLObjectProcessor</classname>.  This subclass should override
            <function>operator()</function>, and optionally <function>onUnregister</function>.
            to implement the desired behavior for the new command.
        </para>
        <para>
            Create an instance of this new class and invoke its
            <function>Register</function>
            member to add it to the interpreter onto which it is bound.  Whenever a
            script executes the new command that object's
            <function>operator()</function> is invoked to process the command.
            If the interpreter is destroyed, or if the command is ever unregistered,
            the <function>onUnregister</function> function is called to perform any
            required global cleanup.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
<function>CTCLObjectProcessor</function>(<type>CTCLInterpreter</type>&amp; <parameter>interp</parameter>,
                    <type>std::string</type>      <parameter>name</parameter>,
                    <type>bool</type>             <parameter>registerMe</parameter>=<literal>true</literal>);

        </programlisting>
        </para>
        <para>
            Constructs a new command processor.  <parameter>interp</parameter> is the
            interpreter on which the command will be registered when the
            <function>Register</function> member is invoked.
            <parameter>name</parameter> is the name of the command.
            If <parameter>registerMe</parameter> is not supplied or is supplied but is
            <literal>true</literal>, the command will be registered as part of the construction process.
            If <parameter>registerMe</parameter> is supplied and is <literal>false</literal>,
            the command is not immediately added, and <function>Register</function> must
            be called later to incorporate it into the interpreter.
        </para>
        <para>
        <programlisting>
<type>void</type> <function>Register</function>();
<type>void</type> <function>unregister</function>();
        </programlisting>
        </para>
        <para>
            <function>Register</function> incorporates the command into the
            interpreter.  If the command is already registered, a
            <classname>CStateException</classname> is thrown.
        </para>
        <para>
            <function>unRegister</function> removes the command from the interpreter.
            This causes <function>onUnregister</function> to be called.
            if the command is registered at destruction time, destruction implies a call
            to <function>unRegister</function> (and therefore <function>onUnregister</function>).
        </para>
        <para>
        <programlisting>
<type>std::string</type> <function>getName</function>() const;
<type>Tcl_CmdInfo</type> <function>getInfo</function>() const;
        </programlisting>
        </para>
        <para>
            <function>getName</function> returns the name of the command
            that will invoke this object's <function>operator()</function>.
            If the command has been registered, and subsequently renamed at the
            script level, this function will reflect the rename.
        </para>
        <para>
            <function>getInfo</function> returns information about the command
            see <function>Tcl_GetCommandInfo</function> for more information about
            what is returned and what it means.
        </para>
        <para>
        <programlisting>
virtual <type>int</type> <function>operator()</function>(<type>CTCLInterpreter</type>&amp; <parameter>interp</parameter>,
                       <type>std::vector&lt;CTCLObject&gt;</type>&amp; <parameter>objv</parameter>) = 0;
        </programlisting>
        </para>
        <para>
            This pure virtual function must be overridden in concrete object command processors.
            The function is called to execute the command that this object is performing.
            <parameter>interp</parameter> provides a reference to the interpreter on which
            the command is being run. <parameter>objv</parameter> is a reference to a
            <type>std::vector&lt;CTCLObject&gt;</type>.
            Each element of <parameter>objv</parameter> is a <classname>CTCLObject</classname>
            containing a word of the command line that invoked us.
        </para>
        <para>
            The function should return <literal>TCL_OK</literal> on success and
            <literal>TCL_ERROR</literal> on failure.  Other return values are possible
            for e.g. commands that implement new control structures however this is beyond
            the scope of this manpage.  If the command processor wants to make a result
            available to the interpreter, it can create a <classname>CTCLResult</classname>
            object, fill it in and commit it.
        </para>
        <para>
        <programlisting>
virtual void onUnregister();
        </programlisting>
        </para>
        <para>
            This function is called when the interpreter is being destroyed or if the
            command is being unregistered either due to object destruction or a call to
            <function>unregister</function>.  The default behavior is to do nothing, but
            this can be overidden in your derived class if desired.
        </para>
        <programlisting>
void bindAll(CTCLInterpreter&amp; interp, std::vector&lt;CTCLObject&gt;&amp; objv);            
        </programlisting>
        <para>
            This is a convenience method for derived classes.  It binds the
            interpreter to all of the elements of the
            <parameter>objv</parameter> vector.  Several of the methods of
            <classname>CTCLObject</classname> require that an interpreter
            be bound.
        </para>
        <programlisting>
void requireAtLeast(std::vector&gt;CTCLObject&lt;&amp; objv, unsigned n, const char* msg=0) const;            
        </programlisting>
        <para>
            Utility method.  Throws an <classname>std::string</classname>
            exception if the <parameter>objv</parameter> vector does
            not have at least <parameter>n</parameter> elements.
            If <parameter>msg</parameter> is provided (non Null pointer),
            that string is incorporated in the exception string.
        </para>
        <programlisting>
void requireAtMost(std::vector&lt;CTCLObject&gt;&amp; objv, unsigned n, const char* msg=0) const;            
        </programlisting>
        <para>
            If <parameter>objv</parameter> has more than
            <parameter>n</parameter> elements, an
            <classname>std::string</classname> exception is thrown.  If
            <parameter>msg</parameter> is provided (not a null
            pointer) it is incorprorated into the exception string.
        </para>
        <programlisting>
void requireExactly(std::vector&lt;CTCLObject&gt;&amp; objv, unsigned n, const char* msg=0) const;            
        </programlisting>
        <para>
            If the <parameter>objv</parameter> vector does not have exactly
            <parameter>n</parameter> elements, an <classname>std::string</classname>
            exception is thrown.  If <parameter>msg</parameter> is supplied
            (not a null pointer), the exception string will incorporate it.
            
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLCompatibilityProcessor(3),
CTCLInterpreter(3),
CTCLInterpreterObject(3),
CTCLObject(3),
CTCLProcessor(3),
CTCLResult(3),
Tcl_CreateObjCommand(3tcl),
Tcl_GetCommandInfo(3tcl)
        </para>
    </refsect1>
</refentry>
<refentry id="manpage.CTCLProcessor">
    <refmeta>
        <refentrytitle>CTCLProcessor</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLProcessor</refname>
        <refpurpose>
            Provide <parameter>argc</parameter>, <parameter>argv</parameter>
            extension commands to Tcl.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLProcessor.h&gt;
...
class CTCLProcessor : public CTCLInterpreterObject
{
public:
  CTCLProcessor(const std::string sCommand, CTCLInterpreter* pInterp);
  CTCLProcessor(const char*       pCommand, CTCLInterpreter* pInterp);
  virtual ~CTCLProcessor();

  std::string getCommandName() const;

  virtual int operator()(CTCLInterpreter&amp; rInterpreter,
                         CTCLResult&amp;      rResult,
                         int argc, char** argv) = 0;
  virtual void OnDelete();

  void Register();
  void Unregister();

  static  std::string ConcatenateParameters (int nArguments,
                                              char* pArguments[])  ;
  int ParseInt (const char* pString, int* pInteger)  ;
  int ParseInt (const std::string&amp; rString, int* pInteger)

  int ParseDouble (const char* pString, double* pDouble)  ;
  int ParseDouble (const std::string&amp; rString, double* pDouble)

  int ParseBoolean (const char* pString, Bool_t* pBoolean)  ;
  int ParseBoolean (const std::string&amp; rString, Bool_t* pBoolean)

  static int MatchKeyword(std::vector&lt;std::string&gt;&amp; MatchTable,
                          const std::string&amp; rValue,
                          int NoMatch = -1);


};

    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <parameter>Do not use this for new commands</parameter>.  Use
            <classname>CTCLObjectProcessor</classname> instead.
        </para>
        <para>
            The <classname>CTCLProcessor</classname> provides a compatibility
            interface to the old Tcl style <parameter>argc</parameter>,
            <parameter>argv</parameter> style of command extension.
            New commands should be written using the
            <classname>CTCLObjectProcessor</classname> class instead.
        </para>
        <para>
            To extend the interpreter using this mechanism, you must
            derive a class from <classname>CTCLProcessor</classname> and
            minimally override and implement its
            <function>operator()</function> pure virtual function.  You may optionally
            overrid its <function>OnDelete</function> member as well.
            Having written the class, you must create an object of that class and
            register it on an interpreter.  Once the class is registered,
            invocations of the command under which it was registered will
            invoke your <function>operator()</function>.
        </para>
        <para>
            If the interpreter is destroyed or the object destroyed, or unregistered,
            the <function>OnDelete</function> member will be called.
            <classname>CTCLProcessor</classname> defines and implements this function
            with an empty body, so it is only necessary for you to override and implement
            this if you have some cleanup actions that must be done when the command is
            deleted.
        </para>
        <para>
            This class is now implemented in terms of a <classname>CTCLObjectProcessor</classname>
            derived class called a <classname>CTCLCompatibilityProcessor</classname>. It is
            less efficient to use this class than to use a class derived directly from a
            <classname>CTCLObjectProcessor</classname>.  This class is therefore not
            recommended for use with new extensions, but is only provided for
            compatibility with existing extensions written before
            <classname>CTCLObjectProcessor</classname> was developed.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
<function>CTCLProcessor</function>(const <type>std::string</type> <command>sCommand</command>,
             <type>CTCLInterpreter</type>* <parameter>pInterp</parameter>);
<function>CTCLProcessor</function>(const <type>char</type>*       <parameter>pCommand</parameter>,
             <type>CTCLInterpreter</type>* <parameter>pInterp</parameter>);
        </programlisting>
        </para>
        <para>
            Constructs a <classname>CTCLProcessor</classname>.  <parameter>sCommand</parameter>
            or <parameter>pCommand</parameter> are the initial name of the command.
            Note that the Tcl interpreter supports command renaming at the script level,
            so there is no gaurentee that this will always be the name of the command.
            <parameter>pInterp</parameter> is the interpreter on which the command
            will be registered when the <function>Register</function> function is called.
        </para>
        <para>
        <programlisting>

<type>std::string</type> <function>getCommandName</function>() const;
        </programlisting>
        </para>
        <para>
            Returns the initial name of the command.  Unlike
            <classname>CTCLObjectCommand</classname>::<function>getName</function>()
            this function does not track changes in the command name.
        </para>
        <para>
        <programlisting>

virtual <type>int</type> <function>operator</function>()(<type>CTCLInterpreter</type>&amp; <parameter>rInterpreter</parameter>,
                       <type>CTCLResult</type>&amp; <parameter>rResult</parameter>,
                       <type>int</type> <parameter>argc</parameter>,
                       <type>char</type>** <parameter>argv</parameter>) = 0;
virtual <type>void</type> <function>OnDelete</function>();
        </programlisting>
        </para>
        <para>
            <function>operator()</function> is a pure virtual function and therefore must
            be overidden and implemented in concrete command implementations.
            <parameter>rInterpreter</parameter> is a reference to the interpreter that is
            executing this command. <parameter>rResult</parameter> is a reference to
            a <classname>CTCLResult</classname> object that represents the result of the
            interpreter.  Any text stored into this object will be made available to the
            interpreter as the result of the command. <parameter>argc</parameter>
            and <parameter>argv</parameter> are the number of words on the command line and
            a pointer to an array of pointers to the command words respectively.
        </para>
        <para>
            <function>operator()</function> should be written to return
            <literal>TCL_OK</literal>
            if it is successful and
            <literal>TCL_ERROR</literal>
            if it encounters an error.   Other return values are possible and meaningful
            for commands that implement flow of control structures, but documenting these
            is beyond the scope of this manpage.   See the return(3tcl) manpage for
            more information about these.
        </para>
        <para>
            <function>OnDelete</function> is called whenever the interpreter
            or the object is being
            destroyed, or the object's <function>Unregister</function> function has been
            called.  <classname>CTCLProcessor</classname> provides a default implementation
            for <function>OnDelete</function> which does nothing.  It is only necessary
            to override and implement this function if you require specific action when
            the command is being unregistered.
        </para>
        <para>
        <programlisting>
<type>void</type> <function>Register</function>();
<type>void</type> <function>Unregister</function>();
        </programlisting>
        </para>
        <para>
            These functions register and unregister the command with the intepreter
            respectively.
        </para>
        <para>
        <programlisting>
static  <type>std::string</type> <function>ConcatenateParameters</function>(<type>int</type> <parameter>nArguments</parameter>,
                                           <type>char</type>* <parameter>pArguments</parameter>[])  ;
        </programlisting>
        </para>
        <para>
            Concatenates all of the <parameter>nArguments</parameter>
            words in the <parameter>pArguments</parameter> array into a <type>std::string</type>
            and returns it.  The words are space separated.
        </para>
        <para>
        <programlisting>
<type>int</type> <function>ParseInt</function>(const <type>char</type>* <parameter>pString</parameter>,
             <type>int</type>* <parameter>pInteger</parameter>)  ;
<type>int</type> <function>ParseInt</function>(const <type>std::string</type>&amp; <parameter>rString</parameter>,
             <type>int</type>* <parameter>pInteger</parameter>)
        </programlisting>
        </para>
        <para>
            Parses the character string <parameter>pString</parameter> or <parameter>rString</parameter>
            as a 32 bit signed integer into <parameter>pInteger</parameter>.  Returns
            <literal>TCL_OK</literal>
            if successful, or
            <literal>TCL_ERROR</literal>
            if the string coult no be parsed.  In that case, the result string
            of the interpreter will report why the string could not be parsed.
        </para>
        <para>
        <programlisting>
<type>int</type> <parameter>ParseDouble</parameter>(const <type>char</type>* <parameter>pString</parameter>,
                <type>double</type>* <parameter>pDouble</parameter>)  ;
<type>int</type> <function>ParseDouble</function>(const <type>std::string</type>&amp; <parameter>rString</parameter>,
                <type>double</type>* <parameter>pDouble</parameter>)
        </programlisting>
        </para>
        <para>
            Parses the input string, either <parameter>pString</parameter> or
            <parameter>rString</parameter>
            as a double precision floating point value, storing the result in the
            double pointed to by <parameter>pDouble</parameter>.
            On success,
            <literal>TCL_OK</literal>
            is returned.  On failure,
            <literal>TCL_ERROR</literal> and the interpreter result is
            a textual reason for the failure.
        </para>
        <para>
        <programlisting>
<type>int</type> <function>ParseBoolean</function>(const <type>char</type>* <parameter>pString</parameter>,
                 <type>Bool_t</type>* <parameter>pBoolean</parameter>)  ;
<type>int</type> <function>ParseBoolean</function>(const <type>std::string</type>&amp; <parameter>rString</parameter>,
                 <type>Bool_t</type>* <function>pBoolean</function>)
        </programlisting>
        </para>
        <para>
            Parses either <parameter>pString</parameter>
            or <parameter>rString</parameter> as a boolean value.  The result
            is stored in boolean pointed to by <parameter>pBoolean</parameter>.
            <literal>TCL_OK</literal>
            is returned on success,
            <literal>TCL_ERROR</literal>
            on error.  If <literal>TCL_ERROR</literal> was returned, the interpreter
            result is the textual reason for the failure.
        </para>
        <para>
        <programlisting>
static <type>int</type> <function>MatchKeyword</function>(<type>std::vector&lt;std::string&gt;</type>&amp; <parameter>MatchTable</parameter>,
                        const <type>std::string</type>&amp; <parameter>rValue</parameter>,
                        <type>int</type> <parameter>NoMatch</parameter> = <literal>-1</literal>);
        </programlisting>
        </para>
        <para>
            Searches for the string <parameter>rValue</parameter> in the vector of strings
            <parameter>MatchTable</parameter>, and returns the index in the vector at which
            the match occured.  If no match could be found, the value
            <parameter>NoMatch</parameter> is returned.
        </para>
        <para>
            Within SpecTcl, this is often used to match command switches.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLCompatibilityProcessor(3),
CTCLObjectProcessor(3),
CTCLPackagedCommand(3),
CTCLResult(3),
return(3tcl)
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLCompatibilityProcessor">
    <refmeta>
        <refentrytitle>CTCLCompatibiltyProcessor</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLCompatibilityProcessor</refname>
        <refpurpose>
            Adaptor between <classname>CTCLOjbectProcessor</classname>
            and <classname>CTCLProcessor</classname>.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLCompatibilityProcessor.h&gt;
...
class CTCLCompatibilityProcessor : public CTCLObjectProcessor
{

public:

  CTCLCompatibilityProcessor(CTCLProcessor&amp; actualCommand);
  virtual ~CTCLCompatibilityProcessor();

  virtual int operator()(CTCLInterpreter&amp; interp,
                         std::vector&lt;CTCLObject&gt;&amp; objv);
  virtual void onUnregister();
};

    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Note that the information on this page is only to be used to
            "grandfather" old <classname>CTCLProcessor</classname> objects
            into Tcl.  New command processors should be based on the
            CTCLObjectProcessor.
        </para>
        <para>
            A rewrite of the TCL++ library in March 2006 eliminated the use of
            Tcl functions that are scheduled to be deprecated in the known future
            of Tcl.    One set of functions scheduled for deprecation are those
            that revolve around direct access to the Tcl interpreter result, and
            command processors that use the <parameter>argc</parameter>,
            <parameter>argv</parameter> interfaces.
        </para>
        <para>
            Since a number of existing command extensions are, no doubt built on
            top of the <classname>CTCLProcessor</classname> <parameter>argc</parameter>
                                                            <parameter>argv</parameter>
            interface, a mechanism that allows the use of existing commands was built
            as well.
        </para>
        <para>
            The current implementation of a <classname>CTCLProcessor</classname> includes
            as member data a <classname>CTCLCompatibilityProcessor</classname> object.
            This object registers itself as a <classname>CTCLObjectProcessor</classname>
            for the command intended by the <classname>CTCLProcessor</classname> and
            serves as an adaptor between these two command types, marshalling command
            objects into an <parameter>argc</parameter>, <parameter>argv</parameter> pair,
            creating and committing a <classname>CTCLResult</classname> object.
        </para>
        <para>
            For most users of this library, this is completely transparent, this documentation
            is provided for completeness, however.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
<function>CTCLCompatibilityProcessor</function>(<type>CTCLProcessor</type>&amp; <parameter>actualCommand</parameter>);
        </programlisting>
        </para>
        <para>
            Constructs a  compatibility processor that adapts the object based command
            interface for <parameter>actualCommand</parameter>.  <parameter>actualCommand</parameter>
            must already be bound to an interpreter.
        </para>
        <para>
        <programlisting>
virtual <type>int</type> <function>operator()</function>(<type>CTCLInterpreter</type>&amp; <parameter>interp</parameter>,
                       <type>std::vector&lt;CTCLObject&gt;</type>&amp; <parameter>objv</parameter>);
        </programlisting>
        </para>
        <para>
            Called when the command is executed.  <parameter>objv</parameter> is marshalled
            into an argc, argv pair.  A <classname>CTCLResult</classname> is created and the
            actual command's <function>operator()</function> is called to execute the command.
            On return, the result is committed, and all dynamic storage released prior to
            returning the status from the command processor.
        </para>
        <para>
        <programlisting>
virtual <type>void</type> <function>onUnregister</function>();
        </programlisting>
        </para>
        <para>
            Called when the command is unregistered.  The actual command's <function>OnDelete</function>
            member is called.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLObject(3),
CTCLObjectProcessor(3),
CTCLProcessor(3),
CTCLResult(3),
        </para>
    </refsect1>
    <refsect1>
        <title>REFERENCES</title>
        <para>
            <programlisting>
Gamma, Helm, Johnson, Vlissides <parameter>Design Patterns Elements of Reusable
Object-Oriented Software</parameter>
Addison-Wesley Professional Computing Series 1995 ISBN 0-0201-63361-2
See Chapter 4 the Adapter pattern.
            </programlisting>
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLCommandPacakge">
    <refmeta>
        <refentrytitle>CTCLCommandPackage</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLCommandPackage</refname>
        <refpurpose>
            Group several related Tcl command extensions and common services they
            may require together.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLCommandPackage.h&gt;
...
typedef std::list &lt;CTCLProcessor*&gt;   CommandList;
typedef CommandList::iterator  CommandListIterator;

class CTCLCommandPackage  : public CTCLInterpreterObject
{

public:
  CTCLCommandPackage (CTCLInterpreter* pInterp,
                      const std::string&amp; rSignon=std::string("Unnamed pkg"));
  CTCLCommandPackage(CTCLInterpreter* pInterp,
                     const char* pSignon = "Unnamed pkg");
  virtual ~ CTCLCommandPackage ( );
  CTCLCommandPackage (const CTCLCommandPackage&amp; aCTCLCommandPackage );
  CTCLCommandPackage&amp; operator= (const CTCLCommandPackage&amp; aCTCLCommandPackage);
  int operator== (const CTCLCommandPackage&amp; aCTCLCommandPackage);

  std::string getSignon() const;
  CommandList getCommandList() const;
protected:
  void setSignon (std::string am_sSignon);

public:
  void Register ()  ;
  void Unregister ()  ;
  void AddProcessor (CTCLProcessor* pProcessor);
  void AddProcessors(CommandList&amp; rList);
  CommandListIterator begin ();
  CommandListIterator end ();
};
    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Extensions to Tcl often come in a set of related commands.  These commands
            may require access to a common set of services.  The <classname>CTCLCommandPackage</classname>
            along with the <classname>CTCLPackagedCommand</classname> provide a pair of base
            classes that facilitate the construction of such commands.
        </para>
        <para>
            The pattern to follow to derive class from <classname>CTCLCommandPackage</classname>
            This class defines and implements common services for the related commands.
            The constructor of the derived class will also create instances of
            classes derived from <classname>CTCLPackagedCommand</classname>.  These objects
            define and implement the related commands.  These command processors will be
            added to the package via <function>AddProcessor</function>, and
            <function>AddProcessors</function>.
        </para>
        <para>
            When the <classname>CTCLCommandPackage</classname>::<function>Register</function>
            function is called, all of the commands added to the package will be
            registered as well.  When a command processor is invoked, it can call its
            <function>getMyPackage</function> member function to obtain a pointer to the
            owning package and therefore access to the services this package provides.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
  <function>CTCLCommandPackage</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
                      <type>const std::string</type>&amp; <parameter>rSignon</parameter>=<type>std::string</type>(<literal>"Unnamed pkg"</literal>));
  <function>CTCLCommandPackage</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
                     <type>const char</type>* <parameter>pSignon</parameter> = <literal>"Unnamed pkg"</literal>);
  <function>CTCLCommandPackage</function> (<type>const CTCLCommandPackage</type>&amp; <parameter>aCTCLCommandPackage</parameter> );
        </programlisting>
        </para>
        <para>
            Constructs instances of the package.  <parameter>pInterp</parameter> is a pointer
            to the interpreter object on which these commands will be registered.
            <parameter>signon</parameter> is a text string that will be emitted to
            <literal>stderr</literal> when the package is asked to register its commands.
            This string is typically a credit or copyright notice for the package.  It can
            be empty if the user desires.
        </para>
        <para>
            The first and second form of the constructor only differ in how the signon message
            is passed.  The final form of the constructor is a copy constructor.  While
            copy construction is legal it is anticipated that this will not normally be used
            as command packages are usually <firstterm>singleton</firstterm> objects.
        </para>
        <para>
        <programlisting>
  <type>std::string</type> <function>getSignon</function>() const;
        </programlisting>
        </para>
        <para>
            Retrieves the signon string from the current object.
        </para>
        <para>
            <programlisting>
  <type>CommandList</type> <function>getCommandList</function>() const;
            </programlisting>
        </para>
        <para>
            Retrieves the list of commands that are managed by this package.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>setSignon</function> (<type>std::string</type> <parameter>am_sSignon</parameter>);
        </programlisting>
        </para>
        <para>
            Allows derived classes to set the signon string after construction is complete.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>Register</function> ()  ;
  <type>void</type> <function>Unregister</function> ()  ;
        </programlisting>
        </para>
        <para>
            <function>Regsiter</function> registers all of the commands in the package
            with the package's interpreter.  <function>Unregister</function> unregisters
            these commands.  It is therefore not advisable to change the set of commands in
            the package between registration and unregistration.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>AddProcessor</function>(<type>CTCLProcessor</type>* <parameter>pProcessor</parameter>);
  <type>void</type> <function>AddProcessors</function>(<type>CommandList</type>&amp; <parameter>rList</parameter>);
        </programlisting>
        </para>
        <para>
            These functions add command processors to the package.  Any type of processor
            can be added to the package, however usually <classname>CTCLPackagedCommand</classname>
            derived objects are in order to provide a mechanism to access the package services.
            <parameter>pProcessor</parameter> is a pointer to a single processor while
            <parameter>rList</parameter> is a reference to a list of such processors.
        </para>
        <para>
        <programlisting>
  <type>CommandListIterator</type> <function>begin</function> ();
  <type>CommandListIterator</type> <function>end</function> ();
        </programlisting>
        </para>
        <para>
            Returns STL list iterators to the beginning and off the end of the
            set of command packages.
            List iterators behave roughly like pointers.  In this case, pointers
            to <classname>CTCLProcessor*</classname>.   Incrementing an interator
            'points' it to the next item in the list.  A full discussion of STL iterators
            is well beyond the scope of this man page.  See references below.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLProcessor(3), CTCLPackagedCommand(3)
        </para>
    </refsect1>
    <refsect1>
        <title>References</title>
        <para>
        <programlisting>
Musser, Derge, Saini: <parameter>STL Tutorial and Reference Guide</parameter>
Addison-Wesley Professional Computing Series; 2001 ISBN 0-201-37923-6
        </programlisting>
        </para>
    </refsect1>
</refentry>


<refentry id="manpage.CTCLPackagedCommand">
    <refmeta>
        <refentrytitle>CTCLPackagedCommand</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLPackagedCommand</refname>
        <refpurpose>
            Base class for a command that lives in a <classname>CTCLCommandPackage</classname>
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLPackagedCommand.h&gt;
...
class CTCLPackagedCommand   : public CTCLProcessor
{

  CTCLPackagedCommand (const std::string&amp; sCommand, CTCLInterpreter* pInterp,
                       CTCLCommandPackage&amp; rPackage);
  CTCLPackagedCommand (const char* pCommand, CTCLInterpreter* pInterp,
                       CTCLCommandPackage&amp; rPackage);
   ~ CTCLPackagedCommand ( );

  CTCLCommandPackage&amp; getMyPackage();

  void setMyPackage (CTCLCommandPackage&amp; am_rMyPackage);

};
    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Command packages (see CTCLCommandPackage(3)), provide a way to organize
            a set of related Tcl command processors  around a set of shared services.
            Objects derived from <classname>CTCLPackagedCommand</classname> are added
            to an object derived from <classname>CTCLCommandPackage</classname>.
            The <classname>CTCLCommandPackage</classname> manages bulk registration of
            all of the commands added to it.  Construcint a
            <classname>CTCLPackagedCommand</classname> object provides it a
            reference to its package so
            that public members of the package can be invoked when the package commands
            are executing.
        </para>
        <para>
            Note that since <classname>CTCLPackagedCommand</classname> is derived from
            <classname>CTCLProcessor</classname>, and does not supply a <function>operator()</function>
            You must derive concrete classes from this class implementing
            <function>operator()</function> to provide the desired command functionality.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
  <function>CTCLPackagedCommand</function> (const <type>std::string</type>&amp; <parameter>sCommand</parameter>,
                       <type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
                       <type>CTCLCommandPackage</type>&amp; <parameter>rPackage</parameter>);
  <function>CTCLPackagedCommand></function> (const <type>char</type>* <parameter>pCommand</parameter>,
                       <type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
                       <type>CTCLCommandPackage</type>&amp; <parameter>rPackage</parameter>);
        </programlisting>
        </para>
        <para>
            Constructs a packaged command.
            <parameter>sCommand</parameter> or
            <parameter>pCommand</parameter>
            provide the command name.  <parameter>pInterp</parameter> is a pointer to the
            interpreter on which the command will be registered.
            <parameter>rPackage</parameter> is a reference to the package this object will
            be a member of.
        </para>
        <para>
            <programlisting>

<type>CTCLCommandPackage</type>&amp; <function>getMyPackage()</function>;
            </programlisting>
        </para>
        <para>
            Returns a reference to the object's package.  This can be cast to the
            actual type of the package at which point package public members can be
            accessed.
        </para>
        <para>
            <programlisting>
  <type>void</type> <function>setMyPackage</function> (<type>CTCLCommandPackage</type>&amp; <parameter>rMyPackage</parameter>);
        </programlisting>
        </para>
        <para>
            Provides a new package for the command.
        </para>
        <para>
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLCommandPackage(3),
CTCLProcessor(3)
        </para>
    </refsect1>
</refentry>


<refentry id="manpage.CTCLVariable">
    <refmeta>
        <refentrytitle>CTCLVariable</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLVariable</refname>
        <refpurpose>
            Encapsulate Tcl interpreter variables.
        </refpurpose>
    </refnamediv>

<refsynopsisdiv>
<programlisting>
#include &lt;TCLVariable.h&gt;
class <classname>CTCLVariable</classname>
{
  std::string getVariableName() const;
  Bool_t IsTracing() const;

  void setVariableName (const std::string am_sVariable);
  virtual   char*  operator() (char* pName,
                               char* pSubscript,
                               int Flags)  ;

   static  char* TraceRelay (ClientData pObject, Tcl_Interp* pInterpreter,
                             tclConstCharPtr  pName,
                             tclConstCharPtr pIndex,
                             int flags)  ;

  const char* Set (const char* pValue, int flags=TCL_LEAVE_ERR_MSG |
                                                 TCL_GLOBAL_ONLY)  ;
  const char* Set (const char* pSubscript, char* pValue,
                   int flags=TCL_LEAVE_ERR_MSG | TCL_GLOBAL_ONLY)  ;
  const char* Get (int flags=TCL_LEAVE_ERR_MSG | TCL_GLOBAL_ONLY,
                   char* pIndex=0)  ;
  int Link (void* pVariable, int Type)  ;
  void Unlink ()  ;
  int Trace (int flags=TCL_TRACE_READS | TCL_TRACE_WRITES | TCL_TRACE_UNSETS,
             char* pIndex = (char*)kpNULL)  ;

  void UnTrace ()  ;

};
</programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <classname>CTCLVariable</classname> allows an existing or new Tcl interpreter
            variable to be encapsulated so that it can be accessed, traced or linked
            in C++ code.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            <programlisting>
  <function>CTCLVariable</function>(<type>std::string</type> <parameter>sName</parameter>,
             <type>Bool_t</type> <parameter>fTracing</parameter>  );
  <function>CTCLVariable</function> (<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
             <type>std::string</type> <parameter>sName</parameter>,
             <type>Bool_t</type> <parameter>fTracing</parameter>  );
  <function>CTCLVariable</function> (<type>const CTCLVariable</type>&amp; <parameter>aCTCLVariable</parameter> );
            </programlisting>
        </para>
        <para>
            In the first two cases, <parameter>sName</parameter> is the name of the variable
            that will be wrapped by this object.  The variable name can contain namespace
            qualifications as well as indices.  If <parameter>fTracing</parameter> is true,
            the object is set to record that it is tracing the variable.  Normally
            this parameter should be allowed to default to <literal>kfFALSE</literal>,
            and the trace member functions used to set explicit traces.
            For the final form of the constructor (copy constructor),
            <parameter>aCTCLVariable</parameter> is a <classname>CTCLVariable</classname> that
            will be copied into this object.
        </para>
        <para>
            In the first form of the constructor, one must later call the
            <function>Bind</function> function (see CTCLInterpreterObject), to bind
            the variable to a specific interpreter prior to accessing it.
        </para>
        <para>
            <programlisting>
  <type>CTCLVariable</type>&amp; <function>operator=</function>(<type>const CTCLVariable</type>&amp; <parameter>rhs</parameter>);
            </programlisting>
        </para>
        <para>
            Assigns the <parameter>rhs</parameter> object to this one.  A reference to the
            left hand side of the assignment is returned.  The semantics of assignment are
            not that the variable values are assigned, but that the left side of the
            assignment becomes a functional equivalent of <parameter>rhs</parameter>,
            that is it stands for the same object and has the same traces (if any) set.
            Thus, if <parameter>rhs</parameter> wraps the interpreter variable <varname>a</varname>
            and the object on the left side wraps interpreter variable <varname>b</varname>
            after the assignment executes, the left side object will be wrapping
            <varname>a</varname>.
            A reference to the object on the left hand side of the assignment is returned.
        </para>
        <para>
            <programlisting>
  <type>int</type> <function>operator==</function>(<type>const CTCLVariable</type>&amp; <parameter>rhs</parameter>) const;
            </programlisting>
        </para>
        <para>
            Compares this object for functional equality with <parameter>rhs</parameter>.
            Functional equality is defined as the two objects referring to the same
            variable, in the same interpreter, and having traces set on the same
            operations.
        </para>
        <para>
            <programlisting>
  <type>std::string</type> <function>getVariableName</function>() const;
            </programlisting>
        </para>
        <para>
            Returns the name of the Tcl variable that is wrapped by this object.
        </para>
        <para>
            <programlisting>
<type>int</type> <function>Trace</function>(<type>int</type> <parameter>flags</parameter>=<literal>TCL_TRACE_READS | TCL_TRACE_WRITES | TCL_TRACE_UNSETS</literal>,
          <type>char</type>* <parameter>pIndex</parameter> = (<type>char</type>*)<literal>kpNULL</literal>)  ;
<type>void</type> <function>UnTrace</function> ()  ;
<type>Bool_t</type> <function>IsTracing</function>() const;
virtual <type>char</type>*  <function>operator()</function> (<type>char</type>* <parameter>pName</parameter>,
                        <type>char</type>* <parameter>pSubscript</parameter>,
                        <type>int</type> <parameter>Flags</parameter>)  ;
            </programlisting>
        </para>
        <para>
            This set of functions supports variable tracing.  In Tcl, a trace is a function
            that is called when some event of interest occurs on a varialbe.  The possible
            events are read, write, and unset.  To effectively use variable tracing, you
            must create a subclass of <classname>CTCLVariable</classname>, override its
            <function>operator()</function> member to handle the trace and call
            <function>Trace</function> to initiate tracing.
        </para>
        <para>
            The <function>Trace</function> member initiates tracing on the variable.
            <parameter>flags</parameter> describes when the trace should fire.
            See the manpage for <function>Tcl_TraceVar</function> for information about
            the legal flag values.
        </para>
        <para>
            <function>Untrace</function> cancels all traces on the variable represented by
            this object.
        </para>
        <para>
            <function>IsTracing</function> returns <literal>kfTRUE</literal> if tracing
            is being performed on the variable.
        </para>
        <para>
            When a trace fires, the <function>operator()</function> member will be called.
            This is why you must override the <classname>CTCLVariable</classname> base
            class to do anything useful with a trace.  The parameters to the
            call are; <parameter>pName</parameter> is the name of the variable that
            has been traced. <parameter>pSubscript</parameter> is the array subscript in the
            event the trace fires on an array or element of an array, and is
            <literal>NULL</literal> otherwise.  <parameter>Flag</parameter> describes
            why the trace fired.  Again, see the <function>Tcl_TraceVar</function>
            manpage for more information.
            Note that for write traces, the variable has already been set.  Modifying
            the value of the traced variable within a trace function will not fire any
            additional traces.
            The <function>operator()</function> function must return a <literal>NULL</literal>
            pointer if the trace is successful.  It must return a pointer to an error message
            if the trace is not successful.  An example of an unsuccessful trace might be
            a write trace that ensures that only particular values are assigned to the
            variable.
        </para>
        <para>
            <programlisting>
const <type>char</type>* <function>Set</function>(const <type>char</type>* <parameter>pValue</parameter>,
                <type>int</type> <parameter>flags</parameter>=<literal>TCL_LEAVE_ERR_MSG</literal> |
                          <literal>TCL_GLOBAL_ONLY</literal>)  ;
const <type>char</type>* <function>Set</function>(const <type>char</type>* <parameter>pSubscript</parameter>,
               <type>char</type>* <parameter>pValue</parameter>,
               <type>int</type> <parameter>flags</parameter>=<literal>TCL_LEAVE_ERR_MSG</literal> | <literal>TCL_GLOBAL_ONLY</literal>)  ;
            </programlisting>
        </para>
        <para>
            Sets the value of the variable to the string pointed to by <parameter>pValue</parameter>
            The second form of this assumes that the <classname>CTCLVariable</classname>
            represents an array and the <parameter>pSubscript</parameter> parameter
            specifies the subscript of the array that is being set.  The <parameter>flags</parameter>
            parameter is fully documented in the Tcl manpage for Tcl_SetVar
        </para>
        <para>
            <programlisting>
const <type>char</type>* <function>Get</function>(<type>int</type> <parameter>flags</parameter>=<literal>TCL_LEAVE_ERR_MSG</literal> | <literal>TCL_GLOBAL_ONLY</literal>,
              <type>char</type>* <parameter>pIndex</parameter>=<literal>0</literal>)  ;
            </programlisting>
        </para>
        <para>
            Retrieves the current value of a variable.  If the <parameter>pIndex</parameter>
            parameter is supplied, the variable wrapped by <classname>CTCLVariable</classname>
            is assumed to be an array and <parameter>pIndex</parameter> points to the subscript of the
            element to retrieve.  The <parameter>flags</parameter> parameter is fully
            documented in the Tcl_GetVar manpage.  The return value of the function is
            a null terminated character string that is the current value of the variable.
            If the variable does not exist, then a <literal>NULL</literal> is returned.
        </para>
        <para>
            <programlisting>
<type>int</type> <function>Link</function>(<type>void</type>* <parameter>pVariable</parameter>,
         <type>int</type> <parameter>Type</parameter>)  ;
<type>void</type> <function>Unlink</function>()  ;
            </programlisting>
        </para>
        <para>
            <function>Link</function> and <function>Unlink</function> support variable
            linking.  Variable linking is when a Tcl variable is made to track the value
            of a C/C++ variable or C++ member variable of an object.
            <function>Link</function> establishes the link.  <parameter>pVariable</parameter>
            points to the C or C++ variable or member variable to link to this
            <classname>CTCLVariable</classname>.  The <parameter>Type</parameter>
            parameter is one of following values:
            <literal>TCL_LINK_INT</literal>,
            <literal>TCL_LINK_DOUBLE</literal>,
            <literal>TCL_LINK_BOOLEAN</literal>,
            <literal>TCL_LINK_WIDE_INT</literal>, or
            <literal>TCL_LINK_STRING</literal> indicating the type of the variable
            to which <parameter>pVariable</parameter> points.  For all but
            <literal>TCL_LINK_STRING</literal>, <parameter>pVariable</parameter> points
            to a variable of the type indicated, and that variable will be linked.
            for <literal>TCL_LINK_STRING</literal>, <parameter>pVariable</parameter> points
            to a <type>char*</type> which should be initialized to point to <literal>NULL</literal>.
            The Tcl interpreter will use <function>Tcl_Alloc</function> and <function>Tcl_Free</function>
            to maintain a dynamically allocated string pointed to by that pointer which
            reflects the value of the variable.  If the C/C++ program modifies this string,
            it must <function>Tcl_Free</function> the prior value and <function>Tcl_Alloc</function>
            a new value with the new variable value.
        </para>
    </refsect1>
    <refsect1>
        <title>DEFECTS</title>
        <para>
            No <function>operator!=</function> has been defined.
        </para>
        <para>
            There is no protection against multiple links... the most recent link
            for an underlying Tcl variable is the one effective.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
        CTCLInterpreter(3), CTCLInterpreterObject(3),
        Tcl_GetVar(3tcl), Tcl_LinkVar(3tcl), Tcl_SetVar(3tcl), Tcl_TraceVar(3tcl)
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLApplication">
    <refmeta>
        <refentrytitle>CTCLApplication 3</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLApplication</refname>
        <refpurpose>
            Base class for TCL/Tk applications.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <programlisting>
#include &lt;tcl.h&gt;
#include &lt;TCLApplication.h&gt;
...
class CTCLApplication  : public CTCLInterpreterObject
{
public:
  CTCLApplication ();
  ~CTCLApplication ( );
  virtual   int operator() ()  =0;
  void      getProgramArguments(int&amp;, char**&amp; argv);
};
        </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <classname>CTCLApplication</classname> is an abstract base class
            that facilitates the creation of applications that extend the
            Tcl interpreter.  The `main program' of SpecTcl is derived from
            this class, for example.
        </para>
        <para>
            Initializing a Tcl application generallly consists of a bunch
            of boilerplate that initializes the interpreter, and then a bunch
            of application specific code to register extensions to the interpreter.
            <classname>CTCLApplication</classname>
            provides the main boilerplate.  It is expected that you
            derive a class from
            <classname>CTCLApplication</classname>
            Implement <function>operator()</function> to register
            application specific commands, and then create exactly one
            instance of your application class named, and a global pointer
            to that object named gpTCLApplication.
        </para>
        <para>
            For example, suppose you have created a class named MyTclApp:
            <informalexample>
            <programlisting>
// This code is at the global level:
...
MyTclApp app;                              // Makes an instance of this
CTCLApplication* gpTCLApplication = &amp;app;  // Pointer expected by framework.
...
            </programlisting>
            </informalexample>
            Will ensure that the <function>operator()</function> of your
            application object will be called with the interpreter already
            initialized.
        </para>
        <para>
            Note that if you use this class as shown above, to create an application,
            you must not define <function>main</function>.  A
            <function>main</function> is defined in the tcl++ library and
            it must be used to initialize the interpreter and, eventually
            hand off control to your application's
            <methodname>operator()</methodname>.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            <type>int</type> <function>operator()</function>()
        </para>
        <para>
            This function is pure virtual and must be overridden by your
            derived class.  <function>operator()</function> is expected to
            install all required extensions to the interprter and return to it
            to start the main event loop.  The return value from this should be
            <literal>TCL_OK</literal> if the application was successfully initialized
            or <literal>TCL_ERROR</literal> if the program encountered an error that
            should prevent the interpreter main loop from starting
        </para>

        <methodsynopsis>
            <type>void</type> <methodname>getProgramArgs</methodname>
            <methodparam>
                <type>int&amp;</type> <parameter>argc</parameter>
            </methodparam>
            <methodparam>
                <type>char**&amp;</type> <parameter>argv</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Provides a mechanism for the concrete class to get the program
            arguments. This allows the program arguments to be parsed for
            application specific switches and arguments.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
        CTCLInterpreter, CTCLInterpreterObject, CTCLObjectProcessor, CTCLVariable
        </para>
    </refsect1>
</refentry>


<refentry id="manpage.CTCLHashTable">
    <refmeta>
        <refentrytitle>CTCLHashTable</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLHashTable</refname>
        <refpurpose>
            Object oriented interface to Tcl's hash table functions.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLHashTable.h&gt;

template &lt;class T&gt;
class CTCLHashTable
{
public:
  CTCLHashTable () ;
  CTCLHashTable (  Tcl_HashTable am_HashTable  );
  CTCLHashTable (const CTCLHashTable&amp; aCTCLHashTable );
  virtual ~CTCLHashTable ( );

  CTCLHashTable operator= (const CTCLHashTable&amp; aCTCLHashTable);

  int operator== (const CTCLHashTable&amp; aCTCLHashTable);

  Tcl_HashTable* getHashTable() const;

  void Enter (const std::string&amp; rKey, rCTCLTHashTableItem rValue);
  const CTCLTHashTableItem* Find (const std::string&amp; rsKeyword) const;
  CTCLTHashTableItem* Delete (const std::string&amp; rsKeyword);
  CTCLTHashTableIterator begin ();
  CTCLTHashTableIterator end ();
  std::string Statistics ();
};

    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Hash tables are tables of keyword value pairs that are organized
            such that the lookup time for any key in the table is <firstterm>amortized
            constant</firstterm>.  Hash tables operate by running the key through a
            function called the <firstterm>hash function</firstterm>, and storing the
            key/value pair as an element of an array indexed by the result of that hash
            function (<firstterm>hash index</firstterm>).  Depending on the implementation of the hash table, different
            methods are used to resolve cases where two keys result in the same
            hash index.
        </para>
        <para>
            Tcl includes support libraries for hash tables with string keys and
            arbitrary value types (e.g. structures, pointers etc. etc.).  One example
            of the use of this sort of data structure is Tcl's storage of array variables.
            Each array is a hash table indexed by the hash index of the array subscripts.
            In this way Tcl supports subscripts that are arbitrary strings without
            any search overhead when referencing an element of the array.
        </para>
        <para>
            The <classname>CTCLHashTable</classname> and related classes provide an object oriented
            interface to the Tcl API for hash tables.  This class is a <firstterm>template class</firstterm>.
            The template parameter is the type of data that will be associated with each
            hash key.  For example, to create a has key of <classname>CSpectrum*</classname>
            (pointers to SpecTcl Spectra):
            <programlisting>
        CTCLHashTable&lt;CSpectrum*&gt; spectrumHashTable;
            </programlisting>
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
  <function>CTCLHashTable</function> () ;
  <function>CTCLHashTable</function> (  <type>Tcl_HashTable</type> <parameter>aHashTable</parameter>  );
  <function>CTCLHashTable</function> (const <type>CTCLHashTable</type>&amp; <parameter>aCTCLHashTable</parameter> );
        </programlisting>
        </para>
        <para>
            Three methods for creating <classname>CTCLHashTable</classname> objects
            are defined.   The first of these creates a new, empty hash table.
            The second, takes the handle to an existing hash table;
            <type>Tcl_HashTable</type> <parameter>aHashTable</parameter> and wraps
            a <classname>CTCLHashTable</classname> around this existing hash table
            providing an object oriented interface to that hash table.
            The final constructor, a copy constructor, creates a
            <classname>CTCLHashTable</classname> that refers to the same underlying
            <type>Tcl_HashTable</type> as the <parameter>aCTCLHashTable</parameter> parameter.
        </para>
        <para>
        <programlisting>
  <type>CTCLHashTable</type> <function>operator</function>= (const <type>CTCLHashTable</type>&amp; <parameter>rhs</parameter>);
  <type>int</type> <function>operator==</function> (const <type>CTCLHashTable</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            <function>operator=</function>  assigns <parameter>rhs</parameter> to an existing
            object.  The semantics of assignment are that
            followingt assignment, <varname>*this</varname> and <parameter>rhs</parameter>
            will refer to the same underlying hash table.
        </para>
        <para>
            <function>operator==</function> compares two hash tables, <varname>*this</varname>
            and <parameter>rhs</parameter> for equality.  The semantics of equality are
            that the two <classname>CTCLHashTable</classname> objects refer to the same
            underlying Tcl hash tables.
        </para>
        <para>
        <programlisting>
  <type>Tcl_HashTable</type>* <function>getHashTable</function>() const;
        </programlisting>
        </para>
        <para>
            Gets the underlying <type>Tcl_HashTable</type> that is wrapped by
            a <classname>CTCLHashTable</classname> object.
        </para>
        <para>
            <programlisting>
<type>void</type> <function>Enter</function> (const <type>std::string</type>&amp; <parameter>rKey</parameter>,
            <type>CTCLTHashTableItem&lt;T&gt;</type> <parameter>rValue</parameter>);
            </programlisting>
            </para>
            <para>
            Adds an entry to a hash table.  <parameter>rKey</parameter> is the
            lookup key that will be associated with the entry.  <parameter>rValue</parameter>
            is the data that is associated with that key.  Note that <type>T</type>
            is the template type that was used to create the hashtable.  E.g. if the
            hash table is a <classname>CTCLHashTable&lt;float&gt;</classname>,
            <parameter>rValue</parameter> must be a <classname>CTCLHashTableItem&lt;float&gt;</classname>.
            Note that Tcl hash tables do not support duplicate keys.  If a hash table
            entry with the key <parameter>rKey</parameter> already is in the table it is
            replaced.
            </para>
            <para>
                <programlisting>
  const <type>CTCLTHashTableItem</type>* <function>Find</function> (const <type>std::string</type>&amp; <parameter>rsKeyword</parameter>) const;
                </programlisting>
            </para>
            <para>
                Looks up a hash table item by key.  If a hash table item with
                the key <parameter>rsKeyword</parameter> exists, a pointer to its
                entry is returned.   If <parameter>rsKeyword</parameter> has not
                yet been <function>Enter</function>ed in the hash table, a
                <literal>NULL</literal> pointer is returned.
            </para>
            <para>
                <programlisting>
  <type>CTCLTHashTableItem</type>* <function>Delete</function> (const <type>std::string</type>&amp; <parameter>rsKeyword</parameter>);
                </programlisting>
            </para>
            <para>
                Removes the hash table entry with the key <parameter>rsKeyword</parameter>.
                If the item existed, a pointer to it is returned.  If the item does not
                exist in the hash table a <literal>NULL</literal> pointer is returned.
            </para>
            <para>
                <programlisting>
  <type>CTCLTHashTableIterator</type> <function>begin</function> ();
  <type>CTCLTHashTableIterator</type> <function>end</function> ();
                </programlisting>
            </para>
            <para>
                <function>begin</function> returns an <firstterm>iterator</firstterm> that
                "points" to the first entry in the hash table.  dereferencing the
                iterator yields the pointer to a HashTableItem.  The iterator can be
                incremented via ++ so that it advances to the next item in the table.
            </para>
            <para>
                <function>end</function>returns an iterator that points past the end of the
                table and can be used to determine when iteration is complete.
            </para>
            <para>
                Iterators are pointer like objects.  See the STL reference below for more
                information about them.  The following example Takes a Hash table and
                counts up the number of elements it contains.
                <programlisting>
        CTCLHashTableIterator i = table.begin();    // Table a CTCLHashTable
        int                   n = 0;
        while (i != table.end()) {
            n++;
        }
        // N is a count of elements in the table.

            </programlisting>
            </para>
            <para>
                <programlisting>
  <type>std::string</type> <function>Statistics</function> ();
                </programlisting>
        </para>
        <para>
            Returns a string that contains statistics about the hash table.
            This is a wrapper for <function>Tcl_HashStats</function>
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLHashTableItem(3),
CTCLHashTableIterator(3),
Tcl_HashStats(3tcl)
        </para>
    </refsect1>
    <refsect1>
        <title>REFERENCES</title>
        <para>
        <programlisting>
Niklaus Wirth <parameter>Algorithms + Data Structures = Programs</parameter>
Prentice Hall Series in Automatic Computation 1976 See section 4.6

Musser, Derge, Saini: <parameter>STL Tutorial and Reference Guide</parameter>
Addison-Wesley Professional Computing Series; 2001 ISBN 0-201-37923-6
        </programlisting>
        </para>
    </refsect1>
</refentry>


<refentry id="manpage.CTCLHashTableItem">
    <refmeta>
        <refentrytitle>CTCLHashTableItem</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLHashTableItem</refname>
        <refpurpose>
            Encapsulation of an entry in a Tcl Hash table as encapsulated
            in <classname>CTCLHashTable</classname>
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <programlisting>
#include &lt;TCLHashTableItem.h&gt;
...

template &lt;class T&gt;              // T Must have copy ctor &amp; Assignment defined.
class CTCLHashTableItem
{
  CTCLHashTableItem (T am_Item );
  CTCLHashTableItem (const CTCLHashTableItem&amp; aCTCLHashTableItem );
  virtual ~CTCLHashTableItem ( );

  CTCLHashTableItem operator= (const CTCLHashTableItem&amp; aCTCLHashTableItem);
   int operator== (const CTCLHashTableItem&amp; aCTCLHashTableItem);
  T getItem() const;
  T* operator-&gt; ();
}
        </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title></title>
        <para>
            Provides an object oriented interface to elements of a hash table.
            See CTCLHashTable(3), and the first REFERENCE below for more information
            about hash tables.
        </para>
        <para>
            Note that this is a templated class.  The template parameter is
            the type of the item to be stored in the hash table.  Suppose,
            for example, we have a bunch of named calibration parameters
            (floating point) that are stored in a hash table.  A calibration
            The following code creates the calibration table, and inserts an
            element named george in it with the initial value of 0.0:
            <programlisting>
        CTCLHashTable&lt;float&gt;  calibrationTable;
        CTCLHashTableItem&lt;float&gt; entry(0.0);
        calibrationTable.Enter(std::string("george"), entry);
            </programlisting>
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
<function>CTCLHashTableItem</function> (<type>T</type> <parameter>Item</parameter> );
<function>CTCLHashTableItem</function> (const <type>CTCLHashTableItem</type>&amp; <parameter>hashItem</parameter> );
        </programlisting>
        </para>
        <para>
            Constructs a <classname>CTCLHashTableItem</classname> either from the underlying
            type (<parameter>Item</parameter>) or from an existing <classname>CTCLHashTableItem</classname>
            (<parameter>hashItem</parameter>).
        </para>
        <para>
        <programlisting>
<type>CTCLHashTableItem</type> <function>operator=</function>(const <type>CTCLHashTableItem</type>&amp; <parameter>rhs</parameter>);
<type>int</type> <parameter>operator==</parameter> (const <type>CTCLHashTableItem</type>&amp; <type>rhs</type>);
        </programlisting>
        </para>
        <para>
            <function>operator=</function> allows you to assign the value of one
            <classname>CTCLHashTableItem</classname> to another.  The underlying
            templated type must be capable of assignment.
        </para>
        <para>
            <function>operator==</function> allows you to compare two
            <classname>CTCLHashTableItem</classname>s to each other.  The underlying
            templated type must be capable of equality comparison.
        </para>
        <para>
            <programlisting>
<type>T</type> <function>getItem</function>() const;
            </programlisting>
        </para>
        <para>
            Returns the value of the item wrapped by the <classname>CTCLHashTableItem</classname>
            The underlying type must be capable of copy construction.
        </para>
        <para>
            <programlisting>
<type>T</type>* <function>operator-&gt;</function> ();       </programlisting>
        </para>
        <para>
            Returns the address of the contents of the <classname>CTCLHashTableItem</classname>.
            This is most useful if <classname>T</classname> is a structure or class as it can be
            used to dereference member (data or functions) of the structure or class.
            For example:
            <programlisting>
                struct complex {
                                 double real;
                                 double imaginary;
                                 complex(double r, double i) :
                                    real(r), imaginary(i) {}
                                } complex;
                CTCLHashTableItem&lt;complex&gt; v(1.0, 2.0);
                double real = v-&gt;real;             // real = 1.0
                double imag = v-&gt;imaginary;        // imag = 2.0
            </programlisting>
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLHashTable(3),
CTCLHashTableIterator(3)
        </para>
    </refsect1>
    <refsect1>
        <title>REFERENCES</title>
        <para>
            <programlisting>
Niklaus Wirth <parameter>Algorithms + Data Structures = Programs</parameter>
Prentice Hall Series in Automatic Computation 1976 See section 4.6
            </programlisting>
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLHashTableIterator">
    <refmeta>
        <refentrytitle>CTCLHashTableIterator</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLHashTableIterator</refname>
        <refpurpose>
            Iterator for visiting all elements of a <classname>CTCLHashTable</classname>
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>

#include &gt;TCLHashTableIterator.h&gt;
...
template &lt;class T&gt;
class CTCLHashTableIterator
{

public:
  CTCLHashTableIterator (Tcl_HashTable*   pTable);
  CTCLHashTableIterator (const CTCLHashTableIterator&amp; aCTCLHashTableIterator );
  virtual ~ CTCLHashTableIterator ( );

  CTCLHashTableIterator operator=
                     (const CTCLHashTableIterator&amp; aCTCLHashTableIterator);
  int operator== (const CTCLHashTableIterator&amp; aCTCLHashTableIterator);
  CTCLHashTableItem&lt;T&gt;* getCurrentEntry() const;
  Tcl_HashTable* getHashTable() const;

  CTCLHashTableIterator&amp; operator++ ();
  CTCLHashTableIterator operator++ (int i);
  CTCLHashTableItem&lt;T&gt;&amp; operator* ();
  CTCLHashTableItem&lt;T&gt;* operator-&gt;();

};



    </programlisting>

    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <classname>CTCLHashTableIterator</classname> objects are created and returned
        by <classname>CTCLHashTableIterator</classname>::<function>begin</function>
        and <classname>CTCLHashTableIterator</classname>::<function>end</function>.
        These objects are pointer like objects to <classname>CTCLHashTableItem</classname>
        objects within the hash table.
        </para>
        <para>
            If you imagine that all containers can have an ordering defined on them,
            iterators are like pointers to elements of this ordering.
            Dereference operators yield an element of the container, and increment operators
            make the iterator 'point' to the next element in the container according to the
            ordering.
        </para>
        <para>
            For more information on both hash tables and iterators see the
            REFERENCES.  For information about the classes that are related to this,
            consult manpages pointed to by the SEE ALSO section.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
  <function>CTCLHashTableIterator</function> (<type>Tcl_HashTable</type>* <parameter>pTable</parameter>);
  <function>CTCLHashTableIterator</function>(const <type>CTCLHashTableIterator</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            Construct a hash table iterator.  Normally you will not need to use these
            constructors directly.  They will be created, instead by
            <classname>CTCLHashTable</classname>::<function>begin()</function>
            or <classname>CTCLHashTable</classname>::<function>end()</function>.
            <parameter>pTable</parameter> is a pointer to an existing <type>Tcl_HashTable</type>
            created via <function>Tcl_InitHashTable</function>.  <parameter>rhs</parameter>
            is an existing <classname>CTCLHashTableIterator</classname> object whose state
            will be used to initialize the object under construction.
        </para>
        <para>
        <programlisting>
  <type>CTCLHashTableIterator</type> <function>operator=</function>
                     (const <type>CTCLHashTableIterator</type>&amp; <parameter>rhs</parameter>);
  <type>int</type> <function>operator==</function>(const <type>CTCLHashTableIterator</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            <function>operator=</function> allows you to assign the state of one <classname>CTCLHashTableIterator</classname>
            to another.  When the assignment is complete, the left hand side object will
            be 'pointing' to the same object as the right hand side object but be separately
            incrementable.
        </para>
        <para>
            <function>operator==</function> allows you to compare two iterators for equality.
            equality is defined as the two iterators being defined on the same underlying
            hash table, pointing to the same element, and having the same increment context
            (e.g. an increment of both iterators will leave them both pointing to the
            same hash table item (different from the one prior to the increment).
        </para>
        <para>
        <programlisting>
<type>CTCLHashTableItem&lt;T&gt;</type>* <function>getCurrentEntry</function>() const;
<type>Tcl_HashTable</type>* <function>getHashTable</function>() const;
        </programlisting>
        </para>
        <para>
            These two functions get at the information the iterator is encapsulating.
            <function>getCurrentEntry</function> returns a pointer to the entry that
            the iterator si currently 'pointing' at.  This is identical to the
            <function>operator-&gt;</function> function.
            <function>getHashTable</function> returns a pointer to the underlying
            <type>Tcl_HashTable</type> created by <function>Tcl_InitHashTable</function>.
        </para>
        <para>
            <programlisting>
CTCLHashTableIterator&amp; operator++ ();
CTCLHashTableIterator operator++ (int i);
            </programlisting>
        </para>
        <para>
            These two function support both pre and post increment operations on an
            iterator.  There are slight differences in semantics between these
            operators best illustrated with a sample code fragment.  In the fragment
            below, i is an <classname>CTCLHashTableIterator</classname>
            <programlisting>
CTCLHashTableItem item1 = *i++;   // item 1 is the item pointed to prior to increment
CTCLHashTableItem item2 = *++i;   // item 2 is the item pointed to after increment.
            </programlisting>
        </para>
        <para>
            <programlisting>
<type>CTCLHashTableItem&lt;T&gt;</type>&amp; <function>operator*</function> ();
<type>CTCLHashTableItem&lt;T&gt;</type>* <function>operator-&gt;</function>();
        </programlisting>
        </para>
        <para>
            These operators allow <classname>CTCLHashTableIterator</classname> objects
            to be treated like pointers to <classname>CTCLHashTableItem</classname> objects.
            <function>operator*</function> provides 'pointer' dereferencing that allows
            code like:
            <programlisting>
                (*i).getItem();
            </programlisting>
        </para>
        <para>
            <function>operator-&gt;</function> provides a pointer to struct like semantics
            allowing code like:
            <programlisting>
                i->getItem();
            </programlisting>
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLHashTable(3),
CTCLHashTableItem(3),
Tcl_InitHashTable(3tcl),
Tcl_FirstHashEntry(3tcl),
Tcl_NextHashEntry(3tcl)
        </para>
    </refsect1>
    <refsect1>
        <title>REFERENCES</title>
        <para>
        <programlisting>
Niklaus Wirth <parameter>Algorithms + Data Structures = Programs</parameter>
Prentice Hall Series in Automatic Computation 1976 See section 4.6

Musser, Derge, Saini: <parameter>STL Tutorial and Reference Guide</parameter>
Addison-Wesley Professional Computing Series; 2001 ISBN 0-201-37923-6
        </programlisting>
        </para>
    </refsect1>
</refentry>


<refentry id="manpage.CTCLString">
    <refmeta>
        <refentrytitle>CTCLString</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLString</refname>
        <refpurpose>
            Provide a wrapper for the <type>Tcl_DString</type> data type
            and its API
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLString.h&gt;
...
class CTCLString
{
public:
  CTCLString ();
  CTCLString (const char* pString  ) ;
  CTCLString(const std::string&amp; rString);
  CTCLString(const Tcl_DString&amp; rString);
  CTCLString (const CTCLString&amp; aCTCLString );
  ~ CTCLString ();

  CTCLString&amp; operator= (const CTCLString&amp; aCTCLString);
  int operator== (const CTCLString&amp; aCTCLString);
  int operator!= (const CTCLString&amp; aCTCLString);
  int operator&gt; (const CTCLString&amp; aCTCLString);
  int operator&lt; (const CTCLString&amp; aCTCLString);
  int operator&gt;=(const CTCLString&amp; aCTCLString);
  int operator&lt;=(const CTCLString&amp; aCTCLString);

  Tcl_DString&amp; getString();
  CTCLString&amp; Append (const std::string&amp; rString, Int_t nLength=-1);
  CTCLString&amp; Append (const CTCLString&amp;  rString, Int_t nLength=-1);
  CTCLString&amp; Append (Tcl_DString&amp;       pString, Int_t nLength=-1);
  CTCLString&amp; Append (const char*        pString, Int_t nLength=-1);
  CTCLString&amp; AppendElement (const Tcl_DString*      pRhs);
  CTCLString&amp; AppendElement (const CTCLString&amp;       rRhs);
  CTCLString&amp; AppendElement (const std::string&amp;      rRhs);
  CTCLString&amp; AppendElement (const char*             pRhs);
  CTCLString&amp; AppendElement(DFloat_t value, const char* pFormat = "%f");
  CTCLString&amp; AppendElement(long value, const char* pFormat = "%i");

  CTCLString&amp; StartSublist ()  ;
  CTCLString&amp; EndSublist ()  ;
  UInt_t  Length () const ;
  CTCLString&amp; Truncate (UInt_t nNewLength)  ;
  Bool_t isCommand () const  ;

  Bool_t Match (const char*       pPattern) const;
  Bool_t Match (std::string&amp;      rPattern) const;
  Bool_t Match (const CTCLString&amp; rPattern) const;

  operator const char* () const;
  operator std::string () const;
  operator Tcl_DString* ();
};
    </programlisting>


    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The Tcl API provides a dynamic string type <type>Tcl_DString</type>.
            For many purposes, the C++ <type>std::string</type> is sufficient, however
            the <type>Tcl_DString</type> list building functions are unmatched in
            <type>std::string</type>.  <classname>CTCLString</classname> is an object oriented
            wrapping of a <type>Tcl_DString</type>
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            <programlisting>
<type>CTCLString</type> ();
<type>CTCLString</type> (const <type>char</type>* <parameter>pString</parameter>) ;
<type>CTCLString</type>(const <type>std::string</type>&amp; <parameter>rString</parameter>);
<type>CTCLString</type>(const <type>Tcl_DString</type>&amp; <parameter>rString</parameter>);
<type>CTCLString</type> (const <type>CTCLString</type>&amp; <type>aCTCLString</type> );
            </programlisting>
            </para>
            <para>
                Constructs a <classname>CTCLString</classname> object.  With the exception
                of the first constructor, which produces an empty string, all of these
                constructors initialize the contents of the underlying
                <classname>Tcl_DString</classname> with the string representation of their
                parameter.
            </para>
            <para>
            <programlisting>
<type>CTCLString</type>&amp; <function>operator=</function> (const <type>CTCLString</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            Supports assignment to a <classname>CTCLString</classname> from another;
            <parameter>rhs</parameter>.
        </para>
        <para>
        <programlisting>
<type>int</type> <function>operator==</function> (const <type>CTCLString</type>&amp; <parameter>rhs</parameter>);
<type>int</type> <function>operator!=</function> (const <type>CTCLString</type>&amp; <parameter>rhs</parameter>);
<type>int</type> <function>operator&gt;</function> (const <type>CTCLString</type>&amp; <parameter>rhs</parameter>);
<type>int</type> <function>operator&lt;</function> (const <type>CTCLString</type>&amp; <parameter>rhs</parameter>);
<type>int</type> <function>operator&gt;=</function>(const <type>CTCLString</type>&amp; <parameter>rhs</parameter>);
<type>int</type> <function>operator&lt;=</function>(const <type>CTCLString</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            Relational operators provide for lexicographic copmarisons between the object
            and <parameter>rhs</parameter> which is another <classname>CTCLString</classname>.
        </para>
        <para>
        <programlisting>
<type>Tcl_DString</type>&amp; <function>getString</function>();
        </programlisting>
        </para>
        <para>
            Returns a reference tothe underlying <type>Tcl_DString</type> of the
            object.
        </para>
        <para>
        <programlisting>
<type>CTCLString</type>&amp; <function>Append</function> (const <type>std::string</type>&amp; <parameter>String</parameter>,
                  <type>Int_t</type> <parameter>nLength</parameter>=<literal>-1</literal>);
<type>CTCLString</type>&amp; <function>Append</function> (const <type>CTCLString</type>&amp; <parameter>String</parameter>,
                  <type>Int_t</type> <parameter>nLength</parameter>=<literal>-1</literal>);
<type>CTCLString</type>&amp; <function>Append</function> (<type>Tcl_DString</type>&amp;       <parameter>String</parameter>,
                  <type>Int_t</type> <parameter>nLength</parameter>=<literal>-1</literal>);
<type>CTCLString</type>&amp; <function>Append</function> (const <type>char</type>*            <parameter>String</parameter>,
                  <type>Int_t</type> <parameter>nLength</parameter>=<literal>-1</literal>);
        </programlisting>
        </para>
        <para>
            Appends a section of <parameter>String</parameter> to the
            <classname>CTCLString</classname> that is being built up.
            The first <parameter>nLength</parameter> characters are appended.
            if <parameter>nLength</parameter> is <literal>-1</literal> then
            all <parameter>String</parameter> is appended.
        </para>
        <para>
        <programlisting>
<type>CTCLString</type>&amp; <function>AppendElement</function> (const <type>Tcl_DString</type>*  <parameter>item</parameter>);
<type>CTCLString</type>&amp; <function>AppendElement</function> (const <type>CTCLString</type>&amp;   <parameter>item</parameter>);
<type>CTCLString</type>&amp; <function>AppendElement</function> (const <type>std::string</type>&amp;  <parameter>item</parameter>);
<type>CTCLString</type>&amp; <function>AppendElement</function> (const <type>char*</type>         <parameter>item</parameter>);
<type>CTCLString</type>&amp; <function>AppendElement</function>(<type>DFloat_t</type> <parameter>item</parameter>,
                         const <type>char*</type> <parameter>pFormat</parameter> = <literal>"%f"</literal>);
<type>CTCLString</type>&amp; <function>AppendElement</function>(<type>long</type>     <parameter>item</parameter>,
                         const <type>char*</type> <parameter>pFormat</parameter> = <literal>"%i"</literal>);
        </programlisting>
        </para>
        <para>
            Appends <parameter>item</parameter> as a list element to the end of the
            string.  If necessary quotation is performed to ensure the item is treated as a
            single list element.  The <parameter>pFormat</parameter> parameter
            controls the conversion of non string data types to a string and is of the form
            of any control sequence used by sprintf.  For example
            <literal>"i = %d"</literal> could be used to convert an integer to a label
            and its value which would be appended to the string as e.g.
            <literal>{i = 1234}</literal>
        </para>
        <para>
        <programlisting>
<type>CTCLString</type>&amp; <function>StartSublist</function> ()  ;
<type>CTCLString</type>&amp; <function>EndSublist</function> ()  ;
        </programlisting>
        </para>
        <para>
            Used in conjuntion with <function>AppendElement</function> these
            start and end sublists which are list elements that consist of lists.
            Sublists can be nested to any depth.
            For example:
            <programlisting>
    CTCLString s;
    s.AppendElement("a");
    s.StartSublist();
    s.AppendElement("b");
    s.AppendElement("c");
    s.StartSublist();
    s.AppendElement("d");
    s.AppendElement("e");
    s.EndSublist();
    s.AppendElement("f");
    s.EndSublist();
    s.AppendElement("g");
            </programlisting>
        Would make the <varname>s</varname> contain the string
        <literal>"a {b c {d e} f} g"</literal>
        </para>
        <para>
        <programlisting>
<type>UInt_t</type>  <function>Length</function>() const ;
        </programlisting>
        </para>
        <para>
            Returns the number of characters in the string.
        </para>
        <informalexample>
        <programlisting>
CTCLString&amp; Truncate (UInt_t nNewLength)  ;
        </programlisting>
        </informalexample>
        <para>
            Truncates the string to the first <parameter>nNewLength</parameter>
            characters.
        </para>
    
        <informalexample>
        <programlisting>
<type>Bool_t</type> <function>isCommand</function> () const  ;
        </programlisting>
        </informalexample>
        <para>
            Analyzes the string and returns <literal>kfTRUE</literal> if the
            string is a 'well formed command'.  Note that a well formed command
            may still have syntax and execution errors.  This just ensures that
            a string has a balanced set of quoting characters.
        </para>
        <informalexample>
        <programlisting>
<type>Bool_t</type> <function>Match</function> (const <type>char</type>*           <parameter>Pattern</parameter>) const;
<type>Bool_t</type> <function>Match</function> (<type>std::string</type>&amp;      <parameter>Pattern</parameter>) const;
<type>Bool_t</type> <function>Match</function> (const <type>CTCLString</type>&amp; <parameter>Pattern</parameter>) const;
        </programlisting>
        </informalexample>
        <para>
            Returns <literal>kfTRUE</literal> if the contents of the string matches the
            <parameter>Pattern</parameter>
            parameter.  The <parameter>Pattern</parameter> parameter can contain all of the
            wildcards in <firstterm>glob</firstterm> style pattern matching.  See
            REFERENCES below for moer information about glob style matching.
        </para>
        <informalexample>
        <programlisting>
operator const char* () const;
operator std::string () const;
operator Tcl_DString* ();
    </programlisting>
        </informalexample>
        <para>
            These operators are implicit and explicit type conversion operators that
            allow a <classname>CTCLString</classname> object to be treated as a
            <type>char*</type> pointing to a null terminated string, a
            <type>std::string</type> object, or a <type>Tcl_DString</type> pointer.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
Tcl_DStringAppend(3tcl),
Tcl_DStringAppendElement(3tcl),
Tcl_DStringEndSublist(3tcl),
Tcl_DStringFree(3tcl),
Tcl_DStringGetResult(3tcl),
Tcl_DStringInit(3tcl),
Tcl_DStringLength(3tcl),
Tcl_DStringResult(3tcl),
Tcl_DStringSetLength(3tcl),
Tcl_DStringStartSublist(3tcl)
        </para>
    </refsect1>
    <refsect1>
        <title>REFERENCES</title>
        <informalexample>
            <programlisting>
J.K. Ousterhout <parameter>Tcl and the Tk Toolkit</parameter>
Addison-Wesley Professional Computing Series 1994 see section 9.2
            </programlisting>
        </informalexample>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLList">
    <refmeta>
        <refentrytitle>CTCLList</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLList</refname>
        <refpurpose>
            Provide access to Tcl List parsing.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <programlisting>
#include &lt;TCLList.h&gt;
...
class CTCLList  : public CTCLInterpreterObject
{

public:
  CTCLList (CTCLInterpreter* pInterp);
  CTCLList (CTCLInterpreter* pInterp, const  char* am_pList  );
  CTCLList (CTCLInterpreter* pInterp, const std::string&amp; rList);
  CTCLList (const CTCLList&amp; aCTCLList );

  CTCLList&amp; operator= (const CTCLList&amp; aCTCLList);
  int operator== (const CTCLList&amp; aCTCLList);
  int operator!= (const CTCLList&amp; aCTCLList);

  const char* getList() const;

  int Split (StringArray&amp; rElements)  ;
  int Split (int&amp; argc, char*** argv);

  const char* Merge (const StringArray&amp; rElements)  ;
  const char* Merge(int argc, char** argv);

};


        </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Tcl Lists are white space separated words.  It is definition of
            words and quoting issues that makes the parsing of lists less than
            straightforward.
        </para>
        <para>
            Fortunately, Tcl provides several list processing functions.  The
            concept of a list and access to list processing functions are
            encapsulated in the <classname>CTCLList</classname> class.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>

<type>CTCLList</type> (<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>);
<type>CTCLList</type> (<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
          const  <type>char</type>* <parameter>pList</parameter>  );
<type>CTCLList</type> (<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
          const <type>std::string</type>&amp; <parameter>rList</parameter>);
<type>CTCLList</type> (const <type>CTCLList</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            These four functions provide various ways to create a <classname>CTCLList</classname>
            object.  The first constructor creates an empty list.  The next two, create a list
            that has an initial value given by either the <literal>NULL</literal>
            terminated string <parameter>pList</parameter>, or the <type>std::string</type>
            object <parameter>rList</parameter>.
            The final constructor creates a list that is a duplicate of the list
            described by the object <parameter>rhs</parameter>.
        </para>
        <para>
            <programlisting>

  <type>CTCLList</type>&amp; <function>operator=</function> (const <type>CTCLList</type>&amp; <parameter>rhs</parameter>);
  <type>int</type> <function>operator==</function> (const <type>CTCLList</type>&amp; <parameter>rhs</parameter>);
  <type>int</type> <function>operator!=</function> (const <type>CTCLList</type>&amp; <parameter>rhs</parameter>);
            </programlisting>
        </para>
        <para>
            These function provide assignment (<function>operator=</function>),
            equality comparison (<function>operator==</function>), and
            inequality comparison (<function>operator!=</function>) with another
            <classname>CTCLList</classname> object, <parameter>rhs</parameter>.
            Assignment is defined as copying the string format of the list.
            Equality comparison is defined as the both interpreter and strings being equal.
            Inequality is defined as !operator==.
        </para>
        <para>
            <programlisting>
  const <type>char</type>* <function>getList()</function> const;
            </programlisting>
        </para>
        <para>
            <function>getList</function> returns an immutable pointer to
            the string rerpesentation of the list.  Note that the const qualfier
            on the pointer means that attempts to dereference the pointer which
            would modify the list result in error messages.  For Example:
            <programlisting>
        CTCLList aList(pInterp, "some list");
        const char* pData = aList.getList();
        *pData = 'S';         // Compiler error!!!!
            </programlisting>
        </para>
        <para>
            <programlisting>
<type>int</type> <function>Split</function> (<type>StringArray</type>&amp; <parameter>rElements</parameter>)  ;
<type>int</type> <function>Split</function> (<type>int</type>&amp; <parameter>argc</parameter>,
           <type>char</type>*** <parameter>argv</parameter>);
            </programlisting>
        </para>
        <para>
            Splits a list up into its component words.   <parameter>relements</parameter>
            is a <type>std::vector&lt;std::string&gt;</type> into which the elements will be split.
            <parameter>argc</parameter> is a reference to an integer into which the
            number of elements will be put. <parameter>argv</parameter> is a pointer to a
            <type>char</type>** into which will be placed a pointer to dynamically
            allocated storage containing a list of <parameter>argc</parameter> pointers
            to the words in the string.  This storage must be released by the caller
            with  <function>Tcl_Free</function>.
            For example:
            <programlisting>
                CTCLList someList(pInterp, someInitialContents);
                ...
                int argc;
                char** argv;
                someList.Split(argc, &amp;argv);
                //
                //  ... do something with the data
                //
                ...
                //
                // Done with the list elements.
                //
                Tcl_Free((char*)argv);
            </programlisting>
        </para>
        <para>
            <programlisting>
const <type>char</type>* <function>Merge</function> (const <type>StringArray</type>&amp; <parameter>rElements</parameter>)  ;
const <type>char</type>* <function>Merge</function>(<type>int</type> argc,
                 <type>char</type>** <parameter>argv</parameter>);
        </programlisting>
        </para>
        <para>
            Merges a bunch of words in to a list.  If necessary, quoting is performed to
            ensure that words that have whitespace or other special characters will be
            correctly formatted into the list. <parameter>rElements</parameter> is a
            <type>std::vector&lt;std::string&gt;</type> of words that will be merged into the
            string.  <parameter>argc</parameter> is a count of the number of words,
            and <parameter>argv</parameter> is a pointer to an array of pointers to the
            words stored as <literal>NULL</literal> terminated strings.
            The return value is the final string representation of the list after the
            merge operation has been performed.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLInterpreter(3),
CTCLInterpreterObject(3),
Tcl_Free(3tcl)
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLChannel">
    <refmeta>
        <refentrytitle>CTCLChannel</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLChannel</refname>
        <refpurpose>
            Provide a C++ abstraction wrapper for Tcl Channels.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLChannel.h&gt;
...
class CTCLChannel : public CTCLInterpreterObject
{
public:

  CTCLChannel(CTCLInterpreter* pInterp,
              std::string      Filename,
              const char*      pMode,
              int              permissions);
  CTCLChannel(CTCLInterpreter* pInterp,
              int              argc,
              const char**           pargv,
              int              flags);
  CTCLChannel(CTCLInterpreter* pInterp,
              int              port,
              std::string      host)
  CTCLChannel(CTCLInterpreter* pInterp,
              int              port,
              Tcl_TcpAcceptProc* proc,
              ClientData       AppData);
  CTCLChannel(CTCLInterpreter* pInterp,
              Tcl_Channel      Channel);
  CTCLChannel(const CTCLChannel&amp; rhs);
  virtual ~CTCLChannel();

  Tcl_Channel getChannel() const;
  bool ClosesOnDestroy() const;

  int Read( void** pData, int nChars);
  int Write(const void* pData, int nBytes);

  bool atEof();
  void Flush();
  void Close();
  void Register();
  void SetEncoding(std::string Name);
  std::string GetEncoding();

    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The Tcl API supplies an I/O abstraction layer on top of the
            operating systems I/O subsystem.  This layer makes use of what Tcl documentation
            refers to a s <firstterm>channels</firstterm>. A channel represents a connection
            to an I/O endpoint (source or sink of data or both).  The <classname>CTCLChannel</classname>
            class allows you to wrap a C++ class around a Tcl channel.
        </para>
        <para>
            Using a <classname>CTCLChannel</classname>, rather than direct operating system
            I/O allows you to improve the portability of your program, as well as allowing
            I/O from the TCL scripting level to be cleanly mixed with I/O at the C/C++ level.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
  <function>CTCLChannel</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
              <type>std::string</type>      <parameter>Filename</parameter>,
              <type>const char</type>*      <parameter>pMode</parameter>,
              <type>int</type>              <parameter>permissions</parameter>);
  <function>CTCLChannel</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
              <type>int</type>              <parameter>argc</parameter>,
              <type>const char</type>**           <parameter>pargv</parameter>,
              <type>int</type>              <parameter>flags</parameter>);
  <function>CTCLChannel</function>(<type>CTCLInterpreter</type>  * <parameter>pInterp</parameter>,
              <type>int</type>              <parameter>port</parameter>,
              <type>std::string</type>      <parameter>host</parameter>);
  <function>CTCLChannel</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
              <type>int</type>              <parameter>port</parameter>,
              <type>Tcl_TcpAcceptProc</type>* <parameter>proc</parameter>,
              <type>ClientData</type>      <parameter>AppData</parameter>);
  <function>CTCLChannel</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
              <type>Tcl_Channel</type>      <parameter>Channel</parameter>);
  <function>CTCLChannel</function>(<type>const CTCLChannel</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            These constructors wrap a <classname>CTCLChannel</classname>
            object around a Tcl channel.  The variety of constructors reflects the
            variety of endpoints around which a <type>Tcl_Channel</type> can be
            wrapped.
        </para>
        <para>
            The first of the constructors attaches the object to a file via
            <function>Tcl_OpenFileChannel</function>.  <parameter>pInterp</parameter>
            is the channel the file is associated.  <parameter>Filename</parameter>
            is the name of the file the channel is connected to. <parameter>pMode</parameter>
            is the connection mode which can be any of of the mode values for the
            Tcl <command>open</command> scripting command.   <parameter>permissions</parameter>
            represents the permissions mask fo rthe file in POSIX format.  See
            open(2) for information about the possible mode bit values.
        </para>
        <para>
            The second form of the constructor connects a channel that is a pipe to a
            program.  The program and its command line arguments are specified
            via the <parameter>argc</parameter> and <parameter>pargv</parameter>
            parameters. The <parameter>flags</parameter> parameter specifies
            how the stdio channels of the program are or are not disposed into the
            channel.   Valid bits are:
            <literal>TCL_STDIN</literal>,
            <literal>TCL_STDOUT</literal>,
            <literal>TCL_STDERR</literal>,
            <literal>TCL_ENFORCE_MODE</literal>.  See the <function>Tcl_OpenCommandChannel</function>
            manpage for information about the meaning of these bits.
        </para>
        <para>
            The third form of the constructor constructs a channel that connects to a
            TCP/IP server, via <function>Tcl_OpenTcpClient</function>.  The
            <parameter>port</parameter> parameter specifies the port number on which the
            server is listening, while <parameter>host</parameter> is the name of the
            host to which the connection should be formed.  The host name can either be a
            DNS resolvable host name or the textual encoding of the TCP/IP address of the
            host (e.g. string("spdaq22.nscl.msu.edu") or string("35.9.56.56").
            This function will block until the connection is accepted by the server.
        </para>
        <para>
            The fourth form of the constructor creates a channel that is a Tcp/IP server.
            <parameter>port</parameter> is the port number on which the server listens
            for connections.
            <parameter>proc</parameter> is a function that will be called when a
            connection has been accepted by the Tcl event loop.
            <parameter>AppData</parameter> is application data that is passed, without
            interpretation to <parameter>proc</parameter>.  See the <function>Tcl_OpenTcpServer</function>
            manpage for more information about how the <parameter>proc</parameter> is
            called.
        </para>
        <para>
            The fifth form of the constructor creates a <classname>CTCLChannel</classname>
            object by wrapping an existing <type>Tcl_Channel</type>; <parameter>Channel</parameter>
            which has been obtained
            directly from the Tcl application programming interface.
        </para>
        <para>
            The final form of the constructor copies an existing <classname>CTCLChannel</classname>
            object so that the two objects refer to the same channel.  The object is created
            so that it will not close the channel on destruction.  Note however that the
            source channel may, depending on how it was constructed.  It is up to the
            application programmer to ensure that channels are closed at appropriate times.
        </para>
        <para>
        <programlisting>
  <type>Tcl_Channel</type> <function>getChannel</function>() const;
        </programlisting>
        </para>
        <para>
            Returns the underlying <type>Tcl_Channel</type> this object is
            wrapped around.  Once this is obtained, it can be usd in any
            Tcl API call that requires a channel.
        </para>
        <para>
        <programlisting>
  <type>bool</type> <function>ClosesOnDestroy</function>() const;
        </programlisting>
        </para>
        <para>
            When a <classname>CTCLChannel</classname> is copy constructed into
            being it is flagged such that destruction will not close the underlying channel.
            the return value from this function is <literal>true</literal> if the
            object will close the underlying channel on destruction and <literal>false</literal>
            if the object will not close the underlying channel on destruction.
        </para>
        <para>
        <programlisting>
  <type>int</type> <function>Read</function>( <type>void</type>** <parameter>pData</parameter>,
           <type>int</type> <parameter>nChars</parameter>);
  <type>int</type> <function>Write</function>(<type>const void</type>* <parameter>pData</parameter>,
           <type>int</type> <parameter>nBytes</parameter>);
        </programlisting>
        </para>
        <para>
            <function>Read</function> transfers data from the channel to the users's buffer;
            <parameter>pData</parameter>.  <parameter>nChars</parameter> is the number
            of characters of data that will be transferred.
            <function>Write</function> transfers <parameter>nBytes</parameter>
            <firstterm>bytes</firstterm> data to the chnnel from <parameter>pData</parameter>.
            Both function return the number of characters actually transferred.
            An important note about the <parameter>nChars</parameter> parameter:  If the
            channel is not opened as a binary channel, this parameter is the number of
            UTF-8 characters transferred.  Depending on the characters actually transmitted,
            this may  not be the same as the number of bytes transmitted.
            The return value is the number of units (bytes or characters) actually transferred.
        </para>
        <para>
        <programlisting>

  <type>bool</type> <function>atEof</function>();
        </programlisting>
        </para>
        <para>
            Returns <literal>true</literal> if the underlying channel is at the end of file.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>Flush</function>();
        </programlisting>
        </para>
        <para>
            Tcl channels are internally buffered. The <function>Flush</function> member
            flushes internal output buffers to the underlying I/O endpoint.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>Close</function>();
        </programlisting>
        </para>
        <para>
            Closes the underlying channel. Note that this is normally done on
            destruction unless the channel object was created via copy construction.
            If the channel was registered to be visible to the interpreter, it is
            unregistered as well.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>Register</function>();
        </programlisting>
        </para>
        <para>
            Makes the channel visible to the interpreter.  This allows the user
            to return the channel name to the script level at which point it can be
            used in Tcl script commands that operate on channels.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>SetEncoding</function>(<type>std::string</type> <parameter>Name</parameter>);
  <type>std::string</type> <function>GetEncoding</function>();
        </programlisting>
        </para>
        <para>
            These functions allow the user to get and set the encoding for the channel.
            See the <command>fconfigure</command> Tcl man page for more information about this.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
close(3tcl),
fconfigure(3tcl),
open(2),
Tcl_OpenCommandChannel(3tcl),
Tcl_OpenFileChannel(3tcl),
Tcl_OpenTcpClient(3tcl),
Tcl_OpenTcpServer(3tcl)
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLFileHandler">
    <refmeta>
        <refentrytitle>CTCLFileHandler</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLFileHandler</refname>
        <refpurpose>
            Base class for building object oriented Tcl File event handlers.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLFileHandler.h&gt;
...

class CTCLFileHandler  : public CTCLInterpreterObject
{
  CTCLFileHandler(CTCLInterpreter* pInterp,
                   UInt_t am_nFid = STDIN_FILENO);
  CTCLFileHandler(CTCLInterpreter* pInterp,
                  FILE* pFile);
  CTCLFileHandler (const CTCLFileHandler&amp; aCTCLFileHandler );
  ~CTCLFileHandler ( );
  CTCLFileHandler&amp; operator= (const CTCLFileHandler&amp; aCTCLFileHandler);
  int operator== (const CTCLFileHandler&amp; aCTCLFileHandler) const;

  UInt_t getFid() const;

  virtual   void operator() (int mask)   = 0;

  void Set (int mask)  ;
  void Clear ()  ;
};

    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Tcl supplies an event loop.  It is possible to add events specifications
            to this loop.  One very useful event type is based on readability or writability
            of a file descriptor.   The <classname>CTCLFileHandler</classname> allows you
            to create an object oriented file handler, and register it with the event
            loop so that you can gain control when, for example, a file becomes readable.
        </para>
        <para>
            As <classname>CTCLFileHandler</classname> is an abstract base class,
            it is necessary to create a derived class.  The derived class should
            implement the <function>operator()</function> which will be called
            when the specific event is fired.  An instance of this derived class should
            be created, and then the <function>Set</function> and <function>Clear</function>
            members used to establish and remove the event handler.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
  <function>CTCLFileHandler</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
                   <type>UInt_t</type> <parameter>nFid</parameter> = <literal>STDIN_FILENO</literal>);
  <function>CTCLFileHandler</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
                  <type>FILE</type>* <parameter>pFile</parameter>);
  <function>CTCLFileHandler</function> (const <type>CTCLFileHandler</type>&amp; <parameter>aCTCLFileHandler</parameter> );
        </programlisting>
        </para>
        <para>
            Constructs a file handler object.  <parameter>pInterp</parameter> is a
            pointer to the interpreter on which the file handler will be registered.
            The file can be specified either by <parameter>nFid</parameter>, a file
            descriptor, or <parameter>pFile</parameter> an stdio File stream pointer.
        </para>
        <para>
            A copy constructor allows the creation of a copy of the file handler object
            given <parameter>aCTCLFileHandler</parameter> an existing one.  This is normally
            not useful.
        </para>
        <para>
            <programlisting>
  <type>CTCLFileHandler</type>&amp; <function>operator=</function> (const <type>CTCLFileHandler</type>&amp; <parameter>aCTCLFileHandler</parameter>);
  <type>int</type> <function>operator==</function> (const <type>CTCLFileHandler</type>&amp; <parameter>aCTCLFileHandler</parameter>) const;
            </programlisting>
        </para>
        <para>
            These functions support assignment and equality comparison.  Note that these functions
            are usually not very useful for file handlers.
        </para>
        <para>
        <programlisting>
  <type>UInt_t</type> <function>getFid()</function> const;
        </programlisting>
        </para>
        <para>
            Returns the file id that is associated with the event.
        </para>
        <para>
            <programlisting>
  virtual   <type>void</type> <function>operator</function>() (<type>int</type> <parameter>mask</parameter>)   = 0;
            </programlisting>
        </para>
        <para>
            The user's derived class must override this to provide the desired
            funtionality when event fires.  <parameter>mask</parameter>
            indicates which event fired the function and can be an or of the following:
            <literal>TCL_READABLE</literal> if the file can be read without blocking,
            <literal>TCL_WRITABLE</literal> if the file can be written without blocking,
            or <literal>TCL_EXCEPTION</literal> if some exceptional condition occured on the
            file.
        </para>
        <para>
            <programlisting>
  <type>void</type> <function>Set</function> (<type>int</type> <parameter>mask</parameter>)  ;
  <type>void</type> <function>Clear</function> ()  ;
        </programlisting>
        </para>
        <para>
            <function>Set</function> establishes the event handler for the set of conditions
            described in <parameter>mask</parameter>.  The valid bits for <parameter>mask</parameter>,
            are described in the documentation for the <parameter>mask</parameter>
            parameter to <function>operator()</function>.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLObject(3),
CTCLInterpreter(3)
Tcl_CreateFileHandler(3tcl),
Tcl_DeleteFileHandler(3tcl)
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLIdleProcess">
    <refmeta>
        <refentrytitle>CTCLIdleProcess</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLIdleProcess</refname>
        <refpurpose>
            Allows the establishment of an executable object that
            can be scheduled to be invoked when the Tcl/Tk intperpreter
            has no events that require processing.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLIdleProcess.h&gt;

class CTCLIdleProcess : protected CTCLTimer
{
public:
  CTCLIdleProcess(CTCLInterpreterObject* pObject);
  CTCLIdleProcess(CTCLInterpreter* pInterp);
  virtual ~CTCLIdleProcess();

  void Set();
  void Clear();
  virtual void operator()() = 0;
};
    </programlisting>

    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            While Tcl provides a mechanism for scheduling the execution of
            a function when the interpreter main loop is idle (no pending events),
            this is not suitable for processes that may need to be rescheduled.
            Therefore, <classname>CTCLIdleProcess</classname> is actually based on a
            timer dispatch where the delay interval is 0ms.
        </para>
        <para>
        <classname>CTCLIdleProcess</classname>
        provides an abstract base class for creating function like classes that
        are 'called' to run interleaved with the interpreter.
        A function like class is one that implements <classname>operator()</classname>
        (see REFERENCES) below.  You can create an idle processor by creating
        a subclass of <classname>CTCLIdleProcess</classname> overriding
        <classname>operator()</classname>, creating an instance of that new class,
        and invoking the <function>Set()</function> function to schedule the
        execution of the <function>operator()</function>.  Note that
        It is possible for the code in your <function>operator()</function> to
        reschedule itself by calling <function>Set()</function>.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
  <function>CTCLIdleProcess</function>(<type>CTCLInterpreterObject</type>* <parameter>pObject</parameter>);
  <function>CTCLIdleProcess</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>);
        </programlisting>
        </para>
        <para>
            Creates a <classname>CTCLIdleProcess</classname> and initializes the timer on which this
            is based. <parameter>pInterp</parameter> is the interpreter that will schedule
            the object's <function>operator()</function>.  <parameter>pObject</parameter>
            points to an interpreter object who's interpreter will schedule the
            <function>operator()</function> to run.
        </para>
        <para>
            <programlisting>
  <type>void</type> <function>Set</function>();
  <type>void</type> <function>Clear</function>();
            </programlisting>
        </para>
        <para>
            These function control the scheduling of the <function>operator()</function>
            call. <function>Set</function> schedules the function to be called pretty much
            the next time the interpreter loop is intered, while <function>Clear</function>
            cancels a pending schedule.
        </para>
        <para>
            <programlisting>
  virtual <type>void</type> <function>operator()</function>() = 0;
        </programlisting>
        </para>
        <para>
            This pure virtual function is overridden by your idle processor to
            provide the behavior of the idle processor.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLTimer(3),
Tcl_CreateTimerHandler(3tcl),
Tcl_DoWhenIdle(3tcl),

        </para>
    </refsect1>
    <refsect1>
        <title>REFERENCES</title>
        <para>
            <programlisting>
Musser, Derge, Saini: <parameter>STL Tutorial and Reference Guide</parameter>
Addison-Wesley Professional Computing Series; 2001 ISBN 0-201-37923-6
See section 2.4 for a description and discussion of function objects.
            </programlisting>
        </para>
    </refsect1>
</refentry>



<refentry id="manpage.CTCLTimer">
    <refmeta>
        <refentrytitle>CTCLTimer</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLTimer</refname>
        <refpurpose>
            Abstract base class for C++ objects attached to timer events.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLTimer.h&gt;
...
class CTCLTimer  : public CTCLInterpreterObject
{
public:
  CTCLTimer ();
  CTCLTimer(CTCLInterpreter* pInterp, UInt_t nMsec = 0);
  virtual ~CTCLTimer ( );


  Tk_TimerToken getToken() const;
  UInt_t getMsec() const;
  Bool_t IsSet() const;

  virtual   void operator() ()   = 0;

  void Set ()  ;
  void Set(UInt_t nms);
  void Clear ()  ;
};


    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Tcl/Tk provide a mechanism for scheduling functions to be executed
            after a time delay specified in milliseconds.   The <classname>CTCLTimer</classname>
            class is an abstract base class that provides an interface into the API
            for that facility.  To use <classname>CTCLTimer</classname> you must
            create a class derived from <classname>CTCLTimer</classname> that
            overrides and implement the <function>operator()</function> function.
            Create an object from the resulting function class.  Use the object's
            <function>Set</function> and <function>Clear</function> members to schedule
            or cancel a scheduled execution.  The code fragment
            example below shows how to do this
            to create a class that periodically emits the text "Tick" to stderr.
            Many #include directives are missing for brevity.
            </para>
            <informalexample>
            <programlisting>
// Interface to <classname>Ticker</classname> normally goes in a header.
class Ticker : public CTCLTimer
{
public:
    Ticker(CTCLInterpreter* pInterp, int seconds);
    virtual ~Ticker();

    virtual void operator()();
};
...
// Implementation of <classname>Ticker</classname> normally goes in a .cpp

// Constructor of Ticker:

Ticker::Ticker(int seconds) :
    CTCLTimer(pInterp, seconds*1000)
{
    Set();                   // Schedule first one.
}
// Destructor.. chain to base class.
Ticker::~Ticker() {}

// called when timer goes off:
void
Ticker::operator()() {
    cerr &lt;&lt; "Tick\n";
    Set();                 // Schedule next one.
}
...


Ticker Tick(pInterp, 1);  // Tick every second.

            </programlisting>
            </informalexample>
        
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <informalexample>
        <programlisting>
<function>CTCLTimer</function> ();
<function>CTCLTimer</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
          <type>UInt_t</type> <parameter>nMsec</parameter> = <literal>0</literal>);
          </programlisting>
        </informalexample>
          <para>
            Construct timer objects.  The first form of the constructor creates a timer
            object that must be later bound into an interpreter via a call to
            <classname>CTCLInterpreterObject</classname>::<function>Bind</function>.
            The seconf form of the contructor creates a timer object that is already
            bound to <parameter>pInterp</parameter> and has an initial schedule delay
            of <parameter>nMsec</parameter>.
          </para>
          <informalexample>
          <programlisting>
  Tk_TimerToken getToken() const;
  UInt_t getMsec() const;
          </programlisting>
          </informalexample>
          <para>
            These two members access internal state of the object.
            <function>getToken</function> returns the <type>Tk_TimerToken</type>
            associated with the timer object.  This is the Tcl/Tk token that
            identifies the timer request to the interpreter.
            <function>getMsec</function> retrieves the current value of the delay parameter
            in milliseconds.
          </para>
          <informalexample>
          <programlisting>
  virtual   void operator() ()   = 0;
        </programlisting>
          </informalexample>
        <para>
            This function must be overidden and implemented in concrete timer classes.
            See the example in DESCRIPTION above.
        </para>
        
        <informalexample>
        <programlisting>

  void Set ()  ;
  void Set(UInt_t nms);
  Bool_t IsSet() const;
        </programlisting>
        </informalexample>
        
        <para>
            <function>Set</function> schedules the object for execution.  If
            <parameter>nms</parameter> is provided it is saved as the scheduling
            parameter and determines the delay
            in milliseconds before <function>operator()</function> is
            next called.  If not provided, the most recently used delay will be
            used again.
        </para>
        <para>
            <function>IsSet</function> returns <literal>kfTRUE</literal> if the
            timer is currently pending, or <literal>kfFALSE</literal> if no pending
            timer request is active.
        </para>
        <para>
        <informalexample>
        <programlisting>
  void Clear ()  ;
        </programlisting>
        </informalexample>
        </para>
        <para>
           If a Timer request is pending, cancels it.  If no timer request is pending,
            this function does nothing, and does not report an error.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLInterpreterObject(3)
        </para>
    </refsect1>
    <refsect1>
        <title>REFERENCES</title>
        <para>
            <informalexample>
            <programlisting>
Musser, Derge, Saini: <parameter>STL Tutorial and Reference Guide</parameter>
Addison-Wesley Professional Computing Series; 2001 ISBN 0-201-37923-6
See section 2.4 for a description and discussion of function objects.
            </programlisting>
            </informalexample>
        </para>
    </refsect1>
</refentry>
    <refentry id="manpage.CTCLLiveEventLoop">
      <refmeta>
         <refentrytitle>CTCLLiveEventLoop</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CTCLLiveEventLoop</refname>
	 <refpurpose>Run Tcl with event loop.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CTCLLiveEventLoop.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CTCLLiveEventLoop</classname></ooclass>
            <methodsynopsis>
                <modifier>static</modifier> <type>CTCLLiveEventLoop*</type>
                                            <methodname>getInstance</methodname>
                                            <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>start</methodname>
                                  <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>start</methodname>
                <methodparam>
                    <type>CTCLInterpreter*</type> <parameter>pInterp</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>stop</methodname>
                                  <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>long</type> <methodname>setStopLatency</methodname>
                <methodparam>
                    <type>long</type> <parameter>ms</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>long</type> <methodname>getStopLatency</methodname>
                                <void /> <modifier>const</modifier>
            </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            The Tcl/Tk applications programming interfaces provides an event loop.
            In the case of Tk programs, the event loop is active once the Tk
            package starts.  For pure Tcl (non GUI) programs, the event loop
            is not active unless the script explicitly enters the event loop
            via e.g. <command>vwait</command>.
         </para>
         <para>
            <command>vwait</command> and other pure Tcl commands that enter
            the event loop block the interpreter from processing commands on
            stdin while the loop is running.  For some Tcl based data acquisition
            programs this is not acceptable.  For example, a readout program may
            want to accept commands on the command line while doing some periodic
            processing.  This class provides the ability to do this.
         </para>
         <para>
            The class is a singleton pattern instance, which means that you cannot
            actually construct an instance, but must use the <methodname>getInstance</methodname>
            method to get a pointer to the single instance of the singleton.
            The class works by establishing an event handler on stdin,
            and manually running the event loop at the C++ level.
            The C++ event loop and stdin input handler do prompting analagous
            to that of tclsh.  When the stdin event handler has accumulated a
            syntactically complete command it passes that on to the interpreter
            for evaluation, reporting the result to stdout.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <methodsynopsis>
                <modifier>static</modifier> <type>CTCLLiveEventLoop*</type>
                                            <methodname>getInstance</methodname>
                                            <void />
            </methodsynopsis>
            <para>
                Returns a pointer to the singleton instance of the
                live event loop object.  The object is a singleton because
                while each application may have more than one interpreter,
                there is only at most one event loop.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>start</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Starts the event loop.  This will not return to the caller
                until some external force has stopped the event loop.
                External forces include the user closing stdin, or
                the event loop being asked to stop.
            </para>
            <para>
                In this invocation, the commands accumulated on stdin are
                dispatched to the interpreter that was bound to the
                <classname>CTCLApplication</classname> object.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>start</methodname>
                <methodparam>
                    <type>CTCLInterpreter*</type> <parameter>pInterp</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Starts the event loop.  Commands accumulated by the stdin event
                handler are submited to <parameter>pInterp</parameter> for
                execution.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>stop</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Requests the event loop to stop processing.
                See below for the latency between this request and the
                actual stop time. Note that a different thread can call this
                than the one running the target interpreter.
            </para>
            <methodsynopsis>
                <type>long</type> <methodname>setStopLatency</methodname>
                <methodparam>
                    <type>long</type> <parameter>ms</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                The event loop waits for events with a timeout. When a wait
                has completed, if there are events in the queue, they are all
                processed.  After processing any pending events, the event loop
                determines if a stop has been requested, and if so, returns to
                its caller.
            </para>
            <para>
                The wait timeout is set by this member function to
                <parameter>ms</parameter> milliseconds.  This effectively sets
                an estimated latency between the <methodname>stop</methodname>
                member being called, and the event loop actually exiting.
            </para>
            <para>
                The function returns the prior latency setting.
            </para>
            <methodsynopsis>
                <type>long</type> <methodname>getStopLatency</methodname>
                                <void /> <modifier>const</modifier>
            </methodsynopsis>
            <para>
                Returns the current value of the latency setting.
                See <methodname>setStopLatency</methodname> above for
                more information. 
            </para>
      </refsect1>
      <refsect1>
         <title>EXAMPLES</title>
         <para>
            The sample below is a stock tclsh that always runs the event loop
             in the background.  It is installed in the NSCLDAQ
             <filename>bin</filename> directory as
            <application>evttclsh</application>
         </para>
         <example>
            <title>evttclsh</title>
            <programlisting>
#include &lt;TCLApplication.h&gt;
#include &lt;TCLLiveEventLoop.h&gt;

class evttclsh : public CTCLApplication
{
public:
  virtual int operator()();
};

int
evttclsh::operator()()
{
  CTCLLiveEventLoop* pLoop = CTCLLiveEventLoop::getInstance();
  pLoop-&gt;start();
  return TCL_ERROR;
}

CTCLApplication* gpTCLApplication = new evttclsh;

            </programlisting>
         </example>
      </refsect1>
   </refentry>


    <refentry id="manpage.ctclchannelcommander">
      <refmeta>
         <refentrytitle>CTCLChannelCommander</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CTCLChannelCommander</refname>
	 <refpurpose>Accept commands on a Tcl channel from the event loop.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CTCLChannelCommander.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CTCLChannelCommander</classname></ooclass>
            <constructorsynopsis>
                <methodname>CTCLChannelCommander</methodname>
                <methodparam>
                    <type>CTCLInterpreter*</type> <parameter>interp</parameter>
                </methodparam>
                <methodparam>
                    <type>Tcl_Channel</type>      <parameter>channel</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~CTCLChannelCommander</methodname>
                                             <void />
            </destructorsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>start</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>stop</methodname>
                                             <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>Tcl_Channel</type>  <methodname>getChannel</methodname>
                                          <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>onInput</methodname>
                                             <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>onInputException</methodname>
                                                               <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>onEndFile</methodname>
                                                               <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>onCommand</methodname>
                                             <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>returnResult</methodname>
                                             <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>prompt1</methodname>
                                <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>prompt2</methodname>
                                             <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>sendPrompt</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>prompt</parameter>
                </methodparam>
            </methodsynopsis>


         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            The <classname>CTCLChannelCommander</classname> is a class that
            registers an input event handler for a Tcl channel.  When input
            is available on the channel, a line of text is read, and appended
            to a command under construction.  When the command is syntactically
            complete, it is dispatched to a Tcl interpreter for execution.
         </para>
         <para>
            The subclass <classname>CTCLStdioCommander</classname> is specifically
            tailored to accept commands on stdin.  ALong with the server listener
            <classname>CTCLServer</classname>, <classname>CTCLTcpServerInstance</classname>
            is tailored to accpet commands on a socket.
         </para>
         <para>
            Many aspects of the class are tailorable by overriding the various
            methods in derived classes.  The class is capable of generating prompts
            in case the channel is interactive.  The classs can also return the
            results of commands to the client over the medium of its choice.
            End file and exception handling can be simlarly tailored.
         </para>
         <para>
            When deriving a specific class be sure you understand the default actions
            of all of the base class members. You may save a great deal of work by
            carefully chosing exactly which members to override, or generate a
            great deal of work by making poor choices.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
           <methodsynopsis>
                <methodname>CTCLChannelCommander</methodname>
                <methodparam>
                    <type>CTCLInterpreter*</type> <parameter>interp</parameter>
                </methodparam>
                <methodparam>
                    <type>Tcl_Channel</type>      <parameter>channel</parameter>
                </methodparam>
            </methodsynopsis>
           <para>
            Constructs a new channel commander. Activation of the commander is
            a two step process.  First the commander is constructed, second
            it <methodname>start</methodname> method is called to register the
            event handlers.  
           </para>
           <para>
            <parameter>interp</parameter> is a pointer to the interpreter
            channel on to which the commands will be dispatched.
            <parameter>channel</parameter> is the channel from which commands
            will be accepted.
           </para>
           <para>
            The application must also be visiting the event loop for
            commands to be processed from the
            <parameter>channel</parameter>.
            Tk applications automatically run the event loop.
            Pure Tcl applications run the event loop only when
            <command>vwait</command> is waiting, while the
            special shell or tcl applications based around
            <classname>CTCLLiveEventLoop</classname> run the
            event loop automatically just like Tk does.
           </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>start</methodname>
                <void />
            </methodsynopsis>
            <para>
                Enables processing of commands from the channel.  When
                the event loop is entered, if the channel is readable,
                control will be to
                <methodname>onInput</methodname> in object context.
                It is not considered an error to call
                <methodname>start</methodname> when event processing
                is in progress.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>stop</methodname>
                                             <void />
            </methodsynopsis>
            <para>
                Requests channel processing be disabled.  The event handlers
                that arrange for control to be dispatched to the
                <methodname>onInput</methodname>
                method are disabled.  The channel remains open and must
                be closed (if desired) by any client software.
            </para>
            <methodsynopsis>
                <type>Tcl_Channel</type>  <methodname>getChannel</methodname>
                                          <void /> <modifier>const</modifier>
            </methodsynopsis>
            <para>
                Returns the channel from which commands are being accepted.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>onInput</methodname>
                                             <void />
            </methodsynopsis>
            <para>
                This member function is called when data can be read from the
                input channel.  The function attempts to read a line of text.
                The text is appended to a command under construction and,
                if <function>Tcl_CommandComplete</function> says that
                string is a syntactically complete command,
                <methodname>onCommand</methodname> is invoked to execute the
                command.  
            </para>
            <para>
                All of this command acquisition and exection is also mixed up
                with prompting.
                <methodname>prompt1</methodname>
                is called when the object is ready to get  a new command, and
                <methodname>prompt2</methodname> is called when the
                object is ready to accept the next line of a multi-line command.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>onInputException</methodname>
                                                               <void />
            </methodsynopsis>
            <para>
                Called when an exception condition is detected on the channel. The default implementation
                calls
                <methodname>onEndFile</methodname>
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>onEndFile</methodname>
                                                               <void />
            </methodsynopsis>
            <para>
                Called when reads of the channel indicate an end file condition.
                <methodname>onInputException</methodname>'s default implementation
                also calls this.  The default behavior is to invoke
                <methodname>stop</methodname> so that no additional events will
                be posted.  This is the normal and reasonable behavior because
                a channel with an endfile condition continously generates
                readable events.
            </para>
            <para>
                The channel remains open.  It is always up to client software to
                close the channel.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>onCommand</methodname>
                                             <void />
            </methodsynopsis>
            <para>
                Called when a complete command has been accepted.  Complete in this
                case means syntactically complete.  It does not imply correctness,
                or even proper number of arguments.
            </para>
            <para>
                Default behavior is to submit the command string to the
                interpreter. Once the command has been executed,
                <methodname>returnResult</methodname>
                is executed to allow the command result to be reported
                if desired.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>returnResult</methodname>
                                             <void />
            </methodsynopsis>
            <para>
                By default this does nothing.  It is provided to allow subclasses
                to tailore what is done with command results.  For example,
                the
                <classname>CTCLStdioCommander</classname>
                class reports the result on
                <literal>stdout</literal>.
                <classname>CTCLTcpServerInstance</classname> on the other hand
                reports the result back to the client over the socket.
            </para>
            <para>
                The <methodname>GetResultString</methodname> method of the
                interpreter object (the pointer <varname>m_pInterp</varname>
                is a pointer to the interpreter object) should be used to
                get the result string.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>prompt1</methodname>
                                <void />
            </methodsynopsis>
            <para>
                Called when its time to prompt for the first line of a command.
                This calls
                <methodname>prompt1String</methodname> to get the prompt string,
                and calls
                <methodname>sendPrompt</methodname> to actually emit the prompt.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>prompt2</methodname>
                                             <void />
            </methodsynopsis>
            <para>
                Called when its time to prompt for additional linesof a command.
                This calls
                <methodname>prompt2String</methodname> to get the prompt string
                and calls
                <methodname>sendPrompt</methodname> to actually emit the prompt.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>sendPrompt</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>prompt</parameter>
                </methodparam>
            </methodsynopsis>
       </refsect1>
      <refsect1>
        <title>Prompting</title>
        <para>
            The class provides a framework for prompting interactive channels.
            This frameworks is based on two prompt strings that can be gotten
            via calls to
            <methodname>prompt1String</methodname> and
            <methodname>prompt2String</methodname>
            respectively.
        </para>
        <para>
            The first of these prompts is emitted when the software is
            ready to accept the first line of a new command.
            By default it is the text "<literal>% </literal>".  Scripts
            can customize this prompt by defining the
            variable <varname>tcl_prompt1</varname> to be a script
            whose returned value is the prompt.
        </para>
        <para>
            The second of these prompts is emitted when the software
            is ready to accept continuation lines of multiline commands.
            By default it is the text "<literal>%_ </literal>".
            Scripts can customize this prompt by defining the
            variable <varname>tcl_prompt2</varname> to be a script
            whose returned value is the desired prompt.
        </para>
      </refsect1>
   </refentry>
    <refentry id="manpage.CTCLStdioCommander">
      <refmeta>
         <refentrytitle>CTCLStdioCommander</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CTCLStdioCommander</refname>
	 <refpurpose>Event driven command input on stdin/stdout</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CTCLStdioCommander.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CTCLStdioCommander</classname></ooclass>
            <constructorsynopsis>
                <methodname>CTCLStdioCommander</methodname>
                <methodparam>
                    <type>CTCLInterpreter*</type> <parameter>pInterp</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~CTCLStdioCommander</methodname>
                                             <void />
            </destructorsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>sendPrompt</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>prompt</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>returnResult</methodname>
                                             <void />
            </methodsynopsis>

         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            Provides a commander that can be hooked to the event loop to allow
            event loop driven applications to continue to process commands on
            stdin/stdout as interactive shells do.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <methodsynopsis>
                <methodname>CTCLStdioCommander</methodname>
                <methodparam>
                    <type>CTCLInterpreter*</type> <parameter>pInterp</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Constructs a commander.  <parameter>pInterp</parameter> is the
                interpreter to which the complete commands will be submitted.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>sendPrompt</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>prompt</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Overrides the base class <methodname>sendPrompt</methodname>
                method by sending the requested <parameter>prompt</parameter>
                string to the <type>Tcl_Channel</type> Tcl has open on
                <literal>stdout</literal>. The channel is also flushed to
                ensure that the prompt is made immediately visible.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>returnResult</methodname>
                                             <void />
            </methodsynopsis>
            <para>
                Overrides the base class member.
                Retrieves the result from the interpreter, appends a newline
                character and passes the resulting string to
                <methodname>sendPrompt</methodname> which makes the result
                visible on stdout.
            </para>
      </refsect1>
   </refentry>


    <refentry id="manpage.CTCLServer">
      <refmeta>
         <refentrytitle>CTCLServer</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CTCLServer</refname>
	 <refpurpose>Listener for a Tcl server.</refpurpose>
      </refnamediv>     
      <refsynopsisdiv>
         <programlisting>
#include &lt;CTCLServer.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CTCLServer</classname></ooclass>
            <constructorsynopsis>
                <methodname>CTCLServer</methodname>
                <methodparam>
                    <type>CTCLInterpreter*</type> <parameter>pInterp</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>port</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~CTCLServer</methodname>
                                             <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>void</type>
                <methodname>instanceExit</methodname>
                <methodparam>
                    <type>CTCLTcpServerInstance*</type> <parameter>pInstance</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type>
                <methodname>shutdown</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>protected virtual</modifier>
                <type>bool</type> <methodname>allowConnection</methodname>
                <methodparam>
                    <type>Tcl_Channel</type> <parameter>connection</parameter>
                </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>hostname</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>protected virtual</modifier>
                <type>CTCLTcpServerInstance*</type>
                <methodname>createInstance</methodname>
                <methodparam>
                    <type>Tcl_Channel</type> <parameter>connection</parameter>
                </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>hostname</parameter>
                </methodparam>
            </methodsynopsis>
 
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            Tcl servers allow a Tcp/Ip client to connect to a tcl application
            and poke commands at it.  While this is a very powerful communications
            mechanism, it should be used very cautiously as it can also be quite
            dangerous (imagine a client pushing a command like
            <command>exec /bin/bash -c rm -rf ~</command> for example).
         </para>
         <para>
            <classname>CTCLServer</classname> is a class that provides the listener
            portion of the server.  The application that uses this must execute
            a Tcl event loop in a timely fashion.
            <classname>CTCLServer</classname> processes connections and creates,
            where appropriate <classname>CTCLTcpServerInstance</classname> objects
            that handle communication with clients.
            The server object maintains a directory of server instances so that when
            asked to shutdown it can shutdown all server instances as well.
         </para>
         <para>
            The class provides strategy pattern hooks to support arbitrary
            authorization models, as well as the production of any subclass
            of <classname>CTCLTcpServerInstance</classname> to process
            the commands.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <methodsynopsis>
                <methodname>CTCLServer</methodname>
                <methodparam>
                    <type>CTCLInterpreter*</type> <parameter>pInterp</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>port</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Constructs and activates a server object. Activation means that
                the Tcl event loop can dispatch events for client connections
                to the object for processing.
                <parameter>pInterp</parameter> is the interpreter this server
                is supposed to be servicing.  In the standard scheme, this is
                the interpreter to which commands will be dispatched.
                <parameter>port</parameter> is the Tcp/IP port on which the
                server will listen for connections.
            </para>
            <methodsynopsis>
                <type>void</type>
                <methodname>instanceExit</methodname>
                <methodparam>
                    <type>CTCLTcpServerInstance*</type> <parameter>pInstance</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                The server maintains a directory of server instances.  When server
                instances exit they must call this function in the server listener
                passing a pointer to themselves (<varname>this</varname>) as a
                parameter.  This function locates the instance in the
                directory, removes it from the directory and
                <emphasis>deletes that object</emphasis>.
            </para>
            <para>
                Having called this, the server instance should return
                immediately as its object context has become invalid.
                If the server listener object is asked to shutdown, it will
                also call <methodname>instanceExit</methodname> on all
                instances to shut them down as well.
            </para>
            <methodsynopsis>
                <type>void</type>
                <methodname>shutdown</methodname>
                <void />
            </methodsynopsis>
            <para>
                Stops listening for connections on the server port and
                shuts down all instances by invoking
                <methodname>instanceExit</methodname> on them.
            </para>
            <methodsynopsis>
                <modifier>protected virtual</modifier>
                <type>bool</type> <methodname>allowConnection</methodname>
                <methodparam>
                    <type>Tcl_Channel</type> <parameter>connection</parameter>
                </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>hostname</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Called at connection time to determine if the connection should
                be allowed.  <parameter>connection</parameter> is the
                <type>Tcl_Channel</type> that is open on the client.
                overrides of this are perfectly free to do any sort of
                communication back and fort with the client to determine
                its elligibility to connect. 
            </para>
            <para>
                <parameter>hostname</parameter> is the name of the host
                that is connecting.  This allows a host based authentication
                scheme to be developed.
            </para>
            <para>
                The function must return <literal>true</literal> to accept the
                connection and <literal>false</literal> to deny it.
            </para>
            <methodsynopsis>
                <modifier>protected virtual</modifier>
                <type>CTCLTcpServerInstance*</type>
                <methodname>createInstance</methodname>
                <methodparam>
                    <type>Tcl_Channel</type> <parameter>connection</parameter>
                </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>hostname</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Called to create a client instance.  The client instance is responsible
                for interacting with the client to do whatever communication is needed.
                By making this virtual, any type descended from
                <classname>CTCLTcpServerInstance</classname> can be created.
            </para>
            <para>
                <parameter>connection</parameter> is the <type>Tcl_Channel</type>
                open on the client.
                <parameter>hostname</parameter> is the host that is connecting.
            </para>
      </refsect1>

   </refentry>

    <refentry id="manpage.CTCLTcpServerInstance">
      <refmeta>
         <refentrytitle>CTCLTcpServerInstance</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CTCLTcpServerInstance</refname>
	 <refpurpose>Channel commander that is a server instance for <classname>CTCLServer</classname></refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CTCLTcpServerInstance.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CTCLTcpServerInstance : public CTCLChannelCommander</classname></ooclass>
            <constructorsynopsis>
                <methodname>CTCLTcpServerInstance</methodname>
                <methodparam>
                    <type>CTCLInterpreter*</type> <parameter>pInterp</parameter>
                </methodparam>
                <methodparam>
                    <type>Tcl_Channel</type> <parameter>connection</parameter>
                </methodparam>
                <methodparam>
                    <type>CTCLServer*</type> <parameter>pServer</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~CTCLTcpServerInstance</methodname>
                                             <void />
            </destructorsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                            <methodname>onEndFile</methodname>
                            <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                        <methodname>returnResult</methodname>
                                        <void />
            </methodsynopsis>

         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            Server instance that takes client commands and submits them to
            an interpreter.  The results of each command are sent back to the
            client. At this point the client can only look at the
            result value to determine if there was an error as no error indication
            is passed back.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <constructorsynopsis>
                <methodname>CTCLTcpServerInstance</methodname>
                <methodparam>
                    <type>CTCLInterpreter*</type> <parameter>pInterp</parameter>
                </methodparam>
                <methodparam>
                    <type>Tcl_Channel</type> <parameter>connection</parameter>
                </methodparam>
                <methodparam>
                    <type>CTCLServer*</type> <parameter>pServer</parameter>
                </methodparam>
            </constructorsynopsis>
            <para>
                Constructs a new server instance.
                <parameter>pInterp</parameter> is the interpreter to which
                commands should be directed.
                <parameter>connection</parameter> is the <type>Tcl_Channel</type>
                that represents the Tcp/IP connection to the client.
                <parameter>pServer</parameter> is the TCL server object
                that starts us.  That server's
                <methodname>instanceExit</methodname> member should be called
                to shut down and clean up this object.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                            <methodname>onEndFile</methodname>
                            <void />
            </methodsynopsis>
            <para>
                Override to end of file handling.  Closes the
                channel and invokes the
                server listener's <methodname>instanceExit</methodname>
                method to get ourselves deleted.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                        <methodname>returnResult</methodname>
                                        <void />
            </methodsynopsis>
            <para>
                Returns a command result by fetching it from the interpreter
                and sending it back to the client on the socket.
            </para>
      </refsect1>
   </refentry>

    <refentry id="manpage.citemconfiguration">
      <refmeta>
         <refentrytitle>CItemConfiguration</refentrytitle>
         <manvolnum>3tcl</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CItemConfiguration</refname>
     <refpurpose>Hold a configuration</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CItemConfiguration.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CItemConfiguration</classname></ooclass>
            <constructorsynopsis>
                <methodname>CItemConfiguration</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CItemConfiguration</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CItemConfiguration&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier>   <methodname>~CItemConfiguration</methodname>
                <void />
                </destructorsynopsis>
            <methodsynopsis>
                <type>CItemConfiguration&amp;</type>
                <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>CItemConfiguration&amp;</type> <parameter>rhs</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>int</type>
                <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CItemConfiguration&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                <modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CItemConfiguration&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                <modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type>
                <methodname>getName</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type> <methodname>cget</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>ConfigurationArray</type> <methodname>cget</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>getIntegerParameter</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>unsigned int</type> <methodname>getUnsignedParameter</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>bool</type>    <methodname>getBoolParameter</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>double</type> <methodname>getFloatParameter</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>std::vector&lt;int&gt;</type> <methodname>getIntegerList</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addParameter</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>typeChecker</type> <parameter>checker</parameter>
                    </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type>  <parameter>defaultValue</parameter>
                    <initializer>std::string("")</initializer>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>clearConfiguration</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>configure</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>value</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>bool</type> <methodname>isInteger</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type>  <parameter>value</parameter>
                    </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>bool</type> <methodname>isBool</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type>  <parameter>value</parameter>
                    </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>bool</type> <methodname>isEnum</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type>  <parameter>value</parameter>
                    </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>bool</type> <methodname>isFloat</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type>  <parameter>value</parameter>
                    </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>bool</type> <methodname>isList</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type>  <parameter>value</parameter>
                    </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier> <type>bool</type>
                <methodname>isBoolList</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type>  <parameter>value</parameter>
                    </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>bool</type> <methodname>isIntList</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type>  <parameter>value</parameter>
                    </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier> <type>bool</type>
                <methodname>isStringList</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type>  <parameter>value</parameter>
                    </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            <classname>CItemConfiguration</classname> captures the configuration of an
            item.   A configuration is a set of name-value pairs.  
         </para>
         <para>
            While the values are all stored as strings, validators and type safe
            'getters' allow you to store strictly typed data as well.  A validator
            is a function that is called to ensure a proposed new value for a
            parameter is suitable for the parameter.    Validators are described
            in "Types and public data" below.  A rich set of pre-defined
            validators should meet most needs, however it is possible to write
            and use custom validators should the built in ones be insufficient for
            your application.
            </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
        <methodsynopsis>
            <methodname>CItemConfiguration</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Constructs the configuration.  <parameter>name</parameter> is just
            any string you'd like to associate with the configuration.
            <methodname>getName</methodname> can be used to fetch the value
            of this string.  Names are used with collections of configurations
            when they may be inserted in an STL Map with the item name as the
            lookup key.
            </para>
        <methodsynopsis>
            <methodname>CItemConfiguration</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CItemConfiguration&amp;</type>
                <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Copy construction.  Note that if your application causes copy
                construction several configurations with the same name can be
                be created.  If you want to ensure that copy construction can't
                exist, us a class derived from this in which the copy constructor
                is declared <firstterm>private</firstterm> but never implemented.
                </para>
        <methodsynopsis>
            <modifier>virtual</modifier>   <methodname>~CItemConfiguration</methodname>
            <void />
            </methodsynopsis>
        <para>
            Destructor.
            </para>
        <methodsynopsis>
            <type>CItemConfiguration&amp;</type>
            <methodname>operator=</methodname>
            <methodparam>
                <modifier>const</modifier>
                <type>CItemConfiguration&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Assignment operator.  Note that in the presence of named
            configuration items, this can result in objects with duplicate
            names.  To avoid this derive from this class and set
            the <literal>=</literal> operator to be private...without ever
            Implementing it.
            </para>
        <methodsynopsis>
            <type>int</type>
            <methodname>operator==</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CItemConfiguration&amp;</type>
                <parameter>rhs</parameter>
                </methodparam>
            <modifier>const</modifier>
            </methodsynopsis>
        <para>
            Compares two objects for equality.  Equality is defined as having
            the same name, same set of configuration items with matching values.
            </para>
        <methodsynopsis>
            <type>int</type> <methodname>operator!=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CItemConfiguration&amp;</type>
                <parameter>rhs</parameter>
                </methodparam>
            <modifier>const</modifier>
            </methodsynopsis>
        <para>
            Inequality test operator is the logical inverse of equality.
            </para>
        <methodsynopsis>
            <type>std::string</type>
            <methodname>getName</methodname>
            <void /><modifier>const</modifier>
            </methodsynopsis>
        <para>
            Returns the name string used to construct the object.
            </para>
        <methodsynopsis>
            <type>std::string</type> <methodname>cget</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Returns the string value of the configuration parameter
            <parameter>name</parameter>.  If the name is not a defined
            configuration parameter, this will throw an explanatory string exception.
            See <methodname>addParameter</methodname> for information about how
            to define configuration parameters.
            </para>
        <methodsynopsis>
            <type>ConfigurationArray</type> <methodname>cget</methodname>
            <void />
            </methodsynopsis>
        <para>
            Returns a container <type>ConfigurationArray</type> that provides
            the entire configuration.  See "Types and public data" for more
            information about the <type>ConfigurationArray</type>
            data type.
            </para>
        <methodsynopsis>
            <type>int</type> <methodname>getIntegerParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Returns the value of a parameter <parameter>name</parameter> converted
            to an integer.  This can throw an explanatory string exception either
            if <parameter>name</parameter> is not a defined parameter or if its
            current value does not translate to an integer
            (using <function>strtoul</function>).  Typically <parameter>name</parameter>
            should have been defined with a validator that will make sure the
            value will always be a legal integer.
            </para>
        <methodsynopsis>
            <type>unsigned int</type> <methodname>getUnsignedParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Same as <methodname>getIntegerParameter</methodname> however
            <function>strtoul</function> is used to convert the string ot
            an unsigned value.  Once more the configuration parameter
            <parameter>name</parameter> should have a validator attached
            to it to ensure that the value always represents a legal
            unsigned integer.
            </para>
        <methodsynopsis>
            <type>bool</type>    <methodname>getBoolParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Returns the value of <parameter>name</parameter> as a boolean.
            This will throw a descriptive string exception if <parameter>name</parameter>
            is not a define configuration parameter or if the value is not one of
            <literal>true</literal>,
            <literal>yes</literal>,
            <literal>1</literal>,
            <literal>on</literal>,
            or <literal>enabled</literal> for true and
            <literal>false</literal>,
            <literal>no</literal>,
            <literal>0</literal>,
            <literal>off</literal> or
            <literal>disabled</literal> for false.
            </para>
        <methodsynopsis>
            <type>double</type> <methodname>getFloatParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Returns the value of a parameter <parameter>name</parameter>
            as a floating point <type>double</type>
            value.  If the parameter cannot be decoded as a floating point number
            a string exception is thrown that describes this.
            </para>

        <methodsynopsis>
            <type>std::vector&lt;int&gt;</type> <methodname>getIntegerList</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Returns a parameter <parameter>name</parameter>
            that is supposed to be a list of integers.
            The list is returned as a <type>std::vector&lt;int&gt;</type>.
            A string exception is thrown describing the error in the event
            that either the parameter value is not a valid Tcl list or
            any of the values does not decode as an integer.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>addParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>typeChecker</type> <parameter>checker</parameter>
                </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type>  <parameter>defaultValue</parameter>
                <initializer>std::string("")</initializer>
                </methodparam>
            </methodsynopsis>
        <para>
            Defines a new configuration parameter.  The value of this configuration
            parameter is modified by calling <methodname>configure</methodname>
            below.  <parameter>name</parameter> is the name of the new parameter.
            This parameter definition is ovewritten if it already exists.
            </para>
        <para>
            <parameter>checker</parameter> is a validation function that will be
            called to approve or disapprove of changes to the configuration
            value. Passing a <literal>NULL</literal> for <parameter>checker</parameter>
            disables value checking.
            <parameter>arg</parameter> is a parameter passed to the type checker.
            See "Types and public data " below for a definition of the
            <type>typeChecker</type> function prototype.
            </para>
        <para>
            <parameter>default</parameter> is the initial value of the parameter.
            This defaults to the empty string.  Note that <parameter>default</parameter>
            is not passed through the <parameter>checker</parameter>, so it
            is up to the definer to ensure this value is a legal value for
            the functions used to fetch it from the parameter.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>clearConfiguration</methodname>
            <void />
            </methodsynopsis>
        <para>
            Destroys all parameter definitions.  After this is called,
            no configuration parameters are defined.
            </para> 
        <methodsynopsis>
            <type>void</type> <methodname>configure</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Modifies the value of the configuration parameter
            <parameter>name</parameter> to
            <parameter>value</parameter>.  If either the
            parameter <parameter>name</parameter> has not been defined, or
            <parameter>value</parameter> fails checking, a string
            exception is thrown to describe in human terms the problem.
            </para>

      </refsect1>
      <refsect1>
         <title>Types and public data</title>
         <para>
            This class exports several public data types.  For the sake of
            brevity only the final typename is give, therefore, when you
            use a type like <type>ConfigurationArray</type> remember that it
            must be qualified with the <classname>CItemConfiguration</classname>
            class name (e.g. referred to in your source code as
            <type>CItemConfiguration::ConfigurationArray</type>)
         </para>
         <para>
            One type is exported in the global (unqualified) namespace, this is
            <type>typeChecker</type> which defines the function prototype for
            a configuration parameter validity checker.  The prototype of
            this function is:
            </para>
         <methodsynopsis>
            <type>bool</type> <methodname>(*typeChecker)</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>value</parameter>
                </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Type checkers are registered when a configuration parameter is
            created via <methodname>addParameter</methodname>.  When
            <methodname>configure</methodname> is called and the parameter
            has a type checker it is called.  <parameter>name</parameter> is the
            name of the configuration parameter being configured,
            <parameter>value</parameter> is the proposed new value for the
            parameter.
        </para>
        <para>
            <parameter>arg</parameter> is the <parameter>arg</parameter>
            parameter specified in the call to <methodname>addParameter</methodname>
            that created the configuration parameter in the first place.
            Usually this is some additional information required to validate the
            proposed value.
        </para>
        <para>
            The function must return <literal>true</literal> in the event
            the proposed <parameter>value</parameter> is acceptable and
            <type>false</type> if not.
            </para>
        <refsect2>
            <title>ConfigurationArray</title>
            <para>
                This type is defined as
                <type>std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt;</type>.
                This is a vector that contains pairs of strings.  The first string of
                each pair is the name of a configuration parameter.  The second
                string is the configuration parameter's current value.
                This type is returned from one of the overloaded <methodname>cget</methodname>
                methods.
                </para>
            <para>
                You cannot make any assumption about the order of the parameters
                in this array.
                </para>
            </refsect2>
        <refsect2>
            <title>Pre-defined type checkers and related data types</title>
            <para>
                This section describes type checkers that are defined as
                static member functions of the <classname>CItemConfiguration</classname>
                class.  Each type checker's <parameter>arg</parameter> is also
                described along with a description of the
                checker.
                </para>
            <para>
                Prior to writing your own type checker you should ensure that
                a suitable one does not already exist.
                </para>
            <para>
                For all of the type checkers the parameters have the same
                names an meanings:
                 </para>
                <variablelist>
                    <varlistentry>
                        <term><type>std::string</type> <parameter>name</parameter></term>
                        <listitem>
                            <para>
                                Name of the configuration parameter being checked.
                                </para>
                            </listitem>
                        </varlistentry>
                    <varlistentry>
                        <term><type>std::string</type> <parameter>value</parameter></term>
                        <listitem>
                            <para>
                                The proposed new value for the configuration
                                parameter.  This is the value to be checked
                                by the validation function.
                                </para>
                            </listitem>
                        </varlistentry>
                    <varlistentry>
                        <term><type>void*</type> <parameter>arg</parameter></term>
                        <listitem>
                            <para>
                                This anonymous pointer points to data that
                                is used to further qualify type checking.
                                For exmaple.  Integer type checkers can specify
                                optional limits on the range of integers that
                                are acceptable, for <methodname>isInteger</methodname>,
                                therefore <parameter>arg</parameter> is actually
                                a pointer to a data structure that specifies
                                limit information.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
               
            
            <methodsynopsis>
            <modifier>static</modifier>
            <type>bool</type> <methodname>isInteger</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type>  <parameter>value</parameter>
                </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Ensures that <parameter>value</parameter> is a legal integer value.
            The <parameter>arg</parameter> parameter is a pointer to a
            <type>Limits</type> type.  This is a
            <type>std::pair&lt;limit, limit&gt;</type>.  Each <type>limit</type>
            defines a limit on the range of acceptable values.  The first one
            defines the lower end of the range, the second the high end of the
            range.
            </para>
        <para>
            If <parameter>arg</parameter> is <literal>NULL</literal> no
            limit checking is performed.
            </para>
        <para>
            The <type>limit</type> is, in turn a struct that has the following
            members:
            </para>
            <informalexample>
            <programlisting>
                bool s_checkMe;          // Check this limit if true
                long s_value             // Limit value
                </programlisting>
            </informalexample>
            <para>
                The <structname>limit</structname> structure also defines
                two construtors:
                <methodsynopsis>
                    <type></type><methodname>limit()</methodname>
                    <void />
                    </methodsynopsis>
                Defines a limit structure with <structfield>s_checkMe</structfield>
                initialized to
                <literal>false</literal> (that is a limit that will not be checked).
                <methodsynopsis>
                    <type></type><methodname>limit</methodname>
                    <methodparam>
                        <type>long</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                defines a limit with <structfield>s_checkMe</structfield> set
                to <literal>true</literal> and
                <structfield>s_value</structfield> initialized to
                <parameter>value</parameter>.
            </para>
        <methodsynopsis>
            <modifier>static</modifier>
            <type>bool</type> <methodname>isBool</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type>  <parameter>value</parameter>
                </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            This type checker ensures that the proposed
            <parameter>value</parameter> is a legal boolean value.
            <methodname>isBool</methodname> does not use its
            <parameter>arg</parameter> parameter.  Legal boolean values
            are any text strings from the following set:
            <literal>{true, yes, 1, on, enabled, false, no, 0, off,  disabled}</literal>.
            Any string not in this set results in a failed type check.
            </para>
        <methodsynopsis>
            <modifier>static</modifier>
            <type>bool</type> <methodname>isEnum</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type>  <parameter>value</parameter>
                </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            This is a type checker for enumerated parameters.  An enumerated
            parameter is a parameter that is constrained to have specific
            discrete values (A boolean is a special case of an enumerated
            parameter).  The <parameter>arg</parameter> value is required and
            must be a pointer to an
            <type>std::set&lt;string&gt;</type>.  The elements you put in this
            set define the allowed values for <parameter>value</parameter>.
            </para>
        <methodsynopsis>
            <modifier>static</modifier>
            <type>bool</type> <methodname>isFloat</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type>  <parameter>value</parameter>
                </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Checks that <parameter>value</parameter> decodes as a floating point
            number and optionally peforms limit checks on the value.
            </para>
        <para>
            <parameter>arg</parameter> is a pointer to a
            <type>FloatingLimits</type>.  <type>FloatingLimits</type> in turn
            is defined to be a <type>std::pair&lt;flimit, flimit&gt;</type>.
            The first <type>flimit</type> of the pair specifies the lower limit
            if any, while the second specifies the upper limit.  If
            <parameter>arg</parameter> is <literal>NULL</literal> no
            limit checking is performed.
            </para>
        <para>
            <type>flimit</type> is a struct that has the following
            members
            </para>

            <para>
                Data members of <structname>flimit</structname> are:
                <informalexample>
                <programlisting>
bool   s_checkMe;        // If true limit is checked.
float  s_value;          // Limit value.
                </programlisting>
                </informalexample>
                </para>
            <para>
                If <structfield>s_checkMe</structfield> is <literal>true</literal>,
                then <structfield>s_value</structfield> is relevant and is the value
                of the limit.
                </para>
            <para>
                <structfield>flimit</structfield> defines a pair of constructors:
                </para>
            <methodsynopsis>
                <type></type> <methodname>flimit</methodname>
                <void />
                </methodsynopsis>
            <para>Initializes <structfield>s_checkMe</structfield> to
            <literal>false</literal> disabling the limit.
            </para>
            <methodsynopsis>
                <type></type> <methodname>flimit</methodname>
                <methodparam>
                    <type>float</type> <parameter>value</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Initializes <structfield>s_checkMe</structfield>
                to <literal>true</literal> and sets
                <structfield>s_value</structfield>
                to <parameter>value</parameter>.  This enables the limit
                and sets it's value to <parameter>value</parameter>.
                </para>
 
    
        <methodsynopsis>
            <modifier>static</modifier>
            <type>bool</type> <methodname>isList</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type>  <parameter>value</parameter>
                </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            This validation function ensures tht the proposed parameter is a
            properly formatted Tcl list. <parameter>arg</parameter>, if supplied,
            allows the list size to be constrained and optionally
            elements of the list to be validated.  If <literal>NULL</literal>
            no constraints are enforced on the contents of the list.
            </para>
        <para>
            <parameter>arg</parameter> if not <literal>NULL</literal> is a pointer
            to a <structname>isListParameter</structname> struct which contains
            the following fields:
            <informalexample>
            <programlisting>
ListSizeConstraint  s_allowedSize;   // Constraints on list size.
TypeCheckInfo       s_checker;       // Element type checker.
                </programlisting>
            </informalexample>
            </para>
            <para>
                <structfield>s_allowedSize</structfield> constrains the number
                of elements in a list.  It is of type
                <structname>ListSizeConstraint</structname> which is a struct
                containing two <type>limit</type> element;
                <structfield>s_atLeast</structfield> which describes the minimum
                number of elements the list must contain and
                <structfield>s_atMost</structfield> which specifies the maximum
                numbger of elements the list must contain.  See
                the <methodname>isInteger</methodname> function description above
                for more information about the <type>limit</type> type.
                </para>
            <para>
                <structfield>s_checker</structfield>, of type
                <type>TypeCheckInfo</type> allows each element of the list to be
                validated (e.g. to require that a list contain integers that are
                all within some range).  
                <type>TypeCheckInfo</type> is a
                <type>std::pair&lt;typeChecker, void*&gt;</type>.  Where the
                <type>typeChecker</type> function is given each list value to
                validate and the <type>void*</type> element of the pair is the
                <parameter>arg</parameter> parameter passed to that validator.
                If <type>TypeCheckInfo</type> is <literal>NULL</literal> no per
                element validation is performed, however the list size can be
                constrained.
                </para>
            <para>
                When elements are validated, the <parameter>name</parameter>
                parameter passed to the element validator is the name of the
                configuration parameter that contains the list.  The
                <parameter>value</parameter> parameter is the proposed value
                of a list element.
                </para>
        <methodsynopsis>
            <modifier>static</modifier> <type>bool</type>
            <methodname>isBoolList</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type>  <parameter>value</parameter>
                </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            This is a specialization of <methodname>isList</methodname>.
            <parameter>arg</parameter> shoule be either be a pointer to
            a <type>ListSizeConstraint</type> to constrain the number of
            elements in the list or <literal>NULL</literal> to keep the size
            unsconstrained.  The method passes each list element through
            <methodname>isBool</methodname> to ensure that the
            list contains only boolean values.
            </para>
        <methodsynopsis>
            <modifier>static</modifier>
            <type>bool</type> <methodname>isIntList</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type>  <parameter>value</parameter>
                </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            This is a specialization of the <methodname>isList</methodname>
            function.  <parameter>arg</parameter> should either be
            a pointer to a <type>ListSizeConstraint</type> or it should be a
            <literal>NULL</literal>.
            If <parameter>arg</parameter> is <literal>NULL</literal>,
            the size of the list is unconstrained.  If not, the
            <type>ListSizeConstraint</type> is used to validate the
            size of the list.
            </para>
        <para>
            The list items are checked via <methodname>isInteger</methodname>
            to be sure they are legal integers.  No capability to set limits on
            the integer values is provdided for at this time.
            </para>
        <methodsynopsis>
            <modifier>static</modifier> <type>bool</type>
            <methodname>isStringList</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type>  <parameter>value</parameter>
                </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            This is a specialization of <methodname>isList</methodname>.  Any
            string is allowed as a list item (if it has the necessary quoting to maintain
            legal Tcl list syntax).   If not <literal>NULL</literal>,
            <parameter>arg</parameter> is a poitner to a
            <type>ListSizeConstraint</type> which can limit the number of elements
            in the list.  If <literal>NULL</literal> no list size constraint
            is enforced.
            </para>
        </refsect2>
      </refsect1>
      <refsect1>
         <title>Exceptions</title>
         <para>
            In the event of error, the class thows exceptions of
            type <type>std::string</type>.  The contents of the string are a
            human readable message that explains the problem and when it was
            detected.
         </para>
      </refsect1>
      <refsect1>
         <title>
            SEE ALSO
         </title>
     <para>
        <link linkend="manpage.cconfigurableobject">CConfigurableObject(3tcl)</link>
     </para>
      </refsect1>
   </refentry>

    <refentry id="manpage.cconfigurableobject">
      <refmeta>
         <refentrytitle>CConfigurableObject</refentrytitle>
         <manvolnum>3tcl</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CConfigurableObject</refname>
     <refpurpose>Base class for objects tht have a configuration.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CConfigurableObject.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CConfigurableObject</classname></ooclass>
            <constructorsynopsis>
                <methodname>CConfigurableObject</methodname>
                <void />
                </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CConfigurableObject</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>CConfigurableObject&amp;</type> <parameter>rhs</parameter>
                    </methodparam>
                </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier>
                <methodname>~CConfigurableObject</methodname>
                <void />
                </destructorsynopsis>
            <methodsynopsis>
                <type>CConfigurableObject&amp;</type>
                <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>CConfigurableObject&amp;</type> <parameter>rsh</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>CConfigurableObject&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                <modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>int</type>
                <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CConfigurableObject&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                <modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>Attach</methodname>
                <methodparam>
                    <type>CItemConfiguration*</type> <parameter>pConfiguration</parameter>
                    </methodparam>
                <methodparam>
                    <type>bool</type> <parameter>dynamic</parameter>
                    <initializer>true</initializer>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>configure</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>value</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type> <methodname>getName</methodname>
                <void />
                <modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type>
                <methodname>cget</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>CItemConfiguration::ConfigurationArray</type>
                <methodname>cget</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>onAttach</methodname>
                <void /><modifier>=0</modifier>
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            <classname>CConfigurableObject</classname> is an abstract base class
            for objects
            that contain configurations via the
            <classname>CItemConfiguration</classname>
            class.  The class embeds an <classname>CItemConfiguration</classname>
            and provides a mechanism for initializing the configuration as it is
            attached.
         </para>
        <para>
            Due to the rules regarding virtual member use in constructors,
            construction and initialization of a <classname>CConfigurableObject</classname>
            is usually a two step process.  The object is constructed, and then
            either an empty or initialized configuration is attached to the
            object via  call to <methodname>Attach</methodname>.
            </para>
        <para>
            When <methodname>Attach</methodname> is called it, in turn calls
            the virtual method (pure/abstract in this base class), to
            allow the actual concrete class to initialize the configuration
            by defining an appropriate set of parameters and their constraints.
            </para>
        <para>
            Once initialized, a partial facade is supplied that allows external
            clients to configure and dump the configuration of an object.
            </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
        <methodsynopsis>
            <methodname>CConfigurableObject</methodname>
            <void />
            </methodsynopsis>
        <para>
            Construts a configurable object.  Note that this does not
            create a configuration unless explicitly done by the constructor.
            Normally due to restrictions in when virtual functions are actually
            virtual (they are not in constructors), The client that constructs
            this will also construct and attach a
            <classname>CItemConfiguration</classname> via
            <methodname>Attach</methodname> soon after constructing the object.
            </para>
        <methodsynopsis>
            <methodname>CConfigurableObject</methodname>
            <methodparam>
                <modifier>const</modifier>
                <type>CConfigurableObject&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Copy construction.  This results in a snapshot of the configuration
            being dynamically made, and marked for deletion on destruction of
            the object.  No attempt is made to synchronize the copy with the
            original.
            </para>
        <methodsynopsis>
            <modifier>virtual</modifier>
            <methodname>~CConfigurableObject</methodname>
            <void />
            </methodsynopsis>
        <para>
            Destroys the configurable object.  If the configuration attached
            was marked as dynamcially allocated it is deleted in order
            to prevent memory leaks.  Dynamic marking is done either
            by copy construction or by specifying at
            <methodname>Attach</methodname> time that the object is responsible
            for deleting <classname>ItemConfiguration</classname>
            object being attached.
            </para>
        <methodsynopsis>
            <type>CConfigurableObject&amp;</type>
            <methodname>operator=</methodname>
            <methodparam>
                <modifier>const</modifier>
                <type>CConfigurableObject&amp;</type> <parameter>rsh</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Object assignment.  If the target object's configuration exists
            and was dynamically attached, it is deleted.  Regardless, the source's
            configuration cloned and assigned to the current configuration with
            dynamic marking.
            </para>
        <methodsynopsis>
            <type>int</type> <methodname>operator==</methodname>
            <methodparam>
                <modifier>const</modifier>
                <type>CConfigurableObject&amp;</type>
                <parameter>rhs</parameter>
                </methodparam>
            <modifier>const</modifier>
            </methodsynopsis>
        <para>
            Returns nonzero if <parameter>rhs</parameter>'s configuration is
            identical to that of <parameter>this</parameter>.
            </para>
        <methodsynopsis>
            <type>int</type>
            <methodname>operator!=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CConfigurableObject&amp;</type>
                <parameter>rhs</parameter>
                </methodparam>
            <modifier>const</modifier>
            </methodsynopsis>
        <para>
            Returns nonzero if <methodname>operator==</methodname> returns 0.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>Attach</methodname>
            <methodparam>
                <type>CItemConfiguration*</type> <parameter>pConfiguration</parameter>
                </methodparam>
            <methodparam>
                <type>bool</type> <parameter>dynamic</parameter>
                <initializer>true</initializer>
                </methodparam>
            </methodsynopsis>
        <para>
            The client should call this to attach a configuration,
            <parameter>pConfiguration</parameter>, (either
            pre-configured or empty) to the object.
            <parameter>dynamic</parameter> should be <literal>true</literal>
            if <parameter>pConfiguration</parameter> should be
            deleted when the object is destroyed.
            </para>
        <para>
            The virtual function <methodname>onAttach</methodname> will be invoked
            to allow the configuration to be set up for the object.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>configure</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Passes the <parameter>name</parameter> and <parameter>value</parameter>
            parameters on to the configuration object's
            <classname>CItemConfiguration</classname> object.  If no configuration
            has been attached to the object, a string exception is
            thrown describing this fact.
            </para>
        <methodsynopsis>
            <type>std::string</type> <methodname>getName</methodname>
            <void />
            <modifier>const</modifier>
            </methodsynopsis>
        <para>
            Returns the configuration's name.  This will throw a string
            exception if no configuration has been attached to the object.
            </para>
        <methodsynopsis>
            <type>std::string</type>
            <methodname>cget</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Returns the value of a configuration option <parameter>name</parameter>.
            The assumption is that clients only want to present configuration
            option values to humans, or save them and therefore ther is only
            a facade in front of the string value function.
            </para>
        <para>
            In addition to the string exceptions that can be thrown by the
            configuration object, an exception will be thrown if the
            object has no attached configuration.
            </para>
        <methodsynopsis>
            <type>CItemConfiguration::ConfigurationArray</type>
            <methodname>cget</methodname>
            <void />
            </methodsynopsis>
        <para>
            Returns the entire configuration. Throws a string exception if no
            configuration object has been attached.
            </para>
        <methodsynopsis>
            <modifier>virtual</modifier>
            <type>void</type> <methodname>onAttach</methodname>
            <void /><modifier>=0</modifier>
            </methodsynopsis>
        <para>
            Concrete base classes should supply and implement this. Normally
            <methodname>onAttache</methodname> is used to initialize the
            configuration which is stored in the protected data member
            <varname>m_pConfiguration</varname>, a pointer to
            <classname>CItemConfiguration</classname>.
            </para>
      </refsect1>
      <refsect1>
         <title>Exceptions</title>
         <para>
            <type>std::string</type> exceptions are thrown both from this and
            the calls it makes to <classname>CItemConfiguration</classname>.
         </para>
      </refsect1>
      <refsect1>
         <title>
            SEE ALSO
         </title>
     <para>
        <link linkend='manpage.citemconfiguration'>CItemConfiguration</link>
     </para>
      </refsect1>
   </refentry>


    <refentry id="manpage.CTCLObjectPackage">
      <refmeta>
         <refentrytitle>CTCLObjectPackage</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CTCLObjectPackage</refname>
	 <refpurpose>Provide common functionality for a set of
                related commands.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;TCLObjectPackage.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CTCLObjectPackage</classname></ooclass>
            <methodsynopsis>
                <type>void</type><methodname>addCommand</methodname>
                <methodparam>
                    <type>CTCLPackagedObjectProcessor*</type> <parameter>processor</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>CTCLObjectPackage::CommandIterator</type>
                <methodname>begin</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>CTCLObjectPackage::CommandIterator</type>
                <methodname>end</methodname>
                <void />
            </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            This class is a base class for a set of common services that
            can be offered to a set of related commands.  The commands themselves
            must be derived from CTCLPackagedObjectProcessor.  
         </para>
         <para>
            The base class provides the infrastructor for maintaining the list
            of command objects that participate in the package, for associating
            a command with the package, and for iterating through associated
            command objects.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
           <methodsynopsis>
                <type>void</type><methodname>addCommand</methodname>
                <methodparam>
                    <type>CTCLPackagedObjectProcessor*</type> <parameter>processor</parameter>
                </methodparam>
            </methodsynopsis>
           <para>
                Adds a new command object to the package.  The command object
                will have its <methodname>onAttache</methodname> method
                invoked, which allows it to save the command package (passed in
                as a parameter), and to do any initialization that requires
                the command package services.
           </para>
            <methodsynopsis>
                <type>CTCLObjectPackage::CommandIterator</type>
                <methodname>begin</methodname>
                <void />
            </methodsynopsis>
            <para>
                Returns an iterator for the first command object associated
                with the object.  The iterator is a pointer like object in the
                sense that dereferencing it will yield a pointer to ta
                command object.  The iterator can be stepped through the
                collection via the incremenet operator (<literal>++</literal>).
                Iteration is complete when the iterator is equal to
                <methodname>end()</methodname> see below.
            </para>
            <methodsynopsis>
                <type>CTCLObjectPackage::CommandIterator</type>
                <methodname>end</methodname>
                <void />
            </methodsynopsis>
            <para>
                Provides an end iterator against which to compare an iterator
                over the commands to determine if all of them have been
                visited.
            </para>
      </refsect1>
      <refsect1>
         <title>Types and public data</title>
         <para>
            <classname>CTCLObjectPackage::CommandIterator</classname> is a
            pointer like object returned by the
            <methodname>begin</methodname> and <methodname>end</methodname>
            methods to allow iteration through the set of command objects
            associated with this package.
         </para>
      </refsect1>
 
      <refsect1>
         <title>
            SEE ALSO
         </title>
	 <para>
            <link linkend="manpage.CTCLPackagedObjectProcessor">
                CTCLPackagedObjectProcessor(3daq)</link>
	 </para>
      </refsect1>
   </refentry>

    <refentry id="manpage.CTCLPackagedObjectProcessor">
      <refmeta>
         <refentrytitle>CTCLPackagedObjectProcessor</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CTCLPackagedObjectProcessor</refname>
	 <refpurpose>Base class for commands living in a
                    <classname>CTCLObjectPackage</classname>
         </refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;TCLPackagedObjectProcessor.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CTCLPackagedObjectProcessor</classname></ooclass>
            <constructorsynopsis>
                <methodname>CTCLPackagedObjectProcessor</methodname>
                <methodparam><type>CTCLInterpreter&amp;</type>
                             <parameter>interp</parameter>
                </methodparam>
                <methodparam><type>std::string</type>
                             <parameter>command</parameter>
                </methodparam>
                <methodparam><type>bool</type>
                             <parameter>registerMe</parameter>
                             <initializer>true</initializer>
                </methodparam>
            </constructorsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>onAttach</methodname>
                <methodparam>
                    <type>CTCLObjectPackage*</type> <parameter>package</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>protected</modifier>
                <type>CTCLObjectPackage*</type>  <methodname>getPackage</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>protected virtual</modifier>
                <type>void</type> <methodname>Initialize</methodname>
                <void />
            </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            A packaged object command is a <classname>CTCLObjectProcessor</classname>
            that can draw on a set of services shared between it and a
            set of related commands.  The set of commands and the common set
            of services is called a <firstterm>package</firstterm>.
         </para>
         <para>
            The <classname>CTCLPackagedObjectProcessor</classname> class
            described here provides a base class for such commands.  The base
            class provides mechanisms for the package to associate the object
            that contains the shared services with the command, and a mechanism
            for the subclass that actually implements real commands to access this
            associated object.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
           <methodsynopsis>
                <methodname>CTCLPackagedObjectProcessor</methodname>
                <methodparam><type>CTCLInterpreter&amp;</type>
                             <parameter>interp</parameter>
                </methodparam>
                <methodparam><type>std::string</type>
                             <parameter>command</parameter>
                </methodparam>
                <methodparam><type>bool</type>
                             <parameter>registerMe</parameter>
                             <initializer>true</initializer>
                </methodparam>
            </methodsynopsis>
            <para>
                Construct the object.  The parameters are the same as for
                a <classname>CTCLObjectProcessor</classname>;
                <parameter>interp</parameter> is a reference to the TCL interpreter
                to which the command will be added.  <parameter>command</parameter>
                is the command keyword that will invoke the object's
                <methodname>operator()</methodname>.
                <parameter>regsiterMe</parameter> is
                <literal>true</literal> if the
                command should be registered on the interpreter immediately
                (this is usually the case and hence the parameter is optional,
                defaulting to <literal>true</literal>
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>onAttach</methodname>
                <methodparam>
                    <type>CTCLObjectPackage*</type> <parameter>package</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                This method is called by the package when the command object is
                added to the package.  <parameter>package</parameter> is a pointer
                to the package object, which contains its shared services.
                This is saved and can be retrieved by subclass objects via
                <methodname>getPackage</methodname>.
            </para>
            <methodsynopsis>
                <modifier>protected</modifier>
                <type>CTCLObjectPackage*</type>  <methodname>getPackage</methodname>
                <void />
            </methodsynopsis>
            <para>
                Returns the package object pointer supplied to
                <methodname>onAttach</methodname>
                by the package.  Normally this will need to be cast to a
                specific concrete package type by the caller so that its methods
                can be accessed.
            </para>
            <para>
                If called prior to the
                <methodname>onAttach</methodname> call, this returns
                a null pointer.
            </para>
            <methodsynopsis>
                <modifier>protected virtual</modifier>
                <type>void</type> <methodname>Initialize</methodname>
                <void />
            </methodsynopsis>
            <para>
                Called by <methodname>onAttach</methodname> after the
                package has been saved (and is therefore accessible by
                <methodname>getPackage</methodname>.  This does nothing in the
                base class but can be overidden in subclasses to allow
                for initialization that requires access to the package services.
            </para>
      </refsect1>
      <refsect1>
         <title>
            SEE ALSO
         </title>
	 <para>
            <link linkend="manpage.CTCLObjectPackage">CTCLObjectPackage(3daq)</link>
	 </para>
      </refsect1>
   </refentry>


    </part>
    <part>
        <title>Core SpecTcl classes</title>
        <partintro>
            <title>Core SpecTcl classes</title>
            <para>
                This part describes the core SpecTcl classes.  These  classes
                are those which can either be used by extensions to do their work
                or provide hooks for extensions written by users.
            </para>
        </partintro>
        <refentry>
            <refmeta>
                <refentrytitle>Extensible Factories</refentrytitle>
                <manvolnum>3SpecTcl</manvolnum>
            </refmeta>
            <refnamediv>
                <refname>CCreator&lt;T&gt;</refname>
                <refname>CExtensibleFactory&lt;T&gt;</refname>
                <refpurpose>Create factories that don't have hard-coded creationals.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <synopsis>
#include &lt;CCreator.h&gt;
#include &lt;ExtensibleFactory.h&gt;

template &lt;class T&gt;
class CCreator
{
public:
  virtual T* operator()() = 0;
  virtual std::string describe() const = 0;
};


template &lt;class T&gt;
class CExtensibleFactory
{

public:
  void addCreator(std::string type,
                  CCreator&lt;T&gt;* pCreator);
  T* create(std::string type);
  std::vector&lt;std::string&gt; getDescriptions();

};
                </synopsis>
            </refsynopsisdiv>
            <refsect1>
                <title>DESCRIPTION</title>
                <para>
                    Suppose you have a class hierarchy whose base class is
                    <classname>T</classname>. In some cases it makes sense
                    to have factory that, given some criterion, knows which
                    specific subclass of <classname>T</classname> to create.
                    You can easily envision some if/then/else or switch based
                    creational method in a factory that can perform that
                    sort of operation for you.
                </para>
                <para>
                    Suppose further, that you write some of the <classname>T</classname>
                    class definitions/implementations but other people write other
                    subclasses.  This would make the if/then/else or switch
                    maintenance a nightmare.
                </para>
                <para>
                    The extensible factory pattern and implementation in SpecTcl is
                    a solution to this problem.  An extensible factory requires
                    that for each subclass of <classname>T</classname> you can
                    instantiate you have a creator class.  The creator class's
                    job is pretty simple. It just returns a <classname>T*</classname>
                    which points to a dynamically allocated object of the
                    actual class it purports to create.
                </para>
                <para>
                    Creator objects are then registered with the factory and
                    associated with a string.   The Factory's creation method then
                    accepts as input a string and returns either a
                    <classname>T*</classname> 
                    if creator has been registered that matches the string
                    or a <literal>nullptr</literal> if there's no matching registered
                    creator.
                </para>
                <para>
                    SpecTcl itself uses this pattern fairly extensively and, in some
                    cases, uses the class described in this manual page
                    to implement that pattern.  The class is tempated so that
                    it can be used, without modification wherever appropriate.
                </para>
            </refsect1>
            <refsect1>
                <title>The <classname>CCreator&lt;T&gt;</classname> class</title>
                <para>
                    As the description says, to use an extensible factory, you need
                    to define a set of subclasses from a base class <classname>T</classname>
                    (<classname>T</classname> may well be an abstract base class).
                    Objects of this subclass are what the factory generates.
                </para>
                <para>
                    You also need to write a subclass of <classname>CCreator&lt;T&gt;</classname>.
                    The methods you need to implement are:
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>T*</type>
                                <methodname>operator()</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This must just reaturn a pointer to a dynamically
                                allocated object from the class that this creator
                                creates.  Suppose <classname>base</classname> is the
                                base class of the hierarchy we're putting under
                                control of the factory and we're writing a
                                creator for <classname>derived</classname> which is
                                derived from <classname>base</classname>.
                                <methodname>operator()</methodname> might look like:
                            </para>
                            <informalexample>
                                <programlisting>
template &lt;class T&gt;
T* MyCreator&lt;base&gt;::operator() { return new derived;}
                                </programlisting>
                            </informalexample>
                            <para>
                                Naturally doing a bit of typedeffery can remove
                                the need to expose all that template notation.
                                For a concrete example, see <filename>AttachCommand.h</filename>
                                where an extensible factory is used to allow the
                                set of buffer decoders that are supported by
                                the <command>attach</command> command's
                                <option>-format</option> option values.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>std::string</type>
                                <methodname>describe</methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This method is intended to return a description
                                of the type of object the creator creates.  This is
                                used in SpecTcl commands that use an extensible
                                factory to be able to describe the available
                                values and meanings for extensible command options.
                                Have a look at the code in
                                <filename>AttachCommand.cpp</filename> to see this
                                in action
                            </para>
                            <para>
                                You can look at this code at:
                                <ulink url='https://sourceforge.net/p/nsclspectcl/Git/ci/master/tree/main/Core/AttachCommand.cpp' />.
                                See how the <methodname>Usage</methodname> method
                                gets the descsription from the
                                factory of decoders and uses them to document
                                valid values for the available format types that
                                can be supplied to the <option>-format</option>
                                option.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
            <refsect1>
                <title>The <classname>CExtensibleFactory&lt;T&gt;</classname> template class methods.</title>
                <variablelist>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void</type>
                                <methodname>addCreator</methodname>
                                <methodparam>
                                    <type>std::string</type><parameter>type</parameter>
                                </methodparam>
                                <methodparam>
                                    <type>CCreator&lt;T&gt;*</type><parameter>pCreator</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This method registers a new creator
                                <parameter>pCreator</parameter> with the factory
                                and associates it with the typename <parameter>type</parameter>.
                                The caller is responsible for storage management in
                                the event that <parameter>pCreator</parameter>
                                is dynamically created.
                            </para>
                            <para>
                                If <parameter>typre</parameter> already has a
                                creator, this method silently replaces the
                                previous creator and, once more, the clients of the
                                factory are responsible for any object destruction
                                required in that case.
                            </para>
                            <para>
                                Note that at present the only way to see if a 
                                <parameter>type</parameter>
                                is defined is to attempt to make an object of of
                                that <parameter>type</parameter> and see if
                                that attempt is successful.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>T*</type>
                                <methodname>create</methodname>
                                <methodparam>
                                    <type>std::string</type><parameter>type</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                If a creator has been registered with a matching
                                <parameter>type</parameter> name, it is asked to
                                create a new object of a class that is derived
                                (directly or indirectl) from <classname>T</classname>.
                                In that case a pointer to that object is returned.
                                If no matching <parameter>type</parameter> has
                                been registered, a <literal>nullptr</literal> is
                                returned instead.
                            </para>
                            <para>
                                The object returned is intended to have been
                                dynamically allocated, though that's not a requirement
                                of the factory (nothing to stop the creators from
                                returning pointers to singleton objects e.g.).
                                If the object was dynamically created, storage
                                management (deletion) is then the responsibility
                                of the caller.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
            <refmeta>
                <refentrytitle>CEventProcessor</refentrytitle>
                <manvolnum>3SpecTcl</manvolnum>
            </refmeta>
            <refnamediv>
                <refname>CEventProcessor</refname>
                <refpurpose>Abstract base class convering events to parameters</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
            <synopsis>
#include &lt;EventProcessor.h&gt;

class CEventProcessor {
 public:
  virtual Bool_t operator()(const Address_t pEvent,
                            CEvent&amp; rEvent,
                            CAnalyzer&amp; rAnalyzer,
                            CBufferDecoder&amp; rDecoder); 
  virtual Bool_t OnAttach(CAnalyzer&amp; rAnalyzer);
  virtual Bool_t OnBegin(CAnalyzer&amp; rAnalyzer,
                         CBufferDecoder&amp; rDecoder);
  virtual Bool_t OnEnd(CAnalyzer&amp; rAnalyzer,
                       CBufferDecoder&amp; rBuffer); 
  virtual Bool_t OnPause(CAnalyzer&amp; rAnalyzer,
                         CBufferDecoder&amp; rDecoder); 
  virtual Bool_t OnResume(CAnalyzer&amp; rAnalyzer,
                          CBufferDecoder&amp; rDecoder);
  virtual Bool_t OnOther(UInt_t nType,
                         CAnalyzer&amp; rAnalyzer,
                         CBufferDecoder&amp; rDecoder);

  virtual Bool_t OnEventSourceOpen(std::string name);
  virtual Bool_t OnEventSourceEOF();
  virtual Bool_t OnInitialize();
};

            </synopsis>
            </refsynopsisdiv>
            <refsect1>
                <title>DESCRIPTION</title>
                <para>
                    <classname>CEventProcessor</classname> Provides the abstract
                    base class for elements of the event processing pipeline.
                    Tailoring SpecTcl to analyze a particular dataset involves
                    writing a set of classes derived from
                    <classname>CEventProcessor</classname> and registering instances
                    of those classes in
                    <classname>MySpecTclApp::</classname><methodname>CreateAnalysisPipeline</methodname>.
                </para>
                <para>
                    Each element of the pipeline normally contributes elements
                    to the event array either directly or indirectly through
                    tree parameters.  These elements, or parameter values, either
                    come from decoding segments of the raw event, or by performing
                    computations on existing parameter values.
                </para>
                <para>
                    Event processors that decode sections of the raw event are
                    often referred to as <firstterm>unpackers</firstterm>.
                </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <para>
                    Note that the methods of <classname>CEventProcessor</classname>
                    are all virtual methods that have default implementations
                    that return <literal>kfTRUE</literal>.  All methods return
                    a <type>Bool_t</type>.  A return value of <literal>kfTRUE</literal>
                    indicates success.  A value of <literal>kfFALSE</literal>
                    indicates failure.  A failure return aborts the event processing
                    pipeline. This means that no more event processors will be called
                    and, for <methodname>operator()</methodname> no histogramming
                    will be done on that event.
                </para>
                <para>
                    A common mistake for implementors of event processors
                    is to forget to return a value.  This can result in randomly
                    and silently dropping events as return value will be
                    not well defined.
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>Bool_t </type>
                                <methodname>operator()</methodname>
                                <methodparam>
                                    <modifier>const</modifier><type> Address_t </type>
                                    <parameter>pEvent</parameter>
                                </methodparam>
                                <methodparam>
                                    <type>CEvent&amp; </type><parameter>rEvent</parameter>
                                </methodparam>
                                <methodparam>
                                    <type>CAnalyzer&amp; </type><parameter>rAnalyzer</parameter>
                                </methodparam>
                                <methodparam>
                                    <type>CBufferDecoder&amp; </type><parameter>rDecoder</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This method is called for each physics event.
                                <parameter>pEvent</parameter> points to the raw
                                event data for this event.  <parameter>rEvent</parameter> 
                                is the array like object that stores the parameter values
                                created by the event processing pipeline for this event.
                            </para>
                            <para>
                                The <parameter>rAnalyzer</parameter> and
                                <parameter>rDecoder</parameter> parameters are
                                not often used but reference the analyzer and
                                buffer decoder objects used to manage event processing
                                for this event data format.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>Bool_t </type>
                                <methodname>OnAttach</methodname>
                                <methodparam>
                                    <type>CAnalyzer&amp; </type><parameter>rAnalyzer</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Called when the event processor is registered
                                with the event processing pipeline.
                                <parameter>rAnalyzer</parameter> references
                                the analyzer that controls the flow of data
                                analysis through SpecTcl.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual</modifier>
                                <type> Bool_t </type>
                                <methodname>OnBegin</methodname>
                                <methodparam>
                                    <type>CAnalyzer&amp; </type><parameter>rAnalyzer</parameter>
                                </methodparam>
                                <methodparam>
                                    <type>CBufferDecoder&amp; </type><parameter>rDecoder</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Called when a begin run item is detected.
                                Note that not all data acquisition systems
                                have begin run items, however all NSCL supported
                                data acquisition systems do.
                            </para>
                            <para>
                                <parameter>rAnalyzer</parameter> and
                                <parameter>rDecoder</parameter> refer to the
                                analyzer and decoder respectively.  The decoder
                                provides services (the run number and title
                                which again may not be available in non NSCL supported
                                data acquisition systems), that may be useful to
                                event processors that choose to implement this
                                method.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>Bool_t </type>
                                <methodname>OnEnd</methodname>
                                <methodparam>
                                    <type>CAnalyzer&amp; </type><parameter>rAnalyzer</parameter>
                                </methodparam>
                                <methodparam>
                                    <type>CBufferDecoder&amp; </type><parameter>rBuffer</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Called when an end fo run item is encountered.
                                See <methodname>OnBegin</methodname> for
                                more.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>Bool_t </type>
                                <methodname>OnPause</methodname>
                                <methodparam>
                                    <type>CAnalyzer&amp; </type><parameter>rAnalyzer</parameter>
                                </methodparam>
                                <methodparam>
                                    <type>CBufferDecoder&amp; </type><parameter>rDecoder</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Like <methodname>OnBegin</methodname> but invoked
                                when a  run temporarily pauses.  Note that not all
                                NSCL Supported data acquisition systems support
                                pausing an active run.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>Bool_t </type>
                                <methodname>OnResume</methodname>
                                <methodparam>
                                    <type>CAnalyzer&amp; </type><parameter>rAnalyzer</parameter>
                                </methodparam>
                                <methodparam>
                                    <type>CBufferDecoder&amp; </type><parameter>rDecoder</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Called when a paused run resumes.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>Bool_t </type>
                                <methodname>OnOther</methodname>
                                <methodparam>
                                    <type>UInt_t </type><parameter>nType</parameter>
                                </methodparam>
                                <methodparam>
                                    <type>CAnalyzer&amp; </type><parameter>rAnalyzer</parameter>
                                </methodparam>
                                <methodparam>
                                    <type>CBufferDecoder&amp; </type><parameter>rDecoder</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Called when an item type that does not neatly fit
                                into the categories above is encountered.
                                <parameter>nType</parameter> is an item type
                                drawn, where possible, from
                                <filename>buftype.h</filename>, and where not,
                                from the underlying DAQ system that produced the
                                data.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>Bool_t </type>
                                <methodname>OnEventSourceOpen</methodname>
                                <methodparam>
                                    <type>std::string </type><parameter>name</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Called when a new event source is opened.
                                <parameter>name</parameter> is a data source type
                                dependent parameter that identifies what the
                                data source is connected to.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>  virtual </modifier>
                                <type>Bool_t </type>
                                <methodname>OnEventSourceEOF</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Called when the event source hits the end of data.
                                For file data sources this means that the  data
                                in the file has been completely processed.
                                For Pipe data sources, this means that the
                                producer end of the pipe has closed the pipe.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>Bool_t </type>
                                <methodname>OnInitialize</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This is called when SpecTcl is initialized.
                                For event processors registered in
                                <classname>MySpecTclApp</classname>::<methodname>CreateAnalysisPipeline</methodname>,
                                this is sometime after registration when SpecTcl
                                has been completely intialized.  For those
                                registered dynamically, later,
                                <methodname>OnInitialize</methodname> is called
                                immediately after
                                <methodname>OnAttach</methodname>.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
            <refmeta>
                <refentrytitle>CEventBuilderEventProcessor</refentrytitle>
                <manvolnum>3SpecTcl</manvolnum>
            </refmeta>
            <refnamediv>
                <refname>CEventBuilderEventProcessor</refname>
                <refpurpose>Event processor for event built data.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <synopsis>
class CEventBuilderEventProcessor : public CEventProcessor
{
public:
    CEventBuilderEventProcessor(double clockMHz, std::string baseName);
    void addEventProcessor(unsigned sourceId, CEventProcessor&amp; processor);
};

                </synopsis>
            </refsynopsisdiv>
            <refsect1>
                <title>DESCRIPTION</title>
                <para>
                    Increasingly, experiments are composed of several
                    detector systems.  Each detector system has its own
                    independent data acquisition system.  These systems
                    run synchronized clocks that provide a timestamp for
                    each event fragment they produce.
                    An event builder is then used to combine
                    event fragments into events that contains fragments that
                    are coincident in time.
                </para>
                <para>
                    The <classname>CEventBuilderEventProcessor</classname>
                    is provided to simplify the unpacking of these events into
                    a base set of raw parameters.  It allows the registration
                    of event processors to handle each data source that can
                    produce event fragments.  For each event, control is dispatched
                    to the appropriate set of event processors.
                </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <para>
                    Naturally, the event processor methods are implemented by
                    this event processor.  For non physics events, each registered
                    event processor is called.  For <methodname>operator()</methodname>,
                    the event processor iterates over the fragments in each event
                    extracting the source id and body of the fragment.
                    The appropriate event processors are then dispatched to with
                    their <parameter>pEvent</parameter> pointing at that fragment's
                    body.
                </para>
                <para>
                    Thus, if you have an event processor which can unpack
                    data from a system in standalone  mode, you can register
                    that event processor to use it with event built data that
                    may contain fragments from that system.
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <constructorsynopsis>
                                <methodname>CEventBuilderEventProcessor</methodname>
                                <methodparam>
                                    <type>double </type><parameter>clockMHz</parameter>
                                </methodparam>
                                <methodparam>
                                    <type>std::string </type><parameter>baseName</parameter>
                                </methodparam>
                            </constructorsynopsis>
                        </term>
                        <listitem>
                            <para>
                                The constructor is parameterized.
                                <parameter>clockMHz</parameter> must be the
                                frequency of the timestamp clock in MHz.
                                This is used to produce a parameter that is
                                the run time in seconds.
                            </para>
                            <para>
                                The event produces several parameters of its own.
                                The <parameter>baseName</parameter> parameter
                                allows some control over the names of those parameters.
                                Specifically, each parameter name will be preceded by
                                the <parameter>baseName</parameter> and a
                                <literal>.</literal>.
                            </para>
                            <para>
                                Thus a <parameter>baseName</parameter> parameter
                                of <literal>diagnostics</literal> will
                                produce a parameter that is the run time in
                                seconds at which an event occured named
                                <literal>diagnostis.run_time</literal>.
                            </para>
                            <para>
                                See <literal>PARAMETERS</literal> below
                                for information about the set of parameters
                                this event processor produces.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void </type>
                                <methodname>addEventProcessor</methodname>
                                <methodparam>
                                    <type>unsigned </type><parameter>sourceId</parameter>
                                </methodparam>
                                <methodparam>
                                    <type>CEventProcessor&amp; </type><parameter>processor</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Adds an event prrocessor; <parameter>processor</parameter>
                                to process events from the specifice source;
                                <parameter>sourceId</parameter>.  Note that
                                each source can only have one event processor,
                                the last one registered for the source.
                            </para>
                            <para>
                                There is, however nothing to stop you from having
                                additional event processors registered in the
                                event processing pipeline after (or before for
                                that matter) the instance of
                                <classname>CEventBuilderEventProcessor</classname>./
                            </para>
                            <para>
                                There's also nothing to stop you from building event
                                processors that, themselves manage a pipeline of processors
                                if you need to have several event processors associated
                                with analyzing data from a specific event source.
                                Too much of this, however should make you  question the
                                organization of and or your processing of it.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
            <refsect1>
                <title>PARAMETERS</title>
                <para>
                    This event processor creates severa parameters that are
                    useful in creating diagnostic spectra that are  typical
                    of a system using event built data.  In this section,
                    we will give the part of the parameter name that follows
                    the <parameter>basName</parameter> and following
                    <literal>.</literal> rather than doing something clumsy
                    to attempt to capture the entire parameter name pattern.
                </para>
                <para>
                    The parameters we produce are divided into a set of
                    fixed parameters and a set of parameters that depend on the
                    event processors registered with us.
                </para>
                <para>
                    The fixed set of parameters are:
                    <variablelist>
                        <varlistentry>
                            <term><literal>sources</literal></term>
                            <listitem>
                                <para>
                                    The number of sources present in the event.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>unrecognized_source</literal></term>
                            <listitem>
                                <para>
                                    The number of fragments that had source ids
                                    for which there was no registered event
                                    processor.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>event_no</literal></term>
                            <listitem>
                                <para>
                                    The event number numbered from zero.
                                    Note that with Xamine, channel 0
                                    of a histogram represents
                                    the underflow counters for the Root histogram.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>run_time</literal></term>
                            <listitem>
                                <para>
                                    The number of seconds into the run corresponding
                                    to the timestamp of the first fragment in the
                                    event.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </para>
                <para>
                    The following parameters depend on the set of sources
                    registered:
                </para>
                <variablelist>
                    <varlistentry>
                        <term>sid<literal>_present</literal></term>
                        <listitem>
                            <para>
                                This is 1 if  a fragment from
                                source sid is present.  It is undefined if not.
                                For example, for source id 2, a parameter named
                                <literal>2_present</literal> will be created.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>tdiffs</literal></term>
                        <listitem>
                            <para>
                                The subtree <literal>tdiffs</literal> will be
                                created.   Parameters in that subtree will
                                contain time differences between all ordered pairs
                                of fragment source ids.  For example, if I have source Ids
                                1, 2, and 3 registered in that order, the parameters
                                
                                <literal>tdiffs.1-2</literal>,
                                <literal>tdiffs.2-3</literal> and
                                <literal>tdiffs.1-3</literal> will be created.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>         
        <refentry>
            <refmeta>
                <refentrytitle>CTclGrammerApp</refentrytitle>
                <manvolnum>3SpecTcl</manvolnum>
            </refmeta>
            <refnamediv>
                <refname>CTclGrammerApp</refname>
                <refpurpose>Base Application class</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <synopsis>
#include &lt;TclGrammerApp.h&gt;
class <classname>CTclGrammerApp</classname>
{
  UInt_t getDisplaySize() const;
  UInt_t getParams() const; 
  UInt_t getListSize() const;
  CAnalyzer* getAnalyzer() const;
  CTCLHistogrammer* getHistogrammer() const;
  CTKRunControl* getRunControl() const;
  CXamineEventHandler* getXamineEvents() const;
  CRunControlPackage* getRunControlPackage() const;
  CParameterPackage* getParameterPackage() const;
  CSpectrumPackage* getSpectrumPackage() const;
  CDataSourcePackage* getDataSourcePackage() const;
  CGatePackage* getGatePackage() const;
  CTCLVariable getTclDisplaySize() const;
  CTCLVariable getTclParameterCount() const;
  CTCLVariable getTclEventListSize() const;
  CMultiTestSource* getTestDataSource();
  CDisplayInterface* getDisplayInterface();
  
protected:
  void setDisplaySize (const UInt_t am_nDisplaySize);
  void setParams (const UInt_t am_nParams);
  void setListSize (const UInt_t am_nListSize);
  void setAnalyzer (CAnalyzer* am_pAnalyzer);
  void setHistogrammer (CTCLHistogrammer* am_pHistogrammer);
  void setRunControl (CTKRunControl* am_pRunControl);
  void setXamineEvents (CXamineEventHandler* am_pXamineEvents);
  void setRunControlPackage (CRunControlPackage* am_pRunControlPackage);
  void setParameterPackage (CParameterPackage* am_pParameterPackage);
  void setSpectrumPackage (CSpectrumPackage* am_pSpectrumPackage);
  void setDataSourcePackage (CDataSourcePackage* am_pDataSourcePackage);
  void setGatePackage (CGatePackage* am_pGatePackage);
  void setRCFile (const CTCLVariable am_RCFile);
  void setTclDisplaySize (const CTCLVariable am_TclDisplaySize);
  void setTclParameterCount (const CTCLVariable am_TclParameterCount);
  void setTclEventListSize (const CTCLVariable am_TclEventListSize);
  void setDisplayInterface(CDisplayInterface* pInterface);

public:
  void RegisterEventProcessor(CEventProcessor&amp; rEventProcessor,
                              const char* name = 0); 
  virtual void BindTCLVariables(CTCLInterpreter&amp; rInterp); 
  virtual void SourceLimitScripts(CTCLInterpreter&amp; rInterpreter);
  virtual void SetLimits(); 
  virtual void CreateHistogrammer(); 
  virtual void CreateDisplays(); 
  virtual void SelectDisplayer();
  virtual void SetUpDisplay(); 
  virtual void SetupTestDataSource(); 
  virtual void CreateAnalyzer(CEventSink* pSink);
  virtual void SelectDecoder(CAnalyzer&amp; rAnalyzer); 
  virtual void CreateAnalysisPipeline(CAnalyzer&amp; rAnalyzer) = 0;
  virtual void AddCommands(CTCLInterpreter&amp; rInterp);
  void SetupRunControl();
  virtual void SourceFunctionalScripts(CTCLInterpreter&amp; rInterp);
  virtual int operator()(); 

  virtual void run();
  CTCLInterpreter* getInterpreter();

  static CTclGrammerApp* getInstance();

protected:
  static void UpdateUInt(CTCLVariable&amp; rVar, UInt_t&amp; rValue);
  static void UpdateString(CTCLVariable&amp; rVar, std::string&amp; rString);
  static std::string SourceOptionalFile(CTCLInterpreter&amp; rInterp,
    std::string filename);


 public:
  static CTclGrammerApp* m_pInstance; 
  static int             m_argc;  
  static char**          m_pArgV; 

};

                </synopsis>
            </refsynopsisdiv>
            <refsect1>
                <title>DESCRIPTION</title>
                <para>
                    This class is the base class of the SpecTcl application
                    class.  The standard SpecTcl skeleton provides a derivation
                    (<classname>MySpecTclApp</classname>) which has stubs for all
                    of the pure virtual methods.  Specialized derived classes
                    can do quite a bit more.
                </para>
                <para>
                    In general, to make a complete SpecTcl, you must write
                    a class derived from <classname>CTclGrammerApp</classname>,
                    instantiate it and assign a pointer to the global variable
                    <varname>CTclGrammerApp::m_pInstance</varname>. 
                </para>
                <para>
                    While normally this sort of thing might be a singleton
                    pattern, our need to derive and use the <firstterm>strategy pattern</firstterm>
                    makes these gymnastics necessary.  For more on the
                    singleton pattern see:
                    <ulink url='https://en.wikipedia.org/wiki/Singleton_pattern' />.
                    For information on the strategy pattern, see:
                    <ulink url='https://en.wikipedia.org/wiki/Strategy_pattern' />.
                </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <para>
                    The methods for this class come in several categories.
                    Since this is an important base class, we'll be documenting
                    methods that include accessors and mutators for member data
                    as well as protected methods that may be of use in special
                    situations.
                </para>
                <para>
                    The first category of methods we'll document are accessors.
                    These are methods that allow read access to member data.
                    They are all public as external objects may want to
                    obtain the values of these variables as well as derived
                    classes:
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>UInt_t </type>
                                <methodname>getDisplaySize</methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                SpecTcl places bulk spectrum data in a shared
                                memory region using the <command>sbind</command>
                                command.  This allows displayers running on the
                                same system as SpecTcl rapid access to these
                                data improving display rendering times.
                            </para>
                            <para>
                                The size of the shared memory region is determined
                                at startup (just after limit scripts are sourced).
                                This method returns the number of megabytes allocated
                                to this shared memory region.  
                            </para>
                            <para>
                                Note that as for most computer applications
                                Mega means <literal>1024*1024</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>UInt_t </type>
                                <methodname>getParams() </methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                SpecTcl uses a <classname>CEvent</classname>
                                object to represent unpacked parameters from
                                an event.   This object is self-resizing.
                                It looks like an array but if an element is
                                referenced out of range of the allowed indices,
                                it is expanded as needed.
                            </para>
                            <para>
                                The <classname>CEvent</classname> object
                                is instantiated by SpecTcl with an initial size.
                                This method returns the initial number of elements
                                in a <classname>CEvent</classname>.  Note that
                                since these objects are recycled from event
                                to event, tuning the initial size has no
                                amortized effect on performance as all
                                of these objects eventually grow to the appropriate
                                size (usually quite quickly).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>UInt_t </type>
                                <methodname>getListSize</methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Determines the number of <classname>CEvent</classname>
                                objects that are collected for each pass through
                                the histogrammer.  
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CAnalyzer*</type>
                                <methodname> getAnalyzer</methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>                          
                        </term>
                        <listitem>
                            <para>
                                Returns a pointer to the analyzer object.
                                This is deprecated in favor of the
                                <methodname>GetAnalyzer</methodname> method
                                in the <classname>SpecTcl</classname> API
                                class.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTCLHistogrammer* </type>
                                <methodname>getHistogrammer</methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns a pointer to the histogrammer object.
                                This is the special event sink pipeline element
                                that performs gating and histogramming
                            </para>
                            <para>
                                Note that this is deprecated in favor of the
                                <methodname>GetHistogrammer</methodname> method
                                if the <classname>SpecTcl</classname> API class.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTKRunControl* </type>
                                <methodname>getRunControl</methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                <classname>CRunControl</classname> objects are
                                responsible for starting and stopping playback
                                from data sources as well as providing a
                                callback when data can be read from a source.
                            </para>
                            <para>
                                The drun control object used by default for
                                <classname>CTclGrammerApp</classname> objects
                                is a <classname>CTKRunControl</classname> object
                                that uses file events to know when data are ready
                                from a data source.  This method returns a pointer
                                to the run control object currently in use.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CXamineEventHandler* </type>
                                <methodname>getXamineEvents</methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                The Xamine displayer communicates with the
                                its client via Unix IPC objects.  Shared memory
                                is used to provide bulk spectrum data and metadata
                                to Xamine.  Message based IPS are used to
                                pass events from Xamine to SpecTcl.
                            </para>
                            <para>
                                An <classname>XamineEventHandler</classname>
                                object is an object that is used to mediate
                                message traffic from Xamine to SpecTcl.
                                It handles both gate notifictions and notifications
                                of button clicks for user button boxes.
                            </para>
                            <para>
                                This method returns thye current instance
                                of the <classname>CXamienEventHandler</classname>.
                                This may not be meaningful if a displayer other
                                than Xamine is used.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>  CRunControlPackage* </type>
                                <methodname>getRunControlPackage</methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                SpecTcl's commands are grouped into sets of
                                related functionality called
                                <firstterm>command packages</firstterm>.  Command
                                package objects,
                                derived from <classname>CTCCommandPackage</classname>,
                                not only contain a set of commands
                                but also provide services that can be accessed by
                                the commands in the package. 
                            </para>
                            <para>
                                This scheme also servers to insulate SpecTcl's
                                command functionality from the language that
                                invokes it... to some extent.
                            </para>
                            <para>
                                This method returns a pointer to the run control
                                command package.  This package provides services
                                for the run control commands;
                                <command>start</command> and
                                <command>stop</command>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CParameterPackage* </type>
                                <methodname>getParameterPackage</methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                See <methodname>getRunControlPackage</methodname>
                                for background information about command
                                packages.  <classname>CParameterPackage</classname>
                                is a package containing the commands that manipulate
                                SpecTcl parameter definitions.  This includes both
                                the <command>parameter</command> and
                                <command>psuedo</command> commands.
                            </para>
                            <para>
                                This method returns a pointer to the parameter
                                package object.
                            </para>
                        </listitem>
                    </varlistentry>                  
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CSpectrumPackage* </type>
                                <methodname>getSpectrumPackage</methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                The <classname>CSpectrumPackage</classname>
                                object contains and provides services for
                                commands that affect spectra.  These include
                                <command>spectrum</command>,
                                <command>clar</command>,
                                <command>sbind</command>,
                                <command>unbind</command>,
                                <command>channel</command>,
                                <command>swrite</command> and
                                <command>sread</command>.
                                This method returns a pointer to this package
                                object.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CDataSourcePackage* </type>
                                <methodname>getDataSourcePackage</methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                The <classname>CDataSourcePackage</classname>
                                contains and provides services for commands that
                                provide access to SpecTcl data sources.
                                These include the <command>attach</command>
                                and <command>ringformat</command> classes.
                                Older versions of SpecTcl also provide
                                access to the obsolete <command>tape</command>
                                command.
                            </para>
                            <para>
                                This method returns a pointer to the
                                data source package object.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CGatePackage* </type>
                                <methodname>getGatePackage</methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                <classname>CGatePackage</classname> contains and
                                provides services for commands that have to do
                                with gates.  These commands include:
                                <command>gate</command>,
                                <command>apply</command> and
                                <command>ungate</command>.
                            </para>
                            <para>
                                This method returns a pointer to the
                                <classname>CGatePackage</classname> object used
                                by SpecTcl.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTCLVariable </type>
                                <methodname>getTclDisplaySize</methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns a <classname>CTCLVariable</classname> that,
                                in <methodname>BindTCLVariables</methodname>
                                is bound to the Tcl variable
                                <literal>DisplayMegabytes</literal>. 
                            </para>
                            <para>
                                This can be set to be the default number of
                                display shared memory megabytes.  This must
                                be done prior to the call to
                                <methodname>SourceLimitScripts</methodname>.
                                One way to accomplish this is to override
                                <methodname>SourceLimitScripts</methodname>
                                and replace it with something like:
                            </para>
                            <programlisting>
void MySpecTclApp::SourceLimitScripts(CTCLInterpreter&amp; interp)
{
    CTCLVariable displaySize = getTclDisplaySize();
    displaySize.Bind();
    displaySize.Set("16");
    
    TclGrammerApp::SourceLimitScripts(interp);
}
                            </programlisting>
                            <para>
                                The method above, sets the default value for
                                the display size to <literal>16MB</literal>
                                before invoking the base class method to
                                actually source the limit scripts. 
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTCLVariable </type>
                                <methodname>getTclParameterCount</methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns an object that represents the
                                Tcl variable that sets the
                                default value for the initial size of
                                new <classname>CEvent</classname> objects.
                                As discussed previously, there's not much to be
                                gained from altering this default as eventually
                                these objects equilibrate in size to the size needed
                                to hold all of the parameters.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CTCLVariable</type>
                                <methodname>getTclEventListSize</methodname>
                                <void />
                                <modifier>const</modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns an object that respresents the Tcl
                                variable that holds the default number of events
                                that are processed by the event processing pipeline
                                before passing events to the event sink pipeline.
                                This can be set prior to the base class executing
                                <methodname>SourceLimitScripts</methodname>.
                                Note that method may invoke a script that overrides
                                the default and that method will also set that
                                parameter.  It is possible that playing with this
                                will have a minor effect on SpecTcl performancde.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CMultiTestSource* </type>
                                <methodname>getTestDataSource</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the object that provides test data
                                for SpecTcl prior to first being attached
                                to a real data source.  It's possible,
                                once you have that object to add or select other
                                than the default test source (fixed length
                                events with gaussian parameters).
                            </para>
                            <para>
                                One potential use for this would be to hook
                                directly to some event simulator, although
                                much simpler would be to teach SpecTcl to analyze
                                the saved event files from such a simulator.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>CDisplayInterface* </type>
                                <methodname>getDisplayInterface</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Provides a pointer to the current display
                                interface.  This object provides methods
                                to manage displayers that can be used by
                                SpecTcl.
                            </para>
                        </listitem>
                    </varlistentry>
    
                </variablelist>
                <para>
                    The second set of methods we will document are mutators.
                    A mutator is a method that allows you to modify internal
                    attributes of an object.  These methods are all intended
                    to be used by derived classes and therefore are all
                    <literal>protected</literal>.
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void </type>
                                <methodname>setDisplaySize </methodname>
                                <methodparam>
                                   <modifier>const</modifier>
                                   <type>UInt_t </type><parameter>am_nDisplaySize</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets the display memory size in megabytes.  This
                                must be called after
                                <methodname>SourceLimitScripts</methodname> to
                                override the value in those scripts or prior to
                                set the default value.   It should also be
                                called prior to
                                <methodname>CreateDisplays</methodname> which
                                actually sets up the display shared memory.
                            </para>
                        </listitem>
                    </varlistentry>                    
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void </type>
                                <methodname>setParams </methodname>
                                <methodparam>
                                   <modifier>const </modifier>
                                   <type>UInt_t </type><parameter>am_nParams</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets the number of parameters that will be used
                                as the initial size for <classname>CEvent</classname>
                                vectors.   To override the user's settings, this
                                should be called after
                                <methodname>SourceLimitScripts</methodname>, otherwise
                                it is used as a default value for that
                                parameter if it is not set in the user's scripts.
                            </para>
                            <para>
                                As previously discussed, setting this has
                                essentially no impact on SpecTcl's performance
                                due to the autosizing and recycling of parameter
                                vectors.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>
                                    void 
                                </type>
                                <methodname>setListSize </methodname>
                                <methodparam>
                                   <modifier>const </modifier>
                                   <type>UInt_t </type><parameter>am_nListSize</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets the event list size.  This is the number
                                of events that is analyzed by the event processing
                                pipeline before those events are passed to the
                                event sink pipeline for histogramming and
                                other processing.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    This set of methods are virtual and therefore can be overridden.
                    These methods are all exposed in the
                    <classname>MySpecTclApp</classname> class in the SpecTcl
                    Skeleton.  In that class, the base class method is invoked.
                    You can add code as needed to meet your needs.
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier> </modifier>
                                <type>void</type>
                                <methodname>RegisterEventProcessor</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>CEventProcessor&amp;</type><parameter> rEventProcessor</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier>const</modifier>
                                   <type> char* </type><parameter>name </parameter>
                                   <initializer>0</initializer>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Not actually a virtual method, this method is
                                used to add an event processor to the end of
                                the event processing pipeline.
                                <parameter>rEventProcessor</parameter>, is the
                                processor to add and <parameter>name</parameter>,
                                if supplied is a name associated with the event
                                processor.  If <parameter>name</parameter>
                                is not supplied, one is assigned.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>void </type>
                                <methodname>BindTCLVariables</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>CTCLInterpreter&amp; </type><parameter>rInterp</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This is called to bind SpecTcl's special Tcl
                                variables to this object's
                                <classname>CTCLVariable</classname>
                                members.  Doing this allows those objects
                                to access the underlying Tcl variables.
                                Variables bound and created include:
                            </para>
                            <itemizedlist>
                                <listitem>
                                    <para>
                                        <varname>tcl_rcFilename</varname>
                                        The name of the early Tcl initialization
                                        file.
                                    </para>
                                </listitem>
                                <listitem>
                                    <para>
                                        <varname>DisplayMegabytes</varname>
                                        Number of megabytes of display shared
                                        memory allocated.
                                    </para>
                                </listitem>
                                <listitem>
                                    <para>
                                        <varname>ParameterCount</varname>
                                        Number of parameers allocated in the
                                        initial create of <classname>CEvent</classname>
                                        objects.
                                    </para>
                                </listitem>
                                <listitem>
                                    <para>
                                        <varname>EventListSize</varname>
                                        Number events analyzed by the analysis
                                        pipeline before passing them on to the
                                        sink pipeline.
                                    </para>
                                </listitem>
                                <listitem>
                                    <para>
                                        <varname>DisplayType</varname>
                                        type of displayer used.
                                    </para>
                                </listitem>
                            </itemizedlist>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>void </type>
                                <methodname>SourceLimitScripts</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>CTCLInterpreter&amp;</type><parameter> rInterpreter</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sources the limit setting scripts
                                (<filename>SpecTclInit.tcl</filename>) into
                                <parameter>rInterpreter</parameter>.  All
                                of the following locations are searched and for
                                the reasons given:
                            </para>
                            <itemizedlist>
                                <listitem>
                                    <para>
                                        The <filename>etc</filename> subdirectory
                                        of the SpecTcl installation is searched
                                        to provide system defaults that override
                                        the default values compiled in to
                                        SpecTcl.
                                    </para>
                                </listitem>
                                <listitem>
                                    <para>
                                        The user's home directory is searched
                                        to provide account wide settings that may
                                        override the system wide settings.
                                    </para>
                                </listitem>
                                <listitem>
                                    <para>
                                        The current working directory is searched
                                         to provide project specific settings.
                                    </para>
                                </listitem>
                            </itemizedlist>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>void </type>
                                <methodname>SetLimits</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Updates the SpecTcl Tcl variables from the
                                final tuning values after
                                <methodname>SourceLimitScripts</methodname>
                                has been executed.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual</modifier>
                                <type> void </type>
                                <methodname>CreateHistogrammer</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This method creates the event sink pipeline,
                                assigning a pointer to it to
                                <varname>gpEventSinkPipeline</varname>.
                                It then immediately creates a
                                <classname>CHistogrammer</classname> object
                                saving it's pointer in
                                <varname>gpEventSink</varname> and adding it
                                to the end of the event sink pipeline.
                            </para>
                            <para>
                                In addition an observer is attached to the
                                spectrum dictionary (part of the histogrammer).
                                This observer, a
                                <classname>SpectrumDictionaryFitObserver</classname>
                                destroys fits on spectra that are being removed
                                from the spectrum dictionary.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>void </type>
                                <methodname>CreateDisplays</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                SpecTcl supports more than one displayer.
                                Currently it supports Xamine, a displayer built
                                directly on Motif and the Xt/X11 toolkit and
                                Spectra, a displayer build on Root.
                                This method sets up a factory of display
                                interfaces.
                                It stocks it with creators for
                                Xamine, Spectra and headless (batch) mode.
                            </para>
                            
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>void </type>
                                <methodname>SelectDisplayer</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Selects and starts the displayer whose name is
                                stored in the Tcl variable
                                <varname>DisplayType</varname>.
                                <varname>DisplayType</varname> must have been
                                set prior to
                                <methodname>SourceLimitScripts</methodname>.
                            </para>
                            <para>
                                The displayer process is started if appropriate.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>void </type>
                                <methodname>SetUpDisplay</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets up communication between SpecTcl and the
                                displayer.  Specifically, when gates are
                                created or destroyed, when spectra have gates
                                applied to them or are ungated, the displayer
                                may provide visual cues.  This method sets up
                                observers on the SpecTcl side that
                                detect appropriate changes and communicate
                                with the selected displayer so that this
                                information is updated by the displayer..
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>void </type>
                                <methodname>SetupTestDataSource</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                SpecTcl has a test data source.  If analysis
                                is started, prior to attaching to a data source,
                                the test source will supply data.  The
                                test data source is, by default, a
                                <classname>CMlutiTestSource</classname> which
                                is can be a container for several types of
                                data sources.  
                            </para>
                            <para>
                                This method establishes that data source
                                and selects its default data source.
                                The default data source delivers fixed sized
                                events that contain several parameters of
                                gaussian distributed parameters.
                            </para>
                            <para>
                                The SpecTcl skeleton files can analyze data
                                from the default test source without modification.
                                This is one way to use and become familiar with
                                SpecTcl.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>void </type>
                                <methodname>CreateAnalyzer</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>CEventSink* </type>
                                   <parameter>pSink</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Creates and attaches the analyzer to the system.
                                The analyzer is the object that controls the
                                flow of data from a data source through the
                                analysis pipeline and to the event sink
                                pipeline.
                            </para>
                            <para>
                                By default a <classname>CTclAnalyzer</classname>
                                is instantiated and hooked in to SpecTcl.
                                A pointer to the analyzer object is stored
                                in <varname>gpAnalyzer</varname> as well
                                as in the attribute
                                <varname>m_pAnalyzer</varname>.  Both should
                                be updated to change the analyzer, if that's
                                desired.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>void </type>
                                <methodname>SelectDecoder</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>CAnalyzer&amp; </type>
                                   <parameter>rAnalyzer</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets the initial buffer decoder. Note that
                                in most cases, SpecTcl's
                                <command>attach</command> command will
                                select a new buffer decoder object to match the
                                <option>-format</option> value, implied by
                                or explicit in the command.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>void </type>
                                <methodname>CreateAnalysisPipeline</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>CAnalyzer&amp; </type>
                                   <parameter>rAnalyzer</parameter>
                                   <initializer>0</initializer>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This is a pure virtual method and therefore
                                must be implemented by any subclass that
                                can be instantiated.  The code in this
                                method should create and add elements
                                to the event processing pipeline.                         
                            </para>
                            <para>
                                <methodname>RegisterEventProcessor</methodname>
                                is provided as a convenience method for
                                adding event processors to the analyzer.
                                Note that event processors are a property
                                of the <classname>CTclAnalyzer</classname>
                                class and its descendents.  
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>void </type>
                                <methodname>AddCommands</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>CTCLInterpreter&amp; </type>
                                   <parameter>rInterp</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Adds SpecTcl specific commands to the
                                Tcl interpreter
                                <parameter>rInterp</parameter>.
                                The base class method creates and adds
                                all of the command packages that hold most
                                of SpecTcl's commands.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void </type>
                                <methodname>SetupRunControl</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Not virtual and therefore cannot be overridden,
                                this method creates a new
                                <classname>CTkRunControl</classname>
                                object, stores a pointer to it in 
                                <varname>gpRunControl</varname> which
                                establishes it as the run control object
                                that SpecTcl uses.  The object's pointer is
                                also stored in the attribute
                                <varname>m_pRunControl</varname>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>void </type>
                                <methodname>SourceFunctionalScripts</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>CTCLInterpreter&amp; </type>
                                   <parameter>rInterp</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sources functional setup scripts into
                                <parameter>rInterp</parameter>.  The
                                functional setup scripts are those named
                                <filename>SpecTclRC.tcl</filename>.  SpecTcl
                                will first run any script by this name that
                                exists in the user's home directory.  Next it
                                will run any script by that name that exists in
                                the current working directory.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>int </type>
                                <methodname>operator()</methodname>
                                <void />
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Entry point.  This method invokes all of the
                                initialization methods in turn.
                                It should return
                                <literal>TCL_OK</literal> if successful
                                and <literal>TCL_ERROR</literal> on
                                any failure.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    The remainder of the methods we'll document are
                    utility functions.  These are protected and therefore
                    can only be called from methods in this class or a
                    class derived from this class
                    (e.g. <classname>MySpecTclApp</classname>).
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>static</modifier>
                                <type> void </type>
                                <methodname>UpdateUInt</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>CTCLVariable&amp; </type>
                                   <parameter>rVar</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>UInt_t&amp;</type>
                                   <parameter> rValue</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This utility method accepts a
                                Tcl variable object
                                (<parameter>rVar</parameter>) which is
                                supposed to hold an
                                unsigned integer and sets
                                <parameter>rValue</parameter> to the value
                                of that integer.  If the variable does not
                                exist in the Tcl interpreter, no error
                                is thrown and the <parameter>rValue</parameter>
                                is un-modified.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>static</modifier>
                                <type> void </type>
                                <methodname>UpdateString</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>CTCLVariable&amp; </type>
                                   <parameter>rVar</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string&amp; </type>
                                   <parameter>rString</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Similiar to
                                <methodname>UpdateUInt</methodname>
                                but the Tcl variable is an arbitrary
                                string.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <methodsynopsis>
                                <modifier>static </modifier>
                                <type>std::string </type>
                                <methodname>SourceOptionalFile</methodname>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>CTCLInterpreter&amp; </type>
                                   <parameter>rInterp</parameter>
                                </methodparam>
                                <methodparam>
                                   <modifier></modifier>
                                   <type>std::string </type>
                                   <parameter>filename</parameter>
                                </methodparam>
                                <modifier></modifier>
                            </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This method attempts to source the file
                                <parameter>filename</parameter> into the
                                interpreter <parameter>rInterp</parameter>.
                                It is not an error for the file to not exist.
                                That's the meaning of the
                                "optional" part of this method's name.
                            </para>
                            <para>
                                The return value from this method is an empty
                                string on success (including missing file)
                                and an error message string if an error occured
                                (such as the script failing).
                            </para>
                        </listitem>
                    </varlistentry>

                </variablelist>
            </refsect1>
        </refentry>
<refentry>
    <refmeta>
        <refentrytitle>CHistogrammer</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CHistogrammer</refname>
        <refpurpose>SpecTcl histogramming core</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>

class <classname>CHistogrammer</classname> : public <classname>CEventSink</classname> {

  typedef std::list&lt;CGateObserver*&gt;   GateObserverList;
  typedef std::list&lt;CGatingObserver*&gt; GatingObserverList;

  ParameterDictionary m_ParameterDictionary;
  SpectrumDictionary  m_SpectrumDictionary;
  CGateDictionary     m_GateDictionary; 
  GateObserverList    m_gateObservers;  
  GatingObserverList  m_gatingObservers;


  CFlattenedGateList*   m_pGateList;
  CSpectrumByParameter* m_pSpectrumLists;


 public:

  const ParameterDictionary&amp; getParameterDictionary() const ;

  const SpectrumDictionary&amp; getSpectrumDictionary() const ;

 protected:

  void setParameterDictionary(const ParameterDictionary&amp; am_ParameterDictionary);

  void setSpectrumDictionary(const SpectrumDictionary&amp; am_SpectrumDictionary) ;

 public:

  virtual void operator() (const CEvent&amp;     rEvent);
  virtual void operator() (CEventList&amp; rEventList);


  CParameter* AddParameter (const std::string&amp; sName,
			    UInt_t nId,
			    const char* pUnits);
  CParameter* AddParameter (const std::string&amp; sName,
			    UInt_t nId,
			    UInt_t  nScale);
  CParameter* AddParameter (const std::string&amp; sName,
			    UInt_t nId, UInt_t nScale,
			    Float_t nLow, Float_t nHi,
			    const std::string&amp; sUnits);
  CParameter* RemoveParameter (const std::string&amp; sName);
  CParameter* FindParameter (const std::string&amp; rName);
  CParameter* FindParameter (UInt_t nPar);
  ParameterDictionaryIterator ParameterBegin();
  ParameterDictionaryIterator ParameterEnd();
  UInt_t ParameterCount();


  void AddSpectrum(CSpectrum&amp; rSpectrum);
  CSpectrum* RemoveSpectrum(const std::string sName);
  void ClearSpectrum(const std::string&amp; rsName);
  void ClearAllSpectra();
  CSpectrum* FindSpectrum(const std::string&amp; rName);
  CSpectrum* FindSpectrum(UInt_t id);
  SpectrumDictionaryIterator SpectrumBegin();
  SpectrumDictionaryIterator SpectrumEnd();
  UInt_t SpectrumCount();
  void addSpectrumDictionaryObserver(SpectrumDictionaryObserver* observer);
  void removeSpectrumDictionaryObserver(SpectrumDictionaryObserver* observer);

  void UnGate(const std::string&amp; rSpectrum); 

  void AddGate(const std::string&amp; rName, UInt_t nId, CGate&amp; rGate);
  void DeleteGate(const std::string&amp; rGateName);
  void ReplaceGate(const std::string&amp; rGateName, CGate&amp; rGate);
  void ApplyGate(const std::string&amp; rGateName,  const std::string&amp; rSpectrum);
  CGateContainer* FindGate(const std::string&amp; rGate);
  CGateContainer* FindGate(UInt_t nId);
  CGateDictionaryIterator GateBegin();
  CGateDictionaryIterator GateEnd();
  UInt_t GateCount();

  void addGateObserver(CGateObserver* observer);
  void removeGateObserver(CGateObserver* observer);

  void addGatingObserver(CGatingObserver* observer);
  void removeGatingObserver(CGatingObserver* observer);

};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Histogramming core of SpecTcl.  In addition to performing the
            actual histogramming, this class encapsulates SpecTcl's dictionaries.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            The first set of methods get and set attributes.  The getter methods
            are public while the setters are all protected.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>const </modifier>
                        <type>ParameterDictionary&amp;</type>
                        <methodname> getParameterDictionary</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a reference to the SpecTcl parameter dictionary.
                        This is a dictionary that contains all of the
                        parameter definitions known to SpecTcl. Note that
                        the <classname>SpecTcl</classname> API class
                        provides the access to this dictionary that most
                        applications need and should be used instead rather than
                        directly accessing the dictionary.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>const </modifier>
                        <type>SpectrumDictionary&amp; </type>
                        <methodname>getSpectrumDictionary</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a reference to the Spectrum dictionary.
                        This contains all of the objects that define the
                        spectra the histogrammer increments.  Note that
                        the <classname>SpecTcl</classname> API class
                        provides the access to this dictionary that most
                        applications need and should be used instead rather than
                        directly accessing the dictionary.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>protected:</modifier>
                        <type>void </type>
                        <methodname>setParameterDictionary</methodname>
                        <methodparam>
                           <modifier>const</modifier>
                           <type> ParameterDictionary&amp;</type>
                           <parameter> am_ParameterDictionary</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Allows derived classes to replace the parameter dictionary.
                        This is only useful in the unlikely event you've
                        derived a new dictionary class from the
                        <classname>ParameterDictionary</classname> class.
                    </para>
                    <para>
                        This method should be called early in the lifetime of
                        the derived class to ensure you don't lose existing definitions
                        when replacing the object.  The constructor would be
                        a good place to do this.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>protected</modifier>
                        <type>  void </type>
                        <methodname>setSpectrumDictionary</methodname>
                        <methodparam>
                           <modifier>const </modifier>
                           <type>SpectrumDictionary&amp; </type>
                           <parameter>am_SpectrumDictionary</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Provides a replacement for a spectrum dictionary.
                        Most of the comments associated with
                        <methodname>setParameterDictionary</methodname>
                        apply here.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            The next set of methods are invoked externally to perform histogramming.
            Normally the analyzer object invokes these after building an
            event list from the results of the analysis pipeline.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                           <modifier>const</modifier>
                           <type> CEvent&amp;     </type>
                           <parameter>rEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Resets all of the gates and histograms the
                        <parameter>rEvent</parameter>, a single event.
                        Note that the histograms check the gates needed to
                        be incremented so there's no separate pass taken to
                        check all gates.  Furthermore, gates cache their
                        results so the actual gate computation is not only
                        performed only on the gates needed but at most once per
                        gate.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>operator() </methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CEventList&amp;</type>
                           <parameter> rEventList</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Iterates over each event in <parameter>rEventlist</parameter>
                        invoking the previous overloaded <methodname>operator()</methodname>
                        for each element in that list.   This is the method
                        invoked by the analyzer object to process events from
                        the event processing pipeline.
                    </para>
                </listitem>
            </varlistentry>

        </variablelist>
        <para>
            The next set of methods mainpulate the parameter dictionary.
            Note that the
            <classname>SpecTcl</classname>
            API provides methods to accomplish
            everything these methods accomplish.  I recommend
            using the API singleton to do parameter manipulation or,
            even simpler, use <classname>CTreeParameter</classname>
            objects instead of directly working with SpecTcl low level
            parameters.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CParameter* </type>
                        <methodname>AddParameter</methodname>
                        <methodparam>
                           <modifier>const</modifier>
                           <type> std::string&amp;</type>
                           <parameter> sName</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>nId</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier>const </modifier>
                           <type>char*</type>
                           <parameter> pUnits</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>                  
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CParameter* </type>
                        <methodname>AddParameter</methodname>
                        <methodparam>
                           <modifier>const</modifier>
                           <type> std::string&amp; </type>
                           <parameter>sName</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t</type>
                           <parameter> nId</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t  </type>
                           <parameter>nScale</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CParameter* </type>
                        <methodname>AddParameter </methodname>
                        <methodparam>
                           <modifier>const</modifier>
                           <type> std::string&amp; </type>
                           <parameter>sName</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>nId</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>nScale</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Float_t</type>
                           <parameter> nLow</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Float_t </type>
                           <parameter>nHi</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier>const </modifier>
                           <type>std::string&amp; </type>
                           <parameter>sUnits</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        These methods create a new parameter and
                        add it to the parameter dictionary.
                    </para>
                    <para>
                        <parameter>sName</parameter> is the name of the new parameter.
                        If a parameter with that name already exists,
                        a <classname>CDictionaryException</classname> is thrown.
                        <parameter>nId</parameter> is the parameter's id which
                        is the slot in the <classname>CEvent</classname> array
                        like object in which parameter values are put.
                        A <classname>CDictionaryException</classname> is
                        also thrown
                        if a parameter with that Id already exists.
                    </para>
                    <para>
                        <parameter>nScale</parameter> determines the
                        resolution of the parameter in bits. When creating
                        a spetrum on a parameter, consider being informed
                        by this value when determining the binning for axes
                        involving this parameter.
                    </para>
                    <para>
                        <parameter>nLow</parameter> and <parameter>nHigh</parameter>
                        are soft limits on the values stored in the parameter.
                        Spectra created with axes defined on this parameter
                        should use these values to inform decisions about the
                        limits on those axes.
                    </para>
                    <para>
                        <parameter>sUnits</parameter> is the units of measure
                        for the parameter.   Spectra can label axes with that as
                        a unix of meausre appropriately.
                    </para>
                    <para>
                        On successful return, a pointer to the new
                        <classname>CParameter</classname> object is returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CParameter*</type>
                        <methodname> RemoveParameter </methodname>
                        <methodparam>
                           <modifier>const </modifier>
                           <type>std::string&amp; </type>
                           <parameter>sName</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes the parameter identified by
                        <parameter>sName</parameter> from the parameter
                        dictionary. The parameter object is copy constructed
                        into a dynamically allocated <classname>CParameter</classname>
                        object whose pointer is returned.  The return value
                        must therefore be <literal>delete</literal>d in order
                        to prevent memory leaks.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CParameter* </type>
                        <methodname>FindParameter</methodname>
                        <methodparam>
                           <modifier>const</modifier>
                           <type> std::string&amp; </type>
                           <parameter>rName</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CParameter* </type>
                        <methodname>FindParameter </methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>nPar</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to a <classname>CParameter</classname>
                        object in the parameter dictionary.  The parameter
                        returned either has a name equal to
                        <parameter>rName</parameter> or a parameter id
                        equal to <parameter>nPar</parameter> depending on which
                        actual method is called.
                    </para>
                    <para>
                        If there is no matching parameter a null pointer is returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>ParameterDictionaryIterator </type>
                        <methodname>ParameterBegin</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an iterator to the first element of the
                        parameter dictionary.  Parameter dictionary Iterators
                        act like pointers that point to an
                        <classname>std::pair&lt;std::string, CParameter&gt;</classname>.
                        The first element of this pair is the name of the
                        parameter while the second is the parameter itself.
                    </para>
                    <para>
                        Incrementing an iterator points to the next element
                        of the container.  Incrementing an iterator that points
                        to the last container element returns
                        the same value as returned by
                        <methodname>ParameterEnd</methodname>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>ParameterDictionaryIterator </type>
                        <methodname>ParameterEnd</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an value that is no longer in the container.
                        Typical iteration over the parameter dictionary follows
                        this pattern:
                    </para>
                    <programlisting>
CHistogrammer* pH;                     // Assume this points to the histogrammer.
for (auto p = pH->ParameterBegin(); p != pH->ParameteEnd(); p++) {
        // do something with p->first and p->second.
        ...
}

                    </programlisting>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>UInt_t </type>
                        <methodname>ParameterCount</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of elements in the parameter
                        dictionary.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            The next methods manipulate the spectrum dictionary. The
            <classname>SpecTcl</classname> API singleton class
            provides these services as well and we recommend you use it rather
            than relyingo n these methods.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>AddSpectrum</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CSpectrum&amp; </type>
                           <parameter>rSpectrum</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a new spectrum object to the spectrum dictionary.
                        The Spectrum's  name is used as the dictionary key.
                        The spectrum's id is used as the spectrum number.
                    </para>
                    <para>
                        If a spectrum matches either the name or the id,
                        a <classname>CDictionaryException</classname>
                        is thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CSpectrum* </type>
                        <methodname>RemoveSpectrum</methodname>
                        <methodparam>
                           <modifier>const</modifier>
                           <type> std::string </type>
                           <parameter>sName</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes a spectrum with the name
                        <parameter>sName</parameter> from the spectrum dictionary.
                        A pointer to the removed spectrum is returned to the
                        caller.  If there is no matching spectrum,
                        a null pointer is returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>ClearSpectrum</methodname>
                        <methodparam>
                           <modifier>const </modifier>
                           <type>std::string&amp; </type>
                           <parameter>rsName</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Locates the spectrum in the spectrum dictionary
                        that is named <parameter>rsName</parameter>.  That
                        spectrum's <methodname>clear</methodname> method is
                        called.  Normally that method sets all of the channels of
                        the spectrum to <literal>0</literal>.
                    </para>
                    <para>
                        If there is no matching spectrum, a
                        <classname>CDictionaryException</classname> is thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>ClearAllSpectra</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Iterates through the spectrum dictionary invoking each
                        <classname>CSpectrum</classname> object's
                        <methodname>clear</methodname> method.  This sets all
                        channels for all spectra to zero (assuming that's what
                        the <methodname>clear</methodname> method does for all
                        subclasses of <classname>CSpectrum</classname>).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CSpectrum* </type>
                        <methodname>FindSpectrum</methodname>
                        <methodparam>
                           <modifier>const </modifier>
                           <type>std::string&amp; </type>
                           <parameter>rName</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CSpectrum* </type>
                        <methodname>FindSpectrum</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>id</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        The return value of <methodname>FindSpectrum</methodname>
                        is a pointer to the <classname>CSpectrum</classname> object
                        in the spectrum dictionary that matches the search criterion
                        passed in as an argument.
                        <parameter>rName</parameter> is the name of the spectrum
                        that must match exactly. <parameter>id</parameter> is the
                        spectrum id.
                    </para>
                    <para>
                        If there is no matching spectrum in the dictionary,
                        a null pointer is returned.  Note that the dictionary
                        management methods ensure that there can be at most
                        one match.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>SpectrumDictionaryIterator </type>
                        <methodname>SpectrumBegin</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>SpectrumDictionaryIterator </type>
                        <methodname>SpectrumEnd</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        These methods can be used to iterate over all of the
                        entries in the spectrum dictionary.  Both methods return
                        a <classname>SpectrumDictionaryIterator</classname>. This
                        object acts like a pointer to a
                        <classname>std::pair&lt;std:;string, CSpectrum*&gt;</classname>
                        object.  The first element of the pair is the name of an
                        entry in the dictinoary (spectrum name), the second a pointer
                        to the spectrum with that name.
                    </para>
                    <para>
                        <methodname>SpectrumBegin</methodname> provides an iterator
                        that points to information about the first entry in the
                        dictionary.
                        Incrementing an iterator via its <methodname>operator++</methodname>
                        points it to the next entry in the dictionary.  Incremeting
                        the  iterator when it points to the last entry of the
                        container makes it equal to the value returned from
                        <methodname>SpectrumEnd</methodname>.  
                    </para>
                    <para>
                        Typical spectrum dictionary iteration can use the
                        STL algorithm std::for_each if you have a functor it can call,
                        or can express your operation as a C++ lambda or, without
                        being fancy looks something like (<varname>pHisto</varname>
                        is a pointer to the histogrammer object).
                    </para>
                    <programlisting>
    for (auto p = pHisto-&gt;SpectrumBegin(); p != pHisto-&gt;SpectrumEnd(); p++) {
        std::string name = p-&gt;first;
        CSpectrum*   pSpec= p-&gt;second;
        
        // Do something with the spectrum or name or both.
    }
                    </programlisting>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>UInt_t </type>
                        <methodname>SpectrumCount</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of spectra in the spectrum dictionary.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>addSpectrumDictionaryObserver</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>SpectrumDictionaryObserver* </type>
                           <parameter>observer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>removeSpectrumDictionaryObserver</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>SpectrumDictionaryObserver* </type>
                           <parameter>observer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        These methods control <firstterm>observers</firstterm> of
                        the spectrum dictionary.  For information about the
                        observer programming pattern see:
                        <ulink url='https://en.wikipedia.org/wiki/Observer_pattern' />.
                        For information about the
                        <classname>SpectrumDictionaryObserver</classname> abstract
                        base class, see <literal>DATA TYPES</literal> below.
                    </para>
                    <para>
                        <methodname>addSpectrumDictionaryObserver</methodname>
                        adds an observer whose methods will be called when
                        changes are made to the spectrum dictionary (adding or
                        removing spectra).  <methodname>removeSpectrumObserver</methodname>
                        removes an existing observer (<parameter>observer</parameter>).
                        If the specified <parameter>observer</parameter> has not
                        been established,
                        <methodname>removeSpectrumObserver</methodname>
                        does nothing.
                    </para>
                    <para>
                        It is possible to register a single observer object more
                        than once.  This is considered a pathology but no
                        effort is made to stop you from doing that.  If an
                        observer has been multiply registered,
                        <methodname>removeSpectrumObserver</methodname> will
                        remove all instances of that observer object.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            The Next group of methods are used to mainpulate gates.  In addition
            to adding and replacing gates in the gate dictionary, this set of
            methods can apply gates to a spectrum as well as remove any
            gate application from a spectrum (called <firstterm>ungating</firstterm>).
        </para>
        <para>
            A couple of words about why gates can't actually
            be removed/deleted from
            the gate dictionary.  Many gate types are compound gates.
            Compound gates are formed from logical combinations of othe gates.
            For example an <literal>and</literal> gate is true if all of its
            constituent gates (some of which might also be compound) are
            true.
        </para>
        <para>
            It's very hard, therefore to get a good definition of the effect
            on a compound gate when a gate it depends on (directly or indirectly)
            is destroyed.  Therefore SpecTcl's commands, normally "deletes" a gate not
            by destroying it but by replacing it with a False gate.  This has a
            consistent well defined behavior with respect not only to gates
            that directly depend on the 'deleted' gate but also indirectly
            dependent gates.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>AddGate</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>const std::string&amp; </type>
                           <parameter>rName, UInt_t nId</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>CGate&amp; </type>
                           <parameter>rGate</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a new gate to the gate dictionary.
                        <parameter>rName</parameter> is the name that is given
                        to the gate.  It must be unique or else a
                        <classname>CDictionaryException</classname> will be thrown.
                    </para>
                    <para>
                        <parameter>nId</parameter> is a gate id number.  It's value
                        is not actually important to SpecTcl's processing but
                        it too must be unique, or else a
                        <classname>CDictionaryException</classname> will be thrown
                    </para>
                    <para>
                        <parameter>rGate</parameter> is a reference to the
                        gate that will be added.  The  object is cloned
                        so that a dynamically created copy is actually stored.
                    </para>
                </listitem>
            </varlistentry>          
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>ReplaceGate</methodname>
                    <methodparam>
                       <modifier></modifier>
                       <type>const std::string&amp; </type>
                       <parameter>rGateName, </parameter>
                    </methodparam>
                    <methodparam>
                       <modifier></modifier>
                       <type>CGate&amp;</type>
                       <parameter> rGate</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>           
            </term>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>DeleteGate</methodname>
                    <methodparam>
                       <modifier>const</modifier>
                       <type> std::string&amp; </type>
                       <parameter>rGateName</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    These methods both actually replace the definition of
                    an existing gate.  <methodname>ReplaceGate</methodname>
                    replaces the defintion of the gate named
                    <parameter>rGateName</parameter> with the gate
                    <parameter>rGate</parameter>. The previous gate
                    definition object is deleted (recall that
                    <methodname>addGate</methodname> makes a dynamic clone).
                </para>
                <para>
                    <methodname>DeleteGate</methodname> simply calls
                    <methodname>ReplaceGate</methodname> with a false gate.
                    SpecTcl's commands understand that such gates are actually
                    deleted when listing gates.
                </para>
                <para>
                    If no gate named <parameter>rGateName</parameter>
                    is defined in the gate dictionary, a
                    <classname>CDictionaryException</classname> is thrown.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>CGateContainer* </type>
                    <methodname>FindGate</methodname>
                    <methodparam>
                       <modifier></modifier>
                       <type>const std::string&amp; </type>
                       <parameter>rGate</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>CGateContainer* </type>
                    <methodname>FindGate</methodname>
                    <methodparam>
                       <modifier></modifier>
                       <type>UInt_t </type>
                       <parameter>nId</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Locates a gate either by its
                    name (<parameter>rGate</parameter>) or integer gate
                    id (<parameter>nId</parameter>).  If no matching gate
                    is found in the gate dictionary; a nul pointer is returned.
                </para>
                <para>
                    The return value is a pointer to a <classname>CGateContainer</classname>.
                    For all purposes, you can treat a <classname>CGateContainer</classname>
                    as a pointer to the gate itself.  The gate container is what
                    dependent gates actually use as this allows gate definitions
                    to be modified transparently.
                </para>
                <para>
                    Note that for any specific matched gate, SpecTcl
                    gaurantees that a subsequent search for the same gate
                    (by name or id) will return the same
                    <classname>CGateContainer</classname>.  Furthermore
                    a search for the same gate either by id or by name
                    will, when matched both return the same gate container pointer.
                </para>
            </listitem>
        </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CGateDictionaryIterator </type>
                        <methodname>GateBegin</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CGateDictionaryIterator </type>
                        <methodname>GateEnd</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        These methods iteration over thee gate dictionary.  A
                        <classname>CGateDictionaryIterator</classname>
                        is like a pointer to a
                        <classname>std::pair&lt;std::string, CGateContainer*&gt;</classname>.
                        The first element of the pair is a gate name.  The second a
                        gate container that points to the gate that's currently
                        bound to  that name.
                    </para>
                    <para>
                        <methodname>GateBegin</methodname> returns an iterator that
                        points to the first element in the gate dictionary.
                        Incrementing this iterator points to the next element of the
                        dictionary.  Incrementing the iterator when it points to the
                        last element of the dictionary results in the value
                        returned by <methodname>GetEnd</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>UInt_t </type>
                        <methodname>GateCount</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of entries in the gate dictionary.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>addGateObserver</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CGateObserver* </type>
                           <parameter>observer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>              
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>removeGateObserver</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CGateObserver* </type>
                           <parameter>observer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        These methods manage observers on the gate dictionary.
                        For information about the
                        observer programming pattern see:
                        <ulink url='https://en.wikipedia.org/wiki/Observer_pattern' />.
                        For information about the
                        <classname>CGateObserver</classname> abstract
                        base class, see <literal>DATA TYPES</literal> below.
                    </para>
                    <para>
                        <methodname>addGateObserver</methodname> adds a new
                        <parameter>observer</parameter>
                        to the end of the list of observers of the
                        gate dictionary.  <methodname>removeGateObserver</methodname>
                        removes the <parameter>observer</parameter> from the
                        set of observers established on the gate dictionary.
                    </para>
                    <para>
                        While establishing the same observer more than once is
                        pathalogical, nothing is done to prevent that.  If
                        <methodname>removeGateObserver</methodname> is passed
                        an <parameter>observer</parameter> that has been
                        added more than once, all instances of that observer
                        are removed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>ApplyGate</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>const std::string&amp; </type>
                           <parameter>rGateName</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier>const </modifier>
                           <type>std::string&amp; </type>
                           <parameter>rSpectrum</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term> 
                <listitem>
                    <para>
                        Applies the gate named
                        <parameter>rGateName</parameter> to the spectrum
                        named <parameter>rSpectrum</parameter>.  If either the
                        gate or the spectrum are not in their respective
                        dictionaries, a <classname>CDictionaryException</classname>
                        is thrown.
                    </para>
                    <para>
                        Any previously applied gate remains defined but no longer
                        affects when the spectrum is incremented.  If successful,
                        the spectrum can only be incremented if the
                        gate named by <parameter>rGateName</parameter> evaluates
                        to true for the event.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>UnGate</methodname>
                        <methodparam>
                           <modifier>const </modifier>
                           <type>std::string&amp; </type>
                           <parameter>rSpectrum</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This is like doing a call to
                        <methodname>ApplyGate</methodname> to the spectrum named
                        <parameter>rSpectrum</parameter> passing a gate that is
                        a true gate.  
                    </para>
                    <para>
                        If <parameter>rSpectrum</parameter> does not name
                        a spectrum that is defined in the spectrum dictionary
                        a <classname>CDictionaryException</classname> is thrown.
                        If successful, <parameter>rSpectrum</parameter> is incremented
                        whenever all of the parameters required are present and
                        inside the spectrum's axis bounds.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>addGatingObserver</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CGatingObserver* </type>
                           <parameter>observer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>removeGatingObserver</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CGatingObserver* </type>
                           <parameter>observer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Manage the gating observers.  Gating observers
                        observe the application of gates to spectra as well
                        as the ungating of spectra.
                        For infoirmation about the observer pattern see
                        <ulink url='https://en.wikipedia.org/wiki/Observer_pattern' />.
                        For information about
                        <classname>CGatingObserver*</classname> objects
                        see <literal>DATA TYPES</literal> below.
                    </para>
                    <para>
                        <methodname>addGatingObserver</methodname> adds a new
                        <parameter>observer</parameter> to the end of the list of
                        observers that will be invoked when gate applications/removals
                        are done.  <methodname>removeGatingObserver</methodname>
                        removes the observer <parameter>observer</parameter>
                        from the list of gating observers.
                    </para>
                    <para>
                        While it is pathalogical to add the same observer more
                        than once, no steps are taken to block this.   Furthermore,
                        if <methodname>removeGatingObserver</methodname> is asked
                        to remove a gating observer that has been multiply added,
                        <emphasis>all</emphasis> instances of it in the observer
                        list are removed.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        
    </refsect1>
    <refsect1>
        <title>DATA TYPES</title>
        <para>
            The <classname>CHistogrammer</classname> methods use a number
            of data types.  These will be documented in full later in this
            part of the manual.  A brief overview of some of them is given here.
        </para>
        <para>
            Let's start with dictionaries.  The <filename>Dictionary.h</filename>
            is a templated class that wraps an <classname>std::map</classname>
            object that is indexed by a string.  The actual object contained
            by the map is templated.  The functionality added by
            <classname>Dictionaries</classname> is support for observation.
        </para>
        <para>
            Observation, or the observer pattern, is an object oriented
            programming pattern that allows external objects (observers)
            to be notified
            of state changes in another objecdt (the observed objecdt).
            <classname>Dictionary</classname> objects maintain a list of
            observers.  
        </para>
        <para>
            Each observer is an object from  class that is derived from
            <classname>DictionaryObserver</classname>.  This is, inn turn
            a templated class, templated by the type of object contained by
            the <classname>Dictionary</classname>  it observers.
        </para>
        <para>
            The observer base class provides an interface that looks like:
        </para>
        <programlisting>
template &lt;class T&gt;
class DictionaryObserver 
{
public:
  virtual void onAdd(std::string   name,   T&amp; item) {}
  virtual void onRemove( std::string name,    T&amp; item) {}

};            
        </programlisting>
        <para>
            Provided a do nothing implementation for each observer method
            allows useful observers to only implement the methods they care about.
        </para>
        <para>
            <methodname>onAdd</methodname> is called whenever <parameter>item</parameter>
            is added to the dictionary with the name <parameter>name</parameter>.
            This observer method is called after <parameter>item</parameter>
            has been successfullly added to the dictionary.
        </para>
        <para>
            <methodname>onRemove</methodname> is invoked whenever the
            <parameter>item</parameter> associated with <parameter>name</parameter>
            is removed from the dictionary.  It is called just prior to
            <parameter>item</parameter>'s erasure from the map.
        </para>
        <para>
            All observers form an ordered list and are called in the order in which
            they were registered.
        </para>
        <para>
            While we are talking about <classname>Dictionary</classname> observers,
            let's look as well at <classname>GatingObserver</classname> objects.
            These allow code to observer the application of gates to spectra
            and the ungating of a spectrum.  As such they don't actually
            fit well into the dictionary observers described.
        </para>
        <para>
            Here's the interface presented by a <classname>GatingOBserver</classname>:
        </para>
        <programlisting>
class CGatingObserver
{
public:
    virtual void onApply(const CGateContainer&amp; rGate, CSpectrum&amp; rSpectrum,
                         CHistogrammer&amp; rSorter) = 0;
    virtual void onRemove(const CGateContainer&amp; rGate, CSpectrum&amp; rSpectrum,
                          CHistogrammer&amp; rSorter) = 0;

};

        </programlisting>
        <para>
            As you can guess, <methodname>onApply</methodname> is invoked when
            <parameter>rGate</parameter> is applied to
            <parameter>rSpectrum</parameter>.  Similarly,
            <methodname>onRemove</methodname> is applied when
            <parameter>rSpectrum</parameter> is un-gated. In that case,
            <parameter>rGate</parameter> is the gate that used to be applied
            to that spectrum.  Note that in all cases,
            <parameter>rSorter</parameter> is a reference to the histogrammer
            object itself.
        </para>
        <para>
            Next let's look at the type of dictinoaries
            <classname>CHistogrammer</classname> maintains.  Each dictionary
            represents a name indexed store of one of the fundamental
            classes SpecTcl defines:
        </para>
        <variablelist>
            <varlistentry>
                <term><classname>ParameterDictionary</classname></term>
                <listitem>
                    <para>
                        The objects contained by this dictionary are
                        <classname>CParameter</classname> objects.
                        Note that
                        this class is a final class; no subclasses are defined.
                        The class supports copy construction allowing
                        <classname>ParameterDictionary</classname> to
                        contains <classname>CParameter</classname> objects rather
                        than pointers or references.
                    </para>
                    <para>
                        Once created  a <classname>CParameter</classname> object
                        is considered immutable.
                        See the <classname>CParameter</classname> reference
                        page for more information about that object.  Normal code,
                        however should strongly consider using
                        <classname>CTreeParameter</classname> and
                        <classname>CTreeParameterArray</classname> objects
                        as front ends to the <classname>CParameter</classname>
                        objects SpecTcl's guts use.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>SpectrumDictionary</classname></term>
                <listitem>
                    <para>
                        This dictionary contains pointers to
                        <classname>CSpectrum</classname> objects.  The
                        <classname>CSpectrum</classname> class is an
                        abstract base class for concrete classes that
                        implement the rich variety of spectra SpecTcl supports.
                    </para>
                    <para>
                        Therefore, spectrum objects must be created and then
                        added to the dictionary in a separate step.
                        
                    </para>
                    <para>
                        In parallel with the spectrum dictionary, SpecTcl maintains
                        data structures that facilitate parameter driven
                        histogramming.  Those structures are maintained using the
                        dictionary observer mechanism.  Their purpose is to restrict
                        the number of histograms that must be asked to increment
                        themselves for each event to those that depend on at least
                        one parameter present in that event.  For sparse events,
                        this results in significant performance improvements.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>CGateDictionary</classname></term>
                <listitem>
                    <para>
                        Contains pointers to <classname>CGateContainer</classname>
                        objects.  <classname>CGateContainer</classname> objects
                        are wrappers for pointers to <classname>CGate</classname>
                        objects.  When they were developed the various
                        pointer like objects in the standard C++ library had not
                        yet been defined and implemented.
                    </para>
                    <para>
                        A <classname>CGateContainer</classname> object is a fixed
                        object that can be handed to a user of a gate that is
                        invariant, although the gate it points to may vary with time.
                        If, for example, spectra contained a pointer to their gate,
                        each time the definition of that gate changed, the
                        value of that pointer would need to change too.
                        You can think of a <classname>CGateContainer</classname>
                        as a hidden pointer the gate pointer with methods that
                        allow it to look like the gate pointer itself.
                    </para>
                    <para>
                        By handing gated spectra a pointer to their gate's
                        <classname>CGateContainer</classname> object the
                        underlying gate pointer can be transparently modified
                        with respect to the gate clients.
                    </para>
                    <para>
                        <classname>CGate</classname> objects, which are what
                        <classname>CGateContainers</classname> appear to point at,
                        implement SpecTcl Gates.  <classname>CGate</classname>
                        is an abstract base class for the class hierarchy that
                        represents the rich set of gates SpecTcl defines.
                    </para>
                    <para>
                        See reference information  on gate classes and
                        the gate container for more information.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>Dictionaries</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>Dictionaries</refname>
        <refpurpose>Describe dictionaries used by SpecTcl</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;Dictionary.h&gt;
template &lt;class T&gt;
class DictionaryObserver 
{
public:
  virtual void onAdd(std::string   name,   T&amp; item) {}
  virtual void onRemove( std::string name,    T&amp; item) {}

};

template &lt;class T&gt;
class CDictionaryObserverManager 
{
  void addObserver(DictionaryObserver&lt;T&gt;* observer);
  void removeObserver(DictionaryObserver&lt;T&gt;* observer);
  void invokeAdd(const std::string name, T&amp; item);
  void invokeRemove(const std::string name, T&amp; item);

};

template &lt;class T&gt;
class CDictionary      
{
  DictionaryIterator Lookup(std::string sName);
  ConstDictionaryIterator Lookup(std::string sName);
  template&lt;class Predicate&gt;
    DictionaryIterator FindMatch(Predicate p);
  template&lt;class Predicate&gt;
    ConstDictionaryIterator FindMatch(Predicate p);
  void Enter(std::string sName, T&amp; Item);
  void Remove(std::string rsName);

  DictionaryIterator begin();
  ConstDictionaryIterator begin() const;
  DictionaryIterator end();
  ConstDictionaryIterator end() const ;

  UInt_t size() const;
  void addObserver(DictionaryObserver&lt;T&gt;* observer);
  void removeObserver(DictionaryObserver&lt;T&gt;* observer);
};

        </synopsis>
        <synopsis>
#include &lt;DictionaryException&gt;
class CDictionaryException  : public CException        
{
public:
  enum {
    knDuplicateKey,
    knDuplicateId,
    knNoSuchId,
    knNoSuchKey,
    knWrongGateType
  };
  
public:
  CDictionaryException(Int_t nReason, const char* pDoing, 
		       const char* pName);
  CDictionaryException(Int_t nReason, const char* pDoing, 
		       const std::string&amp; rName);
  CDictionaryException(Int_t nReason, const std::string&amp; rDoing,
		       const char* pName);
  CDictionaryException(Int_t nReason, const std::string&amp; rDoing,
		       const std::string&amp; rName);
  CDictionaryException(Int_t nReason, const char* pDoing,
		       UInt_t nId) ;
  CDictionaryException(Int_t nReason, const std::string&amp; rDoing,
		       UInt_t nId) ;

  virtual   const char* ReasonText ()  const;
  virtual   Int_t ReasonCode () const  ;
};

        </synopsis>
        <synopsis>
#include &lt;CFitDictionary.h&gt;
class CFitDictionary {
public:
  typedef std::map&lt;std::string, CSpectrumFit*&gt; FitMap;
  typedef FitMap::iterator      iterator;

  class CObserver {
  public:
    virtual void Add(CSpectrumFit&amp; fit) =0;
    virtual void Delete(CSpectrumFit&amp; fit) = 0;
    virtual void Update(CSpectrumFit&amp; fit) = 0;

  };

  typedef std::list&lt;CObserver*&gt; ObserverList;

  static CFitDictionary&amp; getInstance();

  void add(CSpectrumFit&amp; fit);
  void addOrReplace(CSpectrumFit&amp; fit);
  void Delete(std::string name);

  iterator begin();
  iterator end();
  size_t   size();
  iterator find(std::string name);
  void     erase(iterator here);
  void     erase(iterator first, iterator last);

  void updateFits(std::string name=std::string("*")); 

  void addObserver(CObserver&amp; obs);
  void removeObserver(CObserver&amp; obs);
 
};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This page describes SpecTcl dictionaries and their related classes.
        </para>
        <para>
            The <classname>CDictionary</classname> class is a templated
            class that associates names with arbitrary objects.  It adds to the
            <classname>std::map</classname> class the ability to maintain
            a set of <firstterm>observers</firstterm>.  Observers are objects
            that are informed of changes in the dictionary (specifically
            the addition and removal of items from the dictionary).
        </para>
        <para>
            Closely related to the <classname>CDictionary</classname> class,
            therefore are <classname>DictionaryObserver</classname>, the
            templated base class of observers.  Applications will subclass this
            and provide the appropriate template arguments for the dictionary
            used to make use of them.  Note that in most cases where SpecTcl
            uses a dictionary, it provides a typedef for the observer base class
            that already has provided the template parameters.
        </para>
        <para>
            <classname>CDictionaryObserverManager</classname> is actually
            usable by wrapers of any name/value container (e.g. hashes and
            multimaps).  It maintains a list of observer and provides
            methods to invoke the observers it maintains.
        </para>
        <para>
            The <classname>CDictionaryException</classname> class provides
            an exception derived from <classname>CException</classname>
            SpecTcl throws for many dictionary use violations.  These
            are not normally thrown by the dictionary itself but by SpecTcl
            code that provides a higher level API to specific dictionaries.
        </para>
        <para>
            For example, the <classname>CHistogrammer</classname> throws these
            if there is an attempt to duplicate the name or id of a dictionary
            entry.
        </para>
        <para>
            The <classname>CFitDictionary</classname> provides a dictionary
            that manages SpecTcl fit objects.  In addition, the observers
            maintained by fit dictionaries, contain a callback that is invoked
            if a fit is modified, as well as if it is added or removed
            from the dictionary.
        </para>
    </refsect1>
    <refsect1>
        <title>CDictionaryObserverManager</title>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>addObserver</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>DictionaryObserver&lt;T&gt;* </type>
                           <parameter>observer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds an <parameter>observer</parameter>
                        to the list of observers managed by
                        this object.  Observers are an ordered list.  The
                        new <parameter>observer</parameter> is added to the
                        end of the list.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>removeObserver</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>DictionaryObserver&lt;T&gt;* </type>
                           <parameter>observer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes an <parameter>observer</parameter> from the
                        list of observers managed by this object.  Note that
                        while it is pathalogical, it is legal to register
                        the same observer object more than once.  If
                        <methodname>removeObserver</methodname> is asked to
                        remove an observer that is multiply registered,
                        all instances of that observer are removed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>invokeAdd</methodname>
                        <methodparam>
                           <modifier>const </modifier>
                           <type>std::string </type>
                           <parameter>name</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>T&amp; </type>
                           <parameter>item</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Iterates over the list of observer objects this object
                        maintains.  For each observer, the
                        <methodname>onAdd</methodname> method is invoked
                        with the parameters passed to <methodname>invokeAdd</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>invokeRemove</methodname>
                        <methodparam>
                           <modifier>const </modifier>
                           <type>std::string </type>
                           <parameter>name</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>T&amp; </type>
                           <parameter>item</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Same as <methodname>invokeAddd</methodname>
                        but each object's <methodname>onRemove</methodname>
                        is called instead.
                    </para>
                </listitem>
            </varlistentry>
             
        </variablelist>
    </refsect1>
    <refsect1>
        <title>CDictionaryObserver</title>
        <para>
            Note that this is a base class.  Real observers are classes
            that inherit from this one.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>onAdd</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string  </type>
                           <parameter> name</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>T&amp; </type>
                           <parameter>item</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is invoked when an item is added to a
                        dictionary.  <parameter>name</parameter> is the name of
                        the item (dictionary key), <parameter>item</parameter>
                        refers to the item about to be added.  Note that
                        the base class implementation does nothing.  If you
                        don't need to observe dictionary additions simply don't
                        override this method.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>onRemove</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string</type>
                           <parameter> name</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>T&amp; </type>
                           <parameter>item</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is invoked when an item is about to be
                        removed from a dictionary.  <parameter>name</parameter>
                        is the name (dictionary index) of the item and
                        <parameter>item</parameter> refers to the item.
                    </para>
                    <para>
                        At the time this method is called, the item is still
                        in the dictionary.  The item is only removed from the
                        dictionary after all observers have been invoked.
                    </para>
                    <para>
                        The base class implementation is empty.  Therefore if your
                        observer does not need to observer dictionary
                        removals, simply don't override the implementation
                        of this method.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title>CDictionary</title>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>DictionaryIterator </type>
                        <methodname>Lookup</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string </type>
                           <parameter>sName</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>ConstDictionaryIterator </type>
                        <methodname>Lookup</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string </type>
                           <parameter>sName</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a <classname>DictionaryIterator</classname>
                        that points to a
                        <classname>std::pair&lt;std::string, T&gt;</classname>
                        object that has a name that is the same as
                        <parameter>sName</parameter>.  The first item of the
                        pair should be equal to <parameter>sName</parameter>
                        and is the name of the item in the dictionary.
                        The second item of the pair should be the item which is
                        associated with that key.
                    </para>
                    <para>
                        This method requires that <classname>T</classname>
                        have a copy constructor or be trivially copy constructable.
                        If there is no match for <parameter>sName</parameter>
                        in the dictionary, the value returned by
                        <methodname>end</methodname> is returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>template&lt;class Predicate&gt;</modifier>
                        <type>DictionaryIterator </type>
                        <methodname>FindMatch</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>Predicate</type>
                           <parameter> p</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier>template&lt;class Predicate&gt;</modifier>
                        <type>ConstDictionaryIterator </type>
                        <methodname>FindMatch</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>Predicate</type>
                           <parameter> p</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Performs an search using an arbitrary predicate;
                        <parameter>p</parameter> as the matching criterion.
                        The return value is a dictionary iterator as
                        described in <methodname>Lookup</methodname> above.
                    </para>
                    <para>
                        <parameter>p</parameter> is any class that implements
                        the <methodname>operator()</methodname> taking as a
                        single parameter a
                        <classname>std::pair&lt;std::string, T&gt;</classname>
                        object.  The first item of the pair is the name of some
                        entry in the dictionary.  The second is the entry with
                        that name.  The predicate must return a
                        value that can be converte to <type>bool</type>.  If
                        the return is <literal>true</literal>, the item
                        is treated as satisfying the match.  If not iteration
                        continues with different pairs until either the entire
                        container has been checked or a match is found.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>Enter</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string </type>
                           <parameter>sName</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>T&amp; </type>
                           <parameter>Item</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds <parameter>Item</parameter> to the dictionary indexed
                        by <parameter>sName</parameter>.  If an item already
                        exists with that name it's overwitten. If
                        <type>T</type> is a pointer to dynamically allocated
                        objets, this results in memory leaks unless the
                        dictionary is encapsulated by a derived class or front-ended
                        by an API.
                    </para>
                    <para>
                        Many SpecTcl dictionaries live privately in enclosing
                        classes like <classname>CHistogram</classname>.
                        In some cases (e.g. the parameter and spectrum
                        dictionaries), these classes impose an API that throws
                        errors if duplicate entries are attempted.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>Remove</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string </type>
                           <parameter>rsName</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes the entry whose index is
                        <parameter>rsName</parameter>.  This does nothing
                        if there is no entry with the index
                        <parameter>rsName</parameter>.
                    </para>
                    <para>
                        Many SpecTcl dictionaries are encapsulated by other classes.
                        In some cases those classes throw exceptions if attempts are
                        made to remove nonexistent objects.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>DictionaryIterator </type>
                        <methodname>begin</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>ConstDictionaryIterator </type>
                        <methodname>begin </methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>DictionaryIterator </type>
                        <methodname>end</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>ConstDictionaryIterator</type>
                        <methodname> end </methodname>
                        <void />
                        <modifier>const </modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        These methods support iteration over dictionary contents.
                        <classname>DictionaryIterator</classname> and
                        <classname>ConstDictionaryIterator</classname> are
                        pointer like objects.  They 'point' to
                        <classname>std::pair&lt;std::string, T&gt;</classname>
                        objects. The first item of the pair is a dictionary
                        key.  The second, the object stored at that key.
                    </para>
                    <para>
                        <methodname>begin</methodname> returns an iterator
                        to the first element of the container.  Currently,
                        this is the one with the  key that collates earliest.
                        Incrementing an iterator points it to another element
                        of the container.   Currently, the iterator traverses
                        the container in increasing collation order with respect
                        to the key.
                    </para>
                    <para>
                        If an iterator points to the last element of the
                        dict, incrementing it results in the same value
                        returned from the <methodname>end</methodname>
                        method.  The iterators returned by these methods
                        are compatible with the C++ standard library algorithms
                        that accept container iterators.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>UInt_t </type>
                        <methodname>size</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of elements stored in the dictionary.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>addObserver</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>DictionaryObserver&lt;T&gt;* </type>
                           <parameter>observer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>removeObserver</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>DictionaryObserver&lt;T&gt;* </type>
                           <parameter>observer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        These methods support observation of the dictionary.
                        <methodname>addObserver</methodname> adds an
                        <parameter>observer</parameter>
                        that will be called when items are added
                        or removed from the dictionary.  Observers have been
                        previously described.
                    </para>
                    <para>
                        <methodname>removeObserver</methodname> removes the
                        <parameter>observer</parameter> from the list of
                        observers that monitor the dictionary.
                        While it is pathalogical, <methodname>addObserver</methodname>
                        does not prevent you from adding the same observer object
                        more than once.  If have added a specific observer more
                        than onece, <methodname>removeObserver</methodname>
                        removes all instances of that observer from
                        the dictionary's <classname>CDictionaryObserverManager</classname>
                        object.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>              
        <programlisting>
             
        </programlisting>
    </refsect1>
    <refsect1>
        <title>CDictionaryException</title>
        <para>
            Before providing reference material to <classname>CDictionaryException</classname>,
            Let's first look at the public enum that provides the valid
            values for the reason code in the destructor:
        </para>
        <programlisting>
  enum {
    knDuplicateKey,
    knDuplicateId,
    knNoSuchId,
    knNoSuchKey,
    knWrongGateType
  };
            
        </programlisting>
        <para>
            Not all values are used by the APIs in front of all dictionaries.
            These values have the following meanings:
        </para>
        <variablelist>
            <varlistentry>
                <term><literal>knDuplicateKey</literal></term>
                <listitem>
                    <para>
                        An attempt was made to insert an entry with a key that
                        already exists in the dictionary.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>knDuplicateId</literal></term>
                <listitem>
                    <para>
                        For dictionaries whose entries have
                        unique integer ids
                        stored in their objects:  This value indicates an
                        attempt to add an entry that has an id that matches
                        an existing element of the dictionary.  For example;
                        Adding two parameters  with the same Id throws this error.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>knNoSuchId</literal></term>
                <listitem>
                    <para>
                        This reason is used after a search by id results in no
                        matching items.  Note that other dictionary APIs
                        may indicate without an error that there is no match
                        (e.g. returning a null pointer or an end iterator)
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>knNoSuchKey</literal></term>
                <listitem>
                    <para>
                        Similar to <literal>knNoSuchId</literal> this is thrown
                        when a search for an item by name fails to locate
                        a match.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>knWrongGateType</literal></term>
                <listitem>
                    <para>
                        This is not used in SpecTcl.  It is intended for use
                        when a gate of an incompatible type for some operation
                        is selected.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            <classname>CDictionaryException</classname> is essentially an
            <classname>CException</classname> class whose
            <methodname>ReasonText</methodname> and
            <methodname>ReasonCode</methodname> interpret the
            <parameter>nReason</parameter> code used to construct it as
            a member of the enum described above.
        </para>
        <para>
            The class has as rich set of constructors. For the most part
            these match the constructors available for
            <classname>CException</classname>.  The parameters
            <parameter>nReason</parameter> should be chosen from the
            reason enum described above.  The <parameter>pName</parameter>
            and <parameter>rName</parameter> parameters are names of items
            <parameter>nId</parameter> parameters are relevant object Ids.
        </para>
    </refsect1>
    <refsect1>
        <title>CFitDictionary></title>
        <para>
            <classname>CFitDictionary</classname> is a specialized dictionary
            that holds fits.  It also provides an extended observer as
            a nested class; <classname>CFitDictionary::CObserver</classname>.
            The observer base class for fit dictionaries have the following
            pure virtual methods.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>Add</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CSpectrumFit&amp; </type>
                           <parameter>fit</parameter>
                        </methodparam>
                        <modifier>=0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when a fit is added to the dictionary.  <parameter>fit</parameter>
                        is the object that was added.  Note that this object
                        provides the needed methods to get the name of the
                        fit as well as the  name of the spectrum on which the
                        fit is defined.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>Delete</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CSpectrumFit&amp; </type>
                           <parameter>fit</parameter>
                        </methodparam>
                        <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when a fit is deleted (removed from the
                        dictionary).  This is called prior to the actual
                        removal of the <parameter>fit</parameter> from
                        the dictionary.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>Update(</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CSpectrumFit&amp; </type>
                           <parameter>fit</parameter>
                        </methodparam>
                        <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when a fit is updated.  Updating a fit means
                        that its parameters are recomputed based on the current
                        data in  a spectrum.  If a
                        <parameter>fit</parameter> was created and then
                        additional or new data were acquired, updating the
                        fit is necessary to make the fit reflect the new
                        channel values in the region of interest.
                    </para>
                    <para>
                        This method is called just after the update has been
                        computed.  One use is to maintain the display of a fit
                        on a spectrum by a displayer.
                    </para>
                </listitem>
            </varlistentry>
    
    
        </variablelist>
        <para>
            Note that the fit dictionary is also a singleton class and therefore
            has private constructors and destructors.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>CFitDictionary&amp; </type>
                        <methodname>getInstance</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the singleton instance of this class.  If the
                        dictionary has not yet been created, this will create it.
                        If it has, a reference to the existing dictionary
                        is returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>add</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CSpectrumFit&amp; </type>
                           <parameter>fit</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a new fit to the dictionary.  Note that if the
                        dictionary already has a fit named the same as
                        <parameter>fit</parameter>, a
                        <classname>CDictionaryException</classname> is thrown
                        with the reason
                        <literal>CDictionaryException::knDuplicateKey</literal>.
                    </para>
                    <para>
                        See <methodname>addOrReplace</methodname> below as well.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>addOrReplace</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CSpectrumFit&amp; </type>
                           <parameter>fit</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds <parameter>fit</parameter> to the dictionary.  If
                        a fit with that name already exists it is replaced
                        by this new fit.  In that case observer
                        <methodname>Delete</methodname> methods are called.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>Delete</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string </type>
                           <parameter>name</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Delets any fit with the name
                        <parameter>name</parameter>.  If there is no such
                        fit, <classname>CDictionaryException</classname>
                        with the reason
                        <literal>CDictionaryException::knNoSuchkey</literal>
                        is thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>iterator</type>
                        <methodname> begin</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>    
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>iterator </type>
                        <methodname>end</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
  

                <listitem>
                    <para>
                        These methods support iteration over the container
                        that holds the fit dictionary.
                        <classname>CFitDictionary::iterator</classname>
                        is an pointer like object that points at
                        <classname>std::pair&lt;std::string, CSpectrumFit*&gt;</classname>
                        objects.  The first element of the pair is the name of the
                        fit while the second is  a pointer to the fit object.
                    </para>
                    <para>
                        <methodname>begin</methodname> returns an iterator that
                        points to the first element of the dictionary.  Incrementing
                        an iterator results in an interator that points at the next
                        element of the dictionary.  If the iterator points to
                        the last element of the dictionary, incrementing it
                        produces the value returned by
                        <methodname>end</methodname>
                    </para>
                    <para>
                        These iterators are suitable for use in any of the
                        C++ standard library algorithms that require iterators.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>size_t   </type>
                        <methodname>size</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of elements in the dictionary.
                    </para>
                </listitem>
            </varlistentry>
        
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>iterator </type>
                        <methodname>find</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string</type>
                           <parameter> name</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an iterator to the dictionary entry
                        pair with the index <parameter>name</parameter>.
                        If <parameter>name</parameter> is not found,
                        the value returned from
                        <methodname>end</methodname> is returned:
                    </para>
                    <programlisting>
CFitDictionary&amp; fitDict(CFitDictionary::getInstance());

CFitDictionary::iterator p = fitDict->find("foo");
if (p != fitDict.end()) {

std::string name = p-&gt;first;
CSpectrumFit* fit = p-&gt;second;

// Do something with what was found.
} else {
j  // Item was not found.
}
                    </programlisting>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void     </type>
                        <methodname>erase</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>iterator </type>
                           <parameter>here</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void     </type>
                        <methodname>erase</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>iterator </type>
                           <parameter>first</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>iterator </type>
                           <parameter>last</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes items from the dictionary based on iterators.
                        <parameter>here</parameter> is an iterator that points to
                        the item to remove> <parameter>first</parameter> and
                        <parameter>last</parameter> are iterators that define a
                        range of items to remove.  All items from <parameter>first</parameter>
                        up to but not including <parameter>last</parameter>
                        are removed.
                    </para>
                    <para>
                        Note that <methodname>erase</methodname> invalidates
                        the iterator(s) it receives as parameters.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>updateFits</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string </type>
                           <parameter>name</parameter>
                           <initializer>std::string("*")</initializer>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Recomputes fits with current spectrum data for all
                        fit names that match the glob pattter
                        <parameter>name</parameter>.  Note that the default
                        value for this parameter, <literal>*</literal>,
                        matches all fits.
                    </para>
                    <para>
                        Fits are defined on regions of interest in spectra.
                        As spectra accumulate or are cleared and a new data
                        set analyzed, they can be recomputed on the current data.
                        SpecTcl establishes observers that propagate the changes
                        to the fit information to its displayers so that the fitlines
                        displayed on those spectra also automatically update.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>addObserver</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CObserver&amp;</type>
                           <parameter>obs</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>removeObserver</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CObserver&amp; </type>
                           <parameter>obs</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        These methods manage observers that are monitoring
                        the fit dictionary.   <methodname>addObserver</methodname>
                        adds the observer <parameter>obs</parameter> to end of the
                        list of observers.  <methodname>removeObserver</methodname>
                        removes all instances of <parameter>ojbs</parameter> from
                        the list of observers maintained by the dictionary.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CAnalyzer</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CAnalyzer</refname>
        <refpurpose>Analyzer base class and classic analyzer</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;Analyzer.h&gt;

class CAnalyzer
{
public:
  virtual void OnBuffer(UInt_t nBytes, Address_t pData);
  virtual void OnStateChange(UInt_t nType, CBufferDecoder&amp; rDecoder);
  virtual void OnPhysics(CBufferDecoder&amp; rDecoder);
  virtual void OnScaler(CBufferDecoder&amp; rDecoder);
  virtual void OnOther(UInt_t nType, CBufferDecoder&amp; rDecoder);
  virtual void OnEndFile();
  virtual void OnInitialize();

  CEventList&amp; getEventList();
  CBufferDecoder* getDecoder() ;
  CEventSink* getSink() ;

  CBufferDecoder* AttachDecoder(CBufferDecoder&amp; rDecoder);
  CBufferDecoder* DetachDecoder();
  CEventSink*     AttachSink(CEventSink&amp; rSink);
  CEventSink*     DetachSink();
  void            entityNotDone();

  
protected:
  virtual UInt_t OnEvent(Address_t pRawData, CEvent&amp; anEvent);

  void           AbortEvent();

  void CopyEventList(const CEventList&amp; rhs);
  void CopyEventPool(const CEventList&amp; rhs);
  void DetachAll();
  CEvent* CreateEvent();
  void ReturnEvent(CEvent* pEvent);
  void ClearEventList();
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This class is currently used as the base class for the
            <classname>CTclAnalyzer</classname> class used as the analyzer
            in modern SpecTcl.  In the original SpecTcl version, this
            <emphasis>was</emphasis>
            the analyzer. 
        </para>
    </refsect1>
    <refsect1>
        <title>PUBLIC METHODS</title>
        <para>
            The public interfaces to <classname>CAnalyzer</classname>
            come in groups.  The first group defines the interface to the
            analyzer used when handling data from an event source.  New analyzers
            (such as <classname>CTclAnalyzer</classname>) can be built
            by deriving a new class from these and overriding the
            desired methods.
        </para>
        <para>
            The second group of methods are public utilities.  These
            provide methods that are related to the configuration of the
            analyzer.  External entities may also call them but they
            are not, strictly speaking, behavioral methods.
        </para>
        <para>
            Let's look at the set of virtual public  methods that implement
            the behavior of the analyzer first.  Note that 
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnBuffer</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>nBytes</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Address_t </type>
                           <parameter>pData</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is invoked by the event input subsystem
                        when a block of data is available on the data source.
                        It will typically pass the block to the
                        buffer decoder.  The buffer decoder will locate
                        items within the block and make appropriate calls
                        back to the analyzer to analyze those items.
                    </para>
                    <para>
                        <parameter>nBytes</parameter> are the number
                        of bytes of data in the block pointed to by
                        <parameter>pData</parameter>.
                    </para>
                    <para>
                        Typically derived classes don't need to override this
                        method or at least can call it as part of their
                        override.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnStateChange</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>nType</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>CBufferDecoder&amp; </type>
                           <parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called by the buffer decoder when a state change item
                        has been detected in the data block it was passed
                        by <parameter>OnBuffer</parameter>.  State change
                        items indicate that a run has changed state.
                    </para>
                    <para>
                        <parameter>nType</parameter> is the item type from
                        <filename>bufftypes.h</filename>.  It should normally
                        be one of the following values.
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term><literal>BEGRUNBF</literal></term>
                            <listitem>
                                <para>
                                    The state change indicates the beginning
                                    of a new run.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <literal>ENDRUNBF</literal>
                            </term>
                            <listitem>
                                <para>
                                    The state change indicates the end of the
                                    active run
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>PAUSEBF</literal></term>
                            <listitem>
                                <para>
                                    The state change indicates a pause in data taking.
                                    Note that it is perfectly legal for this to be
                                    immediately followed by an end of run.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>RESUMEBF</literal></term>
                            <listitem>
                                <para>
                                    The state change indicates a paused run
                                    is being resumed.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                    <para>
                        <parameter>rDecoder</parameter>, on the other hand
                        refers to the buffer decoder that is calling this method.
                        This is provided because the buffer decoder may have
                        stashed items from the run state method that can be
                        retrieved via some of its methods.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type> void </type>
                        <methodname>OnPhysics</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CBufferDecoder&amp; </type>
                           <parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when one or more physics events is received.
                        <parameter>rDecoder</parameter> is a reference to the
                        decoder that called us.
                    </para>
                    <para>
                        Looking at this method you might rightfully wonder
                        where the data is hiding.  The answer is that
                        the decoder; <parameter>rDecoder</parameter>
                        has methods that can be used to get several pieces of
                        information:
                    </para>
                    <itemizedlist>
                        <listitem>
                            <para>
                                The number of physics events being made available.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                The number of bytes of data required to store
                                these events.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                A pointer to the first of those events.
                            </para>
                        </listitem>
                    </itemizedlist>
                    <para>
                        Note that the buffer decoder is not responsible for
                        telling you where the boundaries between events are.
                        That's the responsibility of the event processor.
                        Pushing that responsibility off to the event processor
                        allows for the possibility that the DAQ system might
                        be able to produce <firstterm>superevents</firstterm>, that
                        is events that actually contain more than one single
                        SpecTcl event.
                    </para>
                    <para>
                        The base class method calls the
                        <methodname>OnEvent</methodname> method for each
                        event in the run of events.  
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type> void </type>
                        <methodname>OnScaler</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CBufferDecoder&amp; </type>
                           <parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called if the buffer decoder locates a scaler event.
                        In this case, the buffer decoder is supposed to supply
                        the number of scalers and a pointer to the body of the
                        scaler item.  The shape of a scaler item varies depending
                        on the data acquisition system that created it.
                        This implies that specialized user software is required
                        to process scalers.
                    </para>
                    <para>
                        If old versions of SpecTcl were used, the analysis of
                        scaler data would have required subclassing
                        <classname>CAnalyzer</classname> with a class that
                        understood the specific scaler format and replacing
                        the standard analyzer with an instance of this subclass.
                        With current versions of SpecTcl, the understanding of
                        scaler data is handled by the event processor.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type> void </type>
                        <methodname>OnOther</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>nType</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>CBufferDecoder&amp; </type>
                           <parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when the decoder finds items in a buffer that
                        don't fit into the catagories handled by the other
                        types.  <parameter>nType</parameter> should be an
                        item type from <filename>buftypes.h</filename>.
                        for example <literal>STATEVARBF</literal> for an item
                        containing state variables. <parameter>rDecoder</parameter>,
                        once more, is a reference to the decoder object.
                    </para> 
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnEndFile</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when by the input handlers when an end file has
                        been detected on the event source.    At present this
                        invokes the decoder's <methodname>OnEnd</methodname>
                        giving it a chance to flush out any unprocessed items.
                        Unprocessed items can result from data sources that don't
                        produce fixed size blocks of data (e.g. NSCLDAQ-10.x and later).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnInitialize</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called after SpecTcl is fully initialized and
                        is about to start processing commands.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            Now let's look at the methods that are not functional in  nature.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventList&amp; </type>
                        <methodname>getEventList</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        SpecTcl's event processing builds lists of
                        <classname>CEvent</classname> objects produced
                        by the <methodname>OnPhysics</methodname> method.
                        When the event list has been sufficiently filled,
                        the event sink is called to, among other things
                        histogram the event.
                    </para>
                    <para>
                        This method returns a reference to the list of events
                        that have not yet been processed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodsynopsis>
                    <modifier></modifier>
                    <type>CBufferDecoder* </type>
                    <methodname>getDecoder</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis></term>
                <listitem>
                    <para>
                        Returns a pointer to the analyzer's current buffer
                        decoder.  
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventSink* </type>
                        <methodname>getSink</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the event sink.  When this
                        analyzer is used (usually not), this should
                        return the histogrammer object. This analyzer does
                        not pipeline the event sink, holding filters as
                        a separate set of objects (another reason to use
                        <classname>CTCLAnalyzer</classname>.
                    </para>
                    
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CBufferDecoder* </type>
                        <methodname>AttachDecoder</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CBufferDecoder&amp; </type>
                           <parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Attach a new buffer decoder to the analyzer.
                        If there is already a buffer decoder its
                        <methodname>OnDetach</methodname> method is invoked.
                        <parameter>rDecoder</parameter>'s
                        <methodname>OnAttach</methodname> is invoked.
                    </para>
                    <para>
                        The return value is a pointer to the previous buffer
                        decoder (NULL if there is none).  It is the
                        responsibility of the caller to <literal>delete</literal>
                        this decoder if it was dynamically allocated.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CBufferDecoder* </type>
                        <methodname>DetachDecoder</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Detaches the current buffer decoder from the
                        analyzer.  The current buffer decoder, if any
                        will have its <methodname>OnDetach</methodname>
                        method invoked.  A pointer to that decoder
                        will be returned.
                    </para>
                    <para>
                        If there was no current buffer decoder, a null pointer
                        is returned.  If the buffer decoder returned was
                        dynamically allocated its up to the caller to
                        <literal>delete</literal> it.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventSink*     </type>
                        <methodname>AttachSink</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CEventSink&amp; </type>
                           <parameter>rSink</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Replaces the current event sink (normall the histogrammer)
                        with <parameter>rSink</parameter>.  If there's a
                        prior event sink its <methodname>OnDetach</methodname>
                        is called.  <parameter>rSink</parameter>'s
                        <methodname>OnAttach</methodname> method is called.
                    </para>
                    <para>
                        A pointer to the previous event sink is returned.
                        If there is none, a null pointer is returned.
                        If the previous event sink was dynamically created the
                        caller must <literal>delete</literal> it.
                    </para>
                    <para>
                        Since most SpecTcls use a <classname>CTCLAnalyzer</classname>,
                        which supports a pipeline of event sinks, there's
                        not a reason to call this in a modern SpecTcl.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventSink*     </type>
                        <methodname>DetachSink</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Detaches the current event sink from the analyzer.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>entityNotDone</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This can be called from an event processor handling
                        physics events.  When that event processor returns,
                        the pointer will advance through the buffer, but
                        the remaining entity count won't be decremented.
                    </para>
                    <para>
                        The intent of this method is to provide support for
                        <firstterm>superevent</firstterm>.  A superevent
                        is an entity that appears to the buffer decoder like
                        a single event, but actually contains several
                        events.
                    </para>
                    <para>
                        This has been used for high performance singles experiments,
                        when muli-event ADC's are used.   In those experiments,
                        the ADC's were allowed to use VME interrupts to signal
                        they had some number of events to readout.  The
                        ADCs were then drained completely for each of these
                        'triggers'.  The result was an event from the standpoint
                        of NSCLDAQ which contained several singles events.
                    </para>
                </listitem>
            </varlistentry>
          
        </variablelist>
    </refsect1>
    <refsect1>
        <title>PROTECTED METHODS</title>
        <para>
            These methods are used by derived classes.  They provide services
            as well as a behavioral method (<methodname>OnEvent</methodname>).
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type> UInt_t </type>
                        <methodname>OnEvent</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>Address_t </type>
                           <parameter>pRawData</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>CEvent&amp; </type>
                           <parameter>anEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called by the anaylzer for each event.
                        <parameter>pRawData</parameter> is a pointer to the
                        event body while <parameter>anEvent</parameter> is
                        the <classname>CEvent</classname> 'array' this method
                        should fill in.  The  method must return the
                        number of bytes processed.
                    </para>
                    <para>
                        This version <classname>CAnalyzer</classname> base class
                        is used by creating a derived class that implements an
                        appropriate <methodname>OnEvent</methodname> method and
                        registering an instance of the derived class as the
                        analyzer.  Modern SpecTcl's, register a
                        <classname>CTCLAnalyzer</classname> instance which
                        implements an <methodname>OnEvent</methodname> method
                        that executes an event processing pipeline instead.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void  </type>
                        <methodname>AbortEvent</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called frrom <methodname>OnEvent</methodname> to prevent
                        an  event from being histogrammed.  This can be called
                        either as a software trigger on the event or, if a
                        structural problem was detected with the event that makes
                        the data untrustworthy.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void CopyEventList</type>
                        <methodname></methodname>
                        <methodparam>
                           <modifier>const </modifier>
                           <type>CEventList&amp; </type>
                           <parameter>rhs</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        The event list are the set of events that have been
                        unpacked by <methodname>OnPhysics</methodname> but not yet
                        passed to the event sink.  This method makes a copy of
                        the event list into <parameter>rhs</parameter>.
                    </para>
                    <para>
                        This is primarily used by the assignment operator and
                        copy constructor.  In other words, if you find yourself
                        using this method, you're probably doing something
                        very odd.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>CopyEventPool</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>const CEventList&amp; </type>
                           <parameter>rhs</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        When <classname>CEvent</classname> objects have
                        been analyzed by the event sink, they are
                        invalidated and returned to an
                        <firstterm>event pool</firstterm>.  This allows them
                        to be recycled, removing the overhead of deletion and
                        re-creation (an event serial is used so that the
                        invalidation is short constant time as well).
                    </para>
                    <para>
                        This method copies the contents of the current
                        event pool to the <parameter>rhs</parameter>.
                        This method is used by the assignment operator and
                        copy constructor.  If you find yourself using this
                        method for other purposes, you're probably doing something
                        odd.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void</type>
                        <methodname> DetachAll</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Detaches both  the event sink and the buffer decoder.
                        Note that this will leak memory if either of those
                        objects was dynamically created.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEvent* </type>
                        <methodname>CreateEvent</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Provides a new invalidated event. Invalidated, in this
                        context means any parameters in the array have not
                        yet been assigned a value.
                    </para>
                    <para>
                        If there are entries in the event pool, on eis removed
                        and a pointer to it is returned.  If not, <literal>new</literal>
                        is used to create a new event.  
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>ReturnEvent</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CEvent* </type>
                           <parameter>pEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Puts the event pointed to by <parameter>pEvent</parameter>
                        back into the event pool.  Normally the event is
                        invalidated first.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>ClearEventList</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        All events in the eventl ist are put into the event pool.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CTclAnalyzer</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTclAnalyzer</refname>
        <refpurpose>Analyzer integrated with Tcl supporting pipeline</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;TCLAnalyzer.h&gt;

class CTclAnalyzer {
public:
  typedef std::pair&lt;std::string, CEventProcessor*&gt; PipelineElement;
  typedef std::list&lt;PipelineElement&gt; EventProcessingPipeline;
  typedef EventProcessingPipeline::iterator EventProcessorIterator;
  typedef std::vector&lt;CTCLVariable*&gt;  VariableArray;
  
public:
  CTclAnalyzer(CTCLInterpreter&amp; rInterp, UInt_t nP, UInt_t nBunch);
  CTCLInterpreter* getInterpreter();
  
  virtual void OnStateChange(UInt_t nType, CBufferDecoder&amp; rDecoder);
  virtual void OnPhysics(CBufferDecoder&amp; rDecoder);
  virtual void OnOther(UInt_t nType, CBufferDecoder&amp; rDecoder);
  virtual void OnScaler(CBufferDecoder&amp; rDecoder);
  virtual void OnEndFile();
  
  virtual void OnBegin(CBufferDecoder* rDecoder);
  virtual void OnEnd(CBufferDecoder*   rDecoder);
  virtual void OnPause(CBufferDecoder* rDecoder);
  virtual void OnResume(CBufferDecoder* rDecoder);
  virtual void OnInitialize();

  void AddEventProcessor(CEventProcessor&amp; rProcessor,
			 const char* pName = 0); // Append to pipe.
  EventProcessorIterator FindEventProcessor(std::string name);
  EventProcessorIterator FindEventProcessor(CEventProcessor&amp; processor);
  void InsertEventProcessor(CEventProcessor&amp; processor, 
			    EventProcessorIterator here, 
			    const char* name = 0);
  CEventProcessor* RemoveEventProcessor(std::string name);
  CEventProcessor* RemoveEventProcessor(EventProcessorIterator here);
  UInt_t size();
  EventProcessorIterator begin();
  EventProcessorIterator end();

  void IncrementCounter(Counter eSelect, UInt_t incr = 1);
  void ClearCounter(Counter eSelect);

  void SetEventSize(UInt_t nSize);
  void IncrementEventSize(UInt_t nIncr=2) ;
  UInt_t GetEventSize() ;
  
};
enum Counter {
  RunsAnalyzed          = 0,
  EventsAnalyzed        = 1,
  EventsAnalyzedThisRun = 2,
  EventsAccepted        = 3,
  EventsAcceptedThisRun = 4,
  EventsRejected        = 5,
  EventsRejectedThisRun = 6
};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
             The <classname>CTclAnalyzer</classname> class is a SpecTcl analyzer
             that extends the base class by:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Maintaining statistical counters that can be retrieved from
                    Tcl
                </para>
            </listitem>
            <listitem>
                <para>
                    Supporting a list of event processors, rather than a single
                    one.  The list is called the
                    <firstterm>Event processing pipeline</firstterm>. 
                </para>
            </listitem>
        </itemizedlist>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CTclAnalyzer</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CTCLInterpreter&amp; </type>
                           <parameter>rInterp</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>nP</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>nBunch</parameter>
                        </methodparam>
                    </constructorsynopsis>
   
                </term>
                <listitem>
                    <para>
                        The constructor sets up several variables that
                        are defined in 
                        <parameter>rInterp</parameter>.  This interpreter
                        should be the SpecTcl command interpreter so that these
                        variables will be visible to commands executed by SpecTcl.
                    </para>
                    <para>
                        <parameter>nP</parameter> is the initial number of parameters
                        for each <classname>CEvent</classname> object
                        constructed by the base class.  Since these objects are
                        recycled from event to event, the value of this
                        has no effect on performance.
                        <parameter>nBunch</parameter> is the size of the bunch
                        of events that will be accumulated before invoking the
                        event sink pipeline.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CTCLInterpreter* </type>
                        <methodname>getInterpreter</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the interpreter in which this analyzer
                        maintains its statistics variables.  Normally, this is
                        the SpecTcl command processing interpreter.  
                    </para>
                    <para>
                        Note that the return value is a pointer to a
                        <classname>CTCLInterpreter</classname> object.  The
                        reference documentation on the Tcl++ library describes
                        this and related classes.  The
                        <link linkend='manpage.CTCLInterpreter'
                              endterm='manpage.CTCLInterpreter.title' /> manpage
                              provides details about this specific claass.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnStateChange</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>nType</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>CBufferDecoder&amp; </type>
                           <parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Overrides the base class's method that processes
                        state change operations.  After calling the base
                        class's <methodname>OnStateChange</methodname> method,
                        this method fans out
                        the state change processing for the following
                        item types:
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term><literal>BEGRUNBF</literal></term>
                            <listitem>
                                <para>
                                    Invokes <methodname>OnBegin</methodname>
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>ENDRUNBF</literal></term>
                            <listitem>
                                <para>
                                    Invokes
                                    <methodname>OnEnd</methodname>.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>PAUSEBF</literal></term>
                            <listitem>
                                <para>
                                    Invokes <methodname>OnPause</methodname>
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>RESUMEBF</literal></term>
                            <listitem>
                                <para>
                                    Invokes <methodname>OnResume</methodname>
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnPhysics</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CBufferDecoder&amp; </type>
                           <parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier>

                        </modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        After invoking the base class <methodname>OnPhysics</methodname>
                        method, increments statistics variables that
                        indicate the number of items analyzed and the
                        sequence number of the last item analyzed. For
                        NSCLDAQ-8.x and earlier, the decoder gets the
                        sequence number from the buffer header.  For
                        NSCLDAQ-10.0 and later, this sequence number is
                        number of triggers from the most recently seen
                        <literal>PHYSICS_EVENT_COUNT</literal> item.
                    </para>
                    <para>
                        Note that no effort is made to actually analyze the
                        data in this method.  The Tcl analyzer establishes
                        an event processor for the base class that contains
                        an ordered list of event processors.   When the
                        base class <methodname>OnPhysics</methodname>
                        method
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnOther</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>nType</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type> CBufferDecoder&amp; </type>
                           <parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Iterates over the event processors in the
                        event processing pipeline invoking their
                        <methodname>OnOther</methodname> methods.
                        If an event processor returns a false value
                        (<literal>kfFALSE</literal>), iteration is aborted
                        after that stage of the pipeline.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnScaler</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CBufferDecoder&amp; </type>
                           <parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when a scaler item is received.  This
                        invokes <methodname>OnOther</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnEndFile</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when an end file is encountered on a data source.
                        For file data sources this happens when there's no
                        more data in the file.  For pipe data sources this
                        happens when the program feeding the pipeline
                        exits.
                    </para>
                    <para>
                        The event processors in the pipeline are iterated
                        calling <methodname>OnEventSourcEOF</methodname>.
                        If one of the event processors returns
                        false, event processor pipeline processing is terminated.
                    </para>
                    <para>
                        Regardless, the <varname>RunState</varname> Tcl variable
                        is set to <literal>Halted</literal> indicating that
                        SpecTcl is no longer processing event data. 
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnEnd</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CBufferDecoder*   </type>
                           <parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when an end run item is encounterd.  Sets the
                        <varname>RunState</varname> variable to
                        <literal>Halted</literal> indicating analysis is no longer
                        active and then calls the <methodname>OnEnd</methodname>
                        method of each event processor in the event processing
                        pipeline.
                    </para>
                    <para>
                        If an event processor returns false, no more event
                        processors will be called.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnPause</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CBufferDecoder* </type>
                           <parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>                  
                </term>
                <listitem>
                    <para>
                        Called when a pause run item is received. The
                        <varname>RunState</varname> variable is set to
                        <literal>Paused</literal> and the
                        <methodname>OnPause</methodname> method is
                        called for each element of the event processing pipeline.
                    </para>
                    <para>
                        If an event processing pipeline element returns
                        false, no futher event processors are called.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnResume</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CBufferDecoder* </type>
                           <parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when a resume item is received.  The
                        <varname>RunState</varname> variable is set to
                        <literal>Active</literal> indicating data is being
                        analyzed.  The 
                        <methodname>OnResume</methodname> method is invoked
                        for each element of the event processing pipeline.
                        If an element  of the pipeline returns false,
                        no more event processors are invoked.
                    </para>
                    <para>
                        Note that when analyzing a file data source, the
                        <varname>RunState</varname> variable will flip quickly
                        between <literal>Paused</literal> and
                        <literal>Active</literal> for a run that is paused and
                        resumed.  For a pipe data source connected to live data,
                        however, this variable will remain in the
                        <literal>Paused</literal> state until the user
                        resumes the run.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                    <modifier>virtual </modifier>
                    <type>void </type>
                    <methodname>OnInitialize</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called after SpecTcl's initialization is complete.
                        The <methodname>OnInitialize</methodname> method
                        of each element of the event processign pipeline is
                        called.  If any element returns false, no more elements
                        are called.
                    </para>
                    <para>
                        This is intended for use when initialization requires
                        knowing that all of SpeTcl's services are available.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void</type>
                        <methodname> AddEventProcessor</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CEventProcessor&amp; </type>
                           <parameter>rProcessor</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier>const </modifier>
                           <type>char* </type>
                           <parameter>pName</parameter><initializer> 0</initializer>
                        </methodparam>
			 
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds <parameter>rProcessor</parameter> as to the
                        end of the event processing pipeline.  The object
                        must be live as long as it is in the event processing
                        pipeline.
                    </para>
                    <para>
                        If provided, <parameter>pName</parameter> is used to name
                        the event processor.  If this is not provided, a unique
                        name of the form <literal>Anonymous::</literal><replaceable>number</replaceable>
                        is assigned where <replaceable>number</replaceable>
                        is a sequentially assigned integer number.
                    </para>
                </listitem>
            </varlistentry>          
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>EventProcessorIterator </type>
                        <methodname>FindEventProcessor</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string </type>
                           <parameter>name</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an iterator to the element of the event processing
                        pipeline that has the name <parameter>name</parameter>.
                        If no such element exists, the value returned is the
                        same as that returned from
                        <methodname>end</methodname>.
                    </para>
                    <para>
                        Event processor iterators can be treated as if they
                        were pointers to an
                        <classname>std::pair&lt;std::string, CEventProcessor*&gt;</classname>.
                        The first element of the pair is the name of an event processor.
                        The second, a pointer to the event processor itself.
                    </para>
                    <para>
                        Incrementing an iterator points it to the next pipeline
                        element.  Incrementing the iterator when it points to the
                        last element of the pipeline returns
                        the same value as that returned from
                        <methodname>end</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>EventProcessorIterator </type>
                        <methodname>FindEventProcessor</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CEventProcessor&amp; </type>
                           <parameter>processor</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Locates an event processor given a reference to it.
                        The use case for this is to delete an anonymous event
                        processor from the eventprocessing pipeline.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>InsertEventProcessor</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CEventProcessor&amp;</type>
                           <parameter> processor</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>EventProcessorIterator </type>
                           <parameter>here</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier>const</modifier>
                           <type> char* </type>
                           <parameter>name</parameter><initializer>0</initializer>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Provides the ability to insert an event processor anywhere
                        in the event processing pipeline.  The event processor
                        is inserted just prior  to the item pointed to by
                        <parameter>here</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventProcessor* </type>
                        <methodname>RemoveEventProcessor</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>std::string</type>
                           <parameter> name</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes the named event processor
                        <parameter>name</parameter>.    The return value
                        is a pointer to the event processor removed from
                        the list.  No steps are taken to destroy that processor so
                        if it has been dynamically created with <literal>new</literal>
                        it must be destroyed with <literal>delete</literal>
                    </para>
                    <para>
                        If there is no event processor in the event processing
                        pipeline, the return value is a null pointer. It is up
                        to the caller to decide if this represents an error.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventProcessor* </type>
                        <methodname>RemoveEventProcessor</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>EventProcessorIterator</type>
                           <parameter> here</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes the event processor pointed to by the iterator
                        <parameter>here</parameter>.  The return value is
                        a pointer to the event processor that was removed.
                        It is up to the caller to destroy that event processor,
                        if desired.
                    </para>
                    <para>
                        Note this method invalidates the iterator <parameter>here</parameter>.
                        Destruction and assignment become the only operatiosn with
                        defined meaning.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>UInt_t </type>
                        <methodname>size</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of elements in the event procesing
                        pipeline.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>EventProcessorIterator </type>
                        <methodname>begin</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an iterator that points to the first element of
                        the event processing pipeline. See
                        <methodname>find</methodname> above for a description of
                        <classname>EventProcessorIterator</classname> objects.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>EventProcessorIterator </type>
                        <methodname>end</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an end of iteration iterator.  This is the value of
                        the iterator that results from incrementing an iterator
                        that points to the last <classname>PipelineElement</classname>
                    </para>
                    <para>
                        Here is sample code that might list the names of all
                        event processors:
                    </para>
                    <programlisting>
CAnalyzer* pA;
...                       // Assume pA got set to point at the analyzer:

for (auto p = pA->begin(), p != pA->end(); p++) {
    std::cout &lt;&lt; p-&gt;first &lt;&lt; std::endl;
}
                    </programlisting>
                    <para>
                        The code above is intended just to show a typical use of
                        <methodname>begin</methodname> and
                        <methodname>end</methodname> to iterate over the entire
                        event processing pipeline.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                     <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>IncrementCounter</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>Counter </type>
                           <parameter>eSelect</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>incr </parameter>
                           <initializer>1</initializer>
                        </methodparam>
                        <modifier></modifier>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Increments one of the Tcl statistics counters
                        maintained by this object.  <parameter>eSelect</parameter>
                        selects which counter to increment.  It is described
                        in <literal>DATA TYPES</literal> below.  
                    </para>
                    <para>
                        Unless <parameter>incr</parameter> is supplied, the
                        counter is incremented by <literal>1</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>ClearCounter</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>Counter </type>
                           <parameter>eSelect</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Clears the counter selected by
                        <parameter>eSelect</parameter>.  This values this
                        enumerated parameter can have are described
                        in <literal>DATA TYPES</literal> below.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>SetEventSize</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>nSize</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        At least one event processor must invoke this.
                        The event size in bytes is set to be <parameter>nSize</parameter>.
                        This is used to determine where the next event in a run of
                        events is.  
                    </para>
                    <para>
                        Note that if a supervent has been declared this will
                        be used to point to the next event in the superevent.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>IncrementEventSize</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>nIncr</parameter><initializer>2</initializer>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds <parameter>nIncr</parameter> to the size of the
                        event. 
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>UInt_t</type>
                        <methodname> GetEventSize</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the current understanding of the size
                        of this event.
                    </para>
                </listitem>
            </varlistentry>
  
           
        </variablelist>
    </refsect1>
    <refsect1>
        <title>DATA TYPES</title>
        <para>
            The header <filename>TCLAnalyzer.h</filename> defines both nested
            and global level data types.  This section will first describe the
            globally defined data types and then the nested type.
        </para>
        <para>
            One globally defined data type <classname>Counter</classname>
            is defined.  This is an enumerated type whose values select the
            Tcl counter operated on by e.g. <methodname>IncrementCounter</methodname>.
            These statistics are maintained in the Tcl array
            <varname>Statistics</varname>.
            The type can have any of the following values.  
        </para>
        <variablelist>
            <varlistentry>
                <term><literal>RunsAnalyzed</literal></term>
                <listitem>
                    <para>
                        Increments the <literal>RunsAnalyzed</literal> element
                        of <varname>Statistics</varname>.  This counter
                        is incremented by the analyzer whenever it
                        executes its
                        <methodname>OnBegin</methodname> method.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>EventsAnalyzed </literal></term>
                <listitem>
                    <para>
                        Selects the element
                        <literal>EventsAnalyzed</literal> from the
                        <varname>Statistics</varname> array.  This counter
                        is incremented every time
                        <methodname>OnEvent</methodname> is executed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>EventsAnalyzedThisRun </literal></term>
                <listitem>
                    <para>
                        Selects <literal>EventsAnalyzedThisRun</literal>.
                        Same as <literal>EventsAnalyzed</literal> but
                        additionally, this counter is also cleared by
                        <methodname>OnBegin</methodname>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>EventsAccepted</literal></term>
                <listitem>
                    <para>
                        Selects <literal>EventsSelected</literal>.  This
                        counts the number of events that made it through
                        the entire event processing pipeline without
                        any element returning false.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>EventsAcceptedThisRun</literal></term>
                <listitem>
                    <para>
                        Selects <literal>EventsAcceptedThisRun</literal>.
                        Same as <literal>EventsAccepted</literal> but is also
                        cleared by <methodname>OnBegin</methodname>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>EventsRejected</literal></term>
                <listitem>
                    <para>
                        Selects <literal>EventsRejected</literal>.  Incremented
                        for each event for which the event processing  pipeline was aborted
                        because an event processor returned false.  Note that
                        exceptions thrown by an event processor caught by the
                        <classname>CTclAnalyzer</classname> object are
                        treated as pipeline aborts for the purpose
                        of this counter.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <literal>EventsRejectedThisRun</literal>
                </term>
                <listitem>
                    <para>
                        Selects <literal>EventsRejectedThisRun</literal>. This
                        is the same as <literal>EventsRejected</literal> but
                        is also cleared by
                        <methodname>OnBegin</methodname>.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            Several data types are defined within the <classname>CTclAnalyzer</classname>
            class.  These are mostly related to the event processing pipeline.
            These types are defined via <literal>typedef</literal>.  To specify
            these types in your code you'll need to use the scope resolution
            operator.  For example, <classname>PipelineElement</classname>
            must be referred to as a <classname>CTclAnalyzer::PipelineElement</classname>.
        </para>
        <variablelist>
            <varlistentry>
                <term><classname>PipelineElement</classname></term>
                <listitem>
                    <para>
                        This is an element of the list that contains
                        an event processing pipeline element. It associates
                        an event processor with a name and places it in an ordered
                        container of event processors.
                    </para>
                    <para>
                        The actual type is:
                        <classname>std::pair&lt;std::string, CEventProcessor*&gt;</classname>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>EventProcessingPipeline</classname></term>
                <listitem>
                    <para>
                        The actual event processing pipeline.  This is actually a
                        <classname>std::list&lt;PipelineElement&gt;</classname>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>EventProcessorIterator</classname></term>
                <listitem>
                    <para>
                        Represents an iterator into the event processing
                        pipeline container.  This is actually a
                        <classname>EventProcessingPipeline::iterator</classname>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>VariableArray</classname></term>
                <listitem>
                    <para>
                        Defines a vector that contains TCL variables:
                        <classname>std::vector&lt;CTCLVariable*&gt;</classname>
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>   
        
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CBufferDecoder</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CBufferDecoder</refname>
        <refpurpose>Base class for SpecTcl buffer decoders</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;BufferDecoder.h&gt;

class CBufferDecoder {
 protected:
  UInt_t    m_nSize;    // Number of bytes in buffer.

 public:
  CBufferDecoder(); 
  virtual ~CBufferDecoder();
  int operator==(const CBufferDecoder&amp; aCBufferDecoder);
  const Address_t getBuffer();
 protected:
  void setBuffer (Address_t am_pBuffer);
 public:
  virtual BufferTranslator* getBufferTranslator();
  virtual const Address_t getBody() = 0;
  virtual UInt_t getBodySize() = 0;
  virtual UInt_t getRun() = 0;
  virtual UInt_t getEntityCount() = 0;
  virtual UInt_t getSequenceNo() = 0;
  virtual UInt_t getLamCount() = 0;
  virtual UInt_t getPatternCount() = 0;
  virtual UInt_t getBufferType() = 0;
  virtual void getByteOrder(Short_t&amp; Signature16,
			    Int_t&amp; Signature32) = 0;
  virtual std::string getTitle() = 0;
  virtual void operator() (UInt_t nBytes,
			   Address_t pBuffer,
			   CAnalyzer&amp; rAnalyzer);

  virtual void OnAttach(CAnalyzer&amp; rAnalyzer);
  virtual void OnDetach(CAnalyzer&amp; rAnalyzer);
  virtual bool blockMode();	
  virtual void OnSourceAttach();
  virtual void OnSourceDetach();
  virtual void OnEndFile();

 protected:
  void ThrowIfNoBuffer(const char* pszWhatImDoing);
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This class is an abstract base class for the set of buffer decoders.
            Buffer decoders are responsible for taking a block of data received
            from a data source and breaking it up into items.  These items are
            then passed to the appropriate analyzer methods for
            detailed processing.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CBufferDecoder</methodname>
                        <void />
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        The base class constructor is a default constructor.
                        It has no parameters.  Typically, the state of a
                        buffer decoder is meaningless until data arrives.
                        This is because only when data arrives does the
                        buffer decoder do anything.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>const </modifier>
                        <type>Address_t </type>
                        <methodname>getBuffer</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the data most recently received.
                        If, for some pathalogical reason, data has not yet
                        been received, a null pointer is received.
                    </para>
                    <para>
                        Note that it is possible that derived classes will have
                        their own book-keeping for buffers of data received from
                        the data source.  Those decoders should, nonetheless
                        use <methodname>setBuffer</methodname> to set the
                        buffer member data of their base class to ensure
                        this methiod works.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>BufferTranslator* </type>
                        <methodname>getBufferTranslator</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to a buffer translator for this
                        block of data.  A buffer translator is an object
                        that knows how to perform byte order translations between
                        the byte ordering of the source system and the system
                        SpecTcl is executing on.
                    </para>
                    <para>
                        In most cases the default implementation will not be
                        useful as it was written with NSCLDAQ-7.x/8.x
                        buffer formats in mind.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual const </modifier>
                        <type>Address_t </type>
                        <methodname>getBody</methodname>
                        <void />
                        <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the body of the block of data
                        the decoder is currently working on.  Normally, this is
                        a pointer to the next item, or run of items the
                        analyzer should process.  For NSCLDAQ-10.x and later,
                        for example, this will be a pointer to the body
                        of a ring item.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getBodySize</methodname>
                        <void />
                        <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of bytes in the body.  This will
                        be the number of bytes of data in the block pointed
                        to by the pointer returned from
                        <methodname>getBody</methodname>.  Note that actually
                        this will be the number of bytes from that body to be
                        processed by the analyzer and may, in fact, be smaller
                        than the storage pointeed to by
                        <methodname>getBody</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getEntityCount</methodname>
                        <void />
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of items in the block of data
                        pointed to by <methodname>getBody</methodname>.  This is
                        mostly intended for use with blocks containing runs of
                        events from physics triggers.  
                    </para>
                    <para>
                        The analyzer's
                        <methodname>OnPhysics</methodname> can use this and
                        <methodname>getBodySize</methodname> to know how much
                        data to process and to double check the
                        event processor does  not over step the boundaries of
                        the block or leave data unprocessed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getSequenceNo</methodname>
                        <void />
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the sequence number of the last item processed.
                        Note that this may not be precisely determined for
                        some DAQ systems, and may not even be available.
                    </para>
                    <para>
                        This value is maintained by SpecTcl in Tcl variables
                        so that the GUI can display the analysis efficiency
                        (which maybe less than 1 for online analysis).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getLamCount</methodname>
                        <void />
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        From the traditional nscldaq, returns the number of LAM
                        registers.  This comes from the tradition of CAMAC where LAM bit masks
                        show the set of modules with data available in a crate.
                        This is vestigial; allowing NSCLDAQ-7.x/8.x to report
                        the number of CAMAC crates in a 'larger' experiment.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getPatternCount</methodname>
                        <void />
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Vestigial method from when readouts were pattern register
                        driven.  This method used to return the number
                        of pattern registers used to drive the readout pattern.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getBufferType</methodname>
                        <void />
                        <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the item type in the block of data currently
                        being processed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>getByteOrder</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>Short_t&amp;</type>
                           <parameter> Signature16</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Int_t&amp; </type>
                           <parameter>Signature32</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns byte order signatures that describe the order
                        of bytes in the data.  <parameter>Signature16</parameter>
                        will be written with the value <literal>0x0102</literal>
                        in the byte ordering of the creating system.
                        <parameter>Signature32</parameter>, will similarly be written
                        with <literal>0x01020304</literal> in the byte ordering
                        of the originating system.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>std::string </type>
                        <methodname>getTitle</methodname>
                        <void />
                        <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the title from the most recently received
                        begin run information.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type> UInt_t </type>
                           <parameter>nBytes</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Address_t </type>
                           <parameter>pBuffer</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>CAnalyzer&amp; </type>
                           <parameter>rAnalyzer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when a new chunk of data comes in.  <parameter>nBytes</parameter>
                        is the number of bytes of data received. <parameter>pBuffer</parameter>
                        is pointer to the data received. <parameter>rAnalyzer</parameter>
                        refers to the analyzer that should be called back
                        to handle specific items and runs of items.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnAttach</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CAnalyzer&amp; </type>
                           <parameter>rAnalyzer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is called when a decoder object is
                        attached to SpecTcl. This can happen at startup time, but
                        also can happen when the
                        <command>attach</command> command specifies a format
                        that selects a specific decoder object type.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnDetach</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CAnalyzer&amp; </type>
                           <parameter>rAnalyzer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when the buffer decoder is detached from SpecTcl.
                        This will happen when a new one is attached.  Typically
                        this will be because the <command>attach</command>
                        command is used to start taking data from a source
                        that has a different format than the prior source.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>bool </type>
                        <methodname>blockMode</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If this method returns <literal>true</literal>,
                        SpecTcl will require that a full fixed size block
                        of data be read before invoking the decoder.  If,
                        however <literal>false</literal> is returned,
                        the buffer decoder is invoked on the successful
                        completion of any read from the data source.
                    </para>
                    <para>
                        This only has any impact on how pipe data sources
                        are handled.  Note that there's still no guarantee
                        the  a block read is a clean multiple of the
                        data items
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnSourceAttach</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Invoked when a new data source is attached to SpecTcl.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnSourceDetach</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when a data source is detached from SpecTcl.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnEndFile</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when an end file is encountered on the current
                        data source.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>protected: </modifier>
                        <type>void </type>
                        <methodname>setBuffer </methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>Address_t </type>
                           <parameter>am_pBuffer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Sets the value returned from
                        <methodname>getBuffer</methodname> to be
                        <parameter>am_pBuffer</parameter>.  This can be used
                        by a derived class when it needs to do its oown buffer
                        management to keep this base class apprised of the data
                        it is operating on.  
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>protected: </modifier>
                        <type>void </type>
                        <methodname>ThrowIfNoBuffer</methodname>
                        <methodparam>
                           <modifier>const </modifier>
                           <type>char*</type>
                           <parameter> pszWhatImDoing</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        To use this a derived class must use
                        <methodname>setBuffer</methodname> to always maintain
                        the a valid buffer pointer.  If this is called and
                        either <methodname>setBuffer</methodname> last
                        set a null pointer or was never called, a
                        <classname>CEventFormatError</classname> exception
                        is called with a reason code of
                        <literal>CEventFormatError::knNoCurrentBuffer</literal>
                        and a was doing text of <parameter>pszWhatImDoint</parameter>.
                    </para>
                </listitem>
            </varlistentry>     
        </variablelist>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
            (3SpecTcl)CNSCLBufferDecoder,
                    (3SpecTcl)CNSCLJumboBufferDecoder, (3SpecTcl)CRingBufferDecoder,
        </para>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CNSCLBufferDecoder</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CNSCLBufferDecoder</refname>
        <refpurpose>Decode fixed sized event buffers from NSCLDAQ-7.x/8.x</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;NSCLBufferDecoder.h&gt;

class CNSCLBufferDecoder : public CBufferDecoder {
public:
  CNSCLBufferDecoder();
  virtual ~CNSCLBufferDecoder();
  virtual const Address_t getBody();
  virtual UInt_t getBodySize();
  virtual UInt_t getRun();
  virtual UInt_t getEntityCount();
  virtual UInt_t getSequenceNo();
  virtual UInt_t getLamCount();
  virtual UInt_t getPatternCount();
  virtual UInt_t getBufferType();
  virtual void getByteOrder(Short_t&amp; Signature16, Int_t&amp; Signature32);
  virtual std::string getTitle();
  virtual void operator()(UInt_t nBytes, Address_t pBuffer, CAnalyzer&amp; rAnalyzer);
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This buffer decoder decodes fixed length event bufers from
            NSCLDAQ-7.x/8.x.  These buffers are typically 8Kbytes long, however
            they may be longer or shorter as long as the total number of bytes
            per buffer is no larger than 128K-2 bytes.
        </para>
        <para>
            See CNSCLJumboBufferDecoder for larger bufer sizess.
        </para>
        <para>
            This data format uses homogeneous buffers.  Typically, non event buffers
            have a single item.  Event buffers, however are packed with as
            many items as will fit.  This means that buffers that contain non
            event data are typically very space wasteful.  Fortunately in most
            cases they are also not frequently emitted compared with event
            data buffers.
        </para>
        <para>
            This class is concrete.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CNSCLBufferDecoder</methodname>
                        <void />
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructor. 
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual const </modifier>
                        <type>Address_t </type>
                        <methodname>getBody</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        NSCLDAQ 7.x/8.x buffers have a header of 32 bytes
                        (16 uin16_t).  This method returns a pointer to the
                        first byte after this header.  
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getBodySize</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of words used in the body of the
                        buffer.  Note that not all words of the buffer
                        may be used.  THe first 16 bits of the buffer contain
                        the number of used 16 bit words  in the buffer;
                        <varname>nwds</varname>.  This method,
                        therefore returns
                        <literal>(nwds - 16) * sizeof(uint16_t)</literal> 
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getRun</methodname>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        The header of NSCLDAQ 7.x/8.x buffers contains
                        the run number.  This method returns the run number
                        from the most recently received buffer.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getEntityCount</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>               
                </term>
                <listitem>
                    <para>
                        Returns the number of entities in the buffer.
                        For physics buffers, this is the number of events in the
                        buffer.  For scaler events, this is the number of
                        scaler channels present in the buffer.  For all other
                        item typesm, this is <literal>1</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getSequenceNo</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        NSCLDAQ 7.x/8.x buffers have sequence numbers.  These,
                        together with a count of the number of buffers seen
                        can be used to approximate the sampling fraction for
                        online analysis (when SpecTcl may not be able to
                        keep up with the data rate).
                    </para>
                    <para>
                        This method returns the sequence number from the last
                        buffer received.  Note that sequence numbers start from
                        zero at the beginning of each run.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getLamCount</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        The header of NSCLDAQ 7.x/8.x buffers includes a
                        word that contains the number of lam masks in an event.
                        This actually is vestigial dating back to K500 days
                        when events has a much more fixed format that include
                        a set of pattern registers and a set of LAM registers.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getPatternCount</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Same as for <methodname>getLamCount</methodname> but the
                        method returns the header field containing the pattern
                        register count.  This too is vestigial.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getBufferType</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>getByteOrder</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>Short_t&amp; </type>
                           <parameter>Signature16</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Int_t&amp; </type>
                           <parameter>Signature32</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the byte order signatures that describe the
                        byte ordering of the system that generated the
                        most recent data buffer.  Note that these values
                        are header members for buffers from
                        NSCLDAQ 7.x/8.x
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>std::string </type>
                        <methodname>getTitle</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the title of the current run.  In
                        NSCLDAQ 7.x/8.x run titles are stored in state
                        transition buffers.  The value returnes is the
                        value from the most recently received state transition
                        buffer.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>nBytes</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Address_t </type>
                           <parameter>pBuffer</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type> CAnalyzer&amp; </type>
                           <parameter>rAnalyzer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Processes a new buffer of data.
                        <parameter>nBytes</parameter> is the physical size
                        of the buffer.  The header of the buffer determines how
                        much of the physical buffer contains useful data.
                        <parameter>pBuffer</parameter> points to the data and
                        <parameter>rAnalyzer</parameter> is a reference
                        to the analyzer we must call back for item processing.
                    </para>
                </listitem>
            </varlistentry>           
        </variablelist>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CNSCLJumboBufferDecoder</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CNSCLJumboBufferDecoder</refname>
        <refpurpose>Decode NSCLDAQ 7.x/8.x buffers bigger than 128Kbytes.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CNSCLJumbBufferDecoder&gt;

class CNSCLJumboBufferDecoder : public CBufferDecoder {
public:
  CNSCLJumboBufferDecoder();
  virtual ~CNSCLJumboBufferDecoder() ;
  virtual const Address_t getBody();
  virtual UInt_t getBodySize();
  virtual UInt_t getRun();
  virtual UInt_t getEntityCount();
  virtual UInt_t getSequenceNo();
  virtual UInt_t getLamCount();
  virtual UInt_t getPatternCount();
  virtual UInt_t getBufferType();
  virtual void getByteOrder(Short_t&amp; Signature16, Int_t&amp; Signature32);
  virtual std::string getTitle();
  virtual void operator()(UInt_t nBytes, Address_t pBuffer, CAnalyzer&amp; rAnalyzer);

        </synopsis>        
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This decoder is a special version of the
            <classname>CNSCLBufferDecoderr</classname> class.  An unused
            header words is repurposed to hold the top bits of a 32 bit buffer
            size.  Furthermore;  events in physics buffers have a 32 bit event
            size as their header.  This allows both for buffers bigger than
            64Kwords and for events larger than 64Kwords.
        </para>
        <para>
            The motivation for this type of buffer was a series of experiments
            that used a waveform capture device capable of delivering
            events much larger than 64Kwords of data.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CNSCLJumboBufferDecoder</methodname>
                        <void />
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructor for objects of this class.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>const Address_t</type>
                        <methodname> getBody</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Operates the same as for <classname>CNSCLBufferDecoder</classname>;
                        returns a pointer tot he first byte after the 32 byte
                        header.
                    </para>
                </listitem>
            </varlistentry>          
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t</type>
                        <methodname> getBodySize</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of bytes used in the buffer.
                        The jumbo buffer format holds the low
                        16 bit of the used buffer size (words) in the first
                        element of the buffer header.   A previously unused
                        word in the buffer (<structfield>nwdsHigh</structfield>)
                        is used to hold the top 16 bits of the used buffer size.
                    </para>
                    <para>
                        The decoder combines these to form a 32 bit value
                        and subtracts the size of the buffer header from that
                        to get the final size.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getRun</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        As with <classname>CNSCLBufferDecoder</classname>, returns
                        the run number from the buffer header.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getEntityCount</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        As with <classname>CNSCLBufferDecoder</classname>,
                        returns the number of entities in the buffer.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getSequenceNo</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        As with <classname>CNSCLBufferDecoder</classname>,
                        returns the sequence number of the last buffer.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t</type>
                        <methodname> getLamCount</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        As for <classname>CNSCLBufferDecoder</classname>,
                        returns the lam count from the buffer header.
                        This is deprecated as LAM register counts have not
                        been part of typical NSCL events for decades.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getPatternCount</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        As with <classname>CNSCLBufferDecoder</classname>,
                        returns the pattern register count from the
                        buffer header.  This is deprecated as most
                        events, these days, don't actually have any pattern
                        registers, thanks to the ability of digitizers
                        to auto-zero suppress.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t</type>
                        <methodname> getBufferType</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the type of data in the buffer.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>getByteOrder</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>Short_t&amp; </type>
                           <parameter>Signature16</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Int_t&amp; </type>
                           <parameter>Signature32</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        As with <classname>CNSCLBufferDecoder</classname>,
                        returns the byte order signatures in
                        <parameter>Signature16</parameter> and
                        <parameter>Signature32</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>std::string </type>
                        <methodname>getTitle</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns title from the most recent run state
                        transition buffer.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>nBytes</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Address_t </type>
                           <parameter>pBuffer</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>CAnalyzer&amp; </type>
                           <parameter>rAnalyzer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called for each block of data received from the data
                        source.  This is a fixed block sized buffer decoder
                        so the value of <parameter>nBytes</parameter> should
                        always be the same within a run.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CRingBufferDecoder</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CRingBufferDecoder</refname>
        <refpurpose>Decode data from ring buffers</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CRingBufferDecoder&gt;
 
class CRingBufferDecoder : public CBufferDecoder
{
public:
  CRingBufferDecoder();
  virtual ~CRingBufferDecoder();

  virtual void operator()(UInt_t nBytes, Address_t pBuffer, CAnalyzer&amp; rAnalyzer);

  virtual const Address_t getBody();
  virtual UInt_t getBodySize();
  virtual UInt_t getRun();
  virtual UInt_t getEntityCount();
  virtual UInt_t getSequenceNo();
  virtual UInt_t getLamCount();
  virtual UInt_t getBufferType();
  virtual UInt_t getPatternCount();
  virtual void   getByteOrder(Short_t&amp; signature16,
			      Int_t&amp;   signature32);
  virtual std::string    getTitle();
  virtual BufferTranslator* getBufferTranslator();

  virtual bool blockMode();	// True if data source must deliver fixed sized blocks.
  
  // Format helpers and stuff that gets you at what they know.
  

  bool  hasBodyHeader();
  void* getBodyHeaderPointer();
  void* getItemPointer();

  void  setFormatHelper(CRingFormatHelper* pHelper);
  void  setDefaultFormatHelper(CRingFormatHelper* pHelper);
  CRingFormatHelper* getCurrentFormatHelper();
  CRingFormatHelper* getDefaultFormatHelper();
  
  CRingFormatHelperFactory* getFormatFactory();
  
  // Members called that can invalidate the format helper:
  
  virtual void OnSourceAttach();
  virtual void OnSourceDetach();
  virtual void OnEndFile();
};       
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This class decodes data from NSCLDAQ 10.x and above.  Since the
            format of ring items differs between NSCLDAQ 10.x and NSCLDAQ 11.0 and
            above (11.0 introduces body headers to better support event building),
            this decoder relies on a <classname>CRingFormatHelper</classname>
            to deal with these differences.
        </para>
        <para>
            When a data source is first opened with <option>-format</option> ring,
            you can use the <command>ringformat</command> command to specify
            the NSCLDAQ version used.  Alternatively, if you are certain
            that the data source will see the beginning of a run
            (not joining a run in progress on an online system), the
            class will use the presence (or absence) of a ring format item
            to select the appropriate format helper.   The absence of a ring
            format item selects the 10.x helper, while the version information
            in a ring format item will select the proper helper, if present.
        </para>
        <para>
            Finally, the format helper can be set programmatically
            via the <methodname>setFormatHelper</methodname> and
            <methodname>setDefaultFormatHelper</methodname> methods, depending
            on what you are trying to do.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CRingBufferDecoder</methodname>
                        <void />
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructor.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void</type>
                        <methodname>operator()</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type>
                           <parameter>nBytes</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type> Address_t</type>
                           <parameter> pBuffer</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>CAnalyzer&amp; </type>
                           <parameter>rAnalyzer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called whenever data has been received from the source.
                        This method breaks the <parameter>nBytes</parameter> bytes
                        of data in <parameter>pBuffer</parameter> into ring items.
                        Each item is then passed to the appropriate
                        method of <parameter>rAnalyzer</parameter>.
                    </para>
                    <para>
                        Note that since SpecTcl does fixed sizedd reads and
                        ring items are inherently variable sized, it is possible
                        for ring items to span from one buffer to the next.
                        This decoder recognizes this and mates partial ring items
                        at the end of each buffer with partial ring items at the
                        beginning of the next buffer.
                    </para>
                    <para>
                        Since ring items are atomically read from the ring buffer,
                        it must be possible to reconstruct ring items that have
                        been split across buffer boundaries as sampling is done
                        at the ring item leve, not the buffer level.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual const </modifier>
                        <type>Address_t </type>
                        <methodname>getBody</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the body of the ring item being processed.  Note
                        that if the nscldaq-11.x helper has been selected,
                        this will be a pointer to the data <emphasis>following</emphasis>
                        the body header.  Otherwise it will point just after
                        the ring item header, as 10.x does not have body headers.
                    </para>
                    <para>
                        The 11.x helper knows about the potential for zero length
                        body headers.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type> UInt_t </type>
                        <methodname>getBodySize</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the size of the ring item body.  Note that this
                        is the amount of data pointed to by the return value
                        from <methodname>getBody</methodname>.
                    </para>
                    <para>
                        To clarify, for the nscldaq 11.x helper, this value does
                        not include the size of the body header.  This choice was
                        made because the purpose of this method is to return
                        the number of bytes that must be processed by the
                        analyzer for data returned by
                        <methodname>getBody</methodname>.  The decoder
                        treats body headers as ancillary metadata for events that
                        can be retrieved by user code via special methods
                        provided by this class.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getRun</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the last run number seen.  Note that in
                        ring buffer NSCLDAQ systems, the run number is only
                        present in state change ring items.  If one of those
                        has not yet been seen, because SpecTcl is joining an
                        online run in progress, the run number returned will
                        be zero, or the most recent run from the prior data source,
                        if there was one.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getEntityCount</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of items in the data pointed to
                        by <methodname>getBody</methodname>.   Normally this
                        will be <literal>1</literal>, however for scaler items,
                        this will be the number of scaler channels present in
                        the item.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type> UInt_t </type>
                        <methodname>getSequenceNo</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an approximation of the number of triggers seen.
                        NSCLDAQ 10.x don't maintain sequence numbers in ring items.
                        Instead periodically a ring item is emitted with trigger
                        statistics.  The value of this method is the
                        number of triggers for which data was emitterd for
                        this run, from the most recently received trigger count
                        item.  As the run evolves in time, this allows a
                        reasonable estimate of the analysis efficiency since
                        the percent error in the number of triggers will
                        go towards zero in the limit as the run time goes to
                        infinity.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getLamCount</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>0</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getBufferType</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the SpecTcl type of the item type currently
                        being processed.  For historical reasons these differ
                        from ring item types and are mapped as follows from
                        types in <filename>dataformat.h</filename> in NSCLDAQ
                        to <filename>buftypes.h</filename>:
                    </para>
                    <itemizedlist>
                        <listitem>
                            <para>
                                <literal>BEGIN_RUN</literal> maps to
                                <literal>BEGRUNBF</literal>.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <literal>END_RUN</literal> maps to
                                <literal>ENDRUNBF</literal>.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <literal>PAUSE_RUN</literal> maps to
                                <literal>PAUSEBF</literal>.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <literal>RESUME_RUN</literal> maps to
                                <literal>RESUMEBF</literal>.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <literal>PACKET_TYPES</literal> maps to
                                <literal>PKTDOCBF</literal>.  Though I should
                                point out that these items are rare in
                                NSCLDAQ-10.x and later readouts.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <literal>MONITORED_VARIABLES</literal>
                                maps to <literal>RUNVARBF</literal>.  This
                                is mostly used by NSCLDAQ 10.x and later
                                when injection of EPICS data into the data stream
                                is done as that's the known use-case now
                                for these item types.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <literal>PERIODIC_SCALERS</literal> this
                                NSCLDAQ-11 type maps to
                                <literal>SCALERBF</literal>.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <literal>NSCLDAQ10::INCREMENTAL_SCALERS</literal>
                                This NSClDAQ-10 type maps to
                                <literal>SCALERBF</literal>.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <literal>PHYSICS_EVENT</literal> maps to
                                <literal>DATABF</literal>
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                Any other type is not modified and will, therefore,
                                cause <methodname>OnOther</methodname> to be
                                called in the analyzer.
                            </para>
                        </listitem>
                    </itemizedlist>
                    
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type> UInt_t </type>
                        <methodname>getPatternCount</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>0</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void   </type>
                        <methodname>getByteOrder</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>Short_t&amp; </type>
                           <parameter>signature16</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Int_t&amp;   </type>
                           <parameter>signature32</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns byte order signatures for the current ring item.
                        Each ring item type is a 16 bit value in a 32 bit word
                        with the most significant bits (in the generating system)
                        zero.  This allows consuming systems to determine the
                        relative byte ordering and, therefore, generate
                        accurate generating byte order signatures.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>std::string    </type>
                        <methodname>getTitle</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the title from the last state change item.  If
                        no state change items have been seen yet (can happen
                        if SpecTcl starts analyzing on line data in the
                        middle of an active run), an empty string is returned.,
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>BufferTranslator* </type>
                        <methodname>getBufferTranslator</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the buffer translator being used
                        to perform any byte order manipulations to transform
                        the data into the format used by the host executing
                        SpecTcl.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>bool </type>
                        <methodname>blockMode</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>false</literal>.  Ring buffer data
                        can  accept data buffers shorter than the requested
                        read size and this can (and probably will) happen at
                        the end of a run.
                    </para>
                </listitem>
            </varlistentry>          
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier> </modifier>
                        <type>bool </type>
                        <methodname>hasBodyHeader</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If the item has a body header <literal>true</literal>
                        is returned, otherwise, <parameter>false</parameter>
                        is returned.  See also <methodname>getBodyHeaderPointer</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void* </type>
                        <methodname>getBodyHeaderPointer</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the body header of a ring item.
                        If the ring item has no body header (NSCLDAQ 10.x) or has
                        a body header length of zero (NSCLDAQ 11.x item with no
                        body header), then a null pointer is returned.
                    </para>
                </listitem>
            </varlistentry>  
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void* </type>
                        <methodname>getItemPointer</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the ring item being processed.
                        In all versions this returns a pointer to the ring item
                        header.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void  </type>
                        <methodname>setFormatHelper</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CRingFormatHelper* </type>
                           <parameter>pHelper</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Replaces the current ring format helper with
                        <parameter>pHelper</parameter>.
                        <parameter>pHelper</parameter> must have been
                        created with <literal>new</literal>
                        
                    </para>
                    <para>
                        Note that if
                        a ring format item is seen after this is called, the
                        ring format helper is destroyed and replaced by the
                        appropriate one.  Therefore it's recommended, instead,
                        to use <methodname>setDefaultFormatHelper</methodname>
                        to set a default ring format helper.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void  </type>
                        <methodname>setDefaultFormatHelper</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CRingFormatHelper* </type>
                           <parameter>pHelper</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Sets the default format helper to use for a new run
                        until (or unless) a format item is seen.  If a format
                        item is seen, that is used to select a (potentially)
                        new format helper.
                    </para>
                    <para>
                        Since NSCLDAQ 10 does not have ring format items,
                        it is wise to use the format helper
                        <classname>CRingFormatHelper10</classname> unless
                        you have good reason to believe that the software
                        will be analyzing NSCLDAQ 11.0 and later and will be
                        joining runs online in the middle of the run.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CRingFormatHelper* </type>
                        <methodname>getCurrentFormatHelper</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the format helper currently being
                        used by the decoder.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CRingFormatHelper* </type>
                        <methodname>getDefaultFormatHelper</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the default format helper currently
                        in effect.  Note that it is possible that the this does
                        not represent the active format helper, especially if
                        a ring format item was encountered that indicates a different
                        format helper should be u7sed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CRingFormatHelperFactory* </type>
                        <methodname>getFormatFactory</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the ring format
                        helper factory
                        being used by this object.  The ring format
                        factory is responsible for selecting and creating
                        a ring format helper compatible with the data
                        that has been seen by the decoder.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnSourceAttach</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when a new data source is attached.  The
                        current buffer format helper is deleted and, for now,
                        the decoder falls back on the default buffer format
                        helper.
                    </para>
                    <para>
                        Once a ring format item is seen, (or rather if one
                        is seen), the ring format helper factory is used
                        to select an appropriate helper for the current
                        data source.  Furthermore, the format helper can be
                        set programmatically by calling
                        <methodname>setFormatHelper</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void</type>
                        <methodname> OnSourceDetach</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when  data source is detached. This invalidates
                        the current buffer format helper in much the same manner
                        as <methodname>OnSourceAttach</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnEndFile</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when an end file is encountered on a data source.
                        This also invalidates the ring format helper.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CRingFormatHelper</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CRingFormatHelper</refname>
        <refpurpose>ABC for4 ring buffer format helpers</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;RingFormatHelper.h&gt;

class CRingFormatHelper
{
public:
    CRingFormatHelper();
    virtual ~CRingFormatHelper();
    CRingFormatHelper(const CRingFormatHelper&amp;);
    CRingFormatHelper&amp; operator=(const CRingFormatHelper&amp;);
    int operator==(const CRingFormatHelper&amp;) const;
    int operator!=(const CRingFormatHelper&amp;) const;
    
public:
    virtual bool hasBodyHeader(void* pItem) const   = 0;
    virtual void* getBodyPointer(void* pItem)       = 0;
    virtual void* getBodyHeaderPointer(void* pItem) = 0;
    
    virtual std::string getTitle(void* pItem) = 0;
    virtual unsigned    getRunNumber(
        void* pItem, BufferTranslator* pTranslator) = 0;
    
    virtual unsigned getStringCount(
        void* pItem, BufferTranslator* pTranslator) = 0;
    
    virtual unsigned getScalerCount(
        void*  pItem, BufferTranslator* pTranslator) = 0;
    
    virtual uint64_t getTriggerCount(
        void* pItem, BufferTranslator* pTranslator) = 0;

    uint16_t itemType(void* pItem);

};

#include &lt;RingFormatHelper10.h&gt;

class CRingFormatHelper10;

#include &lt;RingFormatHelper11.h&gt;
class CRingFormatHelper11;


        </synopsis>    

    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Ring buffer data comes in more than one format, depending on the
            actual version of NSCLDAQ that emitted it.  Ring format helpers
            are classes that know how to untangle data from specific versions
            of NSCL Ring buffer data acquisition systems.
        </para>
        <para>
            <classname>CRingFormatHelper</classname> is an abstract base class
            that provides the interface that the
            <classname>CRingBufferDecoder</classname> class expects these helpers
            to implement.
        </para>
        <para>
            SpecTcl provides two concrete implementations of this class:
            <itemizedlist>
                <listitem>
                    <para>
                        <classname>CRingFormatHelper10</classname> which
                        helps the Ring buffer decoder handle NSCLDAQ10 data (data)
                        that has no provision for body headers. 
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <classname>CRingFormatHelper11</classname> which
                        helps with data from NSCLDAQ11, which does have a provision
                        for body headers that can assist the event builder.
                    </para>
                </listitem>
            </itemizedlist>

        </para>
        <para>
            These helper classes offer no additional public methods beyond those
            specified by <classname>CRingFormatHelper</classname>.  Therefore
            we will not document them further.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            For brevity, only the non-canonicals are described here.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>bool </type>
                        <methodname>hasBodyHeader</methodname>
                        <methodparam>
                            <type>void*</type>
                             <parameter>pItem</parameter>
                        </methodparam>
                        <modifier>const   = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Determines if the ring item pointed to by
                        <parameter>pItem</parameter> contains a body header.
                        Body headers contain additional fixed format data prior
                        to the body of the ring item but after the ring item header
                        itself.  
                    </para>
                    <para>
                        For example in NSCLDAQ 11.x, body headers, if present,
                        contain a timestamp for the item, the source id of the
                        item and a barrier type.  NSCLDAQ 11.x may also emit
                        ring items without body headers.
                    </para>
                    <para>
                        Note that if the version of NSCLDAQ emitting this
                        item does not support body headers, this always returns
                        <literal>false</literal>
                    </para>
                </listitem>
            </varlistentry>        
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void* </type>
                        <methodname>getBodyPointer</methodname>
                        <methodparam>
                            <type>void*</type><parameter>pItem</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the ring item body for the
                        item pointed to by <parameter>pItem</parameter>.
                        Note that
                        in the presence of body headers, this pointer will
                        point past the body header to the actual body data itself.
                    </para>
                </listitem>
            </varlistentry>        
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void* </type>
                        <methodname>getBodyHeaderPointer</methodname>
                        <methodparam>
                            <type>void*</type><parameter> pItem</parameter>
                        </methodparam>
                        <modifier>= 0;</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the body header of the
                        ring item:
                        <parameter>pItem</parameter>.
                        If <parameter>pItem</parameter> does not have a body
                        header (<methodname>hasBodyHeader</methodname> returns
                        <literal>false</literal>), this will return a
                        <literal>nullptr</literal>.
                    </para>
                </listitem>
            </varlistentry>        
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>std::string </type>
                        <methodname>getTitle</methodname>
                        <methodparam>
                            <type>void* </type><parameter>pItem</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If <parameter>pItem</parameter> points to a state
                        transition item, the title is returned from that item.
                        If <parameter>pItem</parameter> does not point to
                        a state transition item, a
                        <type>std::string</type> exception is thrown containing
                        an appropriate error message.
                    </para>
                </listitem>
            </varlistentry>        
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual    </modifier>
                        <type>unsigned </type>
                        <methodname>getRunNumber</methodname>
                        <methodparam>
                            <type>void* </type><parameter>pItem</parameter>
                        </methodparam>
                        <methodparam>
                            <type>BufferTranslator* </type>
                            <parameter>pTranslator</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If <parameter>pItem</parameter> points to a
                        state transition ring item, this method returns
                        the run number from that item.  If not a
                        <type>std::string</type> exception
                        is thrown.  The contents of that string are
                        a human readable error message.
                    </para>
                    <para>
                        <parameter>pTranslator</parameter> points to the
                        appropriate buffer translator and is used to transform
                        the run number in the byte ordering of the producing
                        system to that of the system running SpecTcl.
                    </para>
                </listitem>
            </varlistentry>        
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>unsigned </type>
                        <methodname>getStringCount</methodname>
                        <methodparam>
                            <type>void*  </type><parameter>pItem</parameter>
                        </methodparam>
                        <methodparam>
                            <type> BufferTranslator* </type><parameter>pTranslator</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
			
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If the ring item pointed to by
                        <parameter>pItem</parameter> is a Text item
                        ring item, method returns the number of strings
                        this item has.
                        If the item is not a text ring item, a
                        <type>std::string</type> exception is thrown
                        containing a human readable error message.
                    </para>
                    <para>
                        <parameter>pTranslator</parameter> is used to translate
                        any string count from the byte ordering of the
                        producing system to the byte order of the system
                        running SpecTcl.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>unsigned </type>
                        <methodname>getScalerCount</methodname>
                        <methodparam>
                            <type>void*  </type><parameter>pItem</parameter>
                        </methodparam>
                        <methodparam>
                            <type>BufferTranslator*</type><parameter>pTranslator</parameter>
                        </methodparam>
                        <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If <parameter>pItem</parameter> points to a scaler item,
                        this method returns the number of counters in that
                        item.  If
                        <parameter>pItem</parameter> does not point to a
                        scaler item, a <type>std::string</type> exception is
                        thrown.
                    </para>
                    <para>
                        <parameter>pTranslator</parameter> is used to transform
                        the count from the byte order of the producing system
                        to they byte order of the system that is running SpecTcl.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>uint64_t </type>
                        <methodname>getTriggerCount</methodname>
                        <methodparam>
                            <type>void* </type><parameter>pItem</parameter>
                        </methodparam>
                        <methodparam>
                            <type>BufferTranslator* </type><parameter>pTranslator</parameter>
                        </methodparam>
                        <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If <parameter>pItem</parameter> points to a physics
                        event count item, this method returns the number
                        of triggers accepted by the run so far. If
                        <parameter>pItem</parameter> is not a physics event
                        count item, a <type>std::string</type> exception is
                        thrown.
                    </para>
                    <para>
                        <parameter>pItem</parameter> is used to convert
                        the trigger count from the byte order of the
                        producing system to the byte order of the system
                        running SpecTcl.
                    </para>
                </listitem>
            </varlistentry>        
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>uint16_t </type>
                        <methodname>itemType</methodname>
                        <methodparam>
                            <type>void* </type><parameter>pItem</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the ring item type for the ring item pointed
                        to by <parameter>pItem</parameter>.
                    </para>
                </listitem>
            </varlistentry>        

        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CNamedItem</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CNamedItem</refname>
        <refpurpose>Base class for items with names and ids.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;NamedItem.h&gt;

class CNamedItem      
{
 public:
  CNamedItem();
  CNamedItem (  std::string am_sName,  UInt_t am_nNumber  );

 public:
  std::string getName() const;
  UInt_t getNumber() const;
  void ChangeName(const std::string&amp; rNewName);
};

class CMatchNamedItemId {
 public:
  CMatchNamedItemId(UInt_t id);
  Bool_t operator()(CNamedItem&amp; item);
};


class CMatchNamedItem {
 public:
  CMatchNamedItem(const std::string&amp; rName);
  Bool_t operator()(CNamedItem&amp; item)
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Several SpecTcl objects have names and identifying numbers.  The
            <classname>CNamedItem</classname> class provides a convenient base
            class for those classes.  In addition to the methods shown, named items
            can be copy constructed, assigned and compared for equality.  Those
            methods have standard signatures and, therefore, are not described.
        </para>
        <para>
            Often bits of SpecTcl have to search for named items, either by id
            or by name in C++ standard library container objects (typically
            but not exclusively maps organized by object name).  The
            <classname>CMatchNamedItemId</classname> and
            <classname>CMatchNamedItem</classname> provide predicates for
            C++ algorithms that require matching predicates. 
        </para>
        <para>
            <classname>CMatchNamedItemId</classname> matches item(s) that
            have the same id as the one it is constructed with, while
            <classname>CMatchNamedItem</classname> matches those named
            the same as the string it is constructed with.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            We're only going to document the <classname>CNamedItem</classname>
            classes as the predicates are straightforward to use if you understand
            how predicates are used in the C++ standard library algorithms.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CNamedItem</methodname>
                        <void />
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Parameter-less constructor.   This creaets an object
                        with a name that is an empty string and an id of
                        <literal>0</literal>.  Typically this is used to create
                        an object that will be used as the target of an assignment.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CNamedItem </methodname>
                        <methodparam>
                            <type>std::string  </type><parameter>am_sName</parameter>
                        </methodparam>
                        <methodparam>
                            <type> UInt_t </type><parameter>am_nNumber</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Fully parameterized constructor.  The object will have
                        the name provided by <parameter>am_sName</parameter> and
                        the id provided by <parameter>am_nNumber</parameter>.
                    </para>
                    <para>
                        Note that any attempt to maintain unique naming or id
                        assignement is the responsibility of either the
                        derived class (e.g. through a registry it maintain) or
                        the code that manages the containers used to organize
                        the derived objects.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>std::string </type>
                        <methodname>getName() </methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the name associated with this object.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>UInt_t </type>
                        <methodname>getNumber</methodname>
                        <void />
                        <modifier> const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the id (integer) associated with this object.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>ChangeName</methodname>
                        <methodparam>
                            <modifier>const </modifier><type>std::string&amp; </type>
                            <parameter>rNewName</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        In some cases it's useful to change the name of a named item.
                        This method provides that capability.
                        The object's name is changed to <parameter>rNewName</parameter>.
                    </para>
                </listitem>
            </varlistentry>
           
        </variablelist>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CParameter</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CParameter</refname>
        <refpurpose>Parameter definition.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;Parameter.h&gt;

class CParameter : public CNamedItem {

 public:
  CParameter();

  CParameter(const std::string&amp; rName,
	     UInt_t nId,
	     const char* pUnits);
  CParameter(UInt_t am_nScale, 
	     const std::string&amp; rName, UInt_t nNumber);

  CParameter(UInt_t am_nScale,
	     const std::string&amp; rName, UInt_t nNumber,
	     Float_t nLow, Float_t nHigh, std::string am_sUnits) ;
         
 public:
  Bool_t hasScale() const;
  UInt_t getScale() const;
  Float_t getLow() const;
  Float_t getHigh() const;
  std::string getUnits() const;
  Float_t RawToMapped(Float_t Raw);
  Float_t MappedToRaw(Float_t Mapped);

};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <classname>CParameter</classname> objects contain parameter definitions.
            Parameter definitions are named objects where the name is used to
            refer to the parameter in SpecTcl commands and Tree parameter
            definitions while the id is an index into the
            <classname>CEvent</classname> into which that parameter's values
            for each event should be stored
        </para>
        <para>
            Parameter definitions also include metadata that is used to provide
            hints to users defining spectra about how to define the axes of spectra
            on those parameters.  An optional units metadata provides the units
            of measure for a parameter
        </para>
        <para>
            Because of SpecTcl's long developmental history,
            axis rang information comes in several orthogonal forms.  
        </para>
        <para>
            Originally, SpecTcl parameters were integer values and scaling
            to spectrum axes was done via simple shifting.  Metadata on
            parameter ranges from that epoch is called a scale and represents
            the number of bits of range of the parameter.  For example
            a scale of <literal>10</literal> means the parameter runs
            in the range of <literal>[0, 1024)</literal>.
        </para>
        <para>
            In the second phase of parameter history, SpecTcl parameters were
            still integers but the spectrum axes were labeled in an arbitrary
            range.  This sort of a parameter is called a <firstterm>mapped parameter</firstterm>
            because while it remains an integer, when looking at a spectrum,
            the spectrum axis can be mapped to some arbitrary range.
        </para>
        <para>
            Finally, SpecTcl parameters are full double precision values.
            These values are passed through a set of linear functions to map them from
            raw parameter space to axis space in the spectra in which they are
            used.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            In addition to the methods described, parameter objects can be
            copy constructed, assigned and compared for equality.  These
            canonical methods will not be described further here.
        </para>
        <variablelist>
            <varlistentry>
                <term><constructorsynopsis>
                    <methodname>CParameter</methodname>
                    <void />
                </constructorsynopsis></term>

                <listitem>
                    <para>
                        Constructs a parameter with an id of
                        <literal>UINT_MAX</literal> and a name of
                        <literal>Undefined</literal>.  The scale low and high
                        values are set to <literal>0.0</literal> and the
                        units to an empty string
                    </para>
                    <para>
                        The metadata initialization of this sort of parameter
                        makes it quite useless.  This constructor is intended
                        to produce a parameter definition that will eventually
                        be on the left hand side of an assignemnt from a
                        more meaningful parameter definition object.
                    </para>
                    <para>
                        The id of <literal>UINT_MAX</literal> will make adding
                        this parameter to the parameter dictionary and then actually
                        attempting to assign it a value via e.g. a tree parameter
                        cause SpecTcl to fail with a memory allocation as it
                        tries to expand the active <classname>CParameter</classname>
                        value to accommodate this parameter.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CParameter</methodname>
                        <methodparam>
                            <modifier>const</modifier><type> std::string&amp; </type>
                            <parameter>rName</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t</type><parameter>nId</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>char* </type><parameter>pUnits</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs a parameter named <parameter>rName</parameter>.
                        The parameter Id of the 
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>

                <term>
                    <constructorsynopsis>
                        <methodname>CParameter</methodname>
                        <methodparam>
                            <type>UInt_t </type><parameter>am_nScale</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier>const</modifier><type> std::string&amp;</type>
                            <parameter>rName</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type>
                            <parameter>nNumber</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs a parameter that is <parameter>am_nScale</parameter>
                        bits wide.  The name of the parameters is
                        <parameter>rName</parameter> and the id is
                        <parameter>nNumber</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CParameter(</methodname>
                        <methodparam>
                            <type>UInt_t </type><parameter>am_nScale</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier>const </modifier><type>std::string&amp; </type>
                            <parameter>rName</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type><parameter>nNumber</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t </type><parameter>nLow</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t </type><parameter>nHigh</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::string </type><parameter>am_sUnits</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates a parameter with metadata that indicates the
                        range of values the parameter may senisbly take.
                        <parameter>am_nScale</parameter> is obsolete in modern
                        times.  In the past, when mapped spectra existed,
                        this parameter was the number of bits of range of the
                        parameter.  Now, only <parameter>nLow</parameter>
                        and <parameter>nHigh</parameter> matter.
                        They are the recommended low and high limits
                        for an axis on this parameter.
                    </para>
                    <para>
                        As before, <parameter>rName</parameter> is the
                        name of the parameter and <parameter>nNumber</parameter>
                        is the parameter's id.  <parameter>am_sUnits</parameter>
                        are the units of measure string.  If this makes no sense,
                        simply provide an empty string.
		    </para>
                    <para>
                        This constructor was used to provide the capability
                        of mapping parameters with fixed bit width to some
                        arbitrary range of actual values.  It was used along
                        with the Xamine mapped spectrum capability, and the
                        <methodname>RawToMapped</methodname> as well as
                        <methodname>MappedToRaw</methodname> methods to
                        do something a lot less useful than what
                        arbitrarily ranged parameters and spectra
                        can accomplish.  As such, use of this constructor
                        is strongly discouraged.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Bool_t </type>
                        <methodname>hasScale</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>kfTRUE</literal> if the parameter
                        was constructed with a non-zero scale value.
                        Otherwise returns <literal>kfFALSE</literal> indicating
                        that the parameter range should be gotten from the
                        low and high range values or, may not have been supplied
                        at all (in which case low == high == 0.0).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>UInt_t </type>
                        <methodname>getScale</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the scale value.  This is only meaningful
                        if <methodname>hasScale</methodname> returns
                        <literal>kfTRUE</literal>.   While you an probably
                        guess what this returns when that's not the case
                        I'm not going to gaurantee you're correct either now
                        or in the future, so don't use that value instead of
                        <methodname>hasScale</methodname>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Float_t </type>
                        <methodname>getLow</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the low limit metadata for this parameter.
                        If limits were not provided,
                        both this and <methodname>getHigh</methodname> below
                        will return <literal>0.0</literal>.

                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Float_t </type>
                        <methodname>getHigh</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the high limit metadata for thsi parameter.
                        If limits were not provided, this and
                        <methodname>getLow</methodname> above will return
                        <literal>0.0</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>std::string </type>
                        <methodname>getUnits</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the units of measure string metadata for
                        this parameter.  If no units of measure were provided,
                        this returns an empty string.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Float_t </type>
                        <methodname>RawToMapped</methodname>
                        <methodparam>
                            <type>Float_t </type><parameter>Raw</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Float_t </type>
                        <methodname>MappedToRaw</methodname>
                        <methodparam>
                            <type>Float_t </type>
                            <parameter>Mapped</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        These methods are left over from the days  of
                        mapped spectra/parameters and should not be used
                        in new SpecTcl code.
                    </para>
                </listitem>
            </varlistentry>
  
  
        </variablelist>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CEvent</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CEvent</refname>
        <refpurpose>Destination for decoded event data.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;Event.h&gt;

typedef DFloat_t ParamType;
typedef std::vector&lt;DopedValidValue&lt;ParamType&gt; &gt; CParameterVector;
typedef DopedValidValue&lt;ParamType&gt;                     CParameterValue;
typedef CParameterVector::iterator                           CEventIterator;

class CEvent {
 public:
  CEvent();
  virtual ~CEvent() ;
  CEvent(UInt_t nInitialSize);
  CEvent(const CEvent&amp; aEvent);

  CEvent&amp; operator=(const CEvent&amp; aEvent);
  int operator==(const CEvent&amp; aEvent);
  int operator!=(const CEvent&amp; anEvent);
  
  CParameterValue&amp; operator[](UInt_t nParam);

  CEventIterator begin();
  CEventIterator end();
  UInt_t size() const;
  void clear();

  DopeVector&amp; getDopeVector();


};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <classname>CEvent</classname> objects are the base level object
            produced by the application of the event processing pipeline to
            a raw event.  The object looks very  much like a vector except
            that it expands as needed to allow the largest index to fit.
        </para>
        <para>
            The elements of a <classname>CEvent</classname> object are valid
            values.  Valid values know when they've been assigned to.  Event
            serial numbers are used to allow clearing the assignment status
            of the event in O(1) time.

        </para>
        <para>
            The first time a parameter has been assigned, its index is
            added to a <parameter>Dope Vector</parameter>.  The purpose of the
            dope vector is to improve histogramming efficiency.
            Where the spectrum type allowed, the histogrammer organizes
            histogrammers in lists of histograms that require a specific parameter
            id.  All such histograms for which this is not possible (e.g. summary
            spectra) make up a separate list.
        </para>
        <para>
            This organization means that rather than iterating over all
            defined histograms, the histogrammer can use the dope vector
            contents to restrict iteration to the set of histograms that
            require parameters that have been given values, and those
            histograms for which a required parameter does not exist.
            When events are sparse (typically) and many histograms have
            been defined, this provides a significant performance
            improvement.
        </para>
        <para>
            SpecTcl further recycles events after clearing them.  Over the long run,
            this means that events will no longer require costly expansion but
            will reach equilbrium lengths long enough to hold the highest parameter
            id.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            This class suppports assignment, copy  construction, and
            comparison for both equality and inequality.  Those
            methods are not documented in this section
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CEvent</methodname>
                        <void />
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs an event with an initial sizeof
                        <literal>0</literal> elements.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CEvent</methodname>
                        <methodparam>
                            <type>UInt_t</type><parameter>nInitialSize</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>

                        Creates a <classname>CEvent</classname> object with
                        an initial allocation of <parameter>nInitialSize</parameter>
                        parameters that don't have a valid value. Since
                        <classname>CEvent</classname> objects are recycled
                        from event to event, this constructor is not
                        actually much of an optimization over time.

                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CParameterValue&amp; </type>
                        <methodname>operator[]</methodname>
                        <methodparam>
                            <type>UInt_t </type><parameter>nParam</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a reference to the element at index
                        <parameter>nParam</parameter> in the event.  If
                        the event is not yet big enough to provide that element,
                        it is expanded with unset (not valid) elements until
                        it is.
                    </para>
                    <para>
                        The fact that a reference is returned allows this
                        to occur as an lvalue or rvalue.  If used as an
                        rvalue, an exception is thrown if the value has not
                        yet been assigned a value.  The exception is of
                        type <type>std::string</type> and is the value
                        "Attempted getValue of unset ValidValue object".
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventIterator </type>
                        <methodname>begin</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventIterator</type>
                        <methodname>end</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
		  <para>
		    Provides support for iteration over the parameters in a
		    <classname>CEvent</classname> in the STL sense of the word.
		  </para>
                  <para>
		    <methodname>begin</methodname>
                        returns an iterator to the first element in
                        the <classname>CEvent</classname>.  This is a pointer
                        like object to index <literal>0</literal>.  It is
                        possible, for an empty <classname>CEvent</classname>,
                        this value is the same as that returned by
                        <methodname>end</methodname>.
                    </para>
                    <para>
		      <methodname>end</methodname>
                        Returns an end of iteration iterator.  Note that
                        this is an end of iteration iterator at the time of
                        execution and could be invalidated.  Consider the
                        following code fragments where e is a
                        <classname>CEvent</classname>.
                    </para>
                    <programlisting>
CEventIterator p = e.begin();
CEventIterator end = e.end();
while (p != end) {

...
    p++;
}
                    </programlisting>
                    <para>
                        The loop above is potentially  not going to cover the
                        entire event as the body could do an assignment to
                        <varname>e</varname> that could extend the event,
                        in which case the assigned element would not be included
                        in the iteration.
                    </para>
                    <programlisting>
for (auto p = e.begin(); p != e.end(); p++) {
...
}
                    </programlisting>
                    <para>
                        This loop will always cover the array as the end iterator
                        is re-evaluated after each pass through the loop ensuring
                        that any additions to the event are accommodated.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>UInt_t </type>
                        <methodname>size</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        The <methodname>begin</methodname> and
                        <methodname>end</methodname> methods provide iteration
                        over the full event vector at its current size.
                        Iteration is supported in the same sense as it is
                        for C++ standard library iterators.
                        <methodname>size</methodname> returns the number
                        of elements currently in the vector.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>clear</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Sets all values in the event to invalid (not assigned).
                        This is done by SpecTcl after an event filled in by the
                        event processing pipeline has been passed though the
                        elements of the event sink pipeline.
                    </para>
                    <para>
                        This also clears the dope vector of the event.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>DopeVector&amp; </type>
                        <methodname>getDopeVector</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a reference to the current dope vector for
                        this event.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
      <title>DATA TYPES</title>
      <para>
        Several data types are defined oustide of the
        <classname>CEvent</classname> class by its header:
      </para>
        <variablelist>
            <varlistentry>
                <term>
                    <type>ParamType</type>
                </term>
                <listitem>
                    <para>
                        Defines the data type that is used for parameters
                        in the event object.  At this time ths is a double
                        precision real value.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <type>CParameterVector</type>
                </term>
                <listitem>
                    <para>
                        At any time, this is the data type that holds
                        the parameter values.  Currently this is a
                        <classname>std::Vector&lt;DopedValidValue&lt;Paramtype&gt; &gt;</classname>.
                    </para>
                    <para>
                        That is a valid value vector that has an associated dope vector.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <type>CParameterValue</type>
                </term>
                <listitem>
                    <para>
                        This is a doped valid value of type <type>ParamType</type>.
                        Doped value values have an associated dope vector and
                        an id.  When first assigned after being constructed or
                        reset they append their id to the dope vector.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>CEventIterator </type></term>
                <listitem>
                    <para>
                        Iterator through the <classname>CParameterVector</classname>
                        in a <classname>CEvent</classname> object.
                    </para>
                </listitem>
            </varlistentry>

        </variablelist>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CSpectrum</refentrytitle>
        <manvolnum>Spectrum classes</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CSpectrum</refname>
        <refpurpose>Classes implementing SpecTcl spectra</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
        <synopsis>
#include &lt;Spectrum.h&gt;

class CSpectrum  : public CNamedItem        
{
public:
  typedef std::vector&lt;CAxis&gt;  Axes;
  typedef Axes::iterator  AxisIterator;
  typedef struct SpectrumDefinition;
public:


  CSpectrum (const std::string&amp; rName,  UInt_t nId, Axes  Maps,
	     CGateContainer* pGate = pDefaultGate); 
  CSpectrum(const std::string&amp; rName, UInt_t nId,
	    CGateContainer*  pGate = pDefaultGate);

public:
  const Address_t getStorage() const;
  Bool_t getOwnStorage() const;
  const CGateContainer* getGate() const;
  Axes getAxisMaps() const;
  Int_t getAxisMapCount() const;
  std::string getTextDescription() const;
  virtual SpectrumType_t getSpectrumType() = 0;
              
protected:  
  void setStorage (Address_t am_pStorage);
  void setOwnStorage (Bool_t am_fOwnStorage);
  void setStorageType(DataType_t dt) ;
  void AddAxis(UInt_t nChannels, Float_t fLow,
	       Float_t fHigh, const std::string&amp; Units = std::string(""));
  bool checkRange(int channel, int nChans, int axis);
  

public:
  void operator() (const CEvent&amp; rEvent);
  CGateContainer* ApplyGate(CGateContainer* pNewGate);
  CGateContainer* Ungate();	// Sets the spectrum gate to a CTrueGate
  Bool_t UsesParameter (const CParameter&amp; rParameter) const;
  DataType_t StorageType () const;

  Float_t  ParameterToAxis(UInt_t nAxis, Float_t fParameterValue);
  Float_t AxisToParameter(UInt_t nAxis, UInt_t  nAxisValue);
  Float_t  MappedToAxis(UInt_t nAxis, Float_t fParameterValue);
  Float_t AxisToMapped(UInt_t nAxis, UInt_t nAxisValue);

  void createStatArrays(unsigned nAxes);
  void clearStatArrays();
  void logOverflow(unsigned axis, unsigned increment = 1);
  void logUnderflow(unsigned axis, unsigned increment = 1);
  std::vector&lt;unsigned&gt; getUnderflows() const;
  std::vector&lt;unsigned&gt; getOverflows() const;

  virtual   Bool_t UsesParameter(UInt_t nId) const   = 0;
  virtual   ULong_t operator[] (const UInt_t* pIndices) const  = 0;
  virtual   void set(const UInt_t* pIndices, ULong_t nValue)= 0;
  virtual   void GetParameterIds(std::vector&lt;UInt_t&gt;&amp; rvIds) = 0;
  virtual   void GetResolutions(std::vector&lt;UInt_t&gt;&amp;  rvResolutions) = 0;
  virtual   void Increment(const CEvent&amp; rEvent) = 0;

  virtual   Size_t Dimension (UInt_t nDimension) const;
  virtual   UInt_t Dimensionality () const;
  virtual   Float_t GetLow(UInt_t nDimension) const;
  virtual   Float_t GetHigh(UInt_t nDimension) const;
  virtual   std::string  GetUnits(UInt_t nDimension) const;

  virtual   void Copy(void* pStorage) const;
  virtual   void Clear ()  ;
  virtual   Size_t StorageNeeded () const;
  virtual   void ReplaceStorage (Address_t pNewLoc, 
				 Bool_t fTransferOwnership=kfTRUE)  ;
  virtual   Bool_t CheckGate(const CEvent&amp; rEvent);
  virtual   SpectrumDefinition&amp; GetDefinition() ;

  virtual   Bool_t needParameter() const;
  void setTextDescription(std::string d) ;


};

<beginpage />

#include &lt;BitSpectrumL.h&gt;       // BitSpectrumW.h for word spectra.

class CBitSpectrumL  : public CSpectrum  // CBitSpectrumW for word spectra.
{
public:
  CBitSpectrumL(const std::string&amp; rName, UInt_t nId,
		const CParameter&amp; rParameter,
		UInt_t nChannels);
  CBitSpectrumL(const std::string&amp; rName, UInt_t nId,
		const CParameter&amp; rParameter,
		UInt_t nLow,
		UInt_t nHigh);	

public:
  UInt_t getChannels() const;
  UInt_t getParameter() const;
  virtual SpectrumType_t getSpectrumType();

public:                 
  virtual   void Increment (const CEvent&amp; rEvent);
};

<beginpage />

#include &lt;CGammaSpectrum.h&gt;
class CGammaSpectrum : public CSpectrum
{
public:
  CGammaSpectrum(const std::string&amp; rName, UInt_t nId,  CSpectrum::Axes Maps,
		 std::vector&lt;CParameter&gt;&amp; Parameters,
		 CGateContainer* pGate = pDefaultGate);
  CGammaSpectrum(const std::string&amp; rName, UInt_t nId,  CSpectrum::Axes Maps,
		 std::vector&lt;CParameter&gt;&amp; xParameters,
		 std::vector&lt;CParameter&gt;&amp; yParameters,
		 CGateContainer* pGate = pDefaultGate);
  CGammaSpectrum(const std::string&amp; rName, UInt_t nId, 
		 std::vector&lt;CParameter&gt;&amp; Parameters,
		 CGateContainer* pGate = pDefaultGate);
  CGammaSpectrum(const std::string&amp; rName, UInt_t nId,
		 std::vector&lt;CParameter&gt;&amp; xParameters,
		 std::vector&lt;CParameter&gt;&amp; yParameters,
		 CGateContainer* pGate = pDefaultGate);
  virtual ~CGammaSpectrum();


protected:                   
  void setStorage (Address_t am_pStorage);
  void setOwnStorage (Bool_t am_fOwnStorage);
  void setStorageType(DataType_t dt) ;
  void AddAxis(UInt_t nChannels, Float_t fLow,
	       Float_t fHigh, const std::string&amp; Units = std::string(""));
  bool checkRange(int channel, int nChans, int axis);
  static Int_t Randomize(Float_t channel);

  void ReleaseStorage();
};

<beginpage />

#include &lt;BitSpectrumL.h&gt;       // BitSpectrumW.h for word spectra.

class CBitSpectrumL  : public CSpectrum  // CBitSpectrumW for word spectra.
{
public:
  CBitSpectrumL(const std::string&amp; rName, UInt_t nId,
		const CParameter&amp; rParameter,
		UInt_t nChannels);
  CBitSpectrumL(const std::string&amp; rName, UInt_t nId,
		const CParameter&amp; rParameter,
		UInt_t nLow,
		UInt_t nHigh);	

public:
  UInt_t getChannels() const;
  UInt_t getParameter() const;
  virtual SpectrumType_t getSpectrumType();

public:                 
  virtual   void Increment (const CEvent&amp; rEvent);
};

<beginpage />

#include &lt;CGammaSpectrum.h&gt;
class CGammaSpectrum : public CSpectrum
{
public:
  CGammaSpectrum(const std::string&amp; rName, UInt_t nId,  CSpectrum::Axes Maps,
		 std::vector&lt;CParameter&gt;&amp; Parameters,
		 CGateContainer* pGate = pDefaultGate);
  CGammaSpectrum(const std::string&amp; rName, UInt_t nId,  CSpectrum::Axes Maps,
		 std::vector&lt;CParameter&gt;&amp; xParameters,
		 std::vector&lt;CParameter&gt;&amp; yParameters,
		 CGateContainer* pGate = pDefaultGate);
  CGammaSpectrum(const std::string&amp; rName, UInt_t nId, 
		 std::vector&lt;CParameter&gt;&amp; Parameters,
		 CGateContainer* pGate = pDefaultGate);
  CGammaSpectrum(const std::string&amp; rName, UInt_t nId,
		 std::vector&lt;CParameter&gt;&amp; xParameters,
		 std::vector&lt;CParameter&gt;&amp; yParameters,
		 CGateContainer* pGate = pDefaultGate);
  virtual ~CGammaSpectrum();

public:

>>>>>>> Mere with master - this also catches changes to the filter.
  virtual void Increment(const CEvent&amp; rEvent);
  virtual void Increment(std::vector&lt; std::pair&lt;UInt_t, Float_t&gt; &gt; &amp; rParameters) =0;
  virtual void Increment(std::vector&lt; std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; xParameters,
			 std::vector&lt; std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; yParameters) = 0;
  Bool_t       haveFold();
  void         Fold(CGateContainer* pGate);
  CFold*       getFold();
  virtual void GetParameterIds(std::vector&lt;UInt_t&gt;&amp; rvIds);
  
  UInt_t getnParams() const;
  UInt_t getParameterId (UInt_t n) const;
 
protected:
  void CreateParameterList(std::vector&lt; std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; outList, 
			   const CEvent&amp; rEvent);
  void CreateYParameterList(std::vector&lt; std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; outList,
			    const CEvent&amp; rEvent);
  void CreateParameterVector(std::vector&lt;CParameter&gt;&amp; Parameters);
  void CreateYParameterVector(std::vector&lt;CParameter&gt;&amp; Parameters);

  
};

<beginpage />

#include &lt;Gamma1DL.h&gt;             // Also Gamma1DW.h

class CGamma1DL : public CGammaSpectrum // Also CGamma1DW
{
 public:
  CGamma1DL(const std::string&amp; rName, UInt_t nId,
	    std::vector&lt;CParameter&gt;&amp; rrParameters,
	    UInt_t nScale);	

  CGamma1DL(const std::string&amp; rName, UInt_t nId,
	    std::vector&lt;CParameter&gt;&amp; rrParameters,
	    UInt_t nChannels,
	    Float_t fLow, Float_t fHigh); 

 virtual SpectrumType_t getSpectrumType();


  virtual ULong_t operator[] (const UInt_t* pIndices) const;
  virtual void set (const UInt_t* pIndices, ULong_t nValue);
  
  virtual void Increment(std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; rParameters);
  virtual void Increment(std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; xParameters,
			 std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; yParameters);


  virtual void GetResolutions(std::vector&lt;UInt_t&gt;&amp; rvResolutions);

protected:
  static Axes MakeAxesVector(std::vector&lt;CParameter&gt; Params,
			      UInt_t             nChannels,
			      Float_t fLow, Float_t fHigh);
  void   CreateStorage();
};

<beginpage />
#include &lt;Gamma2DL.h&gt;   // Also 2DW and 2DB versions.

class CGamma2DL : public CGammaSpectrum
{
public:
  CGamma2DL(const std::string&amp; rName, UInt_t nId,
	       std::vector&lt;CParameter&gt;&amp; rParameters,
	       UInt_t nXScale, UInt_t nYScale);
  CGamma2DL(const std::string&amp; rName, UInt_t nId,
	    std::vector&lt;CParameter&gt;&amp; rParameters,
	    UInt_t nXScale, UInt_t nYScale,
	    Float_t xLow, Float_t xHigh,
	    Float_t yLow, Float_t yHigh);

public:
  UInt_t getXScale();
  UInt_t getYScale();
  virtual SpectrumType_t getSpectrumType();
  virtual void GetResolutions(std::vector&lt;UInt_t&gt;&amp;  rvResolutions);

  virtual void Increment(std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; rParameters);
  virtual void Increment(std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; xParameters,
			 std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; yParameters);
};
<beginpage />
#include &lt;Gamma2DD.h&gt;
template&lt;class T&gt;
class CGamma2DD : public CGammaSpectrum
{
public:
  CGamma2DD(const std::string&amp; rName, UInt_t nId,
	     std::vector&lt;CParameter&gt;&amp;  xParameters,
	     std::vector&lt;CParameter&gt;&amp;  yParameters,
	     UInt_t xChannels, UInt_t yChannels);
  
  CGamma2DD(const std::string&amp; rName, UInt_t nId,
	     std::vector&lt;CParameter&gt;&amp; xParameters,
	     std::vector&lt;CParameter&gt;&amp; yParameters,
	     UInt_t nXChannels, UInt_t nYChannels,
	     Float_t xLow, Float_t xHigh,
	     Float_t yLow, Float_t yHigh);
  virtual SpectrumType_t getSpectrumType();
  virtual void Increment(std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; rParameters);
  virtual void Increment(std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; rXParameters,
			 std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; rYParameters);



};


typedef CGamma2DD&lt;UInt_t&gt;  CGamma2DDL;
typedef CGamma2DD&lt;UShort_t&gt; CGamma2DDW;
typedef CGamma2DD&lt;UChar_t&gt;  CGamma2DDB;

<beginpage />
#include &lt;CGammaSummarySpectrum.h&gt;

template &lt;class T&gt;
class CGammaSummarySpectrum : public CSpectrum
{
public:
  CGammaSummarySpectrum(const std::string name, 
			UInt_t nId,
			UInt_t               nYChannels,
			std::vector&lt;std::vector&lt;CParameter&gt; &gt;* pParameters);
  CGammaSummarySpectrum(const std::string name, UInt_t nId,
			std::vector&lt;std::vector&lt;CParameter&gt; &gt;* pParameters,
			UInt_t               nYChannels,
			Float_t              fYLow,
			Float_t              fYHigh);


  virtual   void Increment (const CEvent&amp; rEvent)  ;
  virtual SpectrumType_t getSpectrumType();
};

typedef CGammaSummarySpectrum&lt;UInt_t&gt;   CGammaSummarySpectrumL;
typedef CGammaSummarySpectrum&lt;UShort_t&gt; CGammaSummarySpectrumW;
typedef CGammaSummarySpectrum&lt;UChar_t&gt;  CGammaSummarySpectrumB;

<beginpage />
#include &lt;Spectrum1DL.h&gt;   // also have Spectrum1DW.h

class CSpectrum1DL  : public CSpectrum   // Spectrum1DW.h -&gt; CSpectrum1DW
{
public:
  CSpectrum1DL(const std::string&amp;   rName, 
	       UInt_t               nId,
	       const CParameter&amp;    rParameter,
	       UInt_t               nChannels);

  CSpectrum1DL(const std::string&amp;   rName,
	       UInt_t               nId,
	       const   CParameter&amp;  rParameter,
	       UInt_t               nChannels,
	       Float_t              fLow, 
	       Float_t              fHigh);


  UInt_t getParameter();
  virtual SpectrumType_t getSpectrumType();
  virtual   void Increment (const CEvent&amp; rE);
};
<beginpage />
#include &lt;Spectrum2DL.h&gt; // 2DW and 2DB are also available.

class CSpectrum2DL  : public CSpectrum
{

public:
  CSpectrum2DL(const std::string&amp; rName, UInt_t nId,
	       const CParameter&amp; rXParameter,
	       const CParameter&amp; rYParameter,
	       UInt_t nXScale, UInt_t nYScale);

  CSpectrum2DL(const std::string&amp; rName, UInt_t nId,
	       const CParameter&amp; rXParameter,
	       const CParameter&amp; rYParameter,
	       UInt_t nXChannels, Float_t fxLow, Float_t fxHigh,
	       UInt_t nYChannels, Float_t fyLow, Float_t fyHigh);
  UInt_t getXParameter();
  UInt_t getYParameter();
  virtual SpectrumType_t getSpectrumType() ;
  virtual   void Increment (const CEvent&amp; rEvent)  ;

 
};
<beginpage />
#include &lt;SpectrumS.h&gt;

class CSpectrumS  : public CSpectrum
{
public:

  CSpectrumS(const std::string&amp;         rName, 
	       UInt_t                   nId,
	       const CParameter&amp;        rParameters,
	       const CParameter&amp;        nChannel,
	       UInt_t                    nChannels);

  CSpectrumS(const std::string&amp;         rName,
	       UInt_t                   nId,
	       const CParameter&amp;        rParameters,
 	       const CParameter&amp;        nChannel,
	       UInt_t                   nChannels,
	       Float_t                  fLow, 
	       Float_t                  fHigh);

  void ShiftDataUp (int64_t nShift);
  void ShiftDataDown(int64_t nShift);

  virtual SpectrumType_t getSpectrumType();
  virtual   void Increment (const CEvent&amp; rE);
};
<beginpage />
#include &lt;SummarySpectrumL.h&gt; //W and B versions also.

class CSummarySpectrumL  : public CSpectrum
{
public:
  CSummarySpectrumL(const std::string&amp; rName, UInt_t nId,
		    std::vector&lt;CParameter&gt; rrParameters,
		    UInt_t nYScale); 
  CSummarySpectrumL(const std::string&amp; rName, UInt_t nId,
		    std::vector&lt;CParameter&gt; rrParameters,
		    UInt_t nYScale,
		    Float_t fYLow,
		    Float_t fYHigh); 
  UInt_t getnParams() const ;
  UInt_t getParameterId(UInt_t n) const;
  virtual SpectrumType_t getSpectrumType();
  virtual   void Increment (const CEvent&amp; rEvent)  ;
  
};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <classname>CSpectrum</classname> is the base class for all spectrum
            classes.  SpecTcl has a rich set of spectra.  While there are
            many spectrum types often,  in practice, they are only differentiated
            by how they are constructed and how they increment spectra.
        </para>
        <para>
            The Spectra classes are amongst the oldest in SpecTcl.  There is
            certainly room for refactoring in the future.  There is also
            call for using templated types at some point (at the time
            these classes were written C++ Templates were not always
            reliably implemented by compilers).
        </para>
        <para>
            The remaining sections in this manpage provide information
            about the classes that provide base support as well as provide
            concrete implementations of specific spectrum types.
        </para>
        
    </refsect1>
    <refsect1>
        <title>CSpectrum METHODS</title>
        <para>
            The remaining sections in this manpage provide information
            about the classes that provide base support as well as provide
            concrete implementations of specific spectrum types.
        </para>
    </refsect1>
    <refsect1>
        <title>CSpectrum METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CSpectrum</methodname>
                        <methodparam>
                            <modifier>const </modifier><type>std::string&amp; </type>
                            <parameter>rName</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type><parameter>nId</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Axes  </type><parameter>Maps</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CGateContainer* </type><parameter>pGate</parameter>
                            <initializer> pDefaultGate</initializer>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        This constructor is used when construction time
                        provides sufficient information to provide
                        the axis definitions without computation.
                    </para>
                    <para>
                        <parameter>rName</parameter> and
                        <parameter>nId</parameter> provide the name and
                        Id of the new spectrum.  <parameter>Maps</parameter>
                        is a vector of axis definitions.
                    </para>
                    <para>
                        pGate is the gate to be applied to the spectrum.
                        <varname>pDefault</varname> gate points to a
                        gate container for the default gate which is a
                        <literal>True</literal> gate.
                    </para>                              
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CSpectrum</methodname>
                        <methodparam>
                            <modifier>const </modifier><type>std::string&amp; </type>
                            <parameter>rName</parameter>
                        </methodparam>
                        <methodparam>
                            <type> UInt_t</type><parameter> nId</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CGateContainer*  </type><parameter>pGate </parameter>
                            <initializer> pDefaultGate</initializer>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructor to use when a set of axes easily be
                        pre-built.  The protected method
                        <methodname>addAxis</methodname> can be used to
                        add axis definitions one-by-one to the spectrum.
                        The remaining parameters have the same meaning
                        as for the previousl constructor.
                    </para>

                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>const </modifier>
                        <type>Address_t </type>
                        <methodname>getStorage</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the storage associated with the
                        histogram.  Note that this SpecTcl can maintain
                        spectra which are purely local or it can locate
                        spectra in a shared memory region so that local
                        display programs can access bulk spectrum storage
                        quickly.
                    </para>
                    <para>
                        Closely associated with this pointer, therefore,
                        is the concept of storage ownership.  The spectrum
                        storage is said to be owned by the spectrum
                        object if, on destruction it the storage can be
                        released via the <literal>delete</literal> operator.
                        If storage is not owned by the spectrum, it must
                        not be deleted on destruction.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>ool_t </type>
                        <methodname>getOwnStorage</methodname>
                        <void />
                        <modifier> const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>

                        Spectrum storage may have been dynamically allocated
                        by the spectrum object, or may belong to some other
                        object.  This method returns
                        <literal>kfTRUE</literal> if the spectrum storage
                        has been allocated by this object.
                    </para>
                    <para>
                        One case when this may return <literal>kfFALSE</literal>
                        is a spectrum that has been bound into displayer shared
                        memory when the storage is owned by the object that
                        manages the shared memory region.
                    </para>
                    <para>
                        Storage that is owned by this object may be
                        <literal>delete</literal>d if appropriate.  Storage
                        not owned is released to the custody/management of
                        the owner (e.g. for Display shared memory the space
                        is released for re-use by other spectra).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>const </modifier>
                        <type>CGateContainer* </type>
                        <methodname>getGate</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>

                        Returns the pointer to the
                        <classname>CGateContainer</classname> object that
                        holds the gate applied to this spectrum.  Gate
                        containers are named, pointer like objects that
                        contain a SpecTcl gate.   They provide another level
                        of indirection that allows gates to be replaced
                        without requiring that clients of those gates
                        be notified.
                    </para>
                    <para>
                        The rule is that the gate dictionary contains gate
                        containers that, once created, are never destroyed
                        while gate clients will contain pointers to those
                        gate containers which, in turn provide a fixed
                        point of reference for the gate regardless of what
                        might happen to change the gate later.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Axes </type>
                        <methodname>getAxisMaps</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Int_t </type>
                        <methodname>getAxisMapCount</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        <methodname>getAxisMaps</methodname>
                        returns the vector of
                        <classname>CAxis</classname> objects associated
                        with this spectrum.   Each axis object defines
                        how raw parameter values are mapped to
                        bins on a channel.
                    </para>
                    <para>
                        In general, element 0 of this vector describes the
                        X axis while, if the spectrum is 2-d element 1
                        describes the Y axis.
                        An exception to this are summary spectra which only have
                        an axis definition for the Y axis as the X axis is
                        defined by the number of parameters summarized.
                    </para>
                    <para>
                        <methodname>getAxisMapCount</methodname> returns the
                        number of elements in the axis map vector.
                        it is equivalent to <literal>aspec.getAxisMaps().size()</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>std::string </type>
                        <methodname>getTextDescription</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>

                        This method is an optimization that caters to large
                        analysis cases.  Perfomance analysis showed that the
                        <command>spectrum -list</command> command required
                        a significant amount of time to build spectrum
                        descriptions for analysis cases with large (1000's)
                        numbers of spectra.
                    </para>
                    <para>
                        The <classname>CSpectrum</classname> class therefore
                        has an attribute in to which the
                        spectrum description string can be written when the
                        spectrum is created (e.g. by
                        <command>spectrum -new</command>).  This
                        method returns the value stored in that attribute.

                    </para>
                    <para>
                        This method provides the capability for SpecTcl
                        to cache the Tcl description of a spectrum
                        normally produced by <command>spectrum -list</command>.
                        This was added because when there are a large number
                        of spectra, computing the spectrum definition string
                        can be very time consuming.  Therefore, SpecTcl's
                        <command>spectrum</command> command now computes
                        this string on spectrum creation.
                    </para>
                    <para>
                        The SpecTcl <command>spectrum -list</command> command
                        uses this cached spectrum description string.  If, however,
                        the string is empty, it computes the description string
                        ab intio, caches that string in the spectrum to satisfy
                        future requests and uses the computed string when
                        producing its returned value.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>SpectrumType_t </type>
                        <methodname>getSpectrumType</methodname>
                        <void />
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This pure virtual method must be implemented by concrete
                        spectrum type classes.  It is expected to return the
                        actual spectrum type.  Note that if new
                        spectrum types are implemented
                        <filename>histotypes.h</filename> must be updated
                        to extend the <type>SpectrumType_t</type> enumerated
                        data type.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>void </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                            <modifier>const </modifier><type>CEvent&amp; </type>
                            <parameter>rEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Process the implications of an event;
                        <parameter>rEvent</parameter> for this spectrum.
                        While this method is virtual, the base class implementation
                        is normally sufficient.  The base class implemebntaton
                        checks the gate applied to this spectrum and, if satisfied,
                        invokes the <methodname>Increment</methodname> method for
                        this spectrum. 
                    </para>
                    <para>
                        Normally only the <methodname>Increment</methodname>
                        method needs to be implemented for spectrum event
                        processing to work properly.
                    </para>
                    <para>
                        Note that there is no gaurantee that this method
                        will be invoked for all events.   SpecTcl's histogramming
                        subsystem and the dope arrays in <classname>CEvent</classname>
                        collaborate to minimize the number of histograms
                        that must be invoked for each event.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CGateContainer* </type>
                        <methodname>ApplyGate</methodname>
                        <methodparam>
                            <type>CGateContainer* </type><parameter>pNewGate</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Applies a new gate specified by
                        the gate container <parameter>pNewGate</parameter> to the
                        spectrum.  The previously applied gate container is
                        returned.  From now on <parameter>pNewGate</parameter> is
                        checked by <methodname>operator()</methodname> and must
                        be satisfied for that method to call
                        <methodname>Increment</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CGateContainer* </type>
                        <methodname>Ungate</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Ungates the spectrum and returs the pointer to the
                        previously applied gate container.  Note that spectra
                        are never actually ungated. This method applies
                        a predefined gate container that points to a
                        <literal>true</literal> gate ensuring that
                        <methodname>operator()</methodname> will always
                        invoke <methodname>increment</methodname> when
                        called.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Bool_t </type>
                        <methodname>UsesParameter </methodname>
                        <methodparam>
                            <modifier>const</modifier>
                            <type> CParameter&amp; </type><parameter>rParameter</parameter>
                        </methodparam>
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If the spectrum uses 
                        <parameter>rParameter</parameter>, this method returns
                        <literal>kFTRUE</literal>, otherwise it returns
                        <literal>kfFALSE</literal>.
                    </para>
                    <para>
                        Note the difference between uses and required.
                        For example, a summary spectrum has no required parameters
                        but uses all of the parametersa in its definition.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>DataType_t </type>
                        <methodname>StorageType </methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>

                        Returns the type of channel the spectrum contains.
                        See the definition of
                        <type>DataType_t</type> in
                        <filename>histottypes.h</filename> for the possible
                        values this method can return.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Float_t  </type>
                        <methodname>ParameterToAxis</methodname>
                        <methodparam>
                            <type>UInt_t </type><parameter>nAxis</parameter>
                        </methodparam>
                        <methodparam>
                            <type> Float_t </type><parameter>fParameterValue</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Given a raw parameter value <parameter>fParameterValue</parameter>,
                        converts it to a bin number on the spectrum axis
                        indexed by <parameter>nAxis</parameter>.  The resulting
                        bin number is returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Float_t </type>
                        <methodname>AxisToParameter</methodname>
                        <methodparam>
                            <type>UInt_t </type><parameter>nAxis</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t  </type><parameter>nAxisValue</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Inverse transformation from <methodname>ParameterToAxis</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>createStatArrays</methodname>
                        <methodparam>
                            <type>unsigned </type><parameter>nAxes</parameter>
                        </methodparam>
                        <modifier>const</modifier>

                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        With Root integration, <methodname>createStatArrays</methodname>
                        is obsolete, but provided for compatibility sake.
                        Prior to version 5.0, SpecTcl maintained over/underflow
                        statistics in separate arrays called statistics arrays,
                        one element per axis.  With Root integration, SpecTcl
                        histograms encapsulate a <classname>TH1</classname>
                        or <classname>TH2</classname> derived root class.
                        Those types of spectra maintain over/underflow
                        statistics in additional channels of the spectrum.
                    </para>
                </listitem>
            </varlistentry>  
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>clearStatArrays</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Clears overflow and underflow statistics for the spectrum.
                        With Root integration, this method is somewhat misnamed.
                        In 5.0 and later, SpecTcl spectra are wrappers around
                        <classname>TH1</classname> or <classname>TH2</classname>
                        subclasses.  These maintain over/underflow counts
                        in addtional spetrum channels.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>logOverflow</methodname>
                        <methodparam>
                            <type>unsigned </type><parameter>axis,</parameter>
                        </methodparam>
                        <methodparam>
                            <type>unsigned </type><parameter>increment </parameter>
                            <initializer>1</initializer>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>logUnderflow</methodname>
                        <methodparam>
                            <type>unsigned </type><parameter>increment </parameter>
                            <initializer>1</initializer>
                        </methodparam>                
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        These two methods are completely obsolete and are
                        only present for compatibility sake.  With
                        5.0's root integration, all SpecTcl histograms
                        are wrappers around root
                        <classname>TH1</classname> and
                        <classname>TH2</classname> objects.  The
                        <methodname>Fill</methodname> method of these
                        objects maintains over/underflow statistics in addional
                        channels of the spectrum.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>std::vector&lt;unsigned&gt; </type>
                        <methodname>getUnderflows</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>std::vector&lt;unsigned&gt; </type>
                        <methodname>getOverflows</methodname>
                        <void />
                        <modifier> const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the over/underlflow counters for the
                        histogram.
                    </para>
                    <para>
                        The return value is a vector.  The vector has one element
                        for 1-d spectra and two elements for 2-d spectra.
                    </para>
                    <para>
                        5.0 integrates with Root.  Underflows and
                        overflows are stored in extra channels of the
                        histogram.
                    </para>
                    <para>
                        For 1-d spectra, these methods are trivial.  Underflows
                        are stored in channel 0 and overflows are stored
                        in channel <literal>n+1</literal> (n the number of
                        bins on the X axis).
                    </para>
                    <para>
                        For 2-d spectra, summing must be done.  For example,
                        X underflows are the sum of all channels with coordinates
                        [0, i] where i is in the range [1, n], n the number of
                        channels in the spectrum.  Similarly, Y underflows are
                        summed over all X with Y = 0.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Float_t </type>
                        <methodname>AxisToParameter</methodname>
                        <methodparam>
                            <type>UInt_t </type><parameter>nAxis</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t  </type><parameter>nAxisValue</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Inverse transformation from <methodname>ParameterToAxis</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>createStatArrays</methodname>
                        <methodparam>
                            <type>unsigned </type><parameter>nAxes</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        With Root integration, <methodname>createStatArrays</methodname>
                        is obsolete, but provided for compatibility sake.
                        Prior to version 5.0, SpecTcl maintained over/underflow
                        statistics in separate arrays called statistics arrays,
                        one element per axis.  With Root integration, SpecTcl
                        histograms encapsulate a <classname>TH1</classname>
                        or <classname>TH2</classname> derived root class.
                        Those types of spectra maintain over/underflow
                        statistics in additional channels of the spectrum.
                    </para>
                </listitem>
            </varlistentry>  
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>clearStatArrays</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Clears overflow and underflow statistics for the spectrum.
                        With Root integration, this method is somewhat misnamed.
                        In 5.0 and later, SpecTcl spectra are wrappers around
                        <classname>TH1</classname> or <classname>TH2</classname>
                        subclasses.  These maintain over/underflow counts
                        in addtional spetrum channels.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>logOverflow</methodname>
                        <methodparam>
                            <type>unsigned </type><parameter>axis,</parameter>
                        </methodparam>
                        <methodparam>
                            <type>unsigned </type><parameter>increment </parameter>
                            <initializer>1</initializer>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>logUnderflow</methodname>
                        <methodparam>
                            <type>unsigned </type><parameter>axis,</parameter>
                        </methodparam>
                        <methodparam>
                            <type>unsigned </type><parameter>increment </parameter>
                            <initializer>1</initializer>
                        </methodparam>                
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        These two methods are completely obsolete and are
                        only present for compatibility sake.  With
                        5.0's root integration, all SpecTcl histograms
                        are wrappers around root
                        <classname>TH1</classname> and
                        <classname>TH2</classname> objects.  The
                        <methodname>Fill</methodname> method of these
                        objects maintains over/underflow statistics in addional
                        channels of the spectrum.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>std::vector&lt;unsigned&gt; </type>
                        <methodname>getUnderflows</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>std::vector&lt;unsigned&gt; </type>
                        <methodname>getOverflows</methodname>
                        <void />
                        <modifier> const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the over/underlflow counters for the
                        histogram.
                    </para>
                    <para>
                        The return value is a vector.  The vector has one element
                        for 1-d spectra and two elements for 2-d spectra.
                    </para>
                    <para>
                        5.0 integrates with Root.  Underflows and
                        overflows are stored in extra channels of the
                        histogram.
                    </para>
                    <para>
                        For 1-d spectra, these methods are trivial.  Underflows
                        are stored in channel 0 and overflows are stored
                        in channel <literal>n+1</literal> (n the number of
                        bins on the X axis).
                    </para>
                    <para>
                        For 2-d spectra, summing must be done.  For example,
                        X underflows are the sum of all channels with coordinates
                        [0, i] where i is in the range [1, n], n the number of
                        channels in the spectrum.  Similarly, Y underflows are
                        summed over all X with Y = 0.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>Bool_t</type>
                        <methodname> UsesParameter</methodname>
                        <methodparam>
                            <type>UInt_t </type><parameter>nId</parameter>
                        </methodparam>
                        <modifier>const   = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This pure virtual method must be implemented by
                        concrete spectrum classes. <parameter>nId</parameter>
                        is a parameter id.  The method returns
                        <literal>kfTRUE</literal> if the parameter specified
                        by that id is used by the spectrum.  Otherwise, it
                        returns <literal>kfFALSE</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>ULong_t </type>
                        <methodname>operator[] </methodname>
                        <methodparam>
                            <modifier>const </modifier><type>UInt_t* </type>
                            <parameter>pIndices</parameter>
                        </methodparam>
                        <modifier> const  = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This pure virtual method must be implemented bvy any concrete.
                        spectrum class.  <parameter>pIndices</parameter> points
                        to one (1-d spectra) or two (2-d spectra) axis bin
                        numbers. The method returns the contents of the
                        bin at that coordinate.  An exception such as
                        <classname>std::range_error</classname> is thrown
                        if one or more of the indices is out of range.
                    </para>
                    <para>
                        Note that with Root integration, Spectra aer
                        wrappers around <classname>TH1</classname> or
                        <classname>TH2</classname> derived objects.  These
                        methods may be used to index the over/underflow
                        channels of these objects as well as the regular
                        channels.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier> virtual   </modifier>
                        <type>void </type>
                        <methodname>set</methodname>
                        <methodparam>
                            <modifier>const </modifier><type>UInt_t* </type>
                            <parameter>pIndices</parameter>
                        </methodparam>
                        <methodparam>
                            <type>ULong_t </type><parameter>nValue</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This pure virtual member allows you to store a
                        <parameter>nValue</parameter> at the axis bin indices
                        selected by <parameter>pIndices</parameter>.
                        As with <methodname>operator[]</methodname>,
                        <parameter>pInidices</parameter> points to a one or
                        two element array containing the X axis bin number and,
                        if the spectrum is 2d the Y axis bin number to modify.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>GetParameterIds</methodname>
                        <methodparam>
                            <type>std::vector&lt;UInt_t&gt;&amp; </type>
                            <parameter>rvIds</parameter>
                        </methodparam>
                        
                        <modifier>=0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        <parameter>rvIds</parameter> will be given the set of
                        parameter ids used by the spectrum.  The concreate class
                        should implement this method so that on return
                        <parameter>rvIds</parameter> <emphasis>only</emphasis>
                        contains the parameter ids.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>void </type>
                        <methodname>GetResolutions</methodname>
                        <methodparam>
                            <type>std::vector&lt;UInt_t&gt;&amp;  </type>
                            <parameter>rvResolutions</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        On return from this method call,
                        <parameter>rvResolutions</parameter> will be a vector
                        containing the number of channels in each axis of the
                        spectrum.  Element 0 of <parameter>rvResolutions</parameter>
                        will be the number of channels on the X axis and,
                        if the spectrum is 2-d, element 1 will be the number
                        of channels on the y axis.
                    </para>
                    <para>
                        Note that summary spectra are an exception in that
                        they only have a settable Y axis.   Calling this method
                        on summary spectra will return a single element vector
                        containing the number of channels on the
                        <emphasis>Y</emphasis> axis.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>void </type>
                        <methodname>Increment</methodname>
                        <methodparam>
                            <modifier>const</modifier> <type> CEvent&amp; </type>
                            <parameter>rEvent</parameter>
                        </methodparam>
                        <modifier>=0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Given an event which can be assumed to satisfy the
                        spectrum's gate, this method should increment the
                        channel(s) appropriate to the contents of the event.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type> UInt_t</type>
                        <methodname> Dimensionality </methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the spectrum dimensionality.  This the number
                        of axes that have controllable resolutions.  Note that
                        summary spectra, while they are 2-d spectra only have a
                        Y axis with a controllable resolution.  Summary spectra
                        will therefore return <literal>1</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>Size_t </type>
                        <methodname>Dimension </methodname>
                        <methodparam>
                            <type>UInt_t </type><parameter>nDimension</parameter>
                        </methodparam>
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of channels in dimension
                        <parameter>nDimension</parameter>.  As usual,
                        with the exception of summary spectra,
                        <literal>0</literal> specifies the X dimension
                        while <literal>1</literal> specifies the y.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>Float_t </type>
                        <methodname>GetLow</methodname>
                        <methodparam>
                            <type>UInt_t</type><parameter> nDimension</parameter>
                        </methodparam>
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the axis low limit for the axis number
                        <parameter>nDimension</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>Float_t </type>
                        <methodname>GetHigh</methodname>
                        <methodparam>
                            <type>UInt_t </type><parameter>nDimension</parameter>
                        </methodparam>
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the high limit of the axis selected by
                        <parameter>nDimension</parameter>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>std::string  </type>
                        <methodname>GetUnits</methodname>
                        <methodparam>
                            <type>UInt_t </type><parameter>nDimension</parameter>
                        </methodparam>
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the units of measure of the axis selected by
                        <parameter>nDimension</parameter>.  This will
                        will be an empty string if no axis units were
                        specified.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>void </type>
                        <methodname>Copy</methodname>
                        <methodparam>
                            <type>void* </type><parameter>pStorage</parameter>
                        </methodparam>
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Since SpecTcl can relocate spectra in an out of
                        shared memory this method is provided to support that
                        relocation.
                        <methodname>Copy</methodname> copies the contents of this
                        spectrum into storage pointed to by
                        <parameter>pStorage</parameter>.  It is the responsibility
                        of the caller to ensure that this points to sufficient
                        storage.
                    </para>
                    <para>
                        Note that <methodname>StorageNeeded</methodname>
                        can be used not only to determine how much storage
                        is required but to allow this method to be correctly
                        implemented in the base class.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>void </type>
                        <methodname>Clear </methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Clears the spectrum.  This also clears the
                        over/underflow counters.  For most spectra,
                        the base class implementation is sufficient.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>Size_t </type>
                        <methodname>StorageNeeded</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of bytes of storage required
                        for this spectrum.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>void </type>
                        <methodname>ReplaceStorage</methodname>
                        <methodparam>
                            <type>Address_t </type><parameter>pNewLoc</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Bool_t </type><parameter>fTransferOwnership</parameter>
                            <initializer>kfTRUE</initializer>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Replaces the storage associated with the spectrum
                        with <parameter>pNewLoc</parameter>. If there's already
                        storage associated with the spectrum, its contents are
                        copied into <parameter>pNewLoc</parameter> using the
                        <methodname>Copy</methodname> method.
                        If the storage is owned by the spectrum,
                        <methodname>ReleaseStorage</methodname> is called to
                        free it.  Finally, the value of
                        the storage storage ownership flag is
                        set to the value of
                        <parameter>fTransferOwnership</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>Bool_t </type>
                        <methodname>CheckGate</methodname>
                        <methodparam>
                            <modifier>const</modifier>
                            <type> CEvent&amp; </type><parameter>rEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>kfTRUE</literal> if the event
                        <parameter>rEvent</parameter> satisfies the gate
                        that is currently applied to thsi spectrum.
                        If not, returns <literal>kfFALSE</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>SpectrumDefinition&amp; </type>
                        <methodname>GetDefinition</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a struct that describes the spectrum.
                        See <literal>TYPES</literal> below for
                        more information about the fields in the
                        <type>SpectrumDefinition</type> data type.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type> Bool_t </type>
                        <methodname>needParameter</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This is used by SpecTcl's histogramming object to organize
                        spectra.  Some spectra require the existence of at least
                        one specific parameter (e.g. 1-d or 2-d spectra).  These
                        spectra are placed in lists organized by the id of the
                        first parameter needed.
                    </para>
                    <para>
                        Other spectra can't make the statement that some specific
                        parameter is required for them to be incremented
                        (e.g. Summary spectra and all types of gamma spectra).
                        These are placed in a list and must have their
                        <methodname>operator()</methodname> called for every event.
                    </para>
                    <para>
                        This method returns <literal>kfTRUE</literal> if this spectrum
                        has a parameter that is required for the spectrum
                        to be incremented.  If not, <literal>kfFALSE</literal> is
                        returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>setTextDescription</methodname>
                        <methodparam>
                            <type>std::string </type><parameter>d</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Computing spectrum definition strings can be costly and
                        adds up rapidly for analysis cases with several hundreds
                        or even thousands of spectra.  This method allows a
                        description string to be cached with the spectrum so that it
                        can be fetched with <methodname>getTextDescription</methodname>.
                        <parameter>d</parameter> will be the new cached spectrum
                        description string.
                    </para>
                    <para>
                        SpecTcl makes use of this description caching to vastly
                        improve the performance of <command>spectrum -list</command>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>protected</modifier>
                        <type>void </type>
                        <methodname>setStorage </methodname>
                        <methodparam>
                            <type>Address_t </type><parameter>am_pStorage</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This simply sets the private member data holding the
                        pointer to the spectrum storage with
                        <parameter>am_pStorage</parameter>.
                        <methodname>ReplaceStorage</methodname> is preferred
                        as it takes care of copying current spectrum data and,
                        if appropriate, deleting prior storage.
                        This method is provided if a concrete spectrum class
                        has specific, special storage management requirements.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>protected</modifier>
                        <type>void </type>
                        <methodname>setOwnStorage </methodname>
                        <methodparam>
                            <type>Bool_t </type>
                            <parameter>am_fOwnStorage</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Sets the storage ownership flag to
                        <parameter>am_fOwnStorage</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>protected</modifier>
                        <type>void </type>
                        <methodname>setStorageType</methodname>
                        <methodparam>
                            <type>DataType_t </type><parameter>dt</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Intended for use by specific, concrete constructors.
                        This method sets the spectrum data type element to
                        <parameter>dt</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>protected</modifier>
                        <type>void </type>
                        <methodname>AddAxis</methodname>
                        <methodparam>
                            <type>UInt_t </type><parameter>nChannels</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t </type><parameter>fLow</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t </type><parameter>fHigh</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>std::string&amp; </type><parameter>Units</parameter>
                            <initializer>std::string("")</initializer>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is intended for use by constructors that
                        must incrementally add axis definitions to a spectrum.
                        This method adds a single axis definition for
                        an axis with <parameter>nChannels</parameter> bins,
                        that represent parameter values in the range
                        [<parameter>fLow</parameter>, <parameter>fHigh</parameter>).
                    </para>
                    <para>
                        If supplied, <parameter>Units</parameter> is saved
                        as the units of measure for the axis.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>protected</modifier>
                        <type>bool </type>
                        <methodname>checkRange</methodname>
                        <methodparam>
                            <type>int </type>
                            <parameter>channel</parameter>
                        </methodparam>
                        <methodparam>
                            <type>int </type><parameter>nChans</parameter>
                        </methodparam>
                        <methodparam>
                            <type>int </type><parameter>axis</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is obsolete.  It checks that a avlue
                        <parameter>channel</parameter> is in the range
                        [<literal>0</literal>, <parameter>nChans</parameter>).
                        If so, the method returns <literal>true</literal>.  If
                        not either <methodname>logUnderflow</methodname>
                        or <methodname>logOverflow</methodname> is called
                        as appropriate and <literal>false</literal>
                        is returned.
                    </para>
                    <para>
                        THe method is obsolete because with SpecTcl 5.0
                        root integration, the spectrum classes are wrappers
                        around
                        <classname>TH1</classname> and
                        <classname>TH2</classname> derived objects.  Those
                        objects maintain overflows and underflows via calls to
                        <methodname>Fill</methodname>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>protected</modifier>
                        <type>void </type>
                        <methodname>ReleaseStorage</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Frees storage associated with the spectrum.
                        This should only be called if the
                        spectrum owns its storage.
                    </para>
                </listitem>
            </varlistentry>
  

        </variablelist>
    </refsect1>
    <refsect1>
        <title>TYPES</title>
        <variablelist>
            <varlistentry>
                <term>Axes</term>
                <listitem>
                    <para>
                        Spectra have a vector of <classname>CAxis</classname>
                        objects.  Each object defines an axis and, more importantly,
                        the mapping function between raw parameters and bins
                        on that axis.  
                    </para>
                    <para>
                        See <classname>CAxis</classname> for more information
                        about this class.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>AxisIterator</term>
                <listitem>
                    <para>
                        Defines an iterator into the collection of axes
                        a spectrum maintains.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>SpectrumDefinitions</term>
                <listitem>
                    <para>
                        Spectra require a uniform description.  The
                        <type>SpectrumDefinition</type> struct
                        provides that type.  It has the following
                        members:
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term><type>std::string </type><structfield>sName</structfield></term>
                            <listitem>
                                <para>
                                    Contains the name of the spectrum.
                                    
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><type>UInt_t </type><structfield>nId</structfield></term>
                            <listitem>
                                <para>
                                    The id of the spectrum.  This is a  positive
                                    integer that no longer has much m eaning in
                                    SpecTcl.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><type>SpectrumType_t </type><structfield>eType</structfield></term>
                            <listitem>
                                <para>
                                    This is an enumerated value that contains
                                    the spectrum type.  Valid values are
                                    <literal>ke1D, ke12D, keBitmask, keSummary,
                                    keG1D, keG2d, keUnknown, keStrip, keG2DD, keGSummary</literal>.
                                </para>
                                <para>
                                    As each specific spectrum class is introduced,
                                    its type is given as well.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><type>DataType_t </type><structfield>eDataType</structfield></term>
                            <listitem>
                                <para>
                                    An enumerated value containing the data
                                    type for the spectrum channels.  This is
                                    one of
                                    <literal>keByte, keWord, keLong, keFloat, keDouble,
                                    keUnknown_dt</literal>.  With reasonably
                                    obvious meanings. 
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><type>std::vector&lt;UInt_t&gt;  </type><structfield> vParameters</structfield></term>
                            <listitem>
                                <para>
                                    A vector containing the parameter ids of the
                                    parameters on the x axis the spectrum.  Note
                                    that for 1D spectra ther only is an X axis
                                    hence the lack of a qualifier on the name.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><type>std::vector&lt;UInt_t&gt; </type><structfield>vyParameters</structfield></term>
                            <listitem>
                                <para>
                                    Ids of the parameters on the Y axis.  For 1D
                                    spectra this will be an empty vector.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><type>std::vector&lt;UInt_t&gt;</type><structfield>nChannels</structfield></term>
                            <listitem>
                                <para>
                                    Vector containing the number of channels on
                                    various spectrum axes.  Element 0
                                    is the number of parameters on the X axis.
                                    If the spectrum is a 2-D spectrum,
                                    element 1 will be the number of channels
                                    on the Y axis.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><type>std::vector&lt;Float_t&gt; </type><structfield>fLows</structfield></term>
                            <listitem>
                                <para>
                                    Vector of axis low limits.  For each
                                    element in <structfield>nChannels</structfield>,
                                    a corresponding element in this vector
                                    provides the low limit of the axis in
                                    real world coordinates.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><type>std::vector&lt;Float_t&gt; </type><structfield>fHighs</structfield></term>
                            <listitem>
                                <para>
                                    Similar to <structfield>fLows</structfield>
                                    but provides the real world coordinates of
                                    axis high limits.
                                </para>
                            </listitem>
                        </varlistentry>
                        
                    </variablelist>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title>Bitmask spectra</title>
        <para>
            Bit mask spectra are defined on a single parameter.  They assume
            the parameter is actually an integer and increment a channel for
            each bit set in the parameter (as an integer).  Two types of
            bit mask spectra are defined;
            <itemizedlist>
                <listitem>
                    <para>
                        <classname>CBitSpectrumL</classname>, defined in
                        <filename>BitSpectrumL.h</filename>, defines a spectrum
                        whose channels are all longwords (32 bits wide)
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <classname>CBitSpectrunmW</classname>, defined in
                        <filename>BitSpectrumW.h</filename>, defines a spectrum
                        whose channels are all 16 bits wide.
                    </para>
                </listitem>
            </itemizedlist>
        </para>
        <para>
            This section will only document the methods of significance that either
            have special implementation or have not been documented for
            <classname>CSpectrum</classname>
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CBitSpectrumL</methodname>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>std::string&amp; </type><parameter>rName</parameter>
                        </methodparam>
                        <methodparam>
                            <type> UInt_t</type><parameter> nId</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier>const</modifier>
                            <type> CParameter&amp; </type><parameter>rParameter</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type><parameter>nChannels</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        In this constructor, <parameter>rName</parameter> is
                        the name of the spectrum being created and
                        <parameter>nId</parameter> its id.
                        <parameter>rParameter</parameter> defines the parameter
                        that is used to increment the spectrum.
                        <parameter>nChannels </parameter>.
                    </para>
                    <para>
                        The spectrum will increment for hte bottom
                        <parameter>nChannels</parameter> bits in
                        <parameter>rParameter</parameter>.  It, therefore has
                        an X axis with a range <literal>[0, <parameter>nChannels</parameter>)</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CBitSpectrumL</methodname>
                        <methodparam>
                            <modifier>const</modifier><type> std::string&amp; </type>
                            <parameter>rName</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t</type><parameter> nId</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier>const</modifier><type> CParameter&amp; </type>
                            <parameter>rParameter</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t</type><parameter>nLow</parameter> 		
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type><parameter>nHigh</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        This constructor creates a bit mask spectra that increments
                        for bit numbers in the range of
                        <literal>[<parameter>nLow</parameter>, <parameter>nHigh</parameter>)</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>UInt_t </type>
                        <methodname>getChannels</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of channels in the spectrum.
                        This will also be the number of bits in the range
                        of bits the spectrum displays.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>UInt_t </type>
                        <methodname>getParameter</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the id of the parameter the spectrum is
                        defined on.  This will be the id of the
                        <parameter>rParameter</parameter> parameter passsed to
                        the constructor.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>SpectrumType_t </type>
                        <methodname>getSpectrumType</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the value <literal>keBitMask</literal>
                        indicating this is a bit mask spectrum.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>void </type>
                        <methodname>Increment </methodname>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>CEvent&amp; </type><parameter>rEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If the parameter the spectrum was constructed on was
                        assigned a value in <parameter>rEvent</parameter>,
                        it is converted to a 32 bit integer.
                        For every bit that is set in that spectrum within the
                        range of bits the X axis covers, the appropriate
                        channel is incremented.
                    </para>
                    <para>
                        Note that normally this is called from within
                        <classname>CSpectrum</classname>::<methodname>operator()</methodname>
                        if the gate applied on this spectrum is satisfied.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title>Gamma spectrum base class (<classname>CGammaSpectrum</classname> methods</title>
        <para>
            Gamma spectra are multiply incremented spectra.  The
            <classname>CGammaSpectrum</classname> class is a base class for
            several types of gamma spectra.  One feature gamma spectra have that is
            unique is the ability to have a gate applied as a
            <firstterm>fold</firstterm>.  Folds are a mechanism for untangling
            sequential decays.
        </para>
        <para>
            If a gamma spectrum has a fold applied, that fold must be defined
            only on parameters present in the gamma spectrum.  In that case,
            the spectrum is incremented only for parameters that do not fall
            in the fold as long as at least one set of parameters do fall in the
            fold.
        </para>
        <para>
            One way to look at this:  Suppose you have several peaks in this
            spectrum, one of which you've identified as a peak of interest.
            if you set a gamma gate on that peak and apply it as a fold, the
            only remaining peaks will be those that came in coincidence with the
            peak you set the fold on.  Those peaks typically represent parts of
            a sequential decay that included the peak you set the fold on.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CGammaSpectrum</methodname>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>std::string&amp; </type><parameter>rName</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type><parameter>nId</parameter>
                        </methodparam>
                        <methodparam>
                            <type> CSpectrum::Axes</type><parameter> Maps</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;CParameter&gt;&amp;</type>
                            <parameter> Parameters</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CGateContainer*</type><parameter> pGate </parameter>
                            <initializer>pDefaultGate</initializer>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        This constructor creates a new gamma spetrum
                        base class given the spectrum name
                        (<parameter>rName</parameter>) and id
                        (<parameter>id</parameter>).
                        Axis definitions are supplied by a vector of
                        <classname>CAxis</classname>; <parameter>Maps</parameter>.
                        
                    </para>
                    <para>
                        The gamma spectrum will be incremented from the parameters
                        in <parameter>Parameters</parameter>.  What this means
                        depends on the specific type of gamma spectrum being
                        created by the subclass.
                    </para>
                    <para>
                        Finally <parameter>pGate</parameter> points to the gate container
                        of the gate initially applied to the spectrum.
                        This defaults to <varname>pDefaultGate</varname> which
                        points to a container for a true gate.
                    </para>
                    <para>
                        Note that this constructor is used when there's no
                        distinction between X and Y parameters such as in
                        gamma 1d or ordinary gamma 2d spectra.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CGammaSpectrum</methodname>
                        <methodparam>
                            <modifier>const </modifier><type>std::string&amp;</type>
                            <parameter>rName</parameter>
                        </methodparam>
                        <methodparam>
                            <type> UInt_t </type><parameter>nId</parameter>
                        </methodparam>
                        <methodparam>
                            <type> CSpectrum::Axes</type><parameter> Maps</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;CParameter&gt;&amp;</type>
                            <parameter> xParameters</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;CParameter&gt;&amp; </type>
                            <parameter>yParameters</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CGateContainer* </type>
                            <parameter>pGate</parameter><initializer>pDefaultGate</initializer>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        This constructor should be used by subclasses
                        that differentiate between parameters on the X and Y
                        axis.  For example, the Gamma Deluxe spectrum.
                    </para>
                    <para>
                        The only difference between this and the previous
                        constructor is that parameters are specified
                        by <parameter>xParameters</parameter> - the parameters
                        on the X axis and <parameter>yParameters</parameter> -
                        the parameters on the Y axis.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CGammaSpectrum</methodname>
                        <methodparam>
                            <modifier>const </modifier><type>std::string&amp;</type>
                            <parameter> rName</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type><parameter>nId</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;CParameter&gt;&amp;</type>
                            <parameter>Parameters</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CGateContainer*</type><parameter>pGate</parameter>
                            <initializer>pDefaultGate</initializer>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <term>
                    <constructorsynopsis>
                        <methodname>CGammaSpectrum</methodname>
                         <methodparam>
                            <modifier>const </modifier><type>std::string&amp;</type>
                            <parameter>rName</parameter>
                        </methodparam>
                        <methodparam>
                            <type> UInt_t </type><parameter>nId</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;CParameter&gt;&amp;</type>
                            <parameter> xParameters</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;CParameter&gt;&amp; </type>
                            <parameter>yParameters</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CGateContainer* </type>
                            <parameter>pGate</parameter><initializer>pDefaultGate</initializer>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        These constructors are used when the axis definitions
                        will be computed and added via <methodname>AddAxis</methodname>
                        as during the constructor body.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>Increment</methodname>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>CEvent&amp; rEvent</type><parameter>CEvent&amp; rEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Gamma spectrum increments are mediated by the fold applied
                        on them.  Gamma spectra always have a fold although
                        the fold may be a default one.  
                    </para>
                    <para>
                        This method invokes the fold given the list of parameters
                        and the event, for ordinary gamma spectra, or the
                        x and y parameters and the event for gamma deluxe
                        spectra.  The fold, in turn will determine which of the
                        <methodname>Increment</methodname> methods below and
                        how to invoke it.  Those methods will perform the
                        final increment.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>Increment</methodname>
                        <methodparam>
                            <type>std::vector&lt; std::pair&lt;UInt_t, Float_t&gt; &gt; &amp;</type>
                            <parameter> rParameters</parameter>
                        </methodparam>
                        <modifier>=0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This pure virtual method must be implemented in
                        concrete derived classes.  It performs the appropriate
                        increments of the spectrum given a vector of
                        pairs.  The first element of each pair is a parameter
                        number and the second the value of that parameter.
                        Note that The fold that calls this may have
                        removed some of the parameter/values present in the
                        event due to the impact of the fold.
                    </para>
                    <para>
                        This increment is used by ordinary gamma spectra that
                        don't have a concept of X and Y parameters.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>Increment</methodname>
                        <methodparam>
                            <type>std::vector&lt; std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; </type>
                            <parameter>xParameters</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp;</type>
                            <parameter> yParameters</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This pure virtual method must be implemented in concrete
                        derived classes.  It performs appropriate increments
                        for gamma spectra that differentiate between X and
                        Y parameters (Gamma Deluxe).  It will be called by
                        the spetrum's fold after it has reduced the parameters
                        to the appropriate set after the application of the
                        fold.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Bool_t </type>
                        <methodname>haveFold</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns true if the spectrum has a named fold. Note that
                        the default fold, a fold wrapped around a True gate,
                        has no name.  Only folds wrapped around gamma gates
                        have names, the name of the wrapped gate.
                    </para>
                    <para>
                        What this method actually tells you is whether or not
                        the spectrum has a fold that can influence how
                        spectra are incremented.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void  </type>
                        <methodname>Fold</methodname>
                        <methodparam>
                            <type>CGateContainer* </type><parameter>pGate</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Wraps the gate container (and hence the gate it contains)
                        pointed to by <parameter>pGate</parameter> into a
                        <classname>CFold</classname> object and applies the
                        resulting fold to the spectrum.  The fold can,
                        if it is a gamma gate, dictate how the spectrum
                        is incremented by reducing the set of parameters
                        used to increrment the spectrum.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CFold* </type>
                        <methodname>getFold</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the  fold applied to the
                        spectrum.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>GetParameterIds</methodname>
                        <methodparam>
                            <type>std::vector&lt;UInt_t&gt;&amp; </type>
                            <parameter>rvIds</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        The set of parameter ids used by this spectrum are
                        appended to <parameter>rvIds</parameter>.  Note this
                        vector is not cleared by the method.
                    </para>
                    <para>
                        For spectra that care about X/Y parameters, the
                        X parameters are added first followed by the Y
                        parameters.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>protected</modifier>
                        <type>void </type>
                        <methodname>CreateParameterList</methodname>
                        <methodparam>
                            <type>std::vector&lt; std::pair&lt;UInt_t, Float_t&gt; &gt;&amp;</type>
                            <parameter> outList</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>CEvent&amp; </type><parameter>rEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Given the event
                        <parameter>rEvent</parameter>, creates a vector of parameter
                        number/value pairs for all parameters the spectrum is
                        defined on that have been assigned values in
                        <parameter>rEvent</parameter>.  Note that if the
                        spectrum cares about X/Y parameters, this will represent
                        the X parameters only.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>protected</modifier>
                        <type>void </type>
                        <methodname>CreateYParameterList</methodname>
                        <methodparam>
                            <type>std::vector&lt; std::pair&lt;UInt_t, Float_t&gt; &gt;&amp;</type>
                            <parameter> outList</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>CEvent&amp; </type><parameter>rEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        For spectra that care about which parameters are X
                        and Y, produces what <methodname>CreateParameterList</methodname>
                        does for the Y parameters.  For those spectra,
                        <methodname>CreateParameterList</methodname> only
                        produces a list of X parameters.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>protected</modifier>
                        <type>void </type>
                        <methodname>CreateParameterVector</methodname>
                        <methodparam>
                            <type>std::vector&lt;CParameter&gt;&amp; </type>
                            <parameter>Parameters</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                    <methodsynopsis>
                        <modifier>protected</modifier>
                        <type>void </type>
                        <methodname>CreateYParameterVector</methodname>
                        <methodparam>
                            <type>std::vector&lt;CParameter&gt;&amp; </type>
                            <parameter>Parameters</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates vectors of parameter definitions into
                        <parameter>Parameters</parameter>.  If the
                        Spectrum does not care about X,Y parameters,
                        <methodname>CreateParameterVector</methodname>
                        creates a vector with all of the parameters.
                        If the spectrum does care about X/Y parameters,
                        the method produces only the X parameters
                        and <methodname>CreateYParameterVector</methodname>
                        produces the definitions of the Y parameters.
                    </para>
                </listitem>
            </varlistentry>  
        </variablelist>
    </refsect1>
    <refsect1>
        <title>Methods for simple 1-D Gamma spectra</title>
        <para>
            Gamma spectra are intended to provide a way to look at data from
            several gain matched, identical gamma-ray detectors.
            Gamma spectra are multiply incremented an have folds which can
            be used to untangle sequential decays that occur within one
            event trigger.
        </para>
        <para>
            1-D gamma spectra take a set of parameters and, simplistically,
            increment for each parameter present in the event.  Folds will
            reduce the set of parameters the spectrum increments for on an
            event by event basis.  
        </para>
        <para>
            Two types of classes have been defined for gamma 1d spectra;
            <classname>CGamma1DL</classname> has longword (32 bit) channels
            while <classname>CGamma1DW</classname> has word (16 bit)
            channels.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CGamma1DL</methodname>
                        <methodparam>
                            <modifier>const </modifier><type>std::string&amp; </type>
                            <parameter>rName</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type><parameter>nId</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;CParameter&gt;&amp;</type>
                            <parameter> rrParameters</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type><parameter>nScale</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <term>
                    <constructorsynopsis>
                        <methodname>CGamma1DL</methodname>
                        <methodparam>
                            <modifier>const </modifier><type>std::string&amp; </type>
                            <parameter>rName</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type><parameter>nId</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;CParameter&gt;&amp; </type>
                            <parameter>rrParameters,</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type><parameter>nChannels</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t </type><parameter>fLow</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t </type><parameter>fHigh</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs a 1d Gamma Spectrum.  For the two constructors,
                        <parameter>rName</parameter> and
                        <parameter>nId</parameter> are the name and
                        id of the spectrum respecdtively.
                        <parameter>rrParameters</parameter> is a vector containing
                        the descriptions of the parameters on which the spectrum
                        is defined.
                    </para>
                    <para>
                        In the first form, <parameter>nScales</parameter> is
                        the number of channels in the spectrum.  The X axis of the
                        spectrum, in this case is the range
                        <literal>[0, <parameter>nScale</parameter>)</literal>.
                    </para>
                    <para>
                        In the second form, the number of channels is given
                        by <parameter>nChannels</parameter> and
                        the axis range in parameter coordinates is
                        <literal>[<parameter>fLow</parameter>,<parameter>fHigh</parameter>)</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>SpectrumType_t </type>
                        <methodname>getSpectrumType</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the value <literal>keG1D</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>  virtual </modifier>
                        <type>void </type>
                        <methodname>Increment</methodname>
                        <methodparam>
                            <type>std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; </type>
                            <parameter>rParameters</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Increments appropriate channels of the spectrum
                        given the vector of parameter ids and pairs.  For
                        this simple 1D Gamma spectrum, this just means
                        incrementing for all values that are in axis range.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>Increment</methodname>
                        <methodparam>
                            <type>std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; </type>
                            <parameter>xParameters,</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp;</type>
                            <parameter> yParameters</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is not appropriate for gamma 1d spectra
                        as there's no differentiation between X and Y parameters
                        in this type of spectrum.  Invokingh this wil therefore
                        throw a <classname>CException</classname> whose
                        reason text explains that you're trying to increment
                        a gamma 1d spectrum with the gamma 2d deluxe increment
                        method.
                    </para>
                </listitem>
            </varlistentry>

        </variablelist>
    </refsect1>
    <refsect1>
        <title>Gamma 2D L/W/B spectrum methods</title>
        <para>
            The Gamma 2D spectra come in longword (32 bit channels),
            word (16 bit channels) and byte versinos (8 bit channels).
            The classes are called
            <classname>CGamm2DL</classname>, <classname>CGamma2DW</classname>,
            and <classname>CGamma2DB</classname> respectively.  As all have
            the same set of methods with the same semantics, only
            <classname>CGamma2DL</classname>'s methods will be described.
        </para>
        <para>
            <classname>CGamma2DL</classname> spectra, while they are 2d don't
            differentiate between X and Y axes.  Instead, the spectrum is
            incremented for every ordered pair of parmaeters that fit into
            the spectrum.  See <methodname>Increment</methodname> below for
            the increment pseudo code.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CGamma2DL</methodname>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>std::string&amp; </type><parameter>rName</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type><parameter>nId</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;CParameter&gt;&amp; </type><parameter>rParameters</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t</type><parameter> nXScale</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type><parameter>nYScale</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                
                <term>
                    <constructorsynopsis>
                        <methodname>CGamma2DL</methodname>
                        <methodparam>
                            <modifier>const</modifier>
                            <type> std::string&amp; </type><parameter>rName</parameter>
                        </methodparam>
                        <methodparam>
                            <type> UInt_t </type><parameter>nId</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;CParameter&gt;&amp;</type>
                            <parameter> rParameters</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type><parameter>nXScale</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type><parameter>nYScale</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t </type><parameter>xLow</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t </type><parameter>xHigh</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t </type><parameter>yLow</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t </type><parameter>yHigh</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        These constructors differ only in how the X/Y axes
                        are specified.  Both of them require
                        a spectrum name (<parameter>rName</parameter>),
                        id (<parameter>nId</parameter>).  Both require
                        a vector of parameters that will be used to increment
                        the spectrum and evaluate it's associated fold
                        (<parameter>rParameters</parameter>).  
                    </para>
                    <para>
                        The first constructor specifies the axes only with bin
                        counts, <parameter>nXScale </parameter> and
                        <parameter>nYscale</parameter>.  The
                        X axis runs the range
                        <literal>[0, <parameter>nXScale</parameter>)</literal>
                        and the Y axis has the range
                        <literal>[0, <parameter>nYScale</parameter>)</literal>
                    </para>
                    <para>
                            The second constructor provides full mappings
                        for both the X and Y axes.  In addition to
                        <parameter>nXScale</parameter> and <parameter>nYScale</parameter>,
                        which specify the number of bins on the X and Y axi
                        respectively, both axis ranges are specified.
                        The X axis range is
                        <literal>[<parameter>xLow</parameter>, <parameter>xHigh</parameter>)</literal>.
                        The  axis range is
                        <literal>[<parameter>yLow</parameter>, <parameter>yHigh</parameter>)</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>SpectrumType_t </type>
                        <methodname>getSpectrumType</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Retrns <literal>keG2D</literal> - Gamma 2d spectrum.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodsynopsis>
                    <modifier>virtual </modifier>
                    <type>void </type>
                    <methodname>Increment</methodname>
                    <methodparam>
                        <type>std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; </type>
                        <parameter>rParameters</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis></term>
                <listitem>
                    <para>
                        This method should be called to increment the spectrum.
                        <parameter>rParameters</parameter> is a vector
                        of parameter ids and their associated values.  The
                        spectrum's fold may have reduced the set of parameters
                        from the set in the event for this spectrum.
                    </para>
                    <para>
                        The Gamma 2d spectrum does not know about separate
                        X and Y parameters but increments for all ordered pairs
                        of parameters in the spectrum following psuedo code like:
                    </para>
                    <programlisting>
for i in 0 - rParameters.size() -1 
   for j in i +1 - rParameters.size()
      xparam  = RawToXaxis(rParameters[i].second)
      yparam  = RawToYaxis(rParameters[j].second)
      if xparam and yparam fall in X and Y axes respectively
        increment spectrum at xparam,yparam
      end if
    end for
end for
                    </programlisting>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>Increment</methodname>
                        <methodparam>
                            <type>std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; </type>
                            <parameter>xParameters</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; </type>
                            <parameter>yParameters</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This increment operation is not valid for this spectrum
                        type as it does not distinguish between X and Y parameters.
                        If it is called in error it will throw a
                        <classname>CException</classname> with the reason text
                        <literal>"Gamma 2d Deluxe increment called on CGamma2DL"</literal>
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title>Gamma "Deluxe" spectra</title>
        <para>
            The Gamma Deluxe (2GDD)) spectrum is intended to provide particle gamma
            coincidence spectrum.  The 2GDD family of spectra have a
            distinct set of X and Y parameters, unlike the simple Gamma 2D
            spectra.  2GDD spectra are incremented over every pair of X/Y
            parameters.   Psuedo code will be shown for this in the
            documentation for the <methodname>Increment</methodname> method.
        </para>
        <para>
            When code for the 2GDD spectra was written, C++ templates were quite a
            bit more stable.  As such this spectrum is implemented as a template
            class with the channel type as the template parameter.  Note that
            with Root integration (not shown), a second template parameter,
            the type of Root histogram used for the spectrum
            was added (not shown in this documentation).
        </para>
        <para>
            A set of typedefs define
            <classname>CGamma2DDL</classname>, a spectrum with longword (32 bit) channels,
            <classname>CGamma2DDW</classname>, a spectrum with word (16 bit) channels
            and
            <classname>CGamma2DDB</classname>, a spectrum with byte (8 bit) channels.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CGamma2DD</methodname>
                        <methodparam>
                            <modifier>const</modifier><type> std::string&amp;</type>
                            <parameter> rName</parameter>
                        </methodparam>
                        <methodparam>
                            <type> UInt_t </type><parameter>nId</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;CParameter&gt;&amp;</type>
                            <parameter>xParameters</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;CParameter&gt;&amp;  </type>
                            <parameter>yParameters</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t</type><parameter> xChannels</parameter>
                        </methodparam>
                        <methodparam>
                            <type> UInt_t </type><parameter>yChannels</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <term>
                    <constructorsynopsis>
                        <methodname>CGamma2DD</methodname>
                        <methodparam>
                            <modifier>const</modifier><type> std::string&amp;</type>
                            <parameter> rName</parameter>
                        </methodparam>
                        <methodparam>
                            <type> UInt_t </type><parameter>nId</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;CParameter&gt;&amp;</type>
                            <parameter>xParameters</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;CParameter&gt;&amp;  </type>
                            <parameter>yParameters</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t</type><parameter> xChannels</parameter>
                        </methodparam>
                        <methodparam>
                            <type> UInt_t </type><parameter>yChannels</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t </type><parameter>xLow</parameter>
                        </methodparam>
                        <methodparam>
                            <type> Float_t </type><parameter>xHigh</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t </type><parameter>yLow</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t </type><parameter>yHigh</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructors for G2DD spectra.  Both constructors
                        provide parameters to identify the spectrum.
                        <parameter>rName</parameter> is the spectrum's name
                        and <parameter>nID</parameter> its identifier.
                        Both provide a pair of vector parameters;
                        <parameter>xParameters</parameter> and
                        <parameter>yParameters</parameter> which
                        provide parameters for the X and Y axes respectively.
                        Both also provide a pair of parameters;
                        <parameter>xChannels</parameter> and
                        <parameter>yChannels</parameter> to provide the
                        number of bins on the X and Y axes respectively.
                    </para>
                    <para>
                        The first of the constructors does not provide
                        for a mapping between raw parameters and axis values/bins.
                        The X axis has the range
                        <literal>[0, <parameter>xChannels</parameter>)</literal>.
                        The Y axis has the range
                        <literal>[0, <parameter>yChannels</parameter>)</literal>
                    </para>
                    <para>
                        The second of the constructors provides for the ability
                        to specify parameter coordinate ranges for each axis
                        as well as the binning.   The X axis in this case has the
                        range
                        <literal>[<parameter>xLow</parameter>, <parameter>xHigh</parameter>)</literal>
                        with <parameter>xChannels</parameter> bins.
                        Similarly, the Y axis has the range
                        <literal>[<parameter>yLow</parameter>, <parameter>yHigh</parameter>)</literal>
                        with <parameter>yChannels</parameter> bins.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>SpectrumType_t </type>
                        <methodname>getSpectrumType</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>keG2DD</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>Increment</methodname>
                        <methodparam>
                            <type>std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; </type>
                            <parameter>rParameters</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This, axis blind method is not appropriate for
                        incrementing the Gamma Deluxe family of spectra.
                        If invoked, it will throw a
                        <classname>CException</classname> with the
                        reason text
                        <literal>Attempted a 'non-deluxe' increment of a gamma deluxe spectrum</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void</type>
                        <methodname> Increment</methodname>
                        <methodparam>
                            <type>std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; </type>
                            <parameter>rXParameters</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; </type>
                            <parameter>rYParameters</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This is the appropriate increment method for
                        G2DD spectra.  <parameter>rXParameters</parameter> is
                        a vector of parameter ids and their values for the X
                        axis.  Similarly
                        <parameter>rYParameters</parameter> is a vector
                        for the Y axis.
                    </para>
                    <para>
                        The evaluation of the spectrum's fold can reduce the
                        set of parameters passed to the increment.
                        Psuedo code below shows how these parameters increment
                        the spectrum.
                    </para>
                    <programlisting>
for i in [0, rXParameters.size())
   for j in [0, rYParameters.size()]
       x = RawToXaxis(rXParameters[i].second)
       y = RawToYaxis(rYParameters[j].second)
       if x and y are in the axis ranges
          increment spectrum at (x,y)
        endif
    end for
end for
       

                    </programlisting>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title>Gamma Summary Spectra</title>
        <para>
            <classname>CGammaSummary</classname> spectrum is a templated class.
            Template parameters include the data type of the channel. After
            Root integration, an additional template parameter that is the
            type of Root histogram wrapped by this class was added.
            For convenience, the header defines <literal>typedef</literal>s for
            <classname>CGammaSummarySpectrumL</classname> - 32 bit channels,
            <classname>CGammaSummarySpectrumW</classname> - 16 bit channels and
            <classname>CGammaSummarySpectrumB</classname> - 8 bit channels.
        </para>
        <para>
            Gamma summary spectra are a great deal like ordinary summary spectra,
            except that rather than each X channel representing a single parameter
            it is a gamma spectrum on set of parameters.  This is reflected in its
            constructors as you will see.
        </para>
        <para>
            While gamma summary spectra have a gate applied to them, the don't have
            folds.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CGammaSummarySpectrum</methodname>
                        <methodparam>
                            <type>const std::string</type><parameter> name</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type><parameter>nId</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type><parameter>nYChannels</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;std::vector&lt;CParameter&gt; &gt;* </type>
                            <parameter>pParameters</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <term>
                    <constructorsynopsis>
                        <methodname>CGammaSummarySpectrum</methodname>
                        <methodparam>
                            <type>const std::string </type><parameter>name</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t</type> <parameter>nId</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;std::vector&lt;CParameter&gt; &gt;* </type>
                            <parameter>pParameters</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t</type><parameter> nYChannels</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t </type><parameter>fYLow</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t </type><parameter>fYHigh</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        As usual there are a pair of constructors.  The
                        first of these provides for an one to one mapping
                        between parameter values and Y axis channels.  The second
                        allows for arbitary mappings.
                    </para>
                    <para>
                        For the most part, parameterrs are the same as for
                        other gamma spectra.  The <parameter>pParameters</parameter>
                        paramameter points, however to a vector of vectors.
                        The outer vector indexes the X axis channels while the
                        inner vector contains the parameters that contribute
                        to the gamma spectrum that is on the Y axis for each
                        of those channels.   The
                        <methodname>Increment</methodname> method documentation
                        provides pseudo code for the increment logic.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>SpectrumType_t </type>
                        <methodname>getSpectrumType</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                      returns the value <literal>keGSummary</literal>
                      indicating this spectrum is a gamma summary spectrum.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>void </type>
                        <methodname>Increment</methodname>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>CEvent&amp; </type><parameter>rEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Increments the appropriate channels in the spectrum
                        given the event <parameter>rEvent</parameter>.
                        The object has a member <varname>m_Parameters</varname>
                        that is a vector of vectors of parameter ids.
                        This is used to drive the increment.  Here's pseudo
                        code for the increment operation.
                    </para>
                    <programlisting>
for i in [0, m_Parameters.size()]
    for all m_Parameters[i] py where rEvent[py].isValid()
        y = rawToYAxis(rEvent[py]);
        increment channel (i,y)
    end for
end for
                    </programlisting>
                </listitem>
            </varlistentry>
            

        </variablelist>
    </refsect1>
    <refsect1>
        <title>Simple One dimensional spectra</title>
        <para>
            The simple one dimensional spectrum classes are:
            <classname>CSpectrum1DL</classname> - 32 bit channels and
            <classname>CSpectrum1DW</classname> - 16 bit channels.
            These spectra take a single parameter and will perform at most
            one increment per event.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CSpectrum1DL</methodname>
                        <methodparam>
                            <modifier>const </modifier><type>std::string&amp;  </type>
                            <parameter> rName</parameter>
                        </methodparam>
                        <methodparam>
                            <type> UInt_t</type><parameter> nId</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>CParameter&amp;</type><parameter> rParameter</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type><parameter>nChannels</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <term>
                    <constructorsynopsis>
                        <methodname>CSpectrum1DL</methodname>
                        <methodparam>
                            <modifier>const</modifier><type> std::string&amp;   </type>
                            <parameter>rName</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type><parameter>nId</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier>const   </modifier><type>CParameter&amp; </type>
                            <parameter> rParameter</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t</type><parameter> nChannels</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t </type><parameter> fLow</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t</type><parameter>fHigh</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        These two constructors differ only in how the
                        X axis of the spectrum is described.  For both of them,
                        <parameter>rName</parameter> and
                        <parameter>nId</parameter> are the name and id of the
                        spectrum being created.
                        <parameter>rParameter</parameter> references the
                        description of the parameter that will be used to
                        increment the spectrum. and
                        <parameter>nChannels</parameter> is the number of
                        bins on the X axis.
                    </para>
                    <para>
                        In the first form of the constructor, the mapping from
                        raw parameter to bin is one-to-one.  That is the
                        X axis is assumed to cover the range
                        <literal>[0, <parameter>nChannels</parameter>)</literal>.
                    </para>
                    <para>
                        In the second form of the constructor, the additional
                        parameters; <parameter>fLow</parameter> and
                        <parameter>fHigh</parameter> specify the range of the
                        X axis.  The X axis range is considered to be
                        <literal>[<parameter>fLow</parameter>, <parameter>fHigh</parameter>)</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>UInt_t </type>
                        <methodname>getParameter</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the id of the parameter that will be used
                        to increment the spectrum.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>SpectrumType_t </type>
                        <methodname>getSpectrumType</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>ke1D</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type> void </type>
                        <methodname>Increment</methodname>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>CEvent&amp; </type>
                            <parameter>rE</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Performs the appropriate increment for the event
                        <parameter>rE</parameter>. At most only one increment
                        can be performed.  Pseudo code for the increment
                        (assuming the gate has been satisfied) is
                    </para>
                    <programlisting>
UInt_t id = getParameter();
if (rE[id].isValid())
   x = rawToXaxis(rE[id])
   increment channel x if in range
end if
                    </programlisting>
                </listitem>
            </varlistentry>

        </variablelist>
    </refsect1>
    <refsect1>
        <title>Simple two dimensional spectra</title>
        <para>
            Two dimensional spectra are defined on a pair of parameters
            called the X and Y parameters.  A two dimensional spectrum
            increments a channel in a two dimensional grid of channels indexed
            by a mapping of the values of the X and Y parameterss.
            The two dimensional spectrum classes are
            <classname>CSpectrum2DL</classname> - 32 bit channels,
            <classname>CSpectrum2DW</classname> - 16 bit channels and
            <classname>CSpectrum2DB</classname> - 8 bit channels.
        </para>
        <para>
            As usual, psuedo code for the increment (assuming the spectrum's gate
            has been satisfied) is presented in the documentation of the
            <methodname>Increment method</methodname>.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CSpectrum2DL</methodname>
                        <methodparam>
                            <modifier>const </modifier><type>std::string&amp;</type>
                            <parameter> rName</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type><parameter>nId`</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier>const </modifier><type>CParameter&amp; </type>
                            <parameter>rXParameter</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier>const </modifier><type>CParameter&amp; </type>
                            <parameter>rYParameter</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t</type><parameter>nXScale</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type><parameter>nYScale</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <term>
                    <constructorsynopsis>
                        <methodname>CSpectrum2DL</methodname>
                        <methodparam>
                            <modifier>const </modifier><type>std::string&amp; </type>
                            <parameter>rName</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type><parameter>nId</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier>const </modifier><type>CParameter&amp;</type>
                            <parameter> rXParameter</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier>const </modifier><type>CParameter&amp; </type>
                            <parameter>rYParameter</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t</type><parameter> nXChannels</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t </type><parameter>fxLow, </parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t </type><parameter>fxHigh</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type><parameter>nYChannels</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t </type><parameter>fyLow</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t </type><parameter>fyHigh</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        The two constructors, like the constructors for most
                        spectrum types differ only in how the axes of the spectrum
                        are specified.  
                    </para>
                    <para>
                        The first constructor specifies
                        the X axis as covering the range
                        <literal>[0, <parameter>nXChannels</parameter>)</literal>
                        with <parameter>nXChannels</parameter> bins.
                        The Y axis is similarly specified as covering the range
                        <literal>[0, <parameter>nYChannels</parameter>)</literal>
                        with <parameter>nYChannels</parameter> bins.
                    </para>
                    <para>
                        The second constructor, provides for arbitrary limits and
                        binning.  <parameter>nXChannels</parameter> and
                        <parameter>nYChannels</parameter> specify the number of
                        bins on the X and Y axes respectively  as before. The range
                        of the X axis is, however specified a
                        <literal>[<parameter>fxLow</parameter>, <parameter>fxHigh</parameter>)</literal>.
                        The range for the Y axis is similarly
                        <literal>[<parameter>fyLow</parameter>, <parameter>fyHigh</parameter>)</literal>.
                    </para>
                    <para>
                        The remainder of the constructor parameters are common
                        to both forms of the constructor.
                        <parameter>rName</parameter> and <parameter>nId</parameter>
                        identify the spectrum.
                        <parameter>rXParameter</parameter> and
                        <parameter>rYParameter</parameter> are the definition
                        objects for the X and Y axis parameters respectively.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>UInt_t </type>
                        <methodname>getXParameter</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the parameter id of the X axis parameter.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>UInt_t </type>
                        <methodname>getYParameter</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the parameter id of the Y axis parameter.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>SpectrumType_t </type>
                        <methodname>getSpectrumType</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>ke2D</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>void </type>
                        <methodname>Increment</methodname>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>CEvent&amp; </type>
                            <parameter>rEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Increments the spectrum as appropriate given the
                        event <parameter>rEvent</parameter>.
                        <methodname>Increment</methodname> does not
                        check the gate.  <methodname>operator()</methodname>
                        is assumed to already have done that.
                    </para>
                    <para>
                        Pseudo code for the increment is:
                    </para>
                    <programlisting>
xid  = getXParameter();
yid  = getYParameter();
if rEvent[xid].isValid() and rEvent[yid].isValid()
    x = rawToXaxis(rEvent[xid])
    y = rawToYAxis(rEvent[yid])
    increment spectrum at channel (x,y)
end if
                    </programlisting>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title>Strip chart spectrum</title>
        <para>
            Strip chart spectra are 1-d spectra that are intended to
            represent the time evolution of some parameter.  They are
            defined on two parameters. The value of one of them is called the
            parameter while the value of the other is called the channel.
        </para>
        <para>
            The increment logic will be given in psuedo code when we describe
            the <methodname>Increment method</methodname>. The basic idea, however
            is that the channel selects a bin in the spectrum into which the
            parameter is summed.  If the channel value of an event is outside
            the range of the spectrum, the spectrum is shifted to accommodate it.
            Thus, if you think of the channel parameter as related to time, the
            spectrum does implement a strip chart of the parameter.
        </para>
        <para>
            Note, however that shifts in either direction are supported.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CSpectrumS</methodname>
                        <methodparam>
                            <modifier>const </modifier><type>std::string&amp;</type>
                            <parameter>rName</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t</type><parameter>nId</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier>const</modifier><type> CParameter&amp;</type>
                            <parameter>rParameters</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier>const</modifier><type> CParameter&amp;</type>
                            <parameter>nChannel</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t</type><parameter>nChannels</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <term>
                    <constructorsynopsis>
                        <methodname>CSpectrumS</methodname>
                        <methodparam>
                            <modifier>const </modifier><type>std::string&amp;</type>
                            <parameter>rName</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type><parameter> nId</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier>const</modifier><type> CParameter&amp;</type>
                            <parameter> rParameters</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier>const </modifier><type>CParameter&amp;</type>
                            <parameter>nChannel</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t  </type><parameter>nChannels</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t </type><parameter>fLow</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t</type><parameter>fHigh</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        These tow constructors again differ only in the
                        initial axis specification.  In the first form,
                        the spectrum has <parameter>nChannels</parameter>
                        channels and the channel width corresponds to
                        one unit of width in the raw parameter space.
                    </para>
                    <para>
                        In the second form of the constructor,
                        the initial range of the spectrum
                        is
                        <literal>[<parameter>fLow</parameter>, <parameter>fHigh</parameter>)</literal>.
                        The width of a channel is
                        <literal>(fHigh - fLow)/nChannels</literal>.
                    </para>
                    <para>
                        For both constructor forms,
                        <parameter>rName</parameter> and
                        <parameter>nId</parameter> identify the spectrum.
                        <parameter>rParameters</parameter> is the spectrum's
                        parameter value.  This parameter is on the Y axis of the
                        strip chart.  <parameter>nChannel</parameter> is the
                        spectrum's channel parameter.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>ShiftDataUp</methodname>
                        <methodparam>
                            <type>int64_t </type><parameter>nShift</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is normally used by
                        <methodname>Increment</methodname> for events where
                        the channel parameter is to the left of the origin of
                        the X axis.  Data are shifted upwards
                        (to the right) and zero filled
                        on the left.  <parameter>nShift</parameter> is the
                        number of channels to shift the data.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>ShiftDataDown</methodname>
                        <methodparam>
                            <type>int64_t</type><parameter> nShift</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Same as <parameter>shiftDataUp</parameter> but the channels
                        are shifted to the left in the spectrum.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>SpectrumType_t </type>
                        <methodname>getSpectrumType</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>keStrip</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>void </type>
                        <methodname>Increment</methodname>
                        <methodparam>
                            <modifier>const </modifier><type>CEvent&amp; </type>
                            <parameter>rE</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Increments the spectrum as per the contents of the
                        event <parameter>rE</parameter>.  The Psuedo code is:
                    </para>
                    <programlisting>
nc = getChannelParameter()
np = getParameter()
if (rEvent[nc].isValid() and rEvent[np].isValid())
    channel = rawToX(rEvent[nc])
    if (channel &gt; last channel)
        shift spectrum down
    else if (channel &lt; 0)
        shift spectrum up
    endif
    channel = rawToX(rEvent[nc])
    increment spectrum at channel by rEvent[np]
end if
                    </programlisting>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title>Summary Spectra</title>
        <para>
            Summary spectra are intended to allow you to look at a large number
            of parameters simultaneously.  An obvious use case is to look at all
            of the detectors in a detector array.   Summary spectra are two
            dimensional spectra but actually, each Y strip is a one channel wide
            spectrum of a single parameter.
        </para>
        <para>
            The increment logic, as usual, is shown in pseudo code for the
            <methodname>Increment</methodname> method.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CSummarySpectrumL</methodname>
                        <methodparam>
                            <modifier>const </modifier><type>std::string&amp; </type>
                            <parameter>rName</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t</type><parameter> nId</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;CParameter&gt;</type>
                            <parameter> rrParameters</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type><parameter>nYScale</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <term>
                    <constructorsynopsis>
                        <methodname>CSummarySpectrumL</methodname>
                        <methodparam>
                            <modifier>const </modifier><type>std::string&amp; </type>
                            <parameter>rName</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t</type><parameter> nId</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;CParameter&gt;</type>
                            <parameter> rrParameters</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type><parameter>nYScale</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t </type><parameter>fYLow</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t </type><parameter>fYHigh</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        The two forms of the constructor differ in how they
                        create the range and binning of the Y axis.
                        In the first form; there are
                        <parameter>nYScale </parameter> bins on an axis that spans
                        the interval
                        <literal>[0, <parameter>nYScale</parameter>)</literal>.
                        In the second form; there are again
                        <parameter>nYScale</parameter> channels, but the axis spans the
                        interval
                        <literal>[<parameter>fYLow</parameter>, <parameter>fYHigh</parameter>)</literal>.
                    </para>
                    <para>
                        The remaining parameters are semantically the same for
                        both constructors.  <parameter>rName</parameter>
                        and <parameter>nId</parameter> identify the spectrum.
                        <parameter>rrParameters</parameter> provide the
                        parameters that are histogrammed in the summary.
                        The index of each element of the vector indicates which
                        X channel that parameter's spectrum occupies.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>UInt_t </type>
                        <methodname>getnParams</methodname>
                        <void />
                        <modifier> const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of parameters on the X axis.
                        This is also the number of channels on the X axis.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>UInt_t </type>
                        <methodname>getParameterId</methodname>
                        <methodparam>
                            <type>UInt_t </type><parameter>n</parameter>
                        </methodparam>
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the parameter id for channel
                        <parameter>n</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>SpectrumType_t </type>
                        <methodname>getSpectrumType</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>keSummary</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>void </type>
                        <methodname>Increment</methodname>
                        <methodparam>
                            <modifier>const </modifier><type>CEvent&amp; </type>
                            <parameter>rEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Given an event <parameter>rEvent</parameter> increments
                        the appropriate channels of the spectrum.  The psuedo
                        code for this method looks a bit like this, assuming
                        there's a vector m_parameters that has the parameter
                        ids of the parameters used to construct the spectrum:
                    </para>
                    <programlisting>
xchan = 0
for each parameter id in m_parameters as id
    if rEvent[id].isValid()
        value = rawToYAxis(rEvent[id])
        Increment channel (xchan, value)
    endif
    xchan = xchan + 1
end for
                    </programlisting>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CFold</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CFold</refname>
        <refpurpose>Process gamma ray spectrum folds</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CFold.h&gt;

class CFold
{
public:
  CFold(CGateContainer* m_pGate);
  std::string getFoldName();
  void        setGate(CGateContainer* pGate);
  void        operator()(std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; rEvent, 
                         CGammaSpectrum* pSpectrum);
  void        operator()(std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; xParams,
			 std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; yParams,
			 CGammaSpectrum* pSpectrum);
protected:
  void        CutDownParameters(std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; rNew, 
                                std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; rOld, 
                                UInt_t removeMe);
  void        CutDownParameters(std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; rNew, 
                               std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; rOld, 
                               UInt_t remove1, UInt_t remove2);
  
};


        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Fold mediate the processing of an event in Gamma spectra derived
            from <classname>CGammaSpectrum</classname>.  They help determine which
            peaks are part of a sequential decay process.   They do this by only
            incrementing parameters that are <emphasis>not</emphasis> in the fold's
            gate 
        </para>
        <para>
            This <firstterm>cutting down</firstterm> of the parameters allows
            the spectrum to only increment for gamma rays that are coincident
            with the one in the fold.  In this case, coincident means they
            gammas are in the same event.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CFold</methodname>
                        <methodparam>
                            <type>CGateContainer* </type><parameter>pGate</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        The constructor requires a <parameter>pGate</parameter>
                        which will be used as the fold.  The gate should be
                        a valid gamma gate, however it is not an error to use
                        a non-gamma gate.  Using a  non-gamma gate, however
                        will not affect how the spectrum is incremented.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>std::string </type>
                        <methodname>getFoldName</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the name of the fold. The name of the fold
                        is the same asw the name of the gate it evaluates.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>setGate</methodname>
                        <methodparam>
                            <type>CGateContainer* </type><parameter>pGate</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Sets the fold gate to <parameter>pGate</parameter>.
                        Note that a side-effect of this is that the fold's name
                        is changed since it derived from the
                        name of the underlying gate.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void  </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                            <type>std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; </type>
                            <parameter>xParams</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; </type>
                            <parameter>yParams</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CGammaSpectrum* </type><parameter>pSpectrum</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Processes the cut for a gamma deluxe spectrum.
                        For each pair of parameters that satisfies the
                        gamma gate, all other parameter pairs increment
                        the spectrum.   
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>protected</modifier>
                        <type>void </type>
                        <methodname>CutDownParameters</methodname>
                        <methodparam>
                            <type>std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp;</type>
                            <parameter>rNew</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; </type>
                            <parameter>rOld</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t</type><parameter>removeMe</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates a new list of parameters, <parameter>rNew</parameter>
                        that consists of the previous list, <parameter>rOld</parameter>
                        without any instance of parameter id <parameter>removeMe</parameter>
                        in it.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>protected</modifier>
                        <type>void </type>
                        <methodname> CutDownParameters</methodname>
                        <methodparam>
                            <type>std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; </type>
                            <parameter>rNew</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp;  </type>
                            <parameter>rOld</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t</type><parameter> remove1</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t</type><parameter>remove2</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates a new vector, <parameter>rNew</parameter> consisting
                        of the elements of <parameter>rOld</parameter> that cointains
                        neither <parameter>remove1</parameter> nor
                        <parameter>remove2</parameter>.  This is somewhat faster
                        than using the previous method twice and is a natural
                        method for use with 2d gates that are wrapped by
                        a fold.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CAxis</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CAxis</refname>
        <refpurpose>Spectrum axis coordinate transforms.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CAxis.h&gt;

class CAxis      
{
public:

  CAxis (UInt_t nChannels,
	 std::string sUnits = std::string(""));
  CAxis (Float_t fLow,
	 Float_t fHigh,
	 UInt_t  nChannels,
	 std::string sUnits = std::string(""));	

public:
  // Selectors for member data.
  
  float getLow() const;
  float getHigh() const;
  int getChannels() const;

  Float_t ParameterToAxis (Float_t fParameter);
  Float_t AxisToParameter (UInt_t nAxisValue)   ;
  
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <classname>CAxis</classname> incorporates an axis description
            as well as a set of methods to do transforms from parameter
            space to bin space on an axis and back.  A parameter is defined
            as an interval in parameter coordinates that is divided up into
            a number of equal-sized bins.
        </para>
    </refsect1>
    <refsect1>
        <title>
            METHODS
        </title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CAxis</methodname>
                        <methodparam>
                            <type>UInt_t </type><parameter>nChannels</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::string </type><parameter>sUnits </parameter>
                            <initializer>std::string("")</initializer>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Initializes an axis for a simple integer parameter.
                        The axis is a 1:1 mapping over the range:
                        <literal>[0, <parameter>nChannels</parameter>)</literal>
                    </para>
                    <para>
                        The optional <parameter>sUnits</parameter> parameter
                        provides the axis units of measure and defaults to an
                        empty string.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CAxis</methodname>
                        <methodparam>
                            <type>Float_t </type><parameter>fLow</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t </type><parameter>fHigh</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type><parameter> nChannels</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::string </type><parameter>sUnits </parameter>
                            <initializer>std::string("")</initializer>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates an axis for a floating point parameter.
                        The axis covers the range
                        <literal>[<parameter>fLow</parameter>, <parameter>fHigh</parameter>)</literal>
                        and has <parameter>nChannels</parameter> bins.
                    </para>
                    <para>
                        The optional parameter <parameter>sUnits</parameter>
                        is the axis units of measure and defaults to an
                        empty string if not supplied
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>float </type>
                        <methodname>getLow</methodname>
                        <void />
                        <modifier> const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Return the axis low limit.   The axis range is
                        inclusive of this value.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>float </type>
                        <methodname>getHigh</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the axis high limit.  The axis range
                        is exclusive of this value.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>int </type>
                        <methodname>getChannels</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of bins on the axis. In SpecTcl,
                        all bins are equal sized.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Float_t </type>
                        <methodname>ParameterToAxis</methodname>
                        <methodparam>
                            <type>Float_t </type><parameter>fParameter</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Given a parameter value, converts it to an axis value
                        (bins).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type> Float_t </type>
                        <methodname>AxisToParameter</methodname>
                        <methodparam>
                            <type>UInt_t </type><parameter>nAxisValue</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Given an axis bin number converts the value to
                        a parameter value.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CGate</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CGate</refname>
        <refpurpose>SpecTcl gate classes</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;Gate.h&gt;

class CGate      
{
public:
  CGate ();
  Bool_t getChecked();
  Bool_t getCachedValue();
  void Set (Bool_t fValue);
  void Reset ();
  virtual void RecursiveReset(); 
  Bool_t wasChecked ();
  virtual   Bool_t operator() (CEvent&amp; rEvent)  ;
  virtual   CConstituentIterator Begin ()   = 0;
  virtual   CConstituentIterator End ()   = 0;
  virtual   UInt_t Size ()   = 0;
  virtual   std::string GetConstituent (CConstituentIterator&amp; rIterator)   = 0;
  virtual   CGate* clone ()   = 0;
  virtual   std::string Type () const   = 0;
  virtual   Bool_t inGate (CEvent&amp; rEvent, const std::vector&lt;UInt_t&gt;&amp; Params) = 0;
  virtual   Bool_t inGate (CEvent&amp; rEvent) = 0;
  virtual   Bool_t caches();
};
<beginpage />
#include &lt;Cut.h&gt;

class CCut  : public CGate        
{
  
public:
  CCut (  Float_t am_nLow,  Float_t am_nHigh,  UInt_t am_nId  ) ;
  Float_t getLow() const;
  Float_t getHigh() const;
  UInt_t getId() const;
  virtual std::vector&lt;std::string&gt; getSpecs() const;
  virtual   Bool_t operator()(CEvent&amp; rEvent);
  virtual   CGate* clone ()  ;
  virtual   CConstituentIterator Begin ()  ;
  virtual   CConstituentIterator End ()  ;
  virtual   UInt_t Size ()  ;
  virtual   std::string GetConstituent (CConstituentIterator&amp; rIterator)  ;
  virtual   std::string Type ()  const;
  virtual   Bool_t inGate(CEvent&amp; rEvent, const std::vector&lt;UInt_t&gt;&amp; Params);
  virtual   Bool_t inGate (CEvent&amp; rEvent);
  virtual   Bool_t inGate (Float_t x);
};

<beginpage />
#include &lt;FalseGate.h&gt;

class CFalseGate {
  CFalseGate ();
                       
  virtual   Bool_t operator() (CEvent&amp; rEvent)  ;
  virtual   CConstituentIterator Begin ()  ;
  virtual   CConstituentIterator End ()  ;
  virtual   UInt_t Size ()  ;
  virtual   std::string GetConstituent (CConstituentIterator&amp; rIterator)  ;
  virtual   CGate* clone ()  ;
  virtual   std::string Type () const;
  virtual   Bool_t inGate(CEvent&amp; rEvent, const std::vector&lt;UInt_t&gt;&amp; Params);
  virtual   Bool_t inGate(CEvent&amp; rEvent);
  virtual   Bool_t caches();
};

<beginpage />
#include &lt;TrueGate.h&gt;
class CTrueGate  : public CGate        
{

  CTrueGate () : CGate();
  virtual   Bool_t operator() (CEvent&amp; rEvent)  ;
  virtual   CConstituentIterator Begin ()  ;
  virtual   CConstituentIterator End ()  ;
  virtual   UInt_t Size ()  ;
  virtual   std::string GetConstituent (CConstituentIterator&amp; rIterator)  ;
  virtual   CGate* clone ()  ;
  virtual   std::string Type ()  const;
  virtual   Bool_t inGate(CEvent&amp; rEvent, const std::vector&lt;UInt_t&gt;&amp; Params);
  virtual   Bool_t inGate(CEvent&amp; rEvent);
  virtual   Bool_t caches();
};

<beginpage />
class CMaskGate  : public CGate        
{  
public:
  CMaskGate (UInt_t mask);
  long getCompare() const;
  virtual   Bool_t operator() (CEvent&amp; rEvent)  ;
  virtual   UInt_t Size ()  ;
};

class CMaskAndGate : public CMaskGate  
{  
public:

  CMaskAndGate ( UInt_t am_nId, UInt_t  am_lCompare );
  long getCompare() const;     
  UInt_t getId() const;
  virtual   Bool_t operator() (CEvent&amp; rEvent)  ;
  virtual   CGate* clone ()  ;
  virtual   std::string Type ()  const;
  virtual   Bool_t inGate(CEvent&amp; rEvent, const std::vector&lt;UInt_t&gt;&amp; Params);
  virtual   Bool_t inGate(CEvent&amp; rEvent);
};

#include &lt;MaskEqualGate.h&gt;
class CMaskEqualGate : public CMaskGate  
{  
public:
  CMaskEqualGate ( UInt_t am_nId, UInt_t  am_lCompare ) ;
 
 long getCompare() const;
 UInt_t getId() const;
  virtual   Bool_t operator() (CEvent&amp; rEvent)  ;
  virtual   CGate* clone ()  ;
  virtual   std::string Type ()  const;
  virtual   Bool_t inGate(CEvent&amp; rEvent, const std::vector&lt;UInt_t&gt;&amp; Params);
  virtual   Bool_t inGate(CEvent&amp; rEvent);
};

#include &lt;MaskEqualGate.h&gt;

class CMaskNotGate : public CMaskGate  
{  
public:

  CMaskNotGate ( UInt_t am_nId, UInt_t  am_lCompare );
  long getCompare() const;      
  UInt_t getId() const;

public:            
  virtual   Bool_t operator() (CEvent&amp; rEvent)  ;
  virtual   CGate* clone ()  ;
  virtual   std::string Type ()  const;
  virtual   Bool_t inGate(CEvent&amp; rEvent, const std::vector&lt;UInt_t&gt;&amp; Params);
  virtual   Bool_t inGate(CEvent&amp; rEvent);

};
<beginpage />

#include &lt;Point.h&gt;               // Defines FPoint used below.
#include &lt;PointlistGate.h&gt;

class CPointListGate  : public CGate        
{ 
public:
 CPointListGate (UInt_t nXId, UInt_t nYId,
		  const std::vector&lt;FPoint&gt;&amp; Points);
  CPointListGate(UInt_t nXId, UInt_t nYId, UInt_t nPts,
		 Float_t *xCoords, Float_t *yCoords);
  CPointListGate(UInt_t nXId, UInt_t nYId, UInt_t nPts,
		 FPoint* pPoints);

  UInt_t getxId() const;
  UInt_t getyId() const;
  std::vector&lt;FPoint&gt; getPoints() const;

  std::vector&lt;FPoint&gt;::iterator getBegin();
  std::vector&lt;FPoint&gt;::iterator getEnd() ;

  virtual   CConstituentIterator Begin ()  ;
  virtual   CConstituentIterator End ()  ;
  virtual   UInt_t Size ()  ;
  virtual   std::string GetConstituent (CConstituentIterator&amp; rIterator)  ;
  virtual  Bool_t inGate(CEvent&amp; rEvent);
  virtual  Bool_t Inside(Float_t x, Float_t y) = 0;

};

#include &lt;Band.h&gt;

class CBand  : public CPointListGate        
{
public:
			//Default constructor

  CBand (UInt_t nXid, UInt_t nYid,
	 const std::vector&lt;FPoint&gt;&amp; points);
  CBand (UInt_t nXid, UInt_t nYid,
	 UInt_t nPts, FPoint* pPoints);
  CBand (UInt_t nXid, UInt_t nYid,
	 UInt_t nPts, Float_t* pX, Float_t* pY);
  virtual   Bool_t operator()(CEvent&amp; rEvent);
  virtual   CGate* clone ()  ;
  virtual   std::string Type ()  const;

  virtual   Bool_t Inside(Float_t x, Float_t y) ;
protected:
  Bool_t Interior(Float_t x, Float_t y);

};

#include &lt;Contour.h&gt;


class CContour  : public CPointListGate        
{
public:
			//Default constructor

  CContour (UInt_t nXId, UInt_t nYId, 
	    const std::vector&lt;FPoint&gt;&amp; Points);
  CContour (UInt_t nXId, UInt_t NYId, UInt_t nPts,
	    Float_t *xCoords, Float_t *yCoords);
  CContour (UInt_t nXId, UInt_t NYId, UInt_t nPts,
	    FPoint* pPonts);

	
  FPoint getLowerLeft() const;
  FPoint getUpperRight() const;
  virtual   Bool_t operator()(CEvent&amp; rEvent);
  virtual   CGate* clone ()  ;
  virtual   std::string Type ()  const;
  virtual   Bool_t Inside(Float_t x, Float_t y);


};

#include &lt;C2Bands&gt;

class C2Bands  : public CContour        
{                       
public:


  C2Bands (UInt_t nXId, UInt_t nYId,
	   std::vector&lt;FPoint&gt;&amp; rLowBand, 
	   std::vector&lt;FPoint&gt;&amp; rHiBand); 
 virtual   std::string Type ()    ;

};

<beginpage />

#include &lt;CompoundGate.h&gt;

class CCompoundGate  : public CGate        
{
public:
  CCompoundGate () {}
  CCompoundGate(std::list&lt;CGateContainer*&gt; pGates);
  CCompoundGate(std::vector&lt;CGateContainer*&gt; pGates);
  CCompoundGate(UInt_t nGates, CGateContainer** ppGates);
  std::list&lt;CGateContainer*&gt;&amp; GetConstituents();
  virtual void RecursiveReset(); 
  virtual   CConstituentIterator Begin ()  ;
  virtual   CConstituentIterator End ()  ;
  virtual   UInt_t Size ()  ;
  virtual   std::string GetConstituent (CConstituentIterator&amp; rIterator)  ;
  void      AddGateFront(CGateContainer&amp; rGate);
  void      AddGateBack(CGateContainer&amp; rGate);
  void      AddGate(CConstituentIterator&amp; rSpot, CGateContainer&amp; rGate);

};

#include &lt;AndGate.h&gt;

class CAndGate  : public CCompoundGate        
{  
public
  CAndGate () : CCompoundGate() ;
  CAndGate(std::list&lt;CGateContainer*&gt;amp; rGates); 
  CAndGate(std::vector&lt;CGateContainer*&gt;amp; rGates);
  
  virtual   std::string Type ()  const;
  virtual   Bool_t inGate(CEvent&amp; rEvent, const std::vector&lt;UInt_t&gt;&amp; Params );
  virtual   Bool_t inGate(CEvent&amp; rEvent);

};

#include &lt;OrGate&gt;

class COrGate  : public CCompoundGate        
{
  COrGate ();
  COrGate(std::list&lt;CGateContainer*&gt;&amp; rGates);
  COrGate(std::vector&lt;CGateContainer*&gt;&amp; rGates);
  virtual   CGate* clone ()  ;
  virtual   std::string Type ()  const; 
  virtual   Bool_t inGate(CEvent&amp; rEvent, const std::vector&lt;UInt_t&gt;&amp; Params);
  virtual   Bool_t inGate(CEvent&amp; rEvent);
};
<beginpage />

#include &lt;Not.h&gt;

class CNot : public CGate
{
  CNot (CGateContainer&amp; rGate);
  const CGateContainer* getGate();
  virtual   CConstituentIterator Begin ()  ;
  virtual   CConstituentIterator End ()  ;
  virtual   UInt_t Size ()  ;
  virtual   std::string GetConstituent (CConstituentIterator&amp; rp)  ;
  virtual   CGate* clone ()  ;
  virtual   std::string Type ()  const;
  virtual   Bool_t inGate(CEvent&amp; rEvent, const std::vector&lt;UInt_t&gt;&amp; Params);
  virtual   Bool_t inGate(CEvent&amp; rEvent);
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The <classname>CGate</classname> class provides base class services
            and an API definition for SpecTcl's gate classes.  SpecTcl has
            a rich set of gate types ranging from primitive gates to compound
            gates.  A primitive gate is one that does not depend on other gates.
            A compound gate is one that depends on one or more other gates.
        </para>
        <para>
            As the same gate may be checked more than once per event, gates can
            rememer if they've been checkedand, if they have been, the result of
            the most recent check.
            For most gates, therefore, the actual computation of the gate is
            only done once per event with the cached value of that
            check being used in subsequent attempts to evaluate the gate.
        </para>
    </refsect1>
    <refsect1>
        <title>CGate METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CGate</methodname>
                        <void />
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs the base class.  The gate is set with the
                        cache invalid.  The state of the cached value is therefore
                        meaningless.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Bool_t </type>
                        <methodname>getChecked</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Bool_t </type>
                        <methodname>wasChecked</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If the gate has a valid cached value returns
                        <literal>kfTRUE</literal>.  Otherwise returns
                        <literal>kfFALSE</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Bool_t </type>
                        <methodname>getCachedValue</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If the gate has a cached value (<methodname>getChecked</methodname>
                        returns <literal>kfTRUE</literal>) returns the cached value
                        for that gate.  <literal>kfTRUE</literal> means the
                        gate was satisifed by its last check.
                        <literal>kfFALSE</literal> means the gate was not
                        satisfied.  If
                        <methodname>getChecked</methodname> returns
                        <literal>kfFalse</literal>, the return value
                        from this method has no meaning.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>Set </methodname>
                        <methodparam>
                            <type>Bool_t </type><parameter>fValue</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Sets the new value for the gate.   If called after
                        this method call, <methodname>getChecked</methodname>
                        will return <literal>kfTRUE</literal> until the
                        cache is reset via a call to <methodname>Reset</methodname>
                        is called on this gate or <methodname>RecursiveReste</methodname>
                        is called on this gate  or a gate that contains this gate
                        either directly or indirectly.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>Reset</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Resets the cache on this gate.  Any constituent gates
                        will not be reset.  Therefore, it is preferable
                        to call <methodname>RecursiveReset</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>RecursiveReset</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Resets the cached status of this break.  For every
                        constituent gate this method also does a recursive
                        reset on it.  Thus this method is expected to
                        Reset all the gates that contribute to this gate
                        as well as this gate itself.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>Bool_t </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                            <type>CEvent&amp;</type><parameter>rEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If the gate has a valid cached value, that value is returned.
                        If not, the gate is checked (normally using <methodname>inGate</methodname>).
                        The result is then cached and returned.
                    </para>
                    <para>
                        This might be implemented as:
                    </para>
                    <programlisting>
if (!wasChecked()) {
    Set(inGate(rEvent));   // Sets the gate status and cachce.
}
return getCachedValue();
                    </programlisting>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>CConstituentIterator</type>
                        <methodname> Begin </methodname>
                        <void />
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Compound gates are gates that depend on other
                        gates.  You can think of them as a container for
                        other gates (some may be compound as wel) and a
                        logical relationship required among those gates.  For
                        example, an <literal>And</literal> gate requires all
                        constituent gates to be satisfied if it is to be
                        satisifed for an event.
                        The gates a compound gate depends on are called
                        <firstterm>constituents</firstterm>.
                    </para>
                    <para>
                        If the gate has constituents, this method should return
                        an iterator to the first item of the container of
                        constituents  If the gate has no constitutents, the value
                        returned by <methodname>End</methodname> is returned.
                    </para>
                    <para>
                        This method is pure virtual to allow each
                        gate type to use the container of constituents appropriate
                        to it.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>CConstituentIterator </type>
                        <methodname>End</methodname>
                        <void />
                        <modifier>=0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the end of iteration iterator for the
                        consitutents of this gate.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>std::string </type>
                        <methodname>GetConstituent</methodname>
                        <methodparam>
                            <type>CConstituentIterator&amp;</type><parameter> rIterator</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a stringified version of the gate 'pointed to'
                        by the constituent iterator.  The form of this string
                        may vary from gate type to gate type.  Therefore,
                        this method will be documented completely for each
                        concrete gate class so you know what to expect.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>CGate* </type>
                        <methodname>clone</methodname>
                        <void />
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a dynamically created gate that is
                        identical in state to this gate.  Note that dynamically
                        created means that when the client is done with this
                        gate they must <literal>delete</literal> it.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier> virtual   </modifier>
                        <type>std::string </type>
                        <methodname>Type</methodname>
                        <void />
                        <modifier>const   = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a text string that identifies the gate type.
                        This method will be documented for each concrete
                        gate type.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type> Bool_t </type>
                        <methodname>inGate </methodname>
                        <methodparam>
                            <type>CEvent&amp; </type><parameter>rEvent</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is used mostly by non gamma gates.  That
                        is gates with only one set of possible parameters.
                        It returns <literal>kfTrue</literal> if the event
                        satisfies the gate and <literal>kfFalse</literal>
                        if not. 
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodsynopsis>
                    <modifier>virtual   </modifier>
                    <type>Bool_t </type>
                    <methodname>inGate</methodname>
                    <methodparam>
                        <type>CEvent&amp; </type><parameter>rEvent</parameter>
                    </methodparam>
                    <methodparam>
                        <modifier>const </modifier>
                        <type>std::vector&lt;UInt_t&gt;&amp; </type><parameter>Params</parameter>
                    </methodparam>
                    <modifier>= 0</modifier>
                </methodsynopsis></term>
                <listitem>
                    <para>
                        This is normally used by gamma gates.  If the parameter
                        ids in <parameter>Params</parameter> select a set of
                        parameters in <parameter>rEvent</parameter> that make
                        this gate true, the method returns <literal>kfTrue</literal>
                        otherwise <literal>kfFalse</literal>.
                    </para>
                    <para>
                        Gamma gates can be used as cuts by trying all legal
                        combinations of parmeter ids in the
                        <parameter>Params</parameter> vector.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>Bool_t </type>
                        <methodname>caches</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>kfTrue</literal> if the gate caches.
                        This can be used to restrict the set of gates that
                        are reset to only those that have a cache.
                    </para>
                </listitem>
            </varlistentry>
         </variablelist>
    </refsect1>
    <refsect1>
        <title>CCut Methods</title>
        <para>
            <classname>CCut</classname> gates represent an interval in parameter
            space for some parameter.  If an event has that parameter and that
            parameter lies in that interval, the gate is satisfied.  As with
            other intervals in SpecTcl, the interval is inclusive of the low
            limit but exclusive of the high limit.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CCut </methodname>
                        <methodparam>
                            <type>Float_t</type><parameter> am_nLow</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t </type><parameter>am_nHigh</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type><parameter>am_nId </parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs a gate that is satisfied when the
                        parameter with id <parameter>am_nId</parameter> is in
                        the interval
                        <literal>[<parameter>am_nLow</parameter>, <parameter>am_nHigh</parameter>)</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Float_t </type>
                        <methodname>getLow</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the value of the low end of the interval
                        that defines the cut.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Float_t </type>
                        <methodname>getHigh</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the value of the high end of the
                        interval that defines the cut.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>UInt_t </type>
                        <methodname>getId</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the id of the parameter this gate will test.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>std::vector&lt;std::string&gt; </type>
                        <methodname>getSpecs</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a vector of spectrum names involved with the
                        gate.  For a cut, no spectra are involved so an
                        empty vector is returned.  This is used mainly by
                        gamma gates.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>CConstituentIterator </type>
                        <methodname>Begin</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        A cut is a gate with a single constituent - itself.
                        This method returns an iterator that, once incremented
                        is at the end of iteration.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>CConstituentIterator</type>
                        <methodname> End </methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an iterator that points to nothing, and is
                        off the end of constiuents.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>UInt_t </type>
                        <methodname>Size</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>1</literal> indicating there is only
                        one constituent, the gate itself.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type> std::string </type>
                        <methodname>GetConstituent </methodname>
                        <methodparam>
                            <type>CConstituentIterator&amp;</type>
                            <parameter> rIterator</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If the iterator is not at end returns a string consisting
                        of three space separated values.  The first value is
                        the parameter id.  The second and third are the low and
                        high limits of the cut's interval.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>std::string </type>
                        <methodname>Type</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the string <literal>s</literal> for slice.
                        This is the type of gate.  Note that
                        <literal>c</literal> is used for the type of
                        contour gates.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type>   Bool_t </type>
                        <methodname>inGate</methodname>
                        <methodparam>
                            <type>Float_t </type><parameter>x</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>kfTRUE</literal> if
                        <parameter>x</parameter> is in the cut's interval.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>Bool_t </type>
                        <methodname>inGate</methodname>
                        <methodparam>
                            <type>CEvent&amp; </type><parameter>rEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If the event does not have the parameter whose id was
                        used to construct the cut, returns <literal>kfFalse</literal>.
                        If it does, the value of that parameter is passed to
                        the previous method and the result of that method
                        is returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>Bool_t </type>
                        <methodname>inGate</methodname>
                        <methodparam>
                            <type>CEvent&amp;</type><parameter> rEvent</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier>const </modifier><type>std::vector&lt;UInt_t&gt;&amp; </type>
                            <parameter>Params</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Same as the previous method, howver instead of using
                        the id of the parameter used to construct this
                        object, the parameter id <parameter>Params[0]</parameter>
                        is used.
                    </para>
                </listitem>
            </varlistentry>
            
 
        </variablelist>
    </refsect1>
    <refsect1>
        <title><classname>CFalseGate methods</classname></title>
        <para>
            <classname>CFalseGate</classname> is a gate that is never satisfied.
            When gates are deleted, they are actually replaced by false gates,
            gates are never actually deleted.
        </para>
        <variablelist>
             <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type> Bool_t </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                            <type>CEvent&amp; </type><parameter>rEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        As the gate name implies, regardless of the content
                        of <parameter>rEvent</parameter>, this always
                        returns <literal>kfFALSE</literal>.
                    </para>
                </listitem>
             </varlistentry>
             <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>CConstituentIterator </type>
                        <methodname>Begin</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an iterator at end (same value as
                        <methodname>End</methodname>).  False gates have no
                        components.
                    </para>
                </listitem>
             </varlistentry>
             <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>CConstituentIterator</type>
                        <methodname> End</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                    </para>
                </listitem>
             </varlistentry>
             <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>UInt_t </type>
                        <methodname>Size</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>0</literal>
                    </para>
                </listitem>
             </varlistentry>
             <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>std::string </type>
                        <methodname>GetConstituent </methodname>
                        <methodparam>
                            <type>CConstituentIterator&amp; </type><parameter>rIterator</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Regardless of the value of
                        <parameter>rIterator</parameter>; returns an empty string.
                    </para>
                </listitem>
             </varlistentry>
             <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>  virtual   </modifier>
                        <type>std::string </type>
                        <methodname>Type </methodname>
                        <void />
                        <modifier>const;</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the string <literal>F</literal> which represents
                        a False gate.
                    </para>
                </listitem>
             </varlistentry>
             <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type> Bool_t </type>
                        <methodname>inGate</methodname>
                        <methodparam>
                            <type>CEvent&amp; </type><parameter>rEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>Bool_t </type>
                        <methodname>inGate</methodname>
                        <methodparam>
                            <type>CEvent&amp; </type><parameter>rEvent</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier>const</modifier>
                            <type>std::vector&lt;UInt_t&gt;&amp; </type><parameter>ids</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Both of these return <literal>kfFalse</literal>
                        regardless of the parameters passed in.
                    </para>
                </listitem>
             </varlistentry>
             <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>Bool_t </type>
                        <methodname>caches</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>kfFalse</literal> as there's no need
                        for a hard coded gate like <classname>CFalseGate</classname>
                        to cache its answers.
                    </para>
                </listitem>
             </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title><classname>CTrueGate methods</classname></title>
        <para>
            <classname>CTrueGate</classname> is a gate that is never satisfied.
            When a spectrum is created it is initially gated on a true gate.
            True gates can also be used as place holders for gate to be defined
            later.
        </para>
        <variablelist>
             <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type> Bool_t </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                            <type>CEvent&amp; </type><parameter>rEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        As the gate name implies, regardless of the content
                        of <parameter>rEvent</parameter>, this always
                        returns <literal>kfTRUE</literal>.
                    </para>
                </listitem>
             </varlistentry>
             <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>CConstituentIterator </type>
                        <methodname>Begin</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an iterator at end (same value as
                        <methodname>End</methodname>).  False gates have no
                        components.
                    </para>
                </listitem>
             </varlistentry>
             <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>CConstituentIterator</type>
                        <methodname> End</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                    </para>
                </listitem>
             </varlistentry>
             <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>UInt_t </type>
                        <methodname>Size</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>0</literal>
                    </para>
                </listitem>
             </varlistentry>
             <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>std::string </type>
                        <methodname>GetConstituent </methodname>
                        <methodparam>
                            <type>CConstituentIterator&amp; </type><parameter>rIterator</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Regardless of the value of
                        <parameter>rIterator</parameter>; returns an empty string.
                    </para>
                </listitem>
             </varlistentry>
             <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>  virtual   </modifier>
                        <type>std::string </type>
                        <methodname>Type </methodname>
                        <void />
                        <modifier>const;</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the string <literal>T</literal> which represents
                        a True gate.
                    </para>
                </listitem>
             </varlistentry>
             <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type> Bool_t </type>
                        <methodname>inGate</methodname>
                        <methodparam>
                            <type>CEvent&amp; </type><parameter>rEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>Bool_t </type>
                        <methodname>inGate</methodname>
                        <methodparam>
                            <type>CEvent&amp; </type><parameter>rEvent</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier>const</modifier>
                            <type>std::vector&lt;UInt_t&gt;&amp; </type><parameter>ids</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Both of these return <literal>kfTrue</literal>
                        regardless of the parameters passed in.
                    </para>
                </listitem>
             </varlistentry>
             <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>Bool_t </type>
                        <methodname>caches</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>kfFalse</literal> as there's no need
                        for a hard coded gate like <classname>CFalseGate</classname>
                        to cache its answers.
                    </para>
                </listitem>
             </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title>Mask gate methods</title>
        <para>
            Bit mask gates treat a parameter like a bitmask (integer) and
            perform various bit logic mask and compare operations.
            An abstract base class; <classname>CMaskGate</classname>
            Provides storage for the constant bit mask  and the following
            meaningful methods:
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CMaskGate</methodname>
                        <methodparam>
                            <type>UInt_t</type><parameter> mask</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        This base class constructor stores the
                        <parameter>mask</parameter> as an object attribute.
                        Derived classes can use <methodname>getCompare</methodname>
                        to retrieve this value.  Gates derived from this
                        method normally perform some bitwise operation between
                        the parameter and the mask and then a comparison.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>long </type>
                        <methodname>getCompare</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the mask that used to instantiate this base class.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type> Bool_t </type>
                        <methodname>operator() </methodname>
                        <methodparam>
                            <type>CEvent&amp; </type><parameter>rEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This just determine is the actual class's
                        <methodname>inGate</methodname> method has to be invoked.
                        If not the cached value for the gate is returned.
                        Psuedo code for this is:
                    </para>
                    <programlisting>

if cache is not valid
   Set cached value from Actual Class's inGate(rEvent)
endif
return cached value

                    </programlisting>
                </listitem>
            </varlistentry>
        </variablelist>
        <refsect2>
            <title>MaskAnd gates</title>
            <para>
                These gates check to see if all bits in a mask are present
                in the parameter.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>CMaskAndGate </methodname>
                            <methodparam>
                                <type>UInt_t</type><parameter> am_nId</parameter>
                            </methodparam>
                            <methodparam>
                                <type>UInt_t  </type><parameter>am_lCompare</parameter>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            <parameter>am_nId</parameter> is the parameter id
                            of the parameter to test.
                        </para>
                        <para>
                            <parameter>am_lCompare</parameter> is the bit
                            mask used inthe compare.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>long </type>
                            <methodname>getCompare</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the bit mask used in the test.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>UInt_t</type>
                            <methodname>getId</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the id of the parameter that is checked
                            by this gate.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>std::string </type>
                            <methodname>Type</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns <literal>am</literal> for
                            <firstterm>And Mask</firstterm>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual  </modifier>
                            <type> Bool_t </type>
                            <methodname>inGate</methodname>
                            <methodparam>
                                <type>CEvent&amp; </type><parameter>rEvent</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier>const </modifier>
                                <type>std::vector&lt;UInt_t&gt;&amp; </type><parameter>Params</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>Bool_t </type>
                            <methodname>inGate</methodname>
                            <methodparam>
                                <type>CEvent&amp; </type><parameter>rEvent</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Check for the parameter to satisfy the gate.
                            Unfortunately the implementation of both of these
                            methods are the same (<parameter>Params</parameter> is
                            totally ignored and the first method just calls
                            the second.
                        </para>
                        <para>
                            The Mask used to construct the gate is bitwise
                            anded with the parameter.  If the result is
                            equal to the mask, the gate is satisfied, otherwise
                            not.
                        </para>
                        <para>
                            If the gate is satisfied, the method returns
                            <literal>kfTRUE</literal> otherwise
                            <literal>kfFALSE</literal>.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect2>
        <refsect2>
            <title>Mask Equal gates</title>
            <para>
                These just test for bitwise equality of the integerized parameter
                with the specified comparison bitmask.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>CMaskEqualGate </methodname>
                            <methodparam>
                                <type>UInt_t </type><parameter>am_nId</parameter>
                            </methodparam>
                            <methodparam>
                                <type>UInt_t  </type><parameter>am_lCompare </parameter>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Provides a parameter id and a comparison mask on which
                            the object (gate) is constructed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>long </type>
                            <methodname>getCompare</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the comparison value for the gate.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>UInt_t </type>
                            <methodname>getId</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the Id of the parameter on which the
                            gate was constructed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual</modifier>
                            <type>Bool_t </type>
                            <methodname>inGate</methodname>
                            <methodparam>
                                <type>CEvent&amp;</type><parameter> rEvent</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Compares the specified parameter to the mask.
                            If bitwise equal the gate is satisfied.
                        </para>
                    </listitem>
                </varlistentry>

            </variablelist>
        </refsect2>
        <refsect2>
            <title><classname>CMaskNotGate</classname> METHODS</title>
            <para>
                This gate tests for bits that are not in a mask.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>CMaskNotGate </methodname>
                            <methodparam>
                                <type>UInt_t </type><parameter>am_nId</parameter>
                            </methodparam>
                            <methodparam>
                                <type>UInt_t  </type><parameter>am_lCompare</parameter>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            As with all of these mask gate classes,
                            a parameter id (<parameter>am_nId</parameter>) and
                            a mask (<parameter>am_lCompare</parameter>) are required
                            by the constructor.  The actual gate pseudo code
                            will be shown in the <methodname>inGate</methodname>
                            method.  However, this gate will be satisfied if
                            the parameter contains all of the bits that are not
                            set in the mask.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>long </type>
                            <methodname>getCompare</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the value of the mask used in the
                            <methodname>inGate</methodname> operation.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>UInt_t </type>
                            <methodname>getId</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the id of the parameter checked in the
                            <methodname>inGate</methodname> method.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>Bool_t </type>
                            <methodname>inGate</methodname>
                            <methodparam>
                                <type>CEvent&amp; </type>
                                <parameter>rEvent</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Determines if the parameter associated with the
                            gate satisfies it for the event <parameter>rEvent</parameter>.
                            The psuedo code for this is:
                        </para>
                        <programlisting>
id = getId()
if rEvent[id].isValid() then
   mask = ~getCompare()                   // Note bitwise complement.
   return (mask &amp; rEvent[id])  == mask
endif
return kfFALSE
                        </programlisting>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect2>
    </refsect1>
        <refsect1>
            <title><classname>CPointListGate</classname> methods</title>
            <para>
                2-d gates are normally figures draw in a 2-d space defined by
                a pair of parameters.  These figures are defined by an array
                of points in parameter space.
                <classname>CPointListGate</classname> is an abstract
                base class for simple
                2-d gates which stores the ids of both X and Y parameters and
                the list of points that define the figure.
            </para>
            <para>
                While the figure points can be abstracted, the concept of
                inside-ness of a point in parameter space must be defined
                by a concrete derived class.  It's easy to see that this is
                the case by considering the difference in the definition
                of inside-ness for a contour (closed figure) and a band (polyline).
            </para>
            <variablelist>
                  <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>CPointListGate</methodname>
                            <methodparam>
                                <type>UInt_t </type><parameter>nXId</parameter>
                            </methodparam>
                            <methodparam>
                                <type> UInt_t </type><parameter>nYId</parameter>
                            </methodparam>
                            <methodparam>
                                <type>const std::vector&lt;FPoint&gt;&amp; </type><parameter>Points</parameter>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <term>
                        <constructorsynopsis>
                            <methodname>CPointListGate</methodname>
                            <methodparam>
                                <type>UInt_t </type><parameter>nXId</parameter>
                            </methodparam>
                            <methodparam>
                                <type>UInt_t </type><parameter>nYId</parameter>
                            </methodparam>
                            <methodparam>
                                <type>UInt_t </type><parameter>nPts</parameter>
                            </methodparam>
                            <methodparam>
                                <type>Float_t </type><parameter>*xCoords</parameter>
                            </methodparam>
                            <methodparam>
                                <type>Float_t </type><parameter>*yCoords</parameter>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <term>
                        <constructorsynopsis>
                            <methodname>CPointListGate</methodname>
                            <methodparam>
                                <type>UInt_t </type><parameter>nXId</parameter>
                            </methodparam>
                            <methodparam>
                                <type> UInt_t </type><parameter>nYId</parameter>
                            </methodparam>
                            <methodparam>
                                <type>UInt_t </type><parameter>nPts</parameter>
                            </methodparam>
                            <methodparam>
                                <type>FPoint* </type><parameter>pPoints</parameter>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            All constrcutors provide <parameter>nXId</parameter>,
                            the id of the X parameter for the gate and
                            <parameter>nYId</parameter>, the
                            id of the Y parameter for the gate.  Constructors
                            only differ in how the points that define the gate
                            shape are passed.
                        </para>
                        <para>
                            In the first constructor, points are passsed in as
                            <parameter>Points</parameter>, a vector of type
                            <classname>FPoint</classname>.  This type is
                            defined in the <filename>Point.h</filename> header.
                            It is an object that encapsulates an X,Y coordinate
                            pair that represents one point fo the gate shape.
                        </para>
                        <para>
                            The last two constructors require that the
                            number of points in the gate shape,
                            <parameter>nPts</parameter>, be passed to the
                            constructor.
                        </para>
                        <para>
                            In the first of those two, the parameters
                            <parameter>xCoords</parameter> and
                            <parameter>yCoords</parameter> point to
                            simple C arrays containing the X aqnd Y coordinates
                            of each point
                            respectively.  Clearly <parameter>xCoords</parameter>
                            and <parameter>yCoords</parameter> must both have
                            <parameter>nPts</parameter> elements.
                        </para>
                        <para>
                            In the final constructor, the parameter
                            <parameter>pPoints</parameter> points to a C array
                            of <classname>FPoint</classname> objects.
                        </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>UInt_t </type>
                            <methodname>getxId</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>UInt_t </type>
                            <methodname>getyId</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            These two methods get the ids of the parameters
                            on the X and Y axes of the gate shape.  An event
                            that has both of these ids defines a point in
                            parameter space where the parameter whose id is
                            returned by <methodname>getxId</methodname> is
                            on the X axis and that returned by
                            <methodname>getyId</methodname> is on the Y
                            axis.  Gate points define a figure in this
                            space whose meaning depends on the actual,
                            concrete gate type.
                        </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>std::vector&lt;FPoint&gt; </type>
                            <methodname>getPoints</methodname>
                            <void />
                            <modifier> const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns a copy of the points vector.  This may result
                            in copying a significatn number of
                            <classname>FPoint</classname> objects and should
                            not be userd to obtain gate points in order to
                            check gates.  Better to iterate or, if appropriate,
                            use the <methodname>Crosses</methodname>
                            utility method.
                        </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>std::vector&lt;FPoint&gt;::iterator </type>
                            <methodname>getBegin</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>std::vector&lt;FPoint&gt;::iterator </type>
                            <methodname>getEnd</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            These methods provide support for iteration over
                            the set of points that define the gate.  The
                            <methodname>getBegin</methodname> returns an iterator
                            to the beginning of the container of
                            <classname>FPoint</classname> objects defining the
                            gate points while
                            <methodname>getEnd</methodname> returns an
                            end of iteration iterator.
                        </para>
                        <para>
                            If you are not sure what all this means; look up
                            how iterators work in the C++ Standard Template
                            library.  These iterators work the same way.
                        </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual</modifier>
                            <type>   CConstituentIterator </type>
                            <methodname>Begin</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>CConstituentIterator </type>
                            <methodname>End </methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>UInt_t </type>
                            <methodname>Size</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The constituents of point list gates are the points
                            of the gate.  <methodname>Begin</methodname>
                            and <methodname>End</methodname> provide for
                            iteration over the constituents (see
                            <methodname>GetConstituent</methodname> below).
                            <methodname>Size</methodname> returns the number
                             of constituents, in this case, the number of
                             points in the gate figure.
                        </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>std::string </type>
                            <methodname>GetConstituent</methodname>
                            <methodparam>
                                <type>CConstituentIterator&amp; </type><parameter>rIterator</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Return the text string corresponsding to the
                            constituent iterator <parameter>rIterator</parameter>.
                            This will be a string consisting of two space
                            separated floating point number strings
                            (<literal>%f</literal> conversion).  The first number
                            is the X coordinate value of the point corresponding
                            to the iterator while the second the Y coordinate
                            of the same point.
                        </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier> virtual  </modifier>
                            <type>Bool_t </type>
                            <methodname>inGate</methodname>
                            <methodparam>
                                <type>CEvent&amp; </type><parameter>rEvent</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs common code required to check if a gate
                            is satisfied by an event. The geometry sensitive
                            part of the check is done by the pure virtual
                            method <methodname>Inside</methodname> defined
                            below.  Thwe psuedo code for this
                            method is:
                        </para>
                        <programlisting>
xid = getxId()
yid = getyid()
if (rEvent[xid].isValid() and rEvent[yid].isValid()) then
    return Inside(rEvent[xid], rEvent[yid])
endif

return kfFalse
                        </programlisting>
                        <para>
                            Thus this method only checks that both parameters
                            are defined.  If so <methodname>Inside</methodname>
                            is invoked to see if the point defined by the
                            event satisfies the gate and otherwise,
                            <literal>kfFalse</literal> is returned.
                        </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier> virtual  </modifier>
                            <type>Bool_t </type>
                            <methodname>Inside</methodname>
                            <methodparam>
                                <type>Float_t </type><parameter>x</parameter>
                            </methodparam>
                            <methodparam>
                                <type>Float_t </type><parameter>y</parameter>
                            </methodparam>
                            <modifier>=0</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Pure virtual method that has to be implemented by
                            concrete sub-classes.  <parameter>x</parameter> and
                            <parameter>y</parameter> are a point in the parameter
                            coordinate space in which the gate is drawn.  The
                            method should return <literal>kfTRUE</literal> if this
                            point is 'inside' that gate or
                            <literal>kfFALSE</literal> if not.
                        </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>protected</modifier>
                            <type>int</type>
                            <methodname>Crosses</methodname>
                            <methodparam>
                                <type>Float_t </type><parameter>x</parameter>
                            </methodparam>
                            <methodparam>
                                <type>Float_t </type><parameter>y</parameter>
                            </methodparam>
                            <methodparam>
                                <type>std::vector&lt;FPoint&gt;::iterator</type>
                                <parameter> f</parameter>
                            </methodparam>
                            <methodparam>
                                <type>std::vector&lt;FPoint&gt;::iterator </type>
                                <parameter>s</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This utility method  is useful for determining
                            inside-edness.  The parameters
                            <parameter>x</parameter> and <parameter>y</parameter>
                            define a point in the parameter space of a gate.
                            <parameter>f</parameter> and <parameter>s</parameter>
                            are two iterators that indicate two consecutive points
                            in the figure that defines the gate.
                            
                        </para>
                        <para>
                            Those two points define a line segment in the gate
                            parameter space.  The method 'draws' a horizontal
                            ray that extends left from (<parameter>x</parameter>, <parameter>y</parameter>).
                            The method returns <literal>1</literal> if this
                            line would intersect (cross) the line segment
                            defined by <parameter>f</parameter> and
                            <parameter>s</parameter>.  If not,
                            <literal>0</literal> is returned.
                        </para>
                        <para>
                            Special cases that can speed up the determination
                            are mercilessly  exploited.
                        </para>
                    </listitem>
                  </varlistentry>
            </variablelist>
        <refsect2>
            <title><classname>CBand</classname> methods</title>
            <para>
                A Band is a polyline drawn in a two dimensional space defined
                by two SpecTcl parameters.  Inside-ness is defined as being
                inside a region of the plane defined by the polyline and
                vertical lines from the left and right points extending infinitely
                down.
                A point is inside this region if a horizontal ray drawn
                leftward from the point crosses an odd number of line segments
                that make up the boundaries of the region.   The vertical
                lines described above are included in that count.
            </para>
            <para>
                This definition provides well defined behavior for bands that
                are multivalued in y (polylines for which the x coordinate
                of points is not monotonic).  This definition is also
                consistent withe the definition of inside-ness used by
                contour gates.
            </para>
            <para>
                The constructors are not documented below as there are three
                of them that have all the same parameterizations as the
                three constructors of the <methodname>PointListGate</methodname>
                base class from which <classname>CBand</classname> is defined.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>std::string </type>
                            <methodname>Type </methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the gate type which is
                            <literal>b</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                       <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>Bool_t </type>
                        <methodname>Inside</methodname>
                        <methodparam>
                            <type>Float_t </type><parameter>x</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t </type><parameter>y</parameter>
                        </methodparam>
                        <modifier></modifier>
                       </methodsynopsis> 
                    </term>
                    <listitem>
                        <para>
                            Just invokes <methodname>Interior</methodname>,
                            see below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>protected</modifier>
                            <type>Bool_t</type>
                            <methodname> Interior</methodname>
                            <methodparam>
                                <type>Float_t </type><parameter>x</parameter>
                            </methodparam>
                            <methodparam>
                                <type>Float_t </type><parameter>y</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Determines if a point is inside the band region.
                            A boundary crossing algorithm similar to what is used
                            in flood fill operations is used to define
                            interior points consistently and predictably regardless
                            of any pathologies of the boundary.
                        </para>
                        <para>
                            The software counts boundary crossings, including
                            the crossings of rays extending from the left and
                            right most points to negative infinity.  An odd
                            number of crossings means the point is inside the
                            figure. An even number (zero is even) means the
                            point is outside.
                        </para>
                        <para>
                            Here is pseudo code:
                        </para>
                        <programlisting>
crossings = 0
if point is to the right and below the left most point crossings = crossings + 1
if point is to the right and below the righ tmost point crossings = crossings + 1

for each line segment in the polyline:
    if Crosses(point, segment) then     // Crosses from base class
        crossings = crossings + 1
    endif
end for
return (crosses &amp; 1) == 1
                        </programlisting>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect2>
        <refsect2>
            <title><classname>CContour</classname> methods</title>
            <para>
                Contour gates are closed figures that are drawn on a 2-d parameter
                space. A contour is satisified if the parameters are both defined
                and lie within the figure.  <classname>CContour</classname>
                implements contour gates and is derived from
                <classname>CPointListGate</classname>.
            </para>
            <para>
                As with bands, pathalogical figures are possible.  Contours
                use a definition of inside-ness that is similar to that of
                bands, with the exception that there's no need to draw
                rays from a left and right point to negative infinity to
                complete a semi-infinite closed figure.  For a contour a
                final line segment is drawn from the last point to the first
                point.
            </para>
            <para>
                An optimization is performed when the gate is constructed.
                A bounding rectangle is computed from the points of the figure.
                When checking the gate; the point is first tested against this
                rectangle and the gate is not satisifed if the point is outside
                the rectangle.  If the point is inside the rectangle, then
                a horizontal ray is 'drawn' from the point towards the left.
                The number of times this ray crosses a segment of the
                figure is computed and the point is considered inside the
                figure if this number is odd.
            </para>
            <para>
                Psuedo code for this will be presented in the description
                of the methods below.  Note that the constructors for
                <classname>CContour</classname> are identical
                to those for <classname>CPointListGate</classname>.  They
                will not be documented below.  Refer to
                <classname>CPointListGate</classname> for a description of
                the constructor signatures.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>FPoint </type>
                            <methodname>getLowerLeft</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This method returns the point at the lower left
                            of the rectangle that bounds the contour.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>FPoint </type>
                            <methodname>getUpperRight</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This method returns the point at the upper
                            right of the rectangle that bounds the contour.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>std::string </type>
                            <methodname>Type </methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the string <literal>c</literal> indicating
                            this is a contour gate.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>Bool_t </type>
                            <methodname>Inside</methodname>
                            <methodparam>
                                <type>Float_t </type><parameter>x</parameter>
                            </methodparam>
                            <methodparam>
                                <type>Float_t </type><parameter>y</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns <literal>kfTrue</literal> if
                            <parameter>x</parameter>, <parameter>y</parameter>
                            define a point inside the contour figure.
                            For a conceptual description of the definition
                            of inside (in the presence of pathalogical shapes),
                            see the description at the top of this section.
                        </para>
                        <para>
                            Psuedo code for the check is shown below:
                        </para>
                        <programlisting>
If (x,y) is inside the bounding rectangle then
   crossings = 0
   for each segment in the figure        // Note the last point is connected to first.
        if Crosses(x,y, segment)  then   // From <classname>CPointListGate</classname>
            crossings = crossings + 1
        endif
    end for
    return (crossings &amp; 1) == 1      //  true if odd.
endif
return kfFALSE                           // Outside bounding rectangle.
        
                        </programlisting>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect2>
        <refsect2>
            <title><classname>C2Bands</classname> Methods.</title>
            <para>
                This gate is essentially two bands that are made into
                a countour by joining their left and rightmost points
                to close the figure defined by the two bands.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>C2Bands</methodname>
                            <methodparam>
                                <type>UInt_t </type><parameter>nXId</parameter>
                            </methodparam>
                            <methodparam>
                                <type>UInt_t </type><parameter>nYId</parameter>
                            </methodparam>
                            <methodparam>
                                <type>std::vector&lt;FPoint&gt;&amp;</type><parameter> rLowBand</parameter>
                            </methodparam>
                            <methodparam>
                                <type>std::vector&lt;FPoint&gt;&amp; </type><parameter>rHiBand</parameter>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Constructs a contour from two bands whose
                            parameters are specified by
                            <parameter>nXId</parameter> and
                            <parameter>nYId</parameter>.  The points that define
                            the first band are <parameter>rLowBand</parameter>
                            and those of the second,
                            <parameter>rHiBand</parameter>.
                        </para>
                        <para>
                            The constructor simply marshalls these points
                            for the <classname>CContour</classname>
                            constructor.  Once that's done, the methods of
                            <classname>CContour</classname> class
                            provides all of the functionality.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>std::string</type>
                            <methodname> Type</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the string
                            <literal>cb2</literal>.
                        </para>
                    </listitem>
                </varlistentry>

            </variablelist>
        </refsect2>
    </refsect1>
    <refsect1>
        <title><classname>CCompoundGate</classname> Methods</title>
        <para>
            Compound gates are gates that are composed of one or more
            other <firstterm>constituent</firstterm>
            gates.  The compound gate is satisfied if a logical
            function of its constituent gates is satisfied.
        </para>
        <para>
            <classname>CCompoundGate</classname> is an abstract base
            class for compound gates.  This section will describe that
            gate and the gates that are derived from this class.
        </para>
        <para>
            <classname>CCompoundGate</classname> provides storage of and
            access to the constituent gates.  The constituents can either
            be provided at construction time or built up incrementally..
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname> CCompoundGate</methodname>
                        <void />
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        This constructor creates the base class without
                        any contituent gates.   Method such as
                        <methodname>AddGateBack</methodname> must be used
                        to add constituents to the gate.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CCompoundGate</methodname>
                        <methodparam>
                            <type>std::list&lt;CGateContainer*&gt; </type><parameter>pGates</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <term>
                    <constructorsynopsis>
                        <methodname>CCompoundGate</methodname>
                        <methodparam>
                            <type>std::vector&lt;CGateContainer*&gt; </type><parameter>pGates</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <term>
                    <constructorsynopsis>
                        <methodname>CCompoundGate</methodname>
                        <methodparam>
                            <type>UInt_t </type><parameter>nGates</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CGateContainer** </type><parameter>ppGates</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        These constructors create the object with an initial
                        set of gates.  Gates are stored as pointers to a
                        gate container.  This allows SpecTcl ot modify
                        what the gate container "points to" without having
                        to locate and fix up all references to an underlying
                        gate.  
                    </para>
                    <para>
                        The constructors only differ in the wa in which the
                        constituent gates are passed to the constuctor.
                        The first two use the
                        <classname>std::vector</classname> and
                        <classname>std::list</classname> container for the
                        constituent gates while the last uses a counted
                        C array of pointers to <classname>GateContainer</classname>
                        pointers.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::list&lt;CGateContainer*&gt;&amp; </type>
                    <methodname>GetConstituents</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis></term>
                <listitem>
                    <para>
                        Returns the list of pointers to the gate containers that
                        make up this gate.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>RecursiveReset</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Resets the cache of this gate and all
                        constituent gates.  The next time this, or any
                        constituent gate is asked for its value vai
                        <methodname>operator()</methodname> it must
                        re-evaluate the gate with respect to the event.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type> CConstituentIterator</type>
                        <methodname> Begin </methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>CConstituentIterator </type>
                        <methodname>End</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>UInt_t </type>
                        <methodname>Size </methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Provides the usual constituent iterator interface
                       for the compound gate.  <methodname>Begin</methodname>
                       produces an iterator at the start of the container
                       and <methodname>End</methodname> one that is off
                       the end of the container.  Finally
                       <methodname>Size</methodname> returns the number
                       of times the iterator returned by
                       <methodname>Begin</methodname> can be incremented
                       before it becomes equal to the iterator returned
                       by <methodname>End</methodname>.   
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>std::string </type>
                        <methodname>GetConstituent</methodname>
                        <methodparam>
                            <type>CConstituentIterator&amp; </type><parameter>rIterator</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the name of a constituent gate.
                        For compound gates, the
                        <classname>ConstituentIterator</classname> can be
                        thought of as an object that retrieves
                        constituent gate names.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void      </type>
                        <methodname>AddGateFront</methodname>
                        <methodparam>
                            <type>CGateContainer&amp; </type><parameter>rGate</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a new constituent gate at the beginning of
                        the constituents for the gate. Normally it's too hard
                        to predicts the effect of constituent order on gates.
                        If these can be predicted, however for
                        And gates, the gates are most efficiently ordered in
                        order of decreasing probability they'll fail, while
                        for OR gates, gates are most efficiently ordered
                        in decreasing probability they willl be satisfied.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void      </type>
                    <methodname>AddGateBack</methodname>
                    <methodparam>
                        <type>CGateContainer&amp; </type><parameter>rGate</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis></term>
                <listitem>
                    <para>
                        Adds the gate container <parameter>rGate</parameter>
                        at the end of all of the existing constituents.
                        See above for notes on ordering gates.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void     </type>
                        <methodname> AddGate</methodname>
                        <methodparam>
                            <type>CConstituentIterator&amp; </type><parameter>rSpot</parameter>
                        </methodparam>
                        <methodparam>
                            <type> CGateContainer&amp; </type><parameter>rGate</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds the gate container <parameter>rGate</parameter>
                        in the constituent list just prior to <parameter>rSpot</parameter>.
                        Thus <code>AddGateFront(rGate)</code> is
                        identical to <code>AddGate(Begin(), rGate)</code>.
                        Similarly, <code>AddGateBack(rGate)</code> is
                        identical to <code>AddGate(End(), rGate)</code>.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <refsect2>
            <title><classname>CAndGate</classname> methods</title>
            <para>
                An And gate is a compound gate that is satisfied only if all of
                its constituent gates are satisfied.  Short ciruit evaluation
                improves the efficiency of evaluating this gate.  Gates in
                the constituent list only get evaluated until the first
                gate fails at  which time the gate is determined not to have
                been satisifed.   If all gates are satisified, the and
                gate is satisfied.
            </para>
            <para>
                The constructors for this class mirror those of
                <classname>CCompoundGate</classname> and therefore will not be
                documented below.  Refer to the documentation of the
                constructors for <classname>CCompoundGate</classname> for more
                information about the constructors for this class.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>std::string </type>
                            <methodname> Type</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the string <literal>*</literal>.  This is the
                            symbol for an and gate because the logical and
                            operation is normally called the logical product.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>Bool_t </type>
                            <methodname>inGate</methodname>
                            <methodparam>
                                <type>CEvent&amp; </type><parameter>rEvent</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier>const </modifier>
                                <type>std::vector&lt;UInt_t&gt;&amp; </type><parameter>Params </parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>Bool_t </type>
                            <methodname>inGate</methodname>
                            <methodparam>
                                <type>CEvent&amp; </type><parameter>rEvent</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Determines if the gate is satisfied.  Since this is
                            not a gamma gate, the first of these methods
                            simply calls the second.  The second method
                            evaluates the gate by recursively evaluating
                            the minimum set of constituents needed to determine if the
                            gate is satisfied.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect2>
        <refsect2>
            <title><classname>COrGate</classname> methods</title>
            <para>
                The Or gate is satisfied if any of its consituents is satisfied.
                As with <classname>CAndGate</classname>, short circuit evaluation
                is used to minimize the computation required to evaluate this
                gate.  Constituent gates are evaluated until the first satisfied
                gate at which point, the gate is deemed satisified.  If no
                gates in the list of consitutents are satisfied, the gate is
                deemed to have not been satisfied.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>std::string </type>
                            <methodname>Type</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the string <literal>+</literal>.  This is the
                            type for a an or gate because the logical OR operation
                            is often called the logical sum of its product
                            terms.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual  </modifier>
                            <type> Bool_t</type>
                            <methodname> inGate</methodname>
                            <methodparam>
                                <type>CEvent&amp;</type><parameter> rEvent</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier>const </modifier>
                                <type>std::vector&lt;UInt_t&gt;&amp;</type><parameter> Params</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual </modifier>
                            <type>  Bool_t </type>
                            <methodname>inGate</methodname>
                            <methodparam>
                                <type>CEvent&amp; </type><parameter>rEvent</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Recursively evaluates the constituent gates.  As soon
                            as a constituent gate is determined to  be satisfied,
                            this method returns <literal>kfTRUE</literal>,
                            if no constituent gates are satisfied, the method
                            return <literal>kfFALSE</literal>
                        </para>
                        <para>
                            As the gate does not have fold/gamma gate
                            semantics, the first of these methods simply
                            calls the second.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>            
        </refsect2>
    </refsect1>
    <refsect1>
        <title><classname>CNot</classname> Methods</title>
        <para>
            A Not gate is a gate that is true if its single constituent
            gate is false.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CNot</methodname>
                        <methodparam>
                            <type>CGatContainer&amp; </type><parameter>rGate</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        The <parameter>rGate</parameter> is the single constituent
                        gate.  This gate will
                        only be true for events that satisfy
                        this constituent.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>const </modifier>
                        <type>CGateContainer* </type>
                        <methodname>getGate</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the gate container of the
                        gate whose logical sense is  inverted by this gate.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>CConstituentIterator </type>
                        <methodname>Begin </methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier> virtual   </modifier>
                        <type>CConstituentIterator </type>
                        <methodname>End</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>UInt_t </type>
                        <methodname>Size</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Supplies the constituent iteration interface for
                        this gate type.  <methodname>Begin</methodname> and
                        <methodname>End</methodname> provide iterators for
                        the start of iteration and the end respectively.
                        <methodname>Size</methodname> returns the number
                        of constituents (<literal>1</literal>).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>std::string </type>
                        <methodname>GetConstituent</methodname>
                        <methodparam>
                            <type>CConstituentIterator&amp; </type><parameter>rp</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the constituent pointed at the iterator
                        <parameter>rp</parameter>.  For the iterator
                        returned by <methodname>Begin</methodname>, this returns
                        the name of the constituent gate. Otherwise an empty string
                        is returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>std::string </type>
                        <methodname>Type</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the string <literal>-</literal> which is the
                        type strig for a not gate. The string indicates negation
                        of the constituent gate.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type>Bool_t </type>
                        <methodname>inGate</methodname>
                        <methodparam>
                            <type>CEvent&amp; </type><parameter>rEvent</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>std::vector&lt;UInt_t&gt;&amp; </type><parameter>Params</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type> Bool_t </type>
                        <methodname>inGate</methodname>
                        <methodparam>
                            <type>CEvent&amp; </type><parameter>rEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Rturns <literal>kfTRUE</literal> if
                        <parameter>rEvent</parameter> satisfies the gate
                        (does not satisfy the constituent gate).
                        Otherwise returns <literal>kfFALSE</literal>.
                        The gate is not a gamma gate so the first overload of
                        this method just invokes the second.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CGateContainer</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CGateContainer</refname>
        <refpurpose>Pointer like class for Gates.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;GateContainer.h&gt;
class CGateContainer : public CNamedItem {
 public:

  CGateContainer() ;
  CGateContainer (const std::string&amp; sName, UInt_t nNumber, 
		  CGate&amp; rGate);  
  CGate* getGate() const;   
  void setGate (CGate* am_pGate);
  CGate&amp; operator* () ;

  CGate* operator-> () ;
  Bool_t operator() (CEvent&amp; rEvent);
};

        </synopsis>        
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            SpecTcl gates are mutable.  Not only can the constituents be modified,
            but the gate type can also be changed.  If objects depending on
            gates held a pointer or reference to that gate, SpecTcl would need
            to update all references to a gate whenever the gate was modified,
            a potentially costly and error prone process.
        </para>
        <para>
            It would be possible for gate clients to have a pointer to a pointer.
            That would work.  Changing a gate would change the underlying pointer
            and the pointer to that pointer could remain valid.  That would lead
            to notational abominations like <code>(*pGate)->operator()</code>.
        </para>
        <para>
            Instead of this, SpecTcl employes a pointer like object called a
            gate container.  The gate container contains a gate and wraps it
            with pointer like semantics.   Gate containers are derived from
            <classname>CNamedItem</classname> so it is the container that
            holds the name of a gate, not the gate itself.  Clients of the
            gate can hold either a reference to the gate container (if the
            gate they are clients of won't change names) or a pointer to the
            gate container if, like spectra, they can.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CGateContainer</methodname>
                        <void />
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Default constructors must be defined for objects that
                        will be inserted into STL container classes (such
                        as <classname>std::Map</classname>).  The default
                        constructor constructs a gate container that will
                        segfault when attempts are made to access the underlying
                        gate.
                    </para>
                    <para>
                        Once constructed, assignment can be used to give the
                        container and id, name and gate.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CGateContainer </methodname>
                        <methodparam>
                            <type>const std::string&amp; </type><parameter>sName</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type><parameter>nNumber</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CGate&amp; </type><parameter>rGate</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs with a gate; <parameter>rGate</parameter>,
                        an id;
                        <parameter>nNumber</parameter> and a gate instance
                        <parameter>rGate</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CGate* </type>
                        <methodname>getGate</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the gate that is encapsulated
                        by the gate container.  Normally you won't need to
                        call this as you can manipulate the gate via the
                        methods supplied by the container.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>setGate</methodname>
                        <methodparam>
                            <type>CGate* </type><parameter>am_pGate</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Used by SpecTcl to replace the gate in the container.
                        Note that when a gate is constructed into a gate
                        container, containers are assigned or this method is
                        called, the pointer passed in is not stored.  Instead a
                        clone of the gate is made and <emphasis>that</emphasis>
                        is what's stored in the container.
                    </para>
                    <para>
                        Note that destroying the container also implicitly
                        destroys the cloned gate.    All of this means
                        it's perfectly safe to have code like:
                    </para>
                    <programlisting>
{
    Float_t xcoords[4] = {0.0, 100.0, 100.0, 0.0};
    Float_t ycoords[4] = {0.0, 0.0, 100.100, 100.100};
    CContour square(1, 2, 4, xcoords, ycoords);
    CGateContainer gc = new CGateContainer("rectangle", 100, square);
    
    return gc;
}                     // square object was destroyed here but gc's clone lives.
                    </programlisting>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CGate&amp;</type>
                        <methodname> operator*</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Implements the first part of pointer semantics;
                        plain dereference.
                        This returns a reference to the encapsulated gate.
                        This allows code like:
                    </para>
                    <programlisting>
CGateContainer gc;
...                       // Gate/name etc. set here.
CGate& gate(*gc);
std::string t = gate.Type();
                    </programlisting>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CGate*</type>
                        <methodname>operator-></methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the gate.  This implements
                        the second part of pointer semantics, member dereference.
                        The method allows operations like:
                    </para>
                    <programlisting>
CGateContainer gc;
...                      // Gate name etc. set here.

std::string t = gc->Type();       // Fetch gate type.

                    </programlisting>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodsynopsis>
                    <modifier></modifier>
                    <type>Bool_t</type>
                    <methodname> operator()</methodname>
                    <methodparam>
                        <type>CEvent&amp; </type><parameter>rEvent</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis></term>
                <listitem>
                    <para>
                        This is a convenience method that evaluates the underlying
                        gate for the event <parameter>rEvent</parameter>.
                        Since the gate is encapsulated as a pointer, the
                        actual gate's <methodname>operator()</methodname> is
                        invoked.  This allows code like:
                    </para>
                    <programlisting>
// Assume spec is a CSpectrum reference and rEvent a CEvent reference.

Bool_t gateMade = (*spec.getGate())(rEvent);          // Evaluate the gate

                    </programlisting>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CGateObserver</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CGateObserver</refname>
        <refpurpose>Observe changes in the gate dictionary.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;Histogrammer.h&gt;

template &lt;class T&gt;
class DictionaryObserver 
{
public:
  virtual void onAdd(std::string   name,   T&amp; item) {}
  virtual void onRemove( std::string name,    T&amp; item) {}

};
typedef CDictionary&lt;CGateContainer&gt;             CGateDictionary;
typedef CGateDictionary::DictionaryIterator     CGateDictionaryIterator;
typedef DictionaryObserver&lt;CGateContainer&gt;      GateDictionaryObserver;

class CGateObserver : public GateDictionaryObserver {
public:
  virtual void onChange(std::string name, CGateContainer&amp; gateContainer) = 0;
};

#include &lt;SpecTcl.h&gt;
class SpecTcl
{
public:
...
    void addGateDictionaryObserver(GateObserver* observer);
    void remove GateDictionaryObserver(Gateobservr* observer);
};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Before looking at the documentation for the gate observer;
            if you are not familiar with the <firstterm>Observer</firstterm>
            software pattern, it's worth taking some time to udnerstand it.
            On introduction is available at the wikipedia at:
            <ulink url='https://en.wikipedia.org/wiki/Observer_pattern' />.
        </para>
        <para>
            Gate dictionary observers allow you to become aware of changes made
            to the gate dictionary. The changes you can observer are:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Insertions of gate containers into the dictionary.
                </para>
            </listitem>
            <listitem>
                <para>
                    Changes to existing gate containers already in the
                    dictionary (usually this means the gate contained by
                    that observer is being changed for a new one).
                </para>
            </listitem>
            <listitem>
                <para>
                    Removals of gate containers from the dictionary
                    (this is never done at this time).
                </para>
            </listitem>
        </itemizedlist>
        <para>
            As the synopsis shows, gate containers are added and removed
            fromt he gate dictionary via the SpecTcl API class
            <classname>SpecTcl</classname>.  Observers consitute an ordered list
            of objects attached to the gate dictionary.  When an observable
            change occurs, each of these observers is invoked in the order
            in which they were added
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            The <classname>CGateObserver</classname> is derived from
            the more general templated base class
            <classname>DictionaryObserver</classname>.  This section documents, not only the methods
            defined in <classname>CGateObserver</classname> but the
             methods of <classname>CDictionaryObserver</classname>
            a concrete class can override.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>onAdd</methodname>
                        <methodparam>
                            <type>std::string   </type><parameter>name</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CGateContainer&amp; </type><parameter>item</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when a new gate container is added to the
                        dictionary.  <parameter>name</parameter> is the name
                        of the item in the dictionary (this need not be
                        but currently always is the same as the name of the
                        gate container).
                    </para>
                    <para>
                        <parameter>item</parameter> is a reference to the gate container
                        being added to the dictionary.  The base class
                        implements this as an empty method.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>onRemove</methodname>
                        <methodparam>
                            <type> std::string </type><parameter>name</parameter>
                        </methodparam>
                        <methodparam>
                            <type> CGateContainer&amp; </type><parameter>item</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when an item is removed from the dictionary.
                        At present this does not happen as gate deletion
                        simply replaces the gate with a False gate.
                        The <parameter>name</parameter> of the
                        gate and the gate container <parameter>item</parameter>
                        are passed in as parameters.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>onChange</methodname>
                        <methodparam>
                            <type>std::string</type><parameter> name</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CGateContainer&amp;</type><parameter> gateContainer</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when an item in the dictionary is changed.
                        For the gate dictionary.  This means a gate container
                        is encapsulating a new gate object because the
                        gate has been modified.
                    </para>
                </listitem>
            </varlistentry>

        </variablelist>
    </refsect1>
    <refsect1>
        <title>EXAMPLE</title>
        <para>
            This toy example just prints out some text when for each
            gate observation.  The example includes the class definition
            for the gate dictionary observer as well as a snippet of code
            that registers an instance of that observer with the SpecTcl
            gate dictionary.
        </para>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CFit</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CFit</refname>
        <refpurpose>Base class for spectrum fitting subsystem.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>

#include &lt;CFit.h&gt;
class CFit : public  CNamedItem     
{
public:
  struct Point {		
    double x;
    double y;
    int operator==(const Point&amp; rhs) const;
    int operator!=(const Point&amp; rhs) const;
  };
  
  typedef std::vector&lt;Point&gt; PointArray; 
  typedef PointArray::iterator PointIterator;

  typedef std::pair&lt;std::string, double&gt; FitParameter;
  typedef std::vector&lt;FitParameter&gt; FitParameterList;
  typedef FitParameterList::iterator FitParameterIterator;

  typedef enum {
    Accepting,
    Performed
  } FitState;			//!< State of the fit.

  

  void AddPoint (Point p)   ; 
  PointIterator begin ()   ; 
  PointIterator end ()   ; 
  size_t size ()   ; 
  FitState GetState ()  const ; 

  virtual CFit* clone() = 0;
  virtual   void Perform ()   = 0 ; 
  virtual  double operator() (double x)  =0 ; 
  virtual  FitParameterList GetParameters () =0  ; 
  virtual  std::string Type() const  = 0;
 
protected:
  void SetFitState(FitState state) ;
};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            SpecTcl has an extensible fitting program.  Fits can be
            created and updated based on the current data.  SpecTcl
            also interacts with the display program to display any fits
            on appropriate spectra, if that display program is capable of that.
        </para>
        <para>
            The core of the fitting subsystem is the <classname>CFit</classname>
            abstract base class.  Each object that performs a fit must be a
            concrete class derived from <classname>CFit</classname>
        </para>
        <para>
            Fits are stateful objects.   There are two states a fit can
            be in.  The <literal>Accepting</literal> state means that the
            fit has had at least one point added without a call to
            <methodname>Perform</methodname>.  In this state the fit parameters
            cannot be retrieved.  Once <methodname>Perform</methodname> is called,
            the fit is in the <literal>Performed</literal> state and the fit
            parameters can be extracted from the object.
        </para>
        <para>
            Note that since <classname>CFit</classname> is a
            <classname>CNamedItem</classname>, it inherits a constructor
            that have name and id as parameters.
        </para>
    </refsect1>
    <refsect1>
        <title>DATA TYPES</title>
        <para>
            The class defines a few contained data types.  By contained,
            we mean a data type that is defined inside the class definition.
            Contained data type names must be resolved in the scope of the
            class.  E.g. <code>PointArray a;</code> will cause a compiler
            error but <code>CFit::PointArray a;</code> will not.
        </para>
        <refsect2>
            <title><structname>Point</structname> a data point.</title>
            <para>
                The <structname>Point</structname> struct represents a point
                of data that needs to be fitted.  For spectrum fits, each
                point is a channel coordinate (<structfield>x</structfield>)
                and the counts in that channel (<structfield>y</structfield>).
                At present, SpecTcl fits are restricted to 1-d data sets.
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>double </type><structfield>x</structfield></term>
                    <listitem>
                        <para>
                            The X coordinate of the point. Normally this
                            represents a channel number in the spectrum
                            being fitted.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>double</type> <structfield> y</structfield></term>
                    <listitem>
                        <para>
                            The Y coordinate of the point. Normally this is the
                            number of points in the channel selected by
                            <structfield>x</structfield>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>int </type>
                            <methodname>operator==</methodname>
                            <methodparam>
                                <modifier>const</modifier>
                                <type> Point&amp; </type><parameter>rhs</parameter>
                            </methodparam>
                            <modifier> const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns non zero (<literal>1</literal>) if
                            the <structfield>x</structfield> and
                            <structfield>y</structfield> fields of the
                            <structname>Point</structname> referred to by
                            <parameter>rhs</parameter> are equal to that of this
                            object.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>int </type>
                            <methodname>operator!=</methodname>
                            <methodparam>
                                <modifier>const</modifier>
                                <type> Point&</type><parameter> rhs</parameter>
                            </methodparam>
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Inverse of <methodname>operator==</methodname>.
                        </para>
                    </listitem>
                </varlistentry> 
            </variablelist>
        </refsect2>
        <refsect2>
            <title>Typedefs related to <structname>Point</structname></title>
            <variablelist>
                <varlistentry>
                    <term><code>typedef std::vector&lt;Point&gt; PointArray</code></term>
                    <listitem>
                        <para>
                            <type>PointArray</type> objects maintain the set
                            of points gathered for a fit. 
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><code>typedef PointArray::iterator PointIterator</code></term>
                    <listitem>
                        <para>
                            Support iteration in the container that
                            defines <type>PointArray</type>.  Using iterators
                            rather than indexing allows software to be written
                            independent of the actual underlying container that
                            is <type>PointArray</type>.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect2>
        <refsect2>
            <title>Fit parameter data types.</title>
            <para>
                Fit parameters are a bit tricky.  Each fit type will have its
                own set of parameters.  Thus a fit parameter is defined not
                just by its value but by its meaning in the context of the
                fit type.
            </para>
            <para>
                <code>typedef std::pair&lt;std::string, double&gt; FitParameter</code>
                represents a single fit parameter.  The first part of the pair
                is a name that identifies the meaning of the parameter.
                The second part of the pair is the value itself.  For example,
                for a linear fit, the first item of the pair might be the string
                <literal>slope</literal> and the second part the fitted
                slope.
            </para>
            <para>
                Most fits have more than one parameter.   Therefore:
                <code>typedef std::vector&lt;FitParameter&gt; FitParameterList</code>
                is a container of fit parameters.  
            </para>
            <para>
                In order to allow the container type to change later;
                <type>FitParameterList</type> instances should not be indexed.
                Instead, use iterators defined by
                <code>typedef FitParameterList::iterator FitParameterIterator</code>.
                <type>FitParameterList</type> instances have the standard
                iterator support methods <methodname>begin</methodname>
                and <methodname>end</methodname> to support this.
            </para>
        </refsect2>
        <refsect2>
            <title>FitState</title>
            <para>
                Fit objects are stateful.  They distinguish between accepting
                points and having fit those points.  The fit state is captured
                by <type>FitState</type> which is an enumerated type
                with the following values:
            </para>
            <variablelist>
                <varlistentry>
                    <term><literal> Accepting</literal></term>
                    <listitem>
                        <para>
                            The fit is in the process of accepting points.
                            If it has sufficient points;
                            <methodname>Perform</methodname> can be invoked.
                            In this state, the fit is not able to deliver fit parameters.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>Performed</literal></term>
                    <listitem>
                        <para>
                            The fit has been performed and can deliver
                            parameters.  This is the state right after a call
                            to <methodname>Perform</methodname> and before the
                            fit is invalidated by adding more points.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect2>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>AddPoint </methodname>
                        <methodparam>
                            <type>Point </type><parameter>p</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a point to the internal list of points.  This
                        places the object in the <literal>Accepting</literal>
                        state, if it's not already in that state.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>PointIterator</type>
                        <methodname> begin</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>PointIterator </type>
                        <methodname>end</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>size_t </type>
                        <methodname>size</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        These three methods support iteration over the internal
                        <type>PointArray</type>.  Iteration is supported in the
                        same sense as for C++ container types.  At present,
                        the iterator returned is a pointer like object that
                        points to a <structname>Point</structname> struct.
                    </para>
                    <para>
                        <methodname>begin</methodname> returns an iterator that
                        'points' to the beginning of the
                        <type>PointArray</type>.  <methodname>end</methodname>
                        returns an iterator pointing just off the end of the
                        <type>PointArray</type>.  <methodname>size</methodname>
                        returns the number of points in that container.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>FitState </type>
                        <methodname>GetState </methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the current fit state.  This has been
                        previously described.  
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>CFit* </type>
                        <methodname>clone</methodname>
                        <void />
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Pure virtual method that is supposed to dynamically
                        create a copy of this object.  If the object
                        supports copy construction, this is like a virtual
                        copy constructor and can be implemented like this:
                    </para>
                    <programlisting>
CFit*
CMyFitType::clone()
{
    return new CMyFitType(*this);
}
                    </programlisting>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>void </type>
                        <methodname>Perform</methodname>
                        <void />
                        <modifier> = 0 </modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Performs the fit with the set of points that
                        have been added to the object.  An exception
                        should be thrown if there are not sufficient points to
                        determine the fit.
                    </para>
                    <para>
                        If the fit is successfully performed, this method
                        should invoke <methodname>SetFitState</methodname>
                        to set the new fit state to <literal>Performed</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type> double </type>
                        <methodname>operator() </methodname>
                        <methodparam>
                            <type>double </type><parameter>x</parameter>
                        </methodparam>
                        <modifier>=0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If the fit is not in the <literal>Performed</literal>
                        state this method should throw an exception.  If the
                        fit has been performed, this method should return the
                        value of the fit function evaluated at
                        <parameter>x</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier> virtual  </modifier>
                        <type>FitParameterList </type>
                        <methodname>GetParameters</methodname>
                        <void />
                        <modifier>=0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If the fit is not in the <literal>Performed</literal>
                        state this should throw an exception.  Otherwise it
                        should return the fit specific list of fit parameters.
                        Note that one of them should always be (regardless
                        of fit type) <literal>chisquare</literal>, the Chi Square
                        goodness of fit.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type>std::string </type>
                        <methodname>Type</methodname>
                        <void />
                        <modifier>const  = 0;</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a textual fit type.   This should be
                        a string descriptive of the fit; e.g.
                        <literal>gaussian</literal> is returned by
                        <classname>CGaussianFit</classname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>protected</modifier>
                        <type>void </type>
                        <methodname>SetFitState</methodname>
                        <methodparam>
                            <type>FitState </type><parameter>state</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Allows concrete subclasses to set the fit state.
                        In all cases, this should be used by
                        <methodname>Perform</methodname> to set the state to
                        <literal>Performed</literal> once the fit is actually
                        computed.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>Predefined CFit classes</refentrytitle>
        <manvolnum></manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CGaussianFit</refname>
        <refname>CLinearFit</refname>
        <refpurpose>3SpecTcl</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CGaussianFit.h&gt;

class CGaussianFit : public CFit
{
public:
  CGaussianFit(std::string name, int id = 0);

  virtual void Perform();
  virtual double operator()(double x);
  virtual CFit::FitParameterList GetParameters();
  virtual std::string Type() const;
  virtual std::string makeTclFitScript();
  virtual CFit* clone();

};

<beginpage />

#include &lt;CLinearFit.h&gt;

class CLinearFit  : public CFit        
{

public:
  CLinearFit ();		 //!< Constructor.

  virtual   void Perform ()   ; 
  virtual   double operator() (double x)   ; 
  virtual   CFit::FitParameterList GetParameters ()   ; 
  virtual   std::string Type() const;
  virtual CFit* clone();


};



        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            SpecTcl provides two simple fit functions.  The programming manual
            describes how to add additional fit types to the fit subsystem.
            The fit functions provided are classes that implement a Gaussian
            fit on a constant background and a linear fit.  
        </para>
        <para>
            The linear fit class is mostly provided as an example while the
            gaussian fit has some actual usefulness.
        </para>
        <para>
            The fit classes SpecTcl predefines use the GSL (GNU Scientific
            Library) to perform their fits.  It is easy enough to extend
            SpecTcl's fitting subsystem with fits performed by Root.
        </para>
    </refsect1>
    <refsect1>
        <title><classname>CGaussianFit</classname> METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CGaussianFit</methodname>
                        <methodparam>
                            <type>std::string </type><parameter>name</parameter>
                        </methodparam>
                        <methodparam>
                            <type>int </type><parameter>id </parameter>
                            <initializer> 0</initializer>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        The constructor initializes the base class
                        <classname>CNamedObject</classname> providing a name
                        and an ID.  This is not strictly speaking needed for
                        the SpecTcl fitting system, but was used in another
                        application of this class not relevant to current
                        SpecTcls.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>Perform</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Performs the fit using the available points.
                        At least 5 points must  have been accepted to support
                        performing the gaussian fit.  
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>double </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                            <type>double</type><parameter> x</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the value of the fitted function at the point
                        <parameter>x</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>CFit::FitParameterList </type>
                        <methodname>GetParameters</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the fit parameters.  The fit
                        performed is of the form:
                    </para>
                    <informalexample>
                        <literallayout>
y  = b + he<superscript>-((x-x0)/&#x03c3;)<superscript>2</superscript>/2</superscript>
                        </literallayout>
                    </informalexample>
                    <para>
                        In this equation, the parameters returned are:
                        <literal>baseline</literal> for <literal>b</literal>.
                        <literal>height</literal> for <literal>h</literal>.
                        <literal>centroid</literal> for <literal>x0</literal>.
                        <literal>sigma</literal> for <literal>&#x03c3;</literal>.
                    </para>
                    <para>
                        In addition the parameter <literal>chisquare</literal>
                        contains the chi square of the fit.
                    </para>
                    <para>
                        This method throws an exception if the fit is not in the
                        <literal>Performed</literal> state.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>std::string </type>
                        <methodname>Type</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the string <literal>gaussian</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>std::string</type>
                        <methodname> makeTclFitScript</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Throws an exception if the fit is not
                        <literal>Performed</literal>.   Returns a string that
                        defines a tcl proc named <literal>fitline</literal>.
                        The proc accepts a single double parameter and returns
                        the fit value at the point passed in.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title>CLinearFit</title>
        <para>
            Linear fit is intended just to be a sample.  It performs a fit to the
            function:
        </para>
        <informalexample>
            <literallayout>
y = mx  + b
            </literallayout>
            <para>
                Where the fit parameters are the slope, <varname>m</varname>
                and Y axis intercept; <varname>b</varname>.  The important
                methods for this class are:
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual  </modifier>
                            <type>void </type>
                            <methodname>Perform</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs the fit.   If at least two points have not
                            been accepted; an exception is thrown.  If the fit
                            has two points and they are on a vertical line,
                            an exception is thrown since the slope is not defined.
                        </para>
                        <para>
                            The Gnu Scientific Library function
                            <function>gsl_fit_linear</function> is used
                            to perform the fit.  If successful, the state of the
                            fit is set to <literal>CFit::Performed</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>double </type>
                            <methodname>operator()</methodname>
                            <methodparam>
                                <type>double </type><parameter>x</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            If the fit is not in the <literal>CFit::Performed</literal>
                            state an exception is thrown.  Otherwise, the value
                            of the fit function at <parameter>x</parameter> is
                            returned.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>CFit::FitParameterList</type>
                            <methodname> GetParameters</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            If the fit is not <literal>CFit::Performed</literal>
                            an exception is thrown.  If it has been,
                            the fit parameters are returned.  The fit parameters
                            are named <literal>slope</literal> and
                            <literal>offset</literal> with obvious meanings and
                            the fit provides the required
                            <literal>chisquare</literal> "parameter".
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>std::string </type>
                            <methodname>Type</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the text <literal>linear</literal>
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </informalexample>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CSpectrumFit</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CSpectrumFit</refname>
        <refpurpose>Fit of spectrum channels.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CSpectrumFit.h&gt;

class CSpectrumFit : public CNamedItem
{
public:
  CSpectrumFit(std::string spectrumName, int myId,
	       int low, int high, 
	       CFit&    fit);

  CFit::PointIterator begin();
  CFit::PointIterator end();
  size_t              size();
  CFit::FitState      GetState(); 
  double              operator()(double x);
  CFit::FitParameterList getParameters();
  std::string         fitType();
  std::string         makeTclFitScript();
  std::string         fitName();
  CSpectrumFit*       clone();	// Clone self.
  void                update();
  int                 low() const;
  int                 high() const;
  
};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Joins together a spectrum and a fit performed over some region of
            interest.  The fit is performed when an object is constructed
            and when requested via its <methodname>update</methodname> method.
            This fit should always be in the <literal>CFit::Performed</literal>
            state.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            Note that several of these methods delegate to the underlying
            fit object.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CSpectrumFit(</methodname>
                        <methodparam>
                            <type>std::string </type><parameter>spectrumName</parameter>
                        </methodparam>
                        <methodparam>
                            <type>int </type><parameter>myId</parameter>
                        </methodparam>
                        <methodparam>
                            <type>int </type><parameter>low</parameter>
                        </methodparam>
                        <methodparam>
                            <type>int </type><parameter>high</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CFit&    </type><parameter>fit</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        <parameter>spectrumName</parameter> is the name of
                        a spectrum in the SpecTcl spectrum dictionary.
                        An exception is thrown if the name is not valid.
                        The name is also used to provide a name for the Spectrum
                        Fit object (see, however <classname>CFitDictionary</classname>).
                    </para>
                    <para>
                        <parameter>myId</parameter> is the id used to construct
                        the base class named item.
                    </para>
                    <para>
                        <parameter>low</parameter> and <parameter>high</parameter>
                        specify a region of interest (ROI), in channels, in the spectrum.  If either
                        limit is outside of the spectrum channel limits an exception
                        is thrown.  If there are not sufficient channels in the ROI,
                        an exception will be thrown.
                    </para>
                    <para>
                        <parameter>fit</parameter> is a fit object in the
                        <literal>CFit::Accepting</literal> state.  On
                        construction, among other things, the spectrum channels
                        in the ROI are entered as points into this fit and the
                        and the fit is performed.  The fit must stay in scope
                        for the duration of the lifetime of this object.
                        The fit's destruction is, however the responsibility
                        of client code.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CFit::PointIterator </type>
                        <methodname>begin</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CFit::PointIterator </type>
                        <methodname>end</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>size_t  </type>
                        <methodname>size</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        These methods delegate to the underlying fit object's
                        methods of the same name.  They support iteration through
                        the fit points.  The X coordinate of each point is a
                        channel number.  The Y coordinate is the counts in that
                        channel as of the last time a fit was performed.
                    </para>
                    <para>
                        Fits are performed at construction time and when the
                        <methodname>update</methodname> method is invoked.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>  CFit::FitState      </type>
                        <methodname>GetState</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the underlying fit's state. This should
                        always be <literal>CFit::Performed</literal>.  If it is
                        not, some external actor must be playing with the
                        encapsulated fit.  Something that should not be done.
                    </para>
                    <para>
                        This method delegates to the underlying fit.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>double              </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                            <type>double </type><parameter>x</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Delegates to the underlying fit's <methodname>operator()</methodname>
                        which evaluates the fitted function at <parameter>x</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier> </modifier>
                        <type>CFit::FitParameterListx</type>
                        <methodname>CFit::FitParameterList</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Delegates to <classname>CFit::</classname><methodname>FitParameterList</methodname>.
                        Returns the fit parameters from the current fit.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>std::string         </type>
                        <methodname>fitType</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        in the underlying fit.
                        Delegates to <classname>CFit::</classname><methodname>Type</methodname>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>std::string</type>
                        <methodname>makeTclFitScript</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Delegates to the underlying fit's
                        <methodname>makeTclFitScript</methodname> method
                        to get a proc that can be used by scripts to operate on
                        the fit.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>std::string         </type>
                        <methodname>fitName</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Name of the underlying fit.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CSpectrumFit*</type>
                        <methodname>clone</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a dynamically allocated clone of this object.
                        Note that the fit is cloned as well.  Objects with cloned
                        fits will destroy the fit when they themselves are
                        destroyed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void                </type>
                        <methodname>update</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Fetches the new points from the fit's ROI and performs
                        the fit using them.
                    </para>
                </listitem>
 
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>int                 </type>
                        <methodname>low</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>int                 </type>
                        <methodname>high</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Return the limits of the ROI over hich the fit
                        is computed.
                    </para>
                </listitem>
            </varlistentry>    
        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CFitFactory</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CFitFactory</refname>
        <refname>CFitCreator</refname>
        <refname>CGaussianFitCreator</refname>
        <refname>CLinearFitCreator</refname>
        <refpurpose>Creating fit objects by name</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CFitFactory.h&gt;

class CFitFactory 
{
  // Public data types:
public:
  typedef std::map&lt;std::string, CFitCreator*&gt; FitCreatorMap;
  typedef FitCreatorMap::iterator  FitCreatorIterator;

  typedef std::map&lt;std::string, CFit*&gt;        FitMap;
  typedef FitMap::iterator          FitIterator;

public:


  static void AddFitType (const std::string&amp; rType, CFitCreator* pCreator)   ; 
  static CFit* Create (std::string sFitType, std::string sFitName)   ; 
  static bool Delete (std::string sName)   ; 
  static bool Perform (std::string sName)   ; 
  static bool AddPoints (std::string sName,
			 std::vector&lt;FPoint&gt; vPoints)   ; 
  static double Evaluate (std::string sName, double x)   ; 
  static FitCreatorIterator beginCreators();
  static FitCreatorIterator endCreators();
  static int    sizeCreators();
  static FitCreatorIterator FindFitCreator (std::string sType)   ; 
  static int size ()   ; 
  static FitIterator begin ()   ; 
  static FitIterator end ()   ; 
  static FitIterator FindFit (std::string sName) ; 


};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The <classname>CFitFactory</classname> is both a factory for
            fits and a registry/dictionary
            of the fits it creates.  Note that this is
            an extensible factory.  Extensible factories are not standalone
            entities.  They rely on objects called <firstterm>Creators</firstterm>
            to recognize specific type specifiers and to create the specific
            type on behalf of the factory.
        </para>
        <para>
            Associated with the fit factory is a class hierarhcy of
            <classname>CFitCreator</classname>s.  This hierarchy exactly
            mirrors the <classname>CFit</classname> class hierarchy.  Concrete
            classes of the <classname>CFitCreator</classname> are instantiated
            and registered with the factory to create the corresponding fits.
        </para>
        <para>
            The remainder of this man page will describe the data types
            introduced by this class, the methods this class exports and
            the fit creator hierarchy and pre-defined concrete
            creator classes.
        </para>
        <para>
            Note that all methods of this class are static.  It's therefore
            not necessary to create an instance of this class.  Furthermore,
            this implies that the factory containers are application wide.
        </para>
    </refsect1>
    <refsect1>
        <title>Data types</title>
        <para>
            The class defines several nested data types.  These
            define a keyed container and iterator for the creators,
            and a keyed container and iterator for the fits themselves.
            Note that iterators 'point' to an
            <type>std::pair&lt;std::string, T*&gt;</type>  where
            <classname>T</classname> represents the type of itemin the
            container (e.g. a <classname>CFitCreator</classname>
            or <classname>CFit</classname>).
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <literal>
typedef std::map&lt;std::string, CFitCreator*&gt; FitCreatorMap;
                    </literal>
                </term>
                <listitem>
                    <para>
                        <classname>CFitFactory</classname>::<type>FitCreatorMap</type>
                        is the keyed container that holds fit creators.  Fit creators,
                        recall are objects that will create a fit that corresponds
                        to the key at which they live in the container.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <literal>
 typedef FitCreatorMap::iterator  FitCreatorIterator;                       
                    </literal>
                </term>
                <listitem>
                    <para>
                        Iterator into the <type>FitCreator</type> container.
                        See <literal>DESCRIPTION</literal> for information
                        about this.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <literal>
typedef std::map&lt;std::string, CFit*&gt;        FitMap
                    </literal>
                </term>
                <listitem>
                    <para>
                        <classname>CFitFactory</classname>::<type>FitMap</type>
                        defines the container for the fits themselves.  This is
                        a container that is indexed by a string that names
                        the fit.  This name need not be the same as the name of the
                        fit itself.  See, e.g. <methodname>Create</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <literal>
typedef FitMap::iterator          FitIterator;
                    </literal>
                </term>
                <listitem>
                    <para>
                        Iterator into the fit container
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            All methods are class level (static) methods.  They do not require an
            object to invoke e.g.
            <code>FitFactory::sizeCreators()</code> returns the number of fit
            creators registered.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>void</type>
                        <methodname> AddFitType </methodname>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>std::string&amp; </type><parameter>rType</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CFitCreator* </type><parameter>pCreator</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Registers a new fit type with the factory.
                        <parameter>rType</parameter> will be the name of the
                        fit type.  This value, when passed to
                        <methodname>Create</methodname> will cause the
                        creator passed in as <parameter>pCreator</parameter>
                        to be asked to produce a fit object.
                    </para>
                    <para>
                        If a fit of the same type as
                        <parameter>rType</parameter> has already been
                        registered, an exception is thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>CFit* </type>
                        <methodname>Create </methodname>
                        <methodparam>
                            <type>std::string </type><parameter>sFitType</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::string </type><parameter>sFitName</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Asks the factory to crate a new fit of the type
                        <parameter>sFitType</parameter> and to give it the name
                        <parameter>sFitName</parameter>.  The resulting fit
                        is returned.  The resulting fit is also registered
                        with the factory.
                    </para>
                    <para>
                        If a fit of the name <parameter>sFitName</parameter>
                        already exists, an exception is thrown.  If not
                        creator matches the fit type; <parameter>sFitType</parameter>,
                        a null pointer is returned.
                    </para>
                    <para>
                        The fit is dynamically created by <literal>new</literal>,
                        however you should not directly <literal>delete</literal>
                        it.  See the <methodname>Delete</methodname> method
                        below.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>bool </type>
                        <methodname>Delete </methodname>
                        <methodparam>
                            <type>std::string </type><parameter>sName</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Deletes the fit named <parameter>sName</parameter> from
                        the fit dictionary.   If the fit existed (and had to be
                        deleted) <literal>true</literal> is returned.  If the
                        fit did not exist <literal>false</literal> is
                        returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>bool </type>
                        <methodname>Perform</methodname>
                        <methodparam>
                            <type>std::string </type><parameter>sName</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Requests that the fit named
                        <parameter>sName</parameter> be performed with the
                        current set of points,  This locates the fit in the
                        fit dictionary and just delegates to that fit's
                        <methodname>Perform</methodname> method.
                    </para>
                    <para>
                        If the fit exists, and canbe performed successfully,
                        <literal>true</literal> is returned.  If the
                        fit does not exist or exists but fails,
                        <literal>false</literal> is returned instead.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>bool </type>
                        <methodname>AddPoints</methodname>
                        <methodparam>
                            <type>std::string </type><parameter>sName</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;FPoint&gt; </type><parameter>vPoints</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a vector of points to the fit.  See
                        <filename>Point.h</filename> for the definition of a
                        <type>FPoint</type> object.  This call puts the underlying
                        fit in the <literal>CFit::Accepting</literal> state.
                    </para>
                    <para>
                        If the fit named by <parameter>sName</parameter> was
                        found the the points in
                        <parameter>vPoints </parameter>are added via successive callse to
                        the underlying fit's <methodname>AddPoint</methodname>
                        method and
                         <literal>true</literal> is returned.  If the
                         fit is not found; <literal>false</literal> is returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>double </type>
                        <methodname>Evaluate</methodname>
                        <methodparam>
                            <type>std::string </type><parameter>sName</parameter>
                        </methodparam>
                        <methodparam>
                            <type> double </type><parameter>x</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Evaluates the fit <parameter>sName</parameter> at
                        the X coordinate <parameter>x</parameter>.  The
                        value of the fit function at that point is returned.
                        Note that the fit must be in the
                        <literal>CFit::Performed</literal> state.
                    </para>
                    <para>
                        An exception is thrown if the fit does not exist.
                        If the fit is not in the
                        <literal>CFit::Performed</literal> state, an exception
                        is thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>FitCreatorIterator </type>
                        <methodname>beginCreators</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>FitCreatorIterator </type>
                        <methodname>endCreators</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        These methods support iteration of the container of
                        fit creators.  They both return pointer like objects that
                        point to an <classname>std::pair&lt;std::string, CFitCreator*&gt;</classname>.
                    </para>
                    <para>
                        <methodname>beginCreators</methodname> returns an iterator
                        to the "first" item of the container.  Successive increments
                        will step the  iterator through all items until
                        the increment results in a iterator that is equal to that
                        returned by <methodname>endCreators</methodname> which
                        points just past the end of the container.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>int    </type>
                        <methodname>sizeCreators</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of fit creators that have been
                        registered with the factory.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>FitCreatorIterator </type>
                        <methodname>FindFitCreator </methodname>
                        <methodparam>
                            <type>std::string </type><parameter>sType</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an iterator to the container item that has
                        the fit for the fit type <parameter>sType</parameter>.
                        If there is no matching fit creator, an iterator equal
                        to that returned by
                        <methodname>endCreators</methodname> is returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>FitIterator</type>
                        <methodname> begin </methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>FitIterator</type>
                        <methodname> end </methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Supports iteration over the container that is the
                        dictionary of fits.  These methods return
                        iterators that are pointer like objects.  Each
                        iterator points to an object of the type:
                        <classname>std::pair&lt;std::string, CFit*&gt;</classname>.
                    </para>
                    <para>
                        <methodname>begin</methodname> points to the first object
                        in the container.  Incrementing it will step sequentially
                        through the items in the container.  When all items
                        have been visited, the increment will result in an
                        iterator equal to that returned by <methodname>end</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>int </type>
                        <methodname>size</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of fits in the fit dictionary.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>FitIterator </type>
                        <methodname>FindFit </methodname>
                        <methodparam>
                            <type>std::string </type><parameter>sName</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an iterator that points to the object in the
                        fit dictionary that matches the name <parameter>sName</parameter>.
                        If there is no matching fit, an object equal to that
                        returned by <methodname>end</methodname> is returned.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title>Fit Creators</title>
        <para>
            This section describes the abstract base class the defines
            the fit creator interface.  SpecTcl defines two concrete fit
            creator classes.  The first of these; <classname>CGaussianFitCreator</classname>
            creates <classname>CGaussianFit</classname> objects.  The second;
            <classname>CLinearFitCreator</classname>  creates <classname>CLinearFit</classname>
            objects
        </para>
        <synopsis>
#include &lt;CFitCreator.h&gt;
#include &lt;CGaussianFitCreator.h&gt;
#include &lt;CLinearFitCreator.h&gt;

class CFitCreator      
{

public:
  CFitCreator ();
  
  virtual   CFit* operator() ()   = 0; 
  virtual   std::string DescribeFit()  = 0;
};
        </synopsis>
        <para>
            The methods that must be implemented by concrete classes are:
        </para>
            
        <variablelist>
            <varlistentry>
                <term><methodsynopsis>
                    <modifier>virtual   </modifier>
                    <type>CFit* </type>
                    <methodname>operator() </methodname>
                    <void />
                    <modifier>= 0</modifier>
                </methodsynopsis></term>
                <listitem>
                    <para>
                        Must create the fit of the appropriate type and return it.
                        The fit should be dynamically created.  It will be
                        the client's responsibility to destroy it.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodsynopsis>
                    <modifier>virtual   </modifier>
                    <type>std::string </type>
                    <methodname>DescribeFit</methodname>
                    <void />
                    <modifier>= 0</modifier>
                </methodsynopsis></term>
                <listitem>
                    <para>
                        Returns some brief text to describe the type of fit object
                        produced by the creator.  SpecTcl's
                        <command>fit</command> command iterates through the
                        fit creators and uses these texts when constructing
                        the command help.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CFitDictionary</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CFitDictionary</refname>
        <refpurpose>Fitting subsystem dictionary.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CFitDictionary.h&gt;

class CFitDictionary {

public:
  typedef std::map&lt;std::string, CSpectrumFit*&gt; FitMap;
  typedef FitMap::iterator      iterator;

  class CObserver {
  public:
    virtual void Add(CSpectrumFit&amp; fit) =0;
    virtual void Delete(CSpectrumFit&amp; fit) = 0;
    virtual void Update(CSpectrumFit&amp; fit) = 0;

  };

public:
  static CFitDictionary&amp; getInstance();
  void add(CSpectrumFit&amp; fit);
  void addOrReplace(CSpectrumFit&amp; fit);
  void Delete(std::string name);

  iterator begin();
  iterator end();
  size_t   size();
  iterator find(std::string name);
  void     erase(iterator here);
  void     erase(iterator first, iterator last);

  void updateFits(std::string name=std::string(&quot;*&quot;)); 

  void addObserver(CObserver&amp; obs);
  void removeObserver(CObserver&amp; obs);

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The <classname>CFitDictionary</classname> defines a singleton
            class.  The provides a dictionary of fits derived from
            <classname>CSpectrumFit</classname> and is the dictionary SpecTcl
            uses to store its fits.  In addition to supporting addition
            and removal operations, the iterator, oberver and search operations
            are supported.  It is also possible to request the dictionary
            update fits that match some pattern.
        </para>
        <para>
            Note that the SpecTcl <classname>CHistogrammer</classname> class
            establishes an observer so that it can ensure that Xamine
            can display any fits that have been defined on displayed spectra.
            Note that the Spectra displayer does not yet support the display
            of fit lines.
        </para>
    </refsect1>
    <refsect1>
        <title>
            METHODS
        </title>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>CFitDictionary&amp; </type>
                        <methodname>getInstance</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Gets a  pointer to the singleton instance of the
                        fit dictionary.  This singleton uses lazy creation in
                        that the first invocation of <methodname>getInstance</methodname>
                        is what actually creates the fit dictionary singleton
                        instance.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type> void </type>
                        <methodname>add</methodname>
                        <methodparam>
                            <type>CSpectrumFit&amp; </type><parameter>fit</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a new fit to the dictionary.  The fit must live for
                        the life of its existence in the dictionary as it's not
                        cloned.  The name of the fit is taken from the fit itself.
                    </para>
                    <para>
                        If a fit by this name already exists, an exception is
                        thrown.  If the fit is successfully added, all observers
                        are informed of this via their <methodname>Add</methodname>
                        method.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>addOrReplace</methodname>
                        <methodparam>
                            <type>CSpectrumFit&amp; </type><parameter>fit</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds the fit <parameter>fit</parameter> to the fit dictionary.
                        The name assigned to the fit comes from the fit itself.
                        If the fit already exists, the previous fit is replaced
                        in the dictionary wih <parameter>fit</parameter>.
                    </para>
                    <para>
                        This is treated as an addition and therefore the
                        observers are notified via their <methodname>Add</methodname>
                        methods.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>Delete</methodname>
                        <methodparam>
                            <type>std::string </type><parameter>name</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes the fit named <parameter>name</parameter> from
                        the dictinoary  It's still up to the clients of the
                        dictionary to manage the storage for this fit.
                        If fits are dynamically allocated, removal/deletion should
                        take the form of using <methodname>find</methodname>
                        to get a pointer to the fit, deleting the fit from
                        the dictionary (either with <methodname>erase</methodname>
                        or <methodname>Delete</methodname>), and then
                        using <code>delete</code> to delete the actual fit
                        object.
                    </para>
                    <para>
                        If there is no fit named <parameter>name</parameter> in
                        the dictionary, 
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>iterator </type>
                        <methodname>begin</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>iterator </type>
                        <methodname>end</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>size_t</type>
                        <methodname>size</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        These methods implement an interation interface
                        for the fits.  The iterators return pointer like
                        objects to objects of the type:
                        <classname>std::pair&lt;std:;string, CSpectrumFit&gt;</classname>
                    </para>
                    <para>
                        <methodname>begin</methodname> returns an interator that
                        points to the first item in the fit dictionary container.
                        Incrementing this object steps sequentially through the
                        container until the object is equal to the value
                        returned by <methodname>end</methodname>.  At that point
                        the iteration over the container is complete.
                    </para>
                    <para>
                        <methodname>size</methodname> returns the number of
                        objects in the container.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>iterator </type>
                        <methodname>find</methodname>
                        <methodparam>
                            <type>std::string </type><parameter>name</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an iterator to the item in the gate dictionary
                        container that has a name; <parameter>name</parameter>.
                        If there is no matching item in the gate dictionary
                        container, an iterator that is equal to the one
                        returned by <methodname>end</methodname> is returned.
                        See <methodname>begin</methodname> above for a description
                        of the iterator object.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void     </type>
                        <methodname>erase</methodname>
                        <methodparam>
                            <type>iterator </type><parameter>here</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Given an iterator into the gate container dictionary,
                        removes that entry from the dictionary.  Note that the
                        gate is not deleted.  If the gate was dynamically created
                        the client must delete it.   Suppose we want to delete
                        the gate named <literal>deleteme</literal> and free
                        its storage.  This can be done as follows:
                    </para>
                    <informalexample>
                        <programlisting>
CFitDictionary* pDict = CFitDictionary::getInstance();
CFitDictionary::iterator p = pDict->find("deleteme");
if (p != pDict->end()) {
    CSpectrumFit* pFit = p->second;
    pDict->erase(p);
    delete pFit;
} else {
   // Action to take when the fit does not exist.
}
                        </programlisting>
                    </informalexample>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>updateFits</methodname>
                        <methodparam>
                            <type>std::string </type><parameter>name</parameter>
                            <initializer>std::string(&quot;*&quot;)</initializer>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Updates the fits that have names matching the
                        glob pattern <parameter>name</parameter>.  Note that this
                        defaults to <literal>*</literal> which matches all fits.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>addObserver</methodname>
                        <methodparam>
                            <type>CObserver&amp; </type><parameter>obs</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds an observer to the dictionary.  The observer object
                        methods will be invoked as a result of specific actions
                        performed by the dictionary.  See
                        <literal>Nested Types and Classes</literal> for
                        a description of observers and their  methods.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>removeObserver</methodname>
                        <methodparam>
                            <type>CObserver&amp; </type><parameter>obs</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes the observer <parameter>obs</parameter> from the
                        dictionary.  Once done, <parameter>obs</parameter> will
                        no longer receive method calls from the dictionary.
                        Removing the observer does not destroy it.  That is the
                        responsibility of the dictionary client software.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title>Nested Types and Classes</title>
        <para>
            <classname>CFitDictionary</classname> defines two types and a
            an abstract base class. The types are used to support dictionary
            iterastion and the class to support the observer pattern.
        </para>
        <para>
            <classname>CSpectrumDictionary::FitMap</classname> is the type of
            the container used to store the fit dictionary. While this is
            currently an <classname>std::map</classname>, the only thing you should
            assume is that this object is an associative container of
            <classname>CSpectrumFit*</classname> with keys that are
            <classname>std::string</classname> objects.   The keys are the
            name of the fit.
        </para>
        <para>
            <classname>CSpectrumDictionary::iterator</classname> is an interator
            into the fit container.  As with all iterators for STL associative
            containers it is a pointer-like object.  Dereferencing a
            <classname>::CSpectrumDictionary::iterator</classname> provides
            a reference to a <classname>std::pair&lt;std::string, CSpectrumFit*&gt;</classname>.
            This is also consistent with STL iterators into associative containers.
        </para>
        <para>
            Incrementing an instance of <classname>CSpectrumDictionary::iterator</classname>
            produces a pointer-like object that points to the "next" item in the
            dictionary.  The special iterator value returned by
            <methodname>end</methodname> can be thought of as pointing just
            off the end of the container.  <methodname>begin</methodname>
            can be thought of pointing at the first item in the container.
        </para>
        <para>
            Therefore typical dictionary iteration follows the pattern below:
        </para>
        
        <informalexample>
            <programlisting>
CFitDictionary* pDict = CFitDictionary::getInstance();
for (auto p = pDict->begin(); p != pDict->end(); p++) {
    std::string fitname = p->first;
    CSpectrumfit* pFit  = p->second;
    
    doSomethingWithTheFitAndOrName(fitname, pFit);
}
            </programlisting>

        </informalexample>
        <para>
            Note that this sort of iteration is also perfectly compatible
            with standard library generic algorithms like
            <function>std::for_each</function>.
        </para>
        <para>
            The <classname>CFitDictionary</classname> supports the observer pattern.
            The observer pattern (see <ulink url='https://en.wikipedia.org/wiki/Observer_pattern' />)
            provides a mechanism that allows other objects to be informed
            when important state changes occur in <classname>CFitDictionary</classname>.
            Observers are objects in an ordered list that are derived from the
            abstract base class <classname>CFitDictionary::CObserver</classname>.
            This abstract base class provides a set of method definitions that
            define the set of events that will be observed.
        </para>
        <para>
            The definition of the class is shown below (note this is defined
            within the definition of <classname>CFitDictionary</classname>):
        </para>
        <informalexample>
            <programlisting>
class CObserver {
public:
  virtual void Add(CSpectrumFit&amp; fit) =0;
  virtual void Delete(CSpectrumFit&amp; fit) = 0;
  virtual void Update(CSpectrumFit&amp; fit) = 0;

};            
                
            </programlisting>
        </informalexample>
        <para>
            You can observe the <classname>CFitDictionary</classname> by
        </para>
        <orderedlist>
            <listitem>
                <para>
                    Deriving a class from <classname>CFitDictionary::CObserver</classname>
                </para>
            </listitem>
            <listitem>
                <para>
                    Creating an instance of that class that lives for as long
                    as you want the observation to continue.
                </para>
            </listitem>
            <listitem>
                <para>
                    Using <methodname>addObserver</methodname> to add that object
                    to the ordered list of observers.
                </para>
            </listitem>
            <listitem>
                <para>
                    If the observer is ever no longer needed, use
                    <methodname>removeObserver</methodname> to remove it
                    after which, if appropriate you should ensure
                    the observer's destruction.
                </para>
            </listitem>
        </orderedlist>
        <para>
            The methods you must implement in your observer are:
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void</type>
                        <methodname> Add</methodname>
                        <methodparam>
                            <type>CSpectrumFit&amp; </type><parameter>fit</parameter>
                        </methodparam>
                        <modifier>=0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is invoked when a fit as been successfully added
                        to the dictionary.  <parameter>fit</parameter> is a
                        referenceto the fit just added.  Note that since
                        <parameter>fit</parameter> is a <classname>NamedObject</classname>;
                        <methodname>getName</methodname> can be used to get
                        the fit's name if needed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>Delete</methodname>
                        <methodparam>
                            <type>CSpectrumFit&amp; </type><parameter>fit</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is called when
                        <parameter>fit</parameter> is about to be erased
                        from the fit dictionary.  When called, the fit is still
                        in the dictionary.   Once all observers are run,
                        the fit is erased from the dictionary.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>Update</methodname>
                        <methodparam>
                            <type>CSpectrumFit&amp; </type><parameter>fit</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is invoked when <parameter>fit</parameter>
                        has been updated.  By update we mean that
                        <parameter>fit</parameter> has been recomputed in light
                        of the current spectrum data.  The observer is invoked
                        <emphasis>after</emphasis> the update.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>

</refentry>
       
<refentry>
    <refmeta>
        <refentrytitle>CEventSink</refentrytitle>
        <manvolnum>3Spectcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CEventSink</refname>
        <refpurpose>Base class for event sink pipeline elements</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <synopsis>
#include &lt;EventSink.h&gt;

class CEventSink {
 public:
  CEventSink();
  virtual ~CEventSink();
  CEventSink(const CEventSink&amp; aCEventSink);
  CEventSink&amp; operator=(const CEventSink& aCEventSink);
  int operator==(const CEventSink&amp; aCEventSink);
  virtual void OnAttach(CAnalyzer&amp; rAnalyzer);
  virtual void OnDetach(CAnalyzer&amp; rAnalyzer);

  virtual void operator()(CEventList&amp; rEvents) = 0;
};
</synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            SpecTcl's event sink pipeline is passed events once the event
            processing pipeline has created and filled in the
            <classname>CEvent</classname> for the raw event.  It consists
            of instances of classes derived fromt he abstract base class
            <classname>CEventSink</classname>.  
        </para>
        <para>
            The most interesting element of the pipeline for most SpecTcl users
            is the <classname>CHistogrammer</classname> instance.  That
            object does the heavy lifting of determining which channels of
            which spectra should be incremented for each
            <classname>CEvent</classname> instance.  Other event sink pipeline
            elements can be created and added dynamically.  Of special interest
            are event filters which write out subsets of decoded events that
            satisfy some gate in a specific format.
        </para>
        <para>
            Similarly the 5.0 root integration classes allow Root trees
            to be produced by objects derived from <classname>CEventSink</classname>.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnAttach</methodname>
                        <methodparam>
                            <type>CAnalyzer&amp; </type><parameter>rAnalyzer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method has a empty implementation making its
                        for derived classes.   It is invoked when an instance
                        is added to the event sink pipeline.  The
                        <parameter>rAnalyzer</parameter> parameter refers to the
                        SpecTcl analyzer.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnDetach</methodname>
                        <methodparam>
                            <type>CAnalyzer&amp; </type><parameter>rAnalyzer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method has an empty base class implementation.
                        Therefore its implementation in derived classes is
                        optional.  It is invoked whenever an instance
                        is removed from the event sink pipeline.
                        <parameter>rAnalyzer</parameter> refers to the
                        analyzer in operating at the time of the
                        removal.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                            <type>CEventList&amp; </type><parameter>rEvents</parameter>
                        </methodparam>
                        <modifier>=0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This pure virtual method must be implemented
                        by concrete event sink classes.  It is invoked whenever
                        the event processing pipeline delivers a list of
                        events to the event sink pipeline.  Note that
                        lists of events are delivered in order to promote
                        referential locality in SpecTcl (hopefully improving
                        cache hit rates).
                    </para>
                    <para>
                        <parameter>rEvents</parameter> is the event list
                        the sink should process.  
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CEventFilter</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CEventFilter</refname>
        <refpurpose>Abstract base class for event filters.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
class CEventFilter : public CEventSink {
protected:
   Bool_t m_fEnabled;                           
   std::string              m_sFileName;        
   std::vector&lt;std::string&gt; m_vParameterNames; 
   std::vector&lt;UInt_t&gt;      m_vParameterIds;   
   CFilterOutputStage*      m_pOutput;         
 public:
  CEventFilter(std::string&amp; rFileName);
  std::vector&lt;std::string&gt; getParameterNames() const;
  std::vector&lt;UInt_t&gt; getParameterIds() const;
  Bool_t CheckEnabled() const;
  std::string getFileName() const;
  CFilterOutputStage* getOutputStream();

  void setParameterNames(const std::vector&lt;std::string&gt;&amp; names);
  void setOutputStream(CFilterOutputStage* str);
  
  void Enable();
  void Disable();
  void setFileName(std::string&amp;);
  void setOutputFormat(CFilterOutputStage* format);
  std::string outputFormat() const;
  virtual void operator()(CEventList&amp; rEvents);
  virtual void operator()(CEvent&amp; rEvent);      

protected:
   virtual Bool_t CheckCondition(CEvent&amp; rEvent) = 0;
   static std::string DefaultFilterFilename();   
   void NamesToIds();                       
   std::vector&lt;std::string&gt; IdsToNames() 

};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Filters are objects that, since they are derived from
            <classname>CEventSink</classname>, can be added to the
            event sink pipeline.  Filters are expected to operate on
            decoded events.  They have:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    A file to which output data are written
                </para>
            </listitem>
            <listitem>
                <para>
                    A list of parameters that will be output.
                </para>
            </listitem>
            <listitem>
                <para>
                    A condition that determines which events are written
                </para>
            </listitem>
            <listitem>
                <para>
                    A formatting object that determines how the events
                    are written to the output file.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            Thus filters create subsets of the raw input data. The output
            of filters both subset the events (writing only those events that
            satisfy their condition), and the parameters (writing only the
            specified parameters).
        </para>
        <para>
            Filters can speed up subsequent event processing both by reducing
            the volume of data produced and by writing data in a format much
            easier to decode than the original raw event data.  People using
            filters have reported over an order of magnitude improvement in
            the processing of e.g. XDR formatted filtered data over raw data,
            even when no selection has been performed.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term><constructorsynopsis>
                    <methodname>CEventFilter</methodname>
                    <methodparam>
                        <type>std::string&amp; </type><parameter>rFileName</parameter>
                    </methodparam>
                </constructorsynopsis></term>
                <listitem>
                    <para>
                        Constructor.  <parameter>rFilename</parameter> references
                        the name of the file that filtered data will be written
                        into.  The file is not opened by the constructor.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>std::vector&lt;std::string&gt;</type>
                        <methodname>getParameterNames</methodname>
                        <void />
                        <modifier> const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a vector containing the names of the parameters
                        that will be output by this filter.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>std::vector&lt;UInt_t&gt; </type>
                        <methodname>getParameterIds</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a vector that contains the ids of the parameters
                        that will be output by the filter.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Bool_t </type>
                        <methodname>CheckEnabled</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>kfTRUE</literal> if the filter is
                        currently enabled else <literal>kfFALSE</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>std::string</type>
                        <methodname>getFileName</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the name of the output file associated with
                        this filter.   At construction time, the default
                        filter filename is associated with the filter:
                        <filename>$HOME/filter.flt</filename>.  Normally
                        thsi is overridden by a call to 
                        <methodname>setFilename</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CFilterOutputStage* getOutputStream()</type>
                        <methodname>getOutputStream</methodname>
                        <void />
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the output stream object
                        associated with this filter.  The output stream
                        is responsible for actually opening, and writing filter
                        data to the filter file.   If this has not yet been set
                        then <literal>nullptr</literal> is returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>setParameterNames</methodname>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>std::vector&lt;std::string&gt;&amp; </type>
                            <parameter>names</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Sets the names of the filter parameters.  Note that
                        this does not populate the parameter id vector
                        of the filter.  To do that, one must first
                        invoke <methodname>IdsToNames</methodname>.
                        This functional separation is done to allow the filter
                        to account for changes in parameter definitions between
                        selecting which parameters to output and actually
                        applying the filter.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>setOutputStream</methodname>
                    <methodparam>
                        <type>CFilterOutputStage* </type><parameter>str</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis></term>
                <listitem>
                    <para>
                        Sets the output stage for the filter.  The output
                        stage is what is actually responsible for connecting
                        to the filter file and outputting data to it.
                        Note that this is an alias for and delegates to
                        <methodname>setOutputFormat</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>Enable</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>Disable</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Enable or disable the filter respectively.  Only enabled
                        filters will check and output data.  Disabled filters
                        do nothing.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>setFileName</methodname>
                        <methodparam>
                            <type>std::string&amp;</type><parameter>filename</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Sets a new filename for the filter.  It's up to the
                        filter output stage to understand what to do with this
                        filename.  When the filter is enabled,
                        the output stage will be asked to open the current
                        filename and to describe the parameter names and
                        ids to the filter file.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>setOutputFormat</methodname>
                        <methodparam>
                            <type>CFilterOutputStage* </type><parameter>format</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Sets the new <classname>CFilterOutpuStage</classname>
                        object associated with the filter to
                        <parameter>format</parameter>.  Note that if
                        the filter is enabled, this method throws a
                        <classname>CStateException</classname> because
                        it's  not legal to switch format types in the middle
                        of filtering the data.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>std::string </type>
                        <methodname>outputFormat</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Asks the current output stream to return a description
                        of itself.  If there is no current output stream
                        the string <literal>--</literal> is returned to indicate
                        the filter output format has not been selected.
                        Note that SpecTcl's command interface to filters
                        will never create a filter that does not have an
                        output format defined.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                            <type>CEventList&amp; </type><parameter>rEvents</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Asks the filter to process the events
                        <parameter>rEvents</parameter>.  If the filters is
                        not enabled, this method does nothing.  If it is,
                        then for each item in <parameter>rEvents</parameter> the
                        overload for <methodname>operator()</methodname> described
                        below is invoked for that item.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                            <type>CEvent&amp; </type><parameter>rEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        The filter is processed for the single event
                        <parameter>rEvent</parameter>. The pure virtual method
                        <methodname>CheckCondition</methodname> is invoked.
                        If that returns <literal>kfTRUE</literal>, the
                        output stream is handed the event and directed to
                        output it in its format to the filter output file.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>protected virtual</modifier>
                        <type> Bool_t </type>
                        <methodname>CheckCondition</methodname>
                        <methodparam>
                            <type>CEvent&amp; </type><parameter>rEvent</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This pure virtual method must be implemented by
                        concrete filter classes.  It provides a predicate that
                        is called for every event passed to an enabled filter to
                        determine if the event should be output.  For example,
                        for the <classname>CGateEventFilter</classname> class,
                        the implementation of this method evaluates the gate
                        associated with that filter.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>protected static </modifier>
                        <type>std::string </type>
                        <methodname>DefaultFilterFilename</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the full default path of the filter output
                        file.  It is strongly recommended that this file
                        not be used as you could imagine the chaos that
                        would result if multiple instances of the filter
                        used the default output file.
                    </para>
                    <para>
                        The method returns <filename>$HOME/filter.flt</filename>
                        where, <literal>$HOME</literal> is the translation
                        of the <literal>HOME</literal> environment variable.
                        At login, this variable is set to the user's home directory
                        path.  Note that there's no guarantee it points there
                        at the time this method is called.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>protected </modifier>
                        <type>void </type>
                        <methodname>NamesToIds</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Populates the parameter id vector held internally
                        from the parameter names vector.  Each parameter name
                        is looked up in the parameter dictionary.  If a name
                        has a matching parameter definition, it's id is added
                        to the array.  Any parameters that do not have a
                        definition are silently omitted from the array.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>protected</modifier>
                        <type>std::vector&lt;std::string&gt;</type>
                        <methodname>IdsToNames</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Given the object's vector of parameter ids, returns
                        a vector containing the names of all parameters
                        in corresponding positions of that vector.  If
                        a parameter does not exist in the dictionary any more,
                        a <classname>CDictictionaryException</classname>
                        is thrown.  
                    </para>
                    <para>
                        Note that a call to <methodname>NamesToIds</methodname>
                        followed by a call to this method returns the filter
                        parameter names with nonexistent parameters removed.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title>Data Available to subclasses</title>
        <para>
            Several data members are <literal>protected</literal> and hence
            available to subclasses directly.  Subclasses can also use
            the getters and setters for these members rather than
            accessing them directly.
        </para>
        <variablelist>
            <varlistentry>
                <term><type>Bool_t </type><varname>m_fEnabled</varname></term>
                <listitem>
                    <para>
                        Enable flag for the filter <literal>kfTRUE</literal>
                        if the filter is enabled or <literal>kfFALSE</literal>
                        if not.  This is the value returned by
                        <methodname>CheckEnabled</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>std::string </type><varname>m_sFileName</varname></term>
                <listitem>
                    <para>
                        Name of the file associated withthe filter.  This
                        is the value returned by
                        <methodname>getFileName</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>std::vector&lt;std::string&gt; </type><varname>m_vParameterNames</varname></term>
                <listitem>
                    <para>
                        Vector of the names of the parameters to be output
                        to the filter file for events that should be written.
                        This is the value returned by
                        <methodname>getParameterNames</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>std::vector&lt;UInt_t&gt;</type> <varname>m_vParameterIds</varname></term>
                <listitem>
                    <para>
                        Vector of parameter ids produced by
                        <methodname>NamesToIdes</methodname>.    This is
                        the value returned by
                        <methodname>getParameterIds</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>CFilterOutputStage* </type><varname>m_pOutput;</varname></term>
                <listitem>
                    <para>
                        Pointer to the output stream used by the filter
                        to write events.  This is the value returned by
                        <methodname>getOutputStream</methodname>
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CGatedEventFilter</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CGatedEventFilter</refname>
        <refpurpose>Filter with output conditionalized on a gate check.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;GatedEventFilter.h&gt;

class CGatedEventFilter : public CEventFilter {
 public:
   CGatedEventFilter(CGateContainer*  pGate=(CGateContainer*)kpNULL);
   CGatedEventFilter(std::string&,
       CGateContainer*  pGate=(CGateContainer*)kpNULL);
       
   CGateContainer* getGateContainer();

   void setGateContainer(CGateContainer&amp; container);
   std::string getGateName();
   Int_t getGateID();
protected:
   Bool_t CheckCondition(CEvent&amp; event);

};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The concrete filter class provided by SpecTcl is
            <classname>CGatedEventFilter</classname>.   This class contains
            a gate container and an implementation of
            <methodname>CheckCondition</methodname> that returns the
            evaluation of the gate represented by that container on the
            event.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CGatedEventFilter</methodname>
                        <methodparam>
                            <type>CGateContainer* </type><parameter> pGate</parameter>
                            <initializer>(CGateContainer*)kpNULL</initializer>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs a filter given the gate container
                        <parameter>pGate</parameter>.  The filter is
                        constructed without an output file spefication or, for
                        that matter, an output streamer.
                    </para>
                    <para>
                        <parameter>pGate</parameter> can be omitted in which case,
                        the filter will not output any events, if enabled.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CGatedEventFilter</methodname>
                        <methodparam>
                            <type>std::string& </type><parameter>outputFile</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CGateContainer*  </type><parameter>pGate</parameter>
                            <initializer>=(CGateContainer*)kpNULL</initializer>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        This constructor supplies <parameter>outputFile</parameter>
                        as the file associated with the filter.  Note, however,
                        no output streamer has been defined.  The <parameter>pGate</parameter>
                        parameter, as before, is the pointer to the gate container
                        whose gate must be satisfied for events to be written
                        to the output.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CGateContainer* </type>
                        <methodname>getGateContainer</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the gate container pointer.  Note that this
                        can be <literal>nullptr</literal> if, for example,
                        the constructor defaulted the gate container parameter
                        and <methodname>setGateContainer</methodname> was
                        never called.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>setGateContainer</methodname>
                    <methodparam>
                        <type>CGateContainer&amp; </type><parameter>container</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis></term>
                <listitem>
                    <para>
                        Sets a new gate for the filter to be the one
                        encapsulated by <parameter>container.</parameter>.
                        The old gate is unmodified.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>std::string </type>
                        <methodname>getGateName</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the name of the current gate container.
                        If no gate container has been set, the method returns:
                        <literal>
                            -not yet defined-
                        </literal>
                        .
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Int_t </type>
                        <methodname>getGateID</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the id of the current gate container.  If
                        none have been established, returns
                        <literal>-1</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodsynopsis>
                    <modifier>proteced virtual</modifier>
                    <type>Bool_t </type>
                    <methodname>CheckCondition</methodname>
                    <methodparam>
                        <type>CEvent&amp; </type><parameter>event</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis></term>
                <listitem>
                    <para>
                        Returns the value of the gate container evaluated on the
                        event <parameter>event</parameter>.  If no gate container
                        is associated with the filter; <literal>false</literal>
                        is returned.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CFilterOutputStage</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CFilterOutputStage</refname>
        <refpurpose>Abstract base class for filter output streamers.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CFilterOutputStage.h&gt;

class CFilterOutputStage
{

public:
virtual void open(std::string filename) = 0;
virtual void close() = 0;
virtual void onAttach(CEventFilter&amp; filter);
virtual void DescribeEvent(std::vector&lt;std::string&gt; parameterNames,
                         std::vector&lt;UInt_t&gt;      parameterIds) =0;
virtual void operator()(CEvent&amp; event) = 0;
virtual std::string  type() const = 0;
};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Filter output is managed by output streamers.  These
            are concrete subclasses of <classname>CFilterOutputStage</classname>.
            <classname>CFilterOutputStage</classname> provides the interface
            between a filter an its output streamer.  The output streamer
            knows the format for the filter file and is expected to output
            filter data tothe filter file in that format.
        </para>
        <para>
            Currently SpecTcl has a built in filter output stage that
            understands how to write data in a simple XDR format.  A
            plugin also provides for filters to be written as
            <classname>TNtuples</classname> objects into Root files.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>open</methodname>
                        <methodparam>
                            <type>std::string </type><parameter>filename</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Concrete filter classes must implement this to
                        establish a writable connection to the filter file
                        <parameter>filename</parameter>.   Any file connection
                        information must be kept by the class.
                    </para>
                    <para>
                        Any errors
                        should be reported as exceptions.
                        The preferred exception type is
                        <classname>CErrnoException</classname>.  If that's not
                        possible (e.g. some library that does not set
                        <varname>errno</varname> was used to make the connection)
                        an exception derived from <classname>CException</classname>
                        should be used, even if it's necessary to create
                        a new exception type.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>close</methodname>
                        <void />
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Concrete classes should implement this method to
                        shutdown any connection to the filter output file.
                        While errors are, theoretically, not possible,
                        they should nonetheless be caught and handled:
                    </para>
                    <para>
                        Any errors
                        should be reported as exceptions.
                        The preferred exception type is
                        <classname>CErrnoException</classname>.  If that's not
                        possible (e.g. some library that does not set
                        <varname>errno</varname> was used to make the connection)
                        an exception derived from <classname>CException</classname>
                        should be used, even if it's necessary to create
                        a new exception type.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>onAttach</methodname>
                        <methodparam>
                            <type>CEventFilter&amp; </type><parameter>filter</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This is called when the output stage is attached
                        to a filter. <parameter>filter</parameter>
                        is a reference to the filter to which this object
                        has just been attached.  Since many filters don't
                        actually have to take any action on this event,
                        the base class provides an implementation for
                        <methodname>onAttach</methodname> that does
                        nothing.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>DescribeEvent</methodname>
                        <methodparam>
                            <type>std::vector&lt;std::string&gt; </type><parameter>parameterNames</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;UInt_t&gt; </type><parameter>parameterIds</parameter>
                        </methodparam>
                        <modifier>=0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called by the filter when it's unambiguously known
                        which parameters will be output by the filter.
                        <parameter>parameterNames</parameter> are the
                        requested parameter names.
                        <parameter>parameterIds</parameter> are the
                        ids of the parameters that actually exist.
                    </para>
                    <para>
                        The filter should act on the parameters
                        in <parameter>parameterIds</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                            <type>CEvent&amp; </type><parameter>event</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called by the filter to write an event to the
                        output stream.  
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>std::string  </type>
                        <methodname>type</methodname>
                        <void />
                        <modifier>const = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method should be implemented to return a
                         string that describes the filter's function
                         and format.  For example,
                         <classname>CXdrFilterOutputStage</classname>::<methodname>type</methodname>()
                         retuns <literal>xdr</literal>.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>

    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CXdrFilterOutputStage</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CXdrFilterOutputStage</refname>
        <refpurpose>Filter output stage for writing Xdr filters.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CXdrFilterOutputStage.h&gt;

class CXdrFilterOutputStage : public CFilterOutputStage

public:
  CXdrFilterOutputStage();

  virtual void open(std::string filename) ;
  virtual void close() ;
  virtual void DescribeEvent(std::vector&lt;std::string&gt; parameterNames,
                             std::vector&lt;UInt_t&gt;      parameterIds);

  virtual void operator()(CEvent&amp; event);
  virtual std::string type() const;


};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This concrete output stage uses XDR (EXternal Data Represntation)
            to write a system independent form of filter output data.  See the
            section <literal>File Format</literal> below for a description of
            the file format.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CXdrFilterOutputStage</methodname>
                        <void />
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs an Xdr Filter. 
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>open</methodname>
                        <methodparam>
                            <type>std::string </type><parameter>filename</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called to open the file.  This creates a
                        <classname>CXdrOutputStream</classname>
                        object that is open on the <parameter>filename</parameter>.
                        That object is used to perform action serializations
                        of primitive items to file.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>close</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Closes the output file.  The
                        <classname>CXdrOutputStream</classname> object
                        created in <methodname>open</methodname>
                        is destroyed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void</type>
                        <methodname> DescribeEvent</methodname>
                        <methodparam>
                            <type>std::vector&lt;std::string&gt;</type><parameter>parameterNames</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;UInt_t&gt; </type><parameter>parameterIds</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when the filter knows what parameters will be output
                        to the file. <parameter>parameterNames</parameter>
                        is a vector of the names of the parameters while
                        <parameter>parameterIds</parameter> are the ids
                        of the parameters that are actually in the SpecTcl
                        parameter dictionary.
                    </para>
                    <para>
                        A series of <literal>header</literal> records are
                        written via the <classname>CXdrOutputStream</classname>.
                        These records are described in
                        <literal>File Format</literal> below and describe the
                        set of parameters that will be written to the filter
                        file.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                            <type>CEvent&amp; </type><parameter>event</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called to write an event to the filter files.
                        An <literal>event</literal> record is written to file.
                        See <literal>File Format</literal> for the
                        contents of this record.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>std::string </type>
                        <methodname>type</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the string <literal>xdr</literal> to signify
                        that this output stage produces XDR formatted
                        data.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title>File Format</title>
        <para>
            The file produed by <classname>CXdrOutputStage</classname> objects
            consists of a set of records.  Each record is identified by
            a string record type.  At present, two record types are defined:
            <literal>header</literal> which contains a set of parameter names
            and <literal>event</literal> which contains an event.
        </para>
        <para>
            The file consists first of one or more <literal>header</literal>
            items followed by a sequence of <literal>event</literal> items.
            Items are written into fixed length 8192 byte blocks.  Each
            <literal>header</literal> item is in a block by iteself.
            Several <literal>event</literal> items will be packed into
            a single block.
        </para>
        <refsect2>
            <title>header items</title>
            <para>
                A header block consits of an XDR string with the value
                <literal>header</literal>.   This is then followed by a count
                of strings to follow.  The count is an xdr integer.
                The strings that follow are each the name of a parameter
                that is written to the filter file.  
            </para>
            <para>
                It is important to
                maintain the order in which the parameters appear as this
                will be needed to decode the following
                <literal>event</literal> items.  There can be several
                <literal>header</literal> items.  They cumulatively
                describe the set of parameters written to the file.
            </para>
        </refsect2>
        <refsect2>
            <title>event items</title>
            <para>
                Event items each have a compressed event.  The compression
                scheme takes advantage of the fact that in most cases,
                the occupancy of parameter space is sparse for an event.
            </para>
            <para>
                Each event begins with a bitmask.  The set bits in this bitmask
                determine the number of parameters that follow.  Each element
                of the bitmask is an XDR integer and the number of bitmasks is
                determined by the number of 32 bit integers (XDR integers
                are 32 bits wide) required to provide one bit for each parameter.
            </para>
            <para>
                Bitmasks are ordered by parameters as they appear in the
                <literal>header</literal> records.  The first bitmask has a bit for
                each of the first 32 parameters and so on.  Within each 32 bit
                bitmask, bits are assigned from low order to high order within
                the 32 parameter group.
            </para>
            <para>
                Following the bitmasks are a set of XDR double precision
                values.  Each of those values represents a parameter value for
                one of the parameters corresponding to the bits set in the
                bitmask.  The first parameter is for the lowest order bit set in the
                first nonzero bitmask, and so on.
            </para>
            <para>
                Suppose, for example, we have an event with 48 parameters.
                This requires two bitmasks.  All bits in the first bitmask
                are used and the lower 16 bits in the second one are used.
                Suppose the value of the first bitmask is
                <literal>0x0000000a</literal> and that of the second one is
                <literal>0x00000001</literal>.
                Three parameter values will follow.  
            </para>
            <para>
                If we number the parameters from zero;  The first value will
                be for parameter 1, the second for parameter 2 and the last
                for parameter 32.
            </para>
        </refsect2>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CFilterOutputStageCreator</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CFilterOutputStageCreator</refname>
        <refpurpose>Create filter output stages for
            <classname>CFilterOutputStageFactory</classname></refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CFilterOutputStageCreator.h&gt;

class CFilterOutputStageCreator
{
public:
  virtual CFilterOutputStage*  operator()(std::string type) = 0;
  virtual std::string document() const = 0;
  virtual CFilterOutputStageCreator* clone() = 0;
};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This is an abstract base class that creates objects on behalf of the
            <classname>CFilterOutputStageFactory</classname> extensible
            factory.  Concrete classes of this type create specific output
            stage objects.  This is one of the keys to providing an extensible
            Filter subsystsem.  To add a new filter output stage type only
            requires that you write a filter output stage, a creator for that
            output stage and register that creator with the Filter output
            stage factcory singleton.
        </para>
        <para>
            This class defines the interface that is required of a concrete
            filter output stage creator.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>CFilterOutputStage*  </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                            <type>std::string </type><parameter>type</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Concrete classes must implement this to respond to their
                        filter type by returning a pointer to a newly created
                        instance of a filter output stage.  If the
                        <parameter>type</parameter> is not recognized, the
                        creator should return a <literal>nullptr</literal>.
                    </para>
                    <para>
                        Naturally care must be taken by authors of  filter
                        output stage creators not to recognize strings that are
                        already recognized by other formatters.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>std::string </type>
                        <methodname>document</methodname>
                        <void />
                        <modifier>const = 0</modifier>

                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a string that documents the type of output stage
                        created by this creator.  This is used by
                        the <command>filter</command> command to provide a list
                        of available filter formats.
                    </para>
                    <para>
                        To line up properly, the string returned should be of the form:
                    </para>
                    <informalexample>
                        <programlisting>
                1         2         3
      col:  0123456789012345678901234567890
            type      - description
                        </programlisting>
                    </informalexample>

                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodsynopsis>
                    <modifier>virtual </modifier>
                    <type>CFilterOutputStageCreator* </type>
                    <methodname>clone</methodname>
                    <void />
                    <modifier>= 0</modifier>
                </methodsynopsis></term>
                <listitem>
                    <para>
                        There are situations when the filter output
                        stage factor must create a copy  of an existing creator
                        given a pointer to it with type
                        <classname>CFilterOutputStageCreator*</classname>.
                        The <methodname>clone</methodname> method provides
                        support for it.  The method should return a pointer to
                        a new instance of a duplicate of the object it is called on.
                    </para>
                    <para>
                        If a creator implements copy construction, the simplest
                        way to do this is:

                    </para>
                    <informalexample>
                        <programlisting>
CFilterOutputStageCreator*
CMyOutputStageCreator::clone()
{
   return new CMyOutputStageCreator(*this);
}
                        </programlisting>
                    </informalexample>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CFilterOutputStageFactory</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CFilterOutputStageFactory</refname>
        <refpurpose>Create filter output stage objects.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CFilterOutputStageFactory.h&gt;

class CFilterOutputStageFactory {
public:
  static CFilterOutputStageFactory&amp; getInstance();
  
  CFilterOutputStage* create(std::string type) const;
  void                Register(CFilterOutputStageCreator&amp; creator);
  std::string         document() const;

};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The <classname>CFilterOutputStageFactory</classname>  singleton
            is used to create filter filter output stages to associate with
            filters once their <option>-format</option> is known.
        </para>
        <para>
            The filter output stage is then responsible for actually writing
            filtered events to the output file.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static</modifier>
                        <type> CFilterOutputStageFactory&amp; </type>
                        <methodname>getInstance</methodname>
                        <void />
                        <modifier></modifier>

                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the singleton instance of this
                        class.   Note that if necessary the object is constructed.
                        Constructors for this class are <literal>private</literal>
                        to enforce the singleton nature of this object.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CFilterOutputStage* </type>
                        <methodname>create</methodname>
                        <methodparam>
                            <type>std::string </type><parameter>type</parameter>
                        </methodparam>
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Iterates over the registered filter output stage creators
                        asking them to create a new output stage for the
                        format specified by <parameter>type</parameter>.

                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void</type>
                        <methodname>Register</methodname>
                        <methodparam>
                            <type>CFilterOutputStageCreator&amp; </type>
                            <parameter>creator</parameter>
                        </methodparam>
                        <modifier></modifier>

                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Provides a new output stage creator to the factory.
                        Output stage creators are the objects that actually
                        create filter output stages. 
                    </para>
                    <para>
                        See <classname>CFilterOutputStagereator</classname>
                        for information about filter output stage creators

                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type> std::string </type>
                        <methodname>document</methodname>
                        <void />
                        <modifier>const</modifier>

                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Collects all of the documentation strings from
                        the registered creators separated by newlines.
                        This is used by the <command>filter</command> command
                        to generate help text that describes the available
                        output formats.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CXdrFilterOutputStageCreator</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CXdrFilterOutputStageCreator.h</refname>
        <refpurpose>
            Create <classname>CXrFilterOutputStage</classname> objects
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CXdrFilterOutputStageCreator.h&gt;


class CXdrFilterOutputStageCreator : public CFilterOutputStageCreator
{
public:

  virtual CFilterOutputStage*  operator()(std::string type);
  virtual std::string document() const;
  virtual CFilterOutputStageCreator* clone();
};


        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Creates output stages for the XDR filter format.  See
            <classname>CFilterOutputStageCreator</classname> for documentation
            of the methods implemented by this class.
        </para>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>FilterEventProcessor</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>FilterEventProcessor</refname>
        <refpurpose>
            Decodes events from a filter file into parameters.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;FilterEventProcessor.h&gt;

class CFilterEventProcessor : public CEventProcessor
{

public:
  virtual Bool_t OnOther(UInt_t nType,
                         CAnalyzer&amp; rAnalyzer,
                         CBufferDecoder&amp; rDecoder);

  virtual Bool_t operator()(const Address_t pEvent,
                            CEvent&amp; rEvent,
                            CAnalyzer&amp; rAnalyzer,
                            CBufferDecoder&amp; rDecoder);

  virtual Bool_t OnEventSourceOpen(std::string name);

};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            XDR Filter files are read in through the normal SpecTcl input system.
            The Filter buffer decoder (<classname>CFilterBufferDecoder</classname>)
            dispatches each item to the event processing pipeline.
            <classname>CFilterEventProcessor</classname> knows how to
            take data from the decoded XDR blocks and store them into
            SpecTcl parameters.
        </para>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CFold</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CFold</refname>
        <refpurpose>Process gamma ray spectrum folds</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CFold.h&gt;

class CFold
{
public:
  CFold(CGateContainer* m_pGate);
  std::string getFoldName();
  void        setGate(CGateContainer* pGate);
  void        operator()(std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; rEvent, 
                         CGammaSpectrum* pSpectrum);
  void        operator()(std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; xParams,
			 std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; yParams,
			 CGammaSpectrum* pSpectrum);
protected:
  void        CutDownParameters(std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; rNew, 
                                std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; rOld, 
                                UInt_t removeMe);
  void        CutDownParameters(std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; rNew, 
                               std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; rOld, 
                               UInt_t remove1, UInt_t remove2);
  
};


        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Fold mediate the processing of an event in Gamma spectra derived
            from <classname>CGammaSpectrum</classname>.  They help determine which
            peaks are part of a sequential decay process.   They do this by only
            incrementing parameters that are <emphasis>not</emphasis> in the fold's
            gate 
        </para>
        <para>
            This <firstterm>cutting down</firstterm> of the parameters allows
            the spectrum to only increment for gamma rays that are coincident
            with the one in the fold.  In this case, coincident means they
            gammas are in the same event.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CFold</methodname>
                        <methodparam>
                            <type>CGateContainer* </type><parameter>pGate</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        The constructor requires a <parameter>pGate</parameter>
                        which will be used as the fold.  The gate should be
                        a valid gamma gate, however it is not an error to use
                        a non-gamma gate.  Using a  non-gamma gate, however
                        will not affect how the spectrum is incremented.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>std::string </type>
                        <methodname>getFoldName</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the name of the fold. The name of the fold
                        is the same asw the name of the gate it evaluates.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>setGate</methodname>
                        <methodparam>
                            <type>CGateContainer* </type><parameter>pGate</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Sets the fold gate to <parameter>pGate</parameter>.
                        Note that a side-effect of this is that the fold's name
                        is changed since it derived from the
                        name of the underlying gate.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void  </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                            <type>std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; </type>
                            <parameter>xParams</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; </type>
                            <parameter>yParams</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CGammaSpectrum* </type><parameter>pSpectrum</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Processes the cut for a gamma deluxe spectrum.
                        For each pair of parameters that satisfies the
                        gamma gate, all other parameter pairs increment
                        the spectrum.   
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>protected</modifier>
                        <type>void </type>
                        <methodname>CutDownParameters</methodname>
                        <methodparam>
                            <type>std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp;</type>
                            <parameter>rNew</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; </type>
                            <parameter>rOld</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t</type><parameter>removeMe</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates a new list of parameters, <parameter>rNew</parameter>
                        that consists of the previous list, <parameter>rOld</parameter>
                        without any instance of parameter id <parameter>removeMe</parameter>
                        in it.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>protected</modifier>
                        <type>void </type>
                        <methodname> CutDownParameters</methodname>
                        <methodparam>
                            <type>std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp; </type>
                            <parameter>rNew</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;std::pair&lt;UInt_t, Float_t&gt; &gt;&amp;  </type>
                            <parameter>rOld</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t</type><parameter> remove1</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t</type><parameter>remove2</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates a new vector, <parameter>rNew</parameter> consisting
                        of the elements of <parameter>rOld</parameter> that cointains
                        neither <parameter>remove1</parameter> nor
                        <parameter>remove2</parameter>.  This is somewhat faster
                        than using the previous method twice and is a natural
                        method for use with 2d gates that are wrapped by
                        a fold.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CAxis</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CAxis</refname>
        <refpurpose>Spectrum axis coordinate transforms.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CAxis.h&gt;

class CAxis      
{
public:

  CAxis (UInt_t nChannels,
	 std::string sUnits = std::string(""));
  CAxis (Float_t fLow,
	 Float_t fHigh,
	 UInt_t  nChannels,
	 std::string sUnits = std::string(""));	

public:
  // Selectors for member data.
  
  float getLow() const;
  float getHigh() const;
  int getChannels() const;

  Float_t ParameterToAxis (Float_t fParameter);
  Float_t AxisToParameter (UInt_t nAxisValue)   ;
  
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <classname>CAxis</classname> incorporates an axis description
            as well as a set of methods to do transforms from parameter
            space to bin space on an axis and back.  A parameter is defined
            as an interval in parameter coordinates that is divided up into
            a number of equal-sized bins.
        </para>
    </refsect1>
    <refsect1>
        <title>
            METHODS
        </title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CAxis</methodname>
                        <methodparam>
                            <type>UInt_t </type><parameter>nChannels</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::string </type><parameter>sUnits </parameter>
                            <initializer>std::string("")</initializer>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Initializes an axis for a simple integer parameter.
                        The axis is a 1:1 mapping over the range:
                        <literal>[0, <parameter>nChannels</parameter>)</literal>
                    </para>
                    <para>
                        The optional <parameter>sUnits</parameter> parameter
                        provides the axis units of measure and defaults to an
                        empty string.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CAxis</methodname>
                        <methodparam>
                            <type>Float_t </type><parameter>fLow</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t </type><parameter>fHigh</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type><parameter> nChannels</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::string </type><parameter>sUnits </parameter>
                            <initializer>std::string("")</initializer>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates an axis for a floating point parameter.
                        The axis covers the range
                        <literal>[<parameter>fLow</parameter>, <parameter>fHigh</parameter>)</literal>
                        and has <parameter>nChannels</parameter> bins.
                    </para>
                    <para>
                        The optional parameter <parameter>sUnits</parameter>
                        is the axis units of measure and defaults to an
                        empty string if not supplied
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>float </type>
                        <methodname>getLow</methodname>
                        <void />
                        <modifier> const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Return the axis low limit.   The axis range is
                        inclusive of this value.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>float </type>
                        <methodname>getHigh</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the axis high limit.  The axis range
                        is exclusive of this value.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>int </type>
                        <methodname>getChannels</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of bins on the axis. In SpecTcl,
                        all bins are equal sized.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Float_t </type>
                        <methodname>ParameterToAxis</methodname>
                        <methodparam>
                            <type>Float_t </type><parameter>fParameter</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Given a parameter value, converts it to an axis value
                        (bins).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type> Float_t </type>
                        <methodname>AxisToParameter</methodname>
                        <methodparam>
                            <type>UInt_t </type><parameter>nAxisValue</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Given an axis bin number converts the value to
                        a parameter value.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CGate</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CGate</refname>
        <refpurpose>SpecTcl gate classes</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;Gate.h&gt;

class CGate      
{
public:
  CGate ();
  Bool_t getChecked();
  Bool_t getCachedValue();
  void Set (Bool_t fValue);
  void Reset ();
  virtual void RecursiveReset(); 
  Bool_t wasChecked ();
  virtual   Bool_t operator() (CEvent&amp; rEvent)  ;
  virtual   CConstituentIterator Begin ()   = 0;
  virtual   CConstituentIterator End ()   = 0;
  virtual   UInt_t Size ()   = 0;
  virtual   std::string GetConstituent (CConstituentIterator&amp; rIterator)   = 0;
  virtual   CGate* clone ()   = 0;
  virtual   std::string Type () const   = 0;
  virtual   Bool_t inGate (CEvent&amp; rEvent, const std::vector&lt;UInt_t&gt;&amp; Params) = 0;
  virtual   Bool_t inGate (CEvent&amp; rEvent) = 0;
  virtual   Bool_t caches();
};
<beginpage />
#include &lt;Cut.h&gt;

class CCut  : public CGate        
{
  
public:
  CCut (  Float_t am_nLow,  Float_t am_nHigh,  UInt_t am_nId  ) ;
  Float_t getLow() const;
  Float_t getHigh() const;
  UInt_t getId() const;
  virtual std::vector&lt;std::string&gt; getSpecs() const;
  virtual   Bool_t operator()(CEvent&amp; rEvent);
  virtual   CGate* clone ()  ;
  virtual   CConstituentIterator Begin ()  ;
  virtual   CConstituentIterator End ()  ;
  virtual   UInt_t Size ()  ;
  virtual   std::string GetConstituent (CConstituentIterator&amp; rIterator)  ;
  virtual   std::string Type ()  const;
  virtual   Bool_t inGate(CEvent&amp; rEvent, const std::vector&lt;UInt_t&gt;&amp; Params);
  virtual   Bool_t inGate (CEvent&amp; rEvent);
  virtual   Bool_t inGate (Float_t x);
};

<beginpage />
#include &lt;FalseGate.h&gt;

class CFalseGate {
  CFalseGate ();
                       
  virtual   Bool_t operator() (CEvent&amp; rEvent)  ;
  virtual   CConstituentIterator Begin ()  ;
  virtual   CConstituentIterator End ()  ;
  virtual   UInt_t Size ()  ;
  virtual   std::string GetConstituent (CConstituentIterator&amp; rIterator)  ;
  virtual   CGate* clone ()  ;
  virtual   std::string Type () const;
  virtual   Bool_t inGate(CEvent&amp; rEvent, const std::vector&lt;UInt_t&gt;&amp; Params);
  virtual   Bool_t inGate(CEvent&amp; rEvent);
  virtual   Bool_t caches();
};

<beginpage />
#include &lt;TrueGate.h&gt;
class CTrueGate  : public CGate        
{

  CTrueGate () : CGate();
  virtual   Bool_t operator() (CEvent&amp; rEvent)  ;
  virtual   CConstituentIterator Begin ()  ;
  virtual   CConstituentIterator End ()  ;
  virtual   UInt_t Size ()  ;
  virtual   std::string GetConstituent (CConstituentIterator&amp; rIterator)  ;
  virtual   CGate* clone ()  ;
  virtual   std::string Type ()  const;
  virtual   Bool_t inGate(CEvent&amp; rEvent, const std::vector&lt;UInt_t&gt;&amp; Params);
  virtual   Bool_t inGate(CEvent&amp; rEvent);
  virtual   Bool_t caches();
};

<beginpage />
class CMaskGate  : public CGate        
{  
public:
  CMaskGate (UInt_t mask);
  long getCompare() const;
  virtual   Bool_t operator() (CEvent&amp; rEvent)  ;
  virtual   UInt_t Size ()  ;
};

class CMaskAndGate : public CMaskGate  
{  
public:

  CMaskAndGate ( UInt_t am_nId, UInt_t  am_lCompare );
  long getCompare() const;     
  UInt_t getId() const;
  virtual   Bool_t operator() (CEvent&amp; rEvent)  ;
  virtual   CGate* clone ()  ;
  virtual   std::string Type ()  const;
  virtual   Bool_t inGate(CEvent&amp; rEvent, const std::vector&lt;UInt_t&gt;&amp; Params);
  virtual   Bool_t inGate(CEvent&amp; rEvent);
};

#include &lt;MaskEqualGate.h&gt;
class CMaskEqualGate : public CMaskGate  
{  
public:
  CMaskEqualGate ( UInt_t am_nId, UInt_t  am_lCompare ) ;
 
 long getCompare() const;
 UInt_t getId() const;
  virtual   Bool_t operator() (CEvent&amp; rEvent)  ;
  virtual   CGate* clone ()  ;
  virtual   std::string Type ()  const;
  virtual   Bool_t inGate(CEvent&amp; rEvent, const std::vector&lt;UInt_t&gt;&amp; Params);
  virtual   Bool_t inGate(CEvent&amp; rEvent);
};

#include &lt;MaskEqualGate.h&gt;

class CMaskNotGate : public CMaskGate  
{  
public:

  CMaskNotGate ( UInt_t am_nId, UInt_t  am_lCompare );
  long getCompare() const;      
  UInt_t getId() const;

public:            
  virtual   Bool_t operator() (CEvent&amp; rEvent)  ;
  virtual   CGate* clone ()  ;
  virtual   std::string Type ()  const;
  virtual   Bool_t inGate(CEvent&amp; rEvent, const std::vector&lt;UInt_t&gt;&amp; Params);
  virtual   Bool_t inGate(CEvent&amp; rEvent);

};
<beginpage />

#include &lt;Point.h&gt;               // Defines FPoint used below.
#include &lt;PointlistGate.h&gt;

class CPointListGate  : public CGate        
{ 
public:
 CPointListGate (UInt_t nXId, UInt_t nYId,
		  const std::vector&lt;FPoint&gt;&amp; Points);
  CPointListGate(UInt_t nXId, UInt_t nYId, UInt_t nPts,
		 Float_t *xCoords, Float_t *yCoords);
  CPointListGate(UInt_t nXId, UInt_t nYId, UInt_t nPts,
		 FPoint* pPoints);

  UInt_t getxId() const;
  UInt_t getyId() const;
  std::vector&lt;FPoint&gt; getPoints() const;

  std::vector&lt;FPoint&gt;::iterator getBegin();
  std::vector&lt;FPoint&gt;::iterator getEnd() ;

  virtual   CConstituentIterator Begin ()  ;
  virtual   CConstituentIterator End ()  ;
  virtual   UInt_t Size ()  ;
  virtual   std::string GetConstituent (CConstituentIterator&amp; rIterator)  ;
  virtual  Bool_t inGate(CEvent&amp; rEvent);
  virtual  Bool_t Inside(Float_t x, Float_t y) = 0;

};

#include &lt;Band.h&gt;

class CBand  : public CPointListGate        
{
public:
			//Default constructor

  CBand (UInt_t nXid, UInt_t nYid,
	 const std::vector&lt;FPoint&gt;&amp; points);
  CBand (UInt_t nXid, UInt_t nYid,
	 UInt_t nPts, FPoint* pPoints);
  CBand (UInt_t nXid, UInt_t nYid,
	 UInt_t nPts, Float_t* pX, Float_t* pY);
  virtual   Bool_t operator()(CEvent&amp; rEvent);
  virtual   CGate* clone ()  ;
  virtual   std::string Type ()  const;

  virtual   Bool_t Inside(Float_t x, Float_t y) ;
protected:
  Bool_t Interior(Float_t x, Float_t y);

};

#include &lt;Contour.h&gt;


class CContour  : public CPointListGate        
{
public:
			//Default constructor

  CContour (UInt_t nXId, UInt_t nYId, 
	    const std::vector&lt;FPoint&gt;&amp; Points);
  CContour (UInt_t nXId, UInt_t NYId, UInt_t nPts,
	    Float_t *xCoords, Float_t *yCoords);
  CContour (UInt_t nXId, UInt_t NYId, UInt_t nPts,
	    FPoint* pPonts);

	
  FPoint getLowerLeft() const;
  FPoint getUpperRight() const;
  virtual   Bool_t operator()(CEvent&amp; rEvent);
  virtual   CGate* clone ()  ;
  virtual   std::string Type ()  const;
  virtual   Bool_t Inside(Float_t x, Float_t y);


};

#include &lt;C2Bands&gt;

class C2Bands  : public CContour        
{                       
public:


  C2Bands (UInt_t nXId, UInt_t nYId,
	   std::vector&lt;FPoint&gt;&amp; rLowBand, 
	   std::vector&lt;FPoint&gt;&amp; rHiBand); 
 virtual   std::string Type ()    ;

};

<beginpage />

#include &lt;CompoundGate.h&gt;

class CCompoundGate  : public CGate        
{
public:
  CCompoundGate () {}
  CCompoundGate(std::list&lt;CGateContainer*&gt; pGates);
  CCompoundGate(std::vector&lt;CGateContainer*&gt; pGates);
  CCompoundGate(UInt_t nGates, CGateContainer** ppGates);
  std::list&lt;CGateContainer*&gt;&amp; GetConstituents();
  virtual void RecursiveReset(); 
  virtual   CConstituentIterator Begin ()  ;
  virtual   CConstituentIterator End ()  ;
  virtual   UInt_t Size ()  ;
  virtual   std::string GetConstituent (CConstituentIterator&amp; rIterator)  ;
  void      AddGateFront(CGateContainer&amp; rGate);
  void      AddGateBack(CGateContainer&amp; rGate);
  void      AddGate(CConstituentIterator&amp; rSpot, CGateContainer&amp; rGate);

};

#include &lt;AndGate.h&gt;

class CAndGate  : public CCompoundGate        
{  
public
  CAndGate () : CCompoundGate() ;
  CAndGate(std::list&lt;CGateContainer*&gt;amp; rGates); 
  CAndGate(std::vector&lt;CGateContainer*&gt;amp; rGates);
  
  virtual   std::string Type ()  const;
  virtual   Bool_t inGate(CEvent&amp; rEvent, const std::vector&lt;UInt_t&gt;&amp; Params );
  virtual   Bool_t inGate(CEvent&amp; rEvent);

};

#include &lt;OrGate&gt;

class COrGate  : public CCompoundGate        
{
  COrGate ();
  COrGate(std::list&lt;CGateContainer*&gt;&amp; rGates);
  COrGate(std::vector&lt;CGateContainer*&gt;&amp; rGates);
  virtual   CGate* clone ()  ;
  virtual   std::string Type ()  const; 
  virtual   Bool_t inGate(CEvent&amp; rEvent, const std::vector&lt;UInt_t&gt;&amp; Params);
  virtual   Bool_t inGate(CEvent&amp; rEvent);
};
<beginpage />

#include &lt;Not.h&gt;

class CNot : public CGate
{
  CNot (CGateContainer&amp; rGate);
  const CGateContainer* getGate();
  virtual   CConstituentIterator Begin ()  ;
  virtual   CConstituentIterator End ()  ;
  virtual   UInt_t Size ()  ;
  virtual   std::string GetConstituent (CConstituentIterator&amp; rp)  ;
  virtual   CGate* clone ()  ;
  virtual   std::string Type ()  const;
  virtual   Bool_t inGate(CEvent&amp; rEvent, const std::vector&lt;UInt_t&gt;&amp; Params);
  virtual   Bool_t inGate(CEvent&amp; rEvent);
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The <classname>CGate</classname> class provides base class services
            and an API definition for SpecTcl's gate classes.  SpecTcl has
            a rich set of gate types ranging from primitive gates to compound
            gates.  A primitive gate is one that does not depend on other gates.
            A compound gate is one that depends on one or more other gates.
        </para>
        <para>
            As the same gate may be checked more than once per event, gates can
            rememer if they've been checkedand, if they have been, the result of
            the most recent check.
            For most gates, therefore, the actual computation of the gate is
            only done once per event with the cached value of that
            check being used in subsequent attempts to evaluate the gate.
        </para>
    </refsect1>
    <refsect1>
        <title>CGate METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CGate</methodname>
                        <void />
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs the base class.  The gate is set with the
                        cache invalid.  The state of the cached value is therefore
                        meaningless.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Bool_t </type>
                        <methodname>getChecked</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Bool_t </type>
                        <methodname>wasChecked</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If the gate has a valid cached value returns
                        <literal>kfTRUE</literal>.  Otherwise returns
                        <literal>kfFALSE</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Bool_t </type>
                        <methodname>getCachedValue</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If the gate has a cached value (<methodname>getChecked</methodname>
                        returns <literal>kfTRUE</literal>) returns the cached value
                        for that gate.  <literal>kfTRUE</literal> means the
                        gate was satisifed by its last check.
                        <literal>kfFALSE</literal> means the gate was not
                        satisfied.  If
                        <methodname>getChecked</methodname> returns
                        <literal>kfFalse</literal>, the return value
                        from this method has no meaning.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>Set </methodname>
                        <methodparam>
                            <type>Bool_t </type><parameter>fValue</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Sets the new value for the gate.   If called after
                        this method call, <methodname>getChecked</methodname>
                        will return <literal>kfTRUE</literal> until the
                        cache is reset via a call to <methodname>Reset</methodname>
                        is called on this gate or <methodname>RecursiveReste</methodname>
                        is called on this gate  or a gate that contains this gate
                        either directly or indirectly.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>Reset</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Resets the cache on this gate.  Any constituent gates
                        will not be reset.  Therefore, it is preferable
                        to call <methodname>RecursiveReset</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>RecursiveReset</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Resets the cached status of this break.  For every
                        constituent gate this method also does a recursive
                        reset on it.  Thus this method is expected to
                        Reset all the gates that contribute to this gate
                        as well as this gate itself.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>Bool_t </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                            <type>CEvent&amp;</type><parameter>rEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If the gate has a valid cached value, that value is returned.
                        If not, the gate is checked (normally using <methodname>inGate</methodname>).
                        The result is then cached and returned.
                    </para>
                    <para>
                        This might be implemented as:
                    </para>
                    <programlisting>
if (!wasChecked()) {
    Set(inGate(rEvent));   // Sets the gate status and cachce.
}
return getCachedValue();
                    </programlisting>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>CConstituentIterator</type>
                        <methodname> Begin </methodname>
                        <void />
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Compound gates are gates that depend on other
                        gates.  You can think of them as a container for
                        other gates (some may be compound as wel) and a
                        logical relationship required among those gates.  For
                        example, an <literal>And</literal> gate requires all
                        constituent gates to be satisfied if it is to be
                        satisifed for an event.
                        The gates a compound gate depends on are called
                        <firstterm>constituents</firstterm>.
                    </para>
                    <para>
                        If the gate has constituents, this method should return
                        an iterator to the first item of the container of
                        constituents  If the gate has no constitutents, the value
                        returned by <methodname>End</methodname> is returned.
                    </para>
                    <para>
                        This method is pure virtual to allow each
                        gate type to use the container of constituents appropriate
                        to it.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>CConstituentIterator </type>
                        <methodname>End</methodname>
                        <void />
                        <modifier>=0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the end of iteration iterator for the
                        consitutents of this gate.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>std::string </type>
                        <methodname>GetConstituent</methodname>
                        <methodparam>
                            <type>CConstituentIterator&amp;</type><parameter> rIterator</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a stringified version of the gate 'pointed to'
                        by the constituent iterator.  The form of this string
                        may vary from gate type to gate type.  Therefore,
                        this method will be documented completely for each
                        concrete gate class so you know what to expect.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>CGate* </type>
                        <methodname>clone</methodname>
                        <void />
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a dynamically created gate that is
                        identical in state to this gate.  Note that dynamically
                        created means that when the client is done with this
                        gate they must <literal>delete</literal> it.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier> virtual   </modifier>
                        <type>std::string </type>
                        <methodname>Type</methodname>
                        <void />
                        <modifier>const   = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a text string that identifies the gate type.
                        This method will be documented for each concrete
                        gate type.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type> Bool_t </type>
                        <methodname>inGate </methodname>
                        <methodparam>
                            <type>CEvent&amp; </type><parameter>rEvent</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is used mostly by non gamma gates.  That
                        is gates with only one set of possible parameters.
                        It returns <literal>kfTrue</literal> if the event
                        satisfies the gate and <literal>kfFalse</literal>
                        if not. 
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodsynopsis>
                    <modifier>virtual   </modifier>
                    <type>Bool_t </type>
                    <methodname>inGate</methodname>
                    <methodparam>
                        <type>CEvent&amp; </type><parameter>rEvent</parameter>
                    </methodparam>
                    <methodparam>
                        <modifier>const </modifier>
                        <type>std::vector&lt;UInt_t&gt;&amp; </type><parameter>Params</parameter>
                    </methodparam>
                    <modifier>= 0</modifier>
                </methodsynopsis></term>
                <listitem>
                    <para>
                        This is normally used by gamma gates.  If the parameter
                        ids in <parameter>Params</parameter> select a set of
                        parameters in <parameter>rEvent</parameter> that make
                        this gate true, the method returns <literal>kfTrue</literal>
                        otherwise <literal>kfFalse</literal>.
                    </para>
                    <para>
                        Gamma gates can be used as cuts by trying all legal
                        combinations of parmeter ids in the
                        <parameter>Params</parameter> vector.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>Bool_t </type>
                        <methodname>caches</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>kfTrue</literal> if the gate caches.
                        This can be used to restrict the set of gates that
                        are reset to only those that have a cache.
                    </para>
                </listitem>
            </varlistentry>
         </variablelist>
    </refsect1>
    <refsect1>
        <title>CCut Methods</title>
        <para>
            <classname>CCut</classname> gates represent an interval in parameter
            space for some parameter.  If an event has that parameter and that
            parameter lies in that interval, the gate is satisfied.  As with
            other intervals in SpecTcl, the interval is inclusive of the low
            limit but exclusive of the high limit.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CCut </methodname>
                        <methodparam>
                            <type>Float_t</type><parameter> am_nLow</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t </type><parameter>am_nHigh</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type><parameter>am_nId </parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs a gate that is satisfied when the
                        parameter with id <parameter>am_nId</parameter> is in
                        the interval
                        <literal>[<parameter>am_nLow</parameter>, <parameter>am_nHigh</parameter>)</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Float_t </type>
                        <methodname>getLow</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the value of the low end of the interval
                        that defines the cut.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Float_t </type>
                        <methodname>getHigh</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the value of the high end of the
                        interval that defines the cut.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>UInt_t </type>
                        <methodname>getId</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the id of the parameter this gate will test.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>std::vector&lt;std::string&gt; </type>
                        <methodname>getSpecs</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a vector of spectrum names involved with the
                        gate.  For a cut, no spectra are involved so an
                        empty vector is returned.  This is used mainly by
                        gamma gates.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>CConstituentIterator </type>
                        <methodname>Begin</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        A cut is a gate with a single constituent - itself.
                        This method returns an iterator that, once incremented
                        is at the end of iteration.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>CConstituentIterator</type>
                        <methodname> End </methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an iterator that points to nothing, and is
                        off the end of constiuents.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>UInt_t </type>
                        <methodname>Size</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>1</literal> indicating there is only
                        one constituent, the gate itself.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type> std::string </type>
                        <methodname>GetConstituent </methodname>
                        <methodparam>
                            <type>CConstituentIterator&amp;</type>
                            <parameter> rIterator</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If the iterator is not at end returns a string consisting
                        of three space separated values.  The first value is
                        the parameter id.  The second and third are the low and
                        high limits of the cut's interval.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>std::string </type>
                        <methodname>Type</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the string <literal>s</literal> for slice.
                        This is the type of gate.  Note that
                        <literal>c</literal> is used for the type of
                        contour gates.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type>   Bool_t </type>
                        <methodname>inGate</methodname>
                        <methodparam>
                            <type>Float_t </type><parameter>x</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>kfTRUE</literal> if
                        <parameter>x</parameter> is in the cut's interval.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>Bool_t </type>
                        <methodname>inGate</methodname>
                        <methodparam>
                            <type>CEvent&amp; </type><parameter>rEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If the event does not have the parameter whose id was
                        used to construct the cut, returns <literal>kfFalse</literal>.
                        If it does, the value of that parameter is passed to
                        the previous method and the result of that method
                        is returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>Bool_t </type>
                        <methodname>inGate</methodname>
                        <methodparam>
                            <type>CEvent&amp;</type><parameter> rEvent</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier>const </modifier><type>std::vector&lt;UInt_t&gt;&amp; </type>
                            <parameter>Params</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Same as the previous method, howver instead of using
                        the id of the parameter used to construct this
                        object, the parameter id <parameter>Params[0]</parameter>
                        is used.
                    </para>
                </listitem>
            </varlistentry>
            
 
        </variablelist>
    </refsect1>
    <refsect1>
        <title><classname>CFalseGate methods</classname></title>
        <para>
            <classname>CFalseGate</classname> is a gate that is never satisfied.
            When gates are deleted, they are actually replaced by false gates,
            gates are never actually deleted.
        </para>
        <variablelist>
             <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type> Bool_t </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                            <type>CEvent&amp; </type><parameter>rEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        As the gate name implies, regardless of the content
                        of <parameter>rEvent</parameter>, this always
                        returns <literal>kfFALSE</literal>.
                    </para>
                </listitem>
             </varlistentry>
             <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>CConstituentIterator </type>
                        <methodname>Begin</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an iterator at end (same value as
                        <methodname>End</methodname>).  False gates have no
                        components.
                    </para>
                </listitem>
             </varlistentry>
             <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>CConstituentIterator</type>
                        <methodname> End</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                    </para>
                </listitem>
             </varlistentry>
             <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>UInt_t </type>
                        <methodname>Size</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>0</literal>
                    </para>
                </listitem>
             </varlistentry>
             <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>std::string </type>
                        <methodname>GetConstituent </methodname>
                        <methodparam>
                            <type>CConstituentIterator&amp; </type><parameter>rIterator</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Regardless of the value of
                        <parameter>rIterator</parameter>; returns an empty string.
                    </para>
                </listitem>
             </varlistentry>
             <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>  virtual   </modifier>
                        <type>std::string </type>
                        <methodname>Type </methodname>
                        <void />
                        <modifier>const;</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the string <literal>F</literal> which represents
                        a False gate.
                    </para>
                </listitem>
             </varlistentry>
             <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type> Bool_t </type>
                        <methodname>inGate</methodname>
                        <methodparam>
                            <type>CEvent&amp; </type><parameter>rEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>Bool_t </type>
                        <methodname>inGate</methodname>
                        <methodparam>
                            <type>CEvent&amp; </type><parameter>rEvent</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier>const</modifier>
                            <type>std::vector&lt;UInt_t&gt;&amp; </type><parameter>ids</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Both of these return <literal>kfFalse</literal>
                        regardless of the parameters passed in.
                    </para>
                </listitem>
             </varlistentry>
             <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>Bool_t </type>
                        <methodname>caches</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>kfFalse</literal> as there's no need
                        for a hard coded gate like <classname>CFalseGate</classname>
                        to cache its answers.
                    </para>
                </listitem>
             </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title><classname>CTrueGate methods</classname></title>
        <para>
            <classname>CTrueGate</classname> is a gate that is never satisfied.
            When a spectrum is created it is initially gated on a true gate.
            True gates can also be used as place holders for gate to be defined
            later.
        </para>
        <variablelist>
             <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type> Bool_t </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                            <type>CEvent&amp; </type><parameter>rEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        As the gate name implies, regardless of the content
                        of <parameter>rEvent</parameter>, this always
                        returns <literal>kfTRUE</literal>.
                    </para>
                </listitem>
             </varlistentry>
             <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>CConstituentIterator </type>
                        <methodname>Begin</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an iterator at end (same value as
                        <methodname>End</methodname>).  False gates have no
                        components.
                    </para>
                </listitem>
             </varlistentry>
             <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>CConstituentIterator</type>
                        <methodname> End</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                    </para>
                </listitem>
             </varlistentry>
             <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>UInt_t </type>
                        <methodname>Size</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>0</literal>
                    </para>
                </listitem>
             </varlistentry>
             <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>std::string </type>
                        <methodname>GetConstituent </methodname>
                        <methodparam>
                            <type>CConstituentIterator&amp; </type><parameter>rIterator</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Regardless of the value of
                        <parameter>rIterator</parameter>; returns an empty string.
                    </para>
                </listitem>
             </varlistentry>
             <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>  virtual   </modifier>
                        <type>std::string </type>
                        <methodname>Type </methodname>
                        <void />
                        <modifier>const;</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the string <literal>T</literal> which represents
                        a True gate.
                    </para>
                </listitem>
             </varlistentry>
             <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type> Bool_t </type>
                        <methodname>inGate</methodname>
                        <methodparam>
                            <type>CEvent&amp; </type><parameter>rEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>Bool_t </type>
                        <methodname>inGate</methodname>
                        <methodparam>
                            <type>CEvent&amp; </type><parameter>rEvent</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier>const</modifier>
                            <type>std::vector&lt;UInt_t&gt;&amp; </type><parameter>ids</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Both of these return <literal>kfTrue</literal>
                        regardless of the parameters passed in.
                    </para>
                </listitem>
             </varlistentry>
             <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>Bool_t </type>
                        <methodname>caches</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>kfFalse</literal> as there's no need
                        for a hard coded gate like <classname>CFalseGate</classname>
                        to cache its answers.
                    </para>
                </listitem>
             </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title>Mask gate methods</title>
        <para>
            Bit mask gates treat a parameter like a bitmask (integer) and
            perform various bit logic mask and compare operations.
            An abstract base class; <classname>CMaskGate</classname>
            Provides storage for the constant bit mask  and the following
            meaningful methods:
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CMaskGate</methodname>
                        <methodparam>
                            <type>UInt_t</type><parameter> mask</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        This base class constructor stores the
                        <parameter>mask</parameter> as an object attribute.
                        Derived classes can use <methodname>getCompare</methodname>
                        to retrieve this value.  Gates derived from this
                        method normally perform some bitwise operation between
                        the parameter and the mask and then a comparison.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>long </type>
                        <methodname>getCompare</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the mask that used to instantiate this base class.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type> Bool_t </type>
                        <methodname>operator() </methodname>
                        <methodparam>
                            <type>CEvent&amp; </type><parameter>rEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This just determine is the actual class's
                        <methodname>inGate</methodname> method has to be invoked.
                        If not the cached value for the gate is returned.
                        Psuedo code for this is:
                    </para>
                    <programlisting>

if cache is not valid
   Set cached value from Actual Class's inGate(rEvent)
endif
return cached value

                    </programlisting>
                </listitem>
            </varlistentry>
        </variablelist>
        <refsect2>
            <title>MaskAnd gates</title>
            <para>
                These gates check to see if all bits in a mask are present
                in the parameter.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>CMaskAndGate </methodname>
                            <methodparam>
                                <type>UInt_t</type><parameter> am_nId</parameter>
                            </methodparam>
                            <methodparam>
                                <type>UInt_t  </type><parameter>am_lCompare</parameter>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            <parameter>am_nId</parameter> is the parameter id
                            of the parameter to test.
                        </para>
                        <para>
                            <parameter>am_lCompare</parameter> is the bit
                            mask used inthe compare.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>long </type>
                            <methodname>getCompare</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the bit mask used in the test.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>UInt_t</type>
                            <methodname>getId</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the id of the parameter that is checked
                            by this gate.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>std::string </type>
                            <methodname>Type</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns <literal>am</literal> for
                            <firstterm>And Mask</firstterm>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual  </modifier>
                            <type> Bool_t </type>
                            <methodname>inGate</methodname>
                            <methodparam>
                                <type>CEvent&amp; </type><parameter>rEvent</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier>const </modifier>
                                <type>std::vector&lt;UInt_t&gt;&amp; </type><parameter>Params</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>Bool_t </type>
                            <methodname>inGate</methodname>
                            <methodparam>
                                <type>CEvent&amp; </type><parameter>rEvent</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Check for the parameter to satisfy the gate.
                            Unfortunately the implementation of both of these
                            methods are the same (<parameter>Params</parameter> is
                            totally ignored and the first method just calls
                            the second.
                        </para>
                        <para>
                            The Mask used to construct the gate is bitwise
                            anded with the parameter.  If the result is
                            equal to the mask, the gate is satisfied, otherwise
                            not.
                        </para>
                        <para>
                            If the gate is satisfied, the method returns
                            <literal>kfTRUE</literal> otherwise
                            <literal>kfFALSE</literal>.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect2>
        <refsect2>
            <title>Mask Equal gates</title>
            <para>
                These just test for bitwise equality of the integerized parameter
                with the specified comparison bitmask.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>CMaskEqualGate </methodname>
                            <methodparam>
                                <type>UInt_t </type><parameter>am_nId</parameter>
                            </methodparam>
                            <methodparam>
                                <type>UInt_t  </type><parameter>am_lCompare </parameter>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Provides a parameter id and a comparison mask on which
                            the object (gate) is constructed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>long </type>
                            <methodname>getCompare</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the comparison value for the gate.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>UInt_t </type>
                            <methodname>getId</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the Id of the parameter on which the
                            gate was constructed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual</modifier>
                            <type>Bool_t </type>
                            <methodname>inGate</methodname>
                            <methodparam>
                                <type>CEvent&amp;</type><parameter> rEvent</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Compares the specified parameter to the mask.
                            If bitwise equal the gate is satisfied.
                        </para>
                    </listitem>
                </varlistentry>

            </variablelist>
        </refsect2>
        <refsect2>
            <title><classname>CMaskNotGate</classname> METHODS</title>
            <para>
                This gate tests for bits that are not in a mask.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>CMaskNotGate </methodname>
                            <methodparam>
                                <type>UInt_t </type><parameter>am_nId</parameter>
                            </methodparam>
                            <methodparam>
                                <type>UInt_t  </type><parameter>am_lCompare</parameter>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            As with all of these mask gate classes,
                            a parameter id (<parameter>am_nId</parameter>) and
                            a mask (<parameter>am_lCompare</parameter>) are required
                            by the constructor.  The actual gate pseudo code
                            will be shown in the <methodname>inGate</methodname>
                            method.  However, this gate will be satisfied if
                            the parameter contains all of the bits that are not
                            set in the mask.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>long </type>
                            <methodname>getCompare</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the value of the mask used in the
                            <methodname>inGate</methodname> operation.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>UInt_t </type>
                            <methodname>getId</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the id of the parameter checked in the
                            <methodname>inGate</methodname> method.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>Bool_t </type>
                            <methodname>inGate</methodname>
                            <methodparam>
                                <type>CEvent&amp; </type>
                                <parameter>rEvent</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Determines if the parameter associated with the
                            gate satisfies it for the event <parameter>rEvent</parameter>.
                            The psuedo code for this is:
                        </para>
                        <programlisting>
id = getId()
if rEvent[id].isValid() then
   mask = ~getCompare()                   // Note bitwise complement.
   return (mask &amp; rEvent[id])  == mask
endif
return kfFALSE
                        </programlisting>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect2>
    </refsect1>
        <refsect1>
            <title><classname>CPointListGate</classname> methods</title>
            <para>
                2-d gates are normally figures draw in a 2-d space defined by
                a pair of parameters.  These figures are defined by an array
                of points in parameter space.
                <classname>CPointListGate</classname> is an abstract
                base class for simple
                2-d gates which stores the ids of both X and Y parameters and
                the list of points that define the figure.
            </para>
            <para>
                While the figure points can be abstracted, the concept of
                inside-ness of a point in parameter space must be defined
                by a concrete derived class.  It's easy to see that this is
                the case by considering the difference in the definition
                of inside-ness for a contour (closed figure) and a band (polyline).
            </para>
            <variablelist>
                  <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>CPointListGate</methodname>
                            <methodparam>
                                <type>UInt_t </type><parameter>nXId</parameter>
                            </methodparam>
                            <methodparam>
                                <type> UInt_t </type><parameter>nYId</parameter>
                            </methodparam>
                            <methodparam>
                                <type>const std::vector&lt;FPoint&gt;&amp; </type><parameter>Points</parameter>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <term>
                        <constructorsynopsis>
                            <methodname>CPointListGate</methodname>
                            <methodparam>
                                <type>UInt_t </type><parameter>nXId</parameter>
                            </methodparam>
                            <methodparam>
                                <type>UInt_t </type><parameter>nYId</parameter>
                            </methodparam>
                            <methodparam>
                                <type>UInt_t </type><parameter>nPts</parameter>
                            </methodparam>
                            <methodparam>
                                <type>Float_t </type><parameter>*xCoords</parameter>
                            </methodparam>
                            <methodparam>
                                <type>Float_t </type><parameter>*yCoords</parameter>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <term>
                        <constructorsynopsis>
                            <methodname>CPointListGate</methodname>
                            <methodparam>
                                <type>UInt_t </type><parameter>nXId</parameter>
                            </methodparam>
                            <methodparam>
                                <type> UInt_t </type><parameter>nYId</parameter>
                            </methodparam>
                            <methodparam>
                                <type>UInt_t </type><parameter>nPts</parameter>
                            </methodparam>
                            <methodparam>
                                <type>FPoint* </type><parameter>pPoints</parameter>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            All constrcutors provide <parameter>nXId</parameter>,
                            the id of the X parameter for the gate and
                            <parameter>nYId</parameter>, the
                            id of the Y parameter for the gate.  Constructors
                            only differ in how the points that define the gate
                            shape are passed.
                        </para>
                        <para>
                            In the first constructor, points are passsed in as
                            <parameter>Points</parameter>, a vector of type
                            <classname>FPoint</classname>.  This type is
                            defined in the <filename>Point.h</filename> header.
                            It is an object that encapsulates an X,Y coordinate
                            pair that represents one point fo the gate shape.
                        </para>
                        <para>
                            The last two constructors require that the
                            number of points in the gate shape,
                            <parameter>nPts</parameter>, be passed to the
                            constructor.
                        </para>
                        <para>
                            In the first of those two, the parameters
                            <parameter>xCoords</parameter> and
                            <parameter>yCoords</parameter> point to
                            simple C arrays containing the X aqnd Y coordinates
                            of each point
                            respectively.  Clearly <parameter>xCoords</parameter>
                            and <parameter>yCoords</parameter> must both have
                            <parameter>nPts</parameter> elements.
                        </para>
                        <para>
                            In the final constructor, the parameter
                            <parameter>pPoints</parameter> points to a C array
                            of <classname>FPoint</classname> objects.
                        </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>UInt_t </type>
                            <methodname>getxId</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>UInt_t </type>
                            <methodname>getyId</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            These two methods get the ids of the parameters
                            on the X and Y axes of the gate shape.  An event
                            that has both of these ids defines a point in
                            parameter space where the parameter whose id is
                            returned by <methodname>getxId</methodname> is
                            on the X axis and that returned by
                            <methodname>getyId</methodname> is on the Y
                            axis.  Gate points define a figure in this
                            space whose meaning depends on the actual,
                            concrete gate type.
                        </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>std::vector&lt;FPoint&gt; </type>
                            <methodname>getPoints</methodname>
                            <void />
                            <modifier> const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns a copy of the points vector.  This may result
                            in copying a significatn number of
                            <classname>FPoint</classname> objects and should
                            not be userd to obtain gate points in order to
                            check gates.  Better to iterate or, if appropriate,
                            use the <methodname>Crosses</methodname>
                            utility method.
                        </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>std::vector&lt;FPoint&gt;::iterator </type>
                            <methodname>getBegin</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>std::vector&lt;FPoint&gt;::iterator </type>
                            <methodname>getEnd</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            These methods provide support for iteration over
                            the set of points that define the gate.  The
                            <methodname>getBegin</methodname> returns an iterator
                            to the beginning of the container of
                            <classname>FPoint</classname> objects defining the
                            gate points while
                            <methodname>getEnd</methodname> returns an
                            end of iteration iterator.
                        </para>
                        <para>
                            If you are not sure what all this means; look up
                            how iterators work in the C++ Standard Template
                            library.  These iterators work the same way.
                        </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual</modifier>
                            <type>   CConstituentIterator </type>
                            <methodname>Begin</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>CConstituentIterator </type>
                            <methodname>End </methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>UInt_t </type>
                            <methodname>Size</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The constituents of point list gates are the points
                            of the gate.  <methodname>Begin</methodname>
                            and <methodname>End</methodname> provide for
                            iteration over the constituents (see
                            <methodname>GetConstituent</methodname> below).
                            <methodname>Size</methodname> returns the number
                             of constituents, in this case, the number of
                             points in the gate figure.
                        </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>std::string </type>
                            <methodname>GetConstituent</methodname>
                            <methodparam>
                                <type>CConstituentIterator&amp; </type><parameter>rIterator</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Return the text string corresponsding to the
                            constituent iterator <parameter>rIterator</parameter>.
                            This will be a string consisting of two space
                            separated floating point number strings
                            (<literal>%f</literal> conversion).  The first number
                            is the X coordinate value of the point corresponding
                            to the iterator while the second the Y coordinate
                            of the same point.
                        </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier> virtual  </modifier>
                            <type>Bool_t </type>
                            <methodname>inGate</methodname>
                            <methodparam>
                                <type>CEvent&amp; </type><parameter>rEvent</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs common code required to check if a gate
                            is satisfied by an event. The geometry sensitive
                            part of the check is done by the pure virtual
                            method <methodname>Inside</methodname> defined
                            below.  Thwe psuedo code for this
                            method is:
                        </para>
                        <programlisting>
xid = getxId()
yid = getyid()
if (rEvent[xid].isValid() and rEvent[yid].isValid()) then
    return Inside(rEvent[xid], rEvent[yid])
endif

return kfFalse
                        </programlisting>
                        <para>
                            Thus this method only checks that both parameters
                            are defined.  If so <methodname>Inside</methodname>
                            is invoked to see if the point defined by the
                            event satisfies the gate and otherwise,
                            <literal>kfFalse</literal> is returned.
                        </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier> virtual  </modifier>
                            <type>Bool_t </type>
                            <methodname>Inside</methodname>
                            <methodparam>
                                <type>Float_t </type><parameter>x</parameter>
                            </methodparam>
                            <methodparam>
                                <type>Float_t </type><parameter>y</parameter>
                            </methodparam>
                            <modifier>=0</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Pure virtual method that has to be implemented by
                            concrete sub-classes.  <parameter>x</parameter> and
                            <parameter>y</parameter> are a point in the parameter
                            coordinate space in which the gate is drawn.  The
                            method should return <literal>kfTRUE</literal> if this
                            point is 'inside' that gate or
                            <literal>kfFALSE</literal> if not.
                        </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>protected</modifier>
                            <type>int</type>
                            <methodname>Crosses</methodname>
                            <methodparam>
                                <type>Float_t </type><parameter>x</parameter>
                            </methodparam>
                            <methodparam>
                                <type>Float_t </type><parameter>y</parameter>
                            </methodparam>
                            <methodparam>
                                <type>std::vector&lt;FPoint&gt;::iterator</type>
                                <parameter> f</parameter>
                            </methodparam>
                            <methodparam>
                                <type>std::vector&lt;FPoint&gt;::iterator </type>
                                <parameter>s</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This utility method  is useful for determining
                            inside-edness.  The parameters
                            <parameter>x</parameter> and <parameter>y</parameter>
                            define a point in the parameter space of a gate.
                            <parameter>f</parameter> and <parameter>s</parameter>
                            are two iterators that indicate two consecutive points
                            in the figure that defines the gate.
                            
                        </para>
                        <para>
                            Those two points define a line segment in the gate
                            parameter space.  The method 'draws' a horizontal
                            ray that extends left from (<parameter>x</parameter>, <parameter>y</parameter>).
                            The method returns <literal>1</literal> if this
                            line would intersect (cross) the line segment
                            defined by <parameter>f</parameter> and
                            <parameter>s</parameter>.  If not,
                            <literal>0</literal> is returned.
                        </para>
                        <para>
                            Special cases that can speed up the determination
                            are mercilessly  exploited.
                        </para>
                    </listitem>
                  </varlistentry>
            </variablelist>
        <refsect2>
            <title><classname>CBand</classname> methods</title>
            <para>
                A Band is a polyline drawn in a two dimensional space defined
                by two SpecTcl parameters.  Inside-ness is defined as being
                inside a region of the plane defined by the polyline and
                vertical lines from the left and right points extending infinitely
                down.
                A point is inside this region if a horizontal ray drawn
                leftward from the point crosses an odd number of line segments
                that make up the boundaries of the region.   The vertical
                lines described above are included in that count.
            </para>
            <para>
                This definition provides well defined behavior for bands that
                are multivalued in y (polylines for which the x coordinate
                of points is not monotonic).  This definition is also
                consistent withe the definition of inside-ness used by
                contour gates.
            </para>
            <para>
                The constructors are not documented below as there are three
                of them that have all the same parameterizations as the
                three constructors of the <methodname>PointListGate</methodname>
                base class from which <classname>CBand</classname> is defined.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>std::string </type>
                            <methodname>Type </methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the gate type which is
                            <literal>b</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                       <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>Bool_t </type>
                        <methodname>Inside</methodname>
                        <methodparam>
                            <type>Float_t </type><parameter>x</parameter>
                        </methodparam>
                        <methodparam>
                            <type>Float_t </type><parameter>y</parameter>
                        </methodparam>
                        <modifier></modifier>
                       </methodsynopsis> 
                    </term>
                    <listitem>
                        <para>
                            Just invokes <methodname>Interior</methodname>,
                            see below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>protected</modifier>
                            <type>Bool_t</type>
                            <methodname> Interior</methodname>
                            <methodparam>
                                <type>Float_t </type><parameter>x</parameter>
                            </methodparam>
                            <methodparam>
                                <type>Float_t </type><parameter>y</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Determines if a point is inside the band region.
                            A boundary crossing algorithm similar to what is used
                            in flood fill operations is used to define
                            interior points consistently and predictably regardless
                            of any pathologies of the boundary.
                        </para>
                        <para>
                            The software counts boundary crossings, including
                            the crossings of rays extending from the left and
                            right most points to negative infinity.  An odd
                            number of crossings means the point is inside the
                            figure. An even number (zero is even) means the
                            point is outside.
                        </para>
                        <para>
                            Here is pseudo code:
                        </para>
                        <programlisting>
crossings = 0
if point is to the right and below the left most point crossings = crossings + 1
if point is to the right and below the righ tmost point crossings = crossings + 1

for each line segment in the polyline:
    if Crosses(point, segment) then     // Crosses from base class
        crossings = crossings + 1
    endif
end for
return (crosses &amp; 1) == 1
                        </programlisting>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect2>
        <refsect2>
            <title><classname>CContour</classname> methods</title>
            <para>
                Contour gates are closed figures that are drawn on a 2-d parameter
                space. A contour is satisified if the parameters are both defined
                and lie within the figure.  <classname>CContour</classname>
                implements contour gates and is derived from
                <classname>CPointListGate</classname>.
            </para>
            <para>
                As with bands, pathalogical figures are possible.  Contours
                use a definition of inside-ness that is similar to that of
                bands, with the exception that there's no need to draw
                rays from a left and right point to negative infinity to
                complete a semi-infinite closed figure.  For a contour a
                final line segment is drawn from the last point to the first
                point.
            </para>
            <para>
                An optimization is performed when the gate is constructed.
                A bounding rectangle is computed from the points of the figure.
                When checking the gate; the point is first tested against this
                rectangle and the gate is not satisifed if the point is outside
                the rectangle.  If the point is inside the rectangle, then
                a horizontal ray is 'drawn' from the point towards the left.
                The number of times this ray crosses a segment of the
                figure is computed and the point is considered inside the
                figure if this number is odd.
            </para>
            <para>
                Psuedo code for this will be presented in the description
                of the methods below.  Note that the constructors for
                <classname>CContour</classname> are identical
                to those for <classname>CPointListGate</classname>.  They
                will not be documented below.  Refer to
                <classname>CPointListGate</classname> for a description of
                the constructor signatures.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>FPoint </type>
                            <methodname>getLowerLeft</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This method returns the point at the lower left
                            of the rectangle that bounds the contour.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>FPoint </type>
                            <methodname>getUpperRight</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This method returns the point at the upper
                            right of the rectangle that bounds the contour.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>std::string </type>
                            <methodname>Type </methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the string <literal>c</literal> indicating
                            this is a contour gate.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>Bool_t </type>
                            <methodname>Inside</methodname>
                            <methodparam>
                                <type>Float_t </type><parameter>x</parameter>
                            </methodparam>
                            <methodparam>
                                <type>Float_t </type><parameter>y</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns <literal>kfTrue</literal> if
                            <parameter>x</parameter>, <parameter>y</parameter>
                            define a point inside the contour figure.
                            For a conceptual description of the definition
                            of inside (in the presence of pathalogical shapes),
                            see the description at the top of this section.
                        </para>
                        <para>
                            Psuedo code for the check is shown below:
                        </para>
                        <programlisting>
If (x,y) is inside the bounding rectangle then
   crossings = 0
   for each segment in the figure        // Note the last point is connected to first.
        if Crosses(x,y, segment)  then   // From <classname>CPointListGate</classname>
            crossings = crossings + 1
        endif
    end for
    return (crossings &amp; 1) == 1      //  true if odd.
endif
return kfFALSE                           // Outside bounding rectangle.
        
                        </programlisting>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect2>
        <refsect2>
            <title><classname>C2Bands</classname> Methods.</title>
            <para>
                This gate is essentially two bands that are made into
                a countour by joining their left and rightmost points
                to close the figure defined by the two bands.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>C2Bands</methodname>
                            <methodparam>
                                <type>UInt_t </type><parameter>nXId</parameter>
                            </methodparam>
                            <methodparam>
                                <type>UInt_t </type><parameter>nYId</parameter>
                            </methodparam>
                            <methodparam>
                                <type>std::vector&lt;FPoint&gt;&amp;</type><parameter> rLowBand</parameter>
                            </methodparam>
                            <methodparam>
                                <type>std::vector&lt;FPoint&gt;&amp; </type><parameter>rHiBand</parameter>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Constructs a contour from two bands whose
                            parameters are specified by
                            <parameter>nXId</parameter> and
                            <parameter>nYId</parameter>.  The points that define
                            the first band are <parameter>rLowBand</parameter>
                            and those of the second,
                            <parameter>rHiBand</parameter>.
                        </para>
                        <para>
                            The constructor simply marshalls these points
                            for the <classname>CContour</classname>
                            constructor.  Once that's done, the methods of
                            <classname>CContour</classname> class
                            provides all of the functionality.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>std::string</type>
                            <methodname> Type</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the string
                            <literal>cb2</literal>.
                        </para>
                    </listitem>
                </varlistentry>

            </variablelist>
        </refsect2>
    </refsect1>
    <refsect1>
        <title><classname>CCompoundGate</classname> Methods</title>
        <para>
            Compound gates are gates that are composed of one or more
            other <firstterm>constituent</firstterm>
            gates.  The compound gate is satisfied if a logical
            function of its constituent gates is satisfied.
        </para>
        <para>
            <classname>CCompoundGate</classname> is an abstract base
            class for compound gates.  This section will describe that
            gate and the gates that are derived from this class.
        </para>
        <para>
            <classname>CCompoundGate</classname> provides storage of and
            access to the constituent gates.  The constituents can either
            be provided at construction time or built up incrementally..
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname> CCompoundGate</methodname>
                        <void />
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        This constructor creates the base class without
                        any contituent gates.   Method such as
                        <methodname>AddGateBack</methodname> must be used
                        to add constituents to the gate.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CCompoundGate</methodname>
                        <methodparam>
                            <type>std::list&lt;CGateContainer*&gt; </type><parameter>pGates</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <term>
                    <constructorsynopsis>
                        <methodname>CCompoundGate</methodname>
                        <methodparam>
                            <type>std::vector&lt;CGateContainer*&gt; </type><parameter>pGates</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <term>
                    <constructorsynopsis>
                        <methodname>CCompoundGate</methodname>
                        <methodparam>
                            <type>UInt_t </type><parameter>nGates</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CGateContainer** </type><parameter>ppGates</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        These constructors create the object with an initial
                        set of gates.  Gates are stored as pointers to a
                        gate container.  This allows SpecTcl ot modify
                        what the gate container "points to" without having
                        to locate and fix up all references to an underlying
                        gate.  
                    </para>
                    <para>
                        The constructors only differ in the wa in which the
                        constituent gates are passed to the constuctor.
                        The first two use the
                        <classname>std::vector</classname> and
                        <classname>std::list</classname> container for the
                        constituent gates while the last uses a counted
                        C array of pointers to <classname>GateContainer</classname>
                        pointers.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::list&lt;CGateContainer*&gt;&amp; </type>
                    <methodname>GetConstituents</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis></term>
                <listitem>
                    <para>
                        Returns the list of pointers to the gate containers that
                        make up this gate.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>RecursiveReset</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Resets the cache of this gate and all
                        constituent gates.  The next time this, or any
                        constituent gate is asked for its value vai
                        <methodname>operator()</methodname> it must
                        re-evaluate the gate with respect to the event.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type> CConstituentIterator</type>
                        <methodname> Begin </methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>CConstituentIterator </type>
                        <methodname>End</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>UInt_t </type>
                        <methodname>Size </methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Provides the usual constituent iterator interface
                       for the compound gate.  <methodname>Begin</methodname>
                       produces an iterator at the start of the container
                       and <methodname>End</methodname> one that is off
                       the end of the container.  Finally
                       <methodname>Size</methodname> returns the number
                       of times the iterator returned by
                       <methodname>Begin</methodname> can be incremented
                       before it becomes equal to the iterator returned
                       by <methodname>End</methodname>.   
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>std::string </type>
                        <methodname>GetConstituent</methodname>
                        <methodparam>
                            <type>CConstituentIterator&amp; </type><parameter>rIterator</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the name of a constituent gate.
                        For compound gates, the
                        <classname>ConstituentIterator</classname> can be
                        thought of as an object that retrieves
                        constituent gate names.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void      </type>
                        <methodname>AddGateFront</methodname>
                        <methodparam>
                            <type>CGateContainer&amp; </type><parameter>rGate</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a new constituent gate at the beginning of
                        the constituents for the gate. Normally it's too hard
                        to predicts the effect of constituent order on gates.
                        If these can be predicted, however for
                        And gates, the gates are most efficiently ordered in
                        order of decreasing probability they'll fail, while
                        for OR gates, gates are most efficiently ordered
                        in decreasing probability they willl be satisfied.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void      </type>
                    <methodname>AddGateBack</methodname>
                    <methodparam>
                        <type>CGateContainer&amp; </type><parameter>rGate</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis></term>
                <listitem>
                    <para>
                        Adds the gate container <parameter>rGate</parameter>
                        at the end of all of the existing constituents.
                        See above for notes on ordering gates.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void     </type>
                        <methodname> AddGate</methodname>
                        <methodparam>
                            <type>CConstituentIterator&amp; </type><parameter>rSpot</parameter>
                        </methodparam>
                        <methodparam>
                            <type> CGateContainer&amp; </type><parameter>rGate</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds the gate container <parameter>rGate</parameter>
                        in the constituent list just prior to <parameter>rSpot</parameter>.
                        Thus <code>AddGateFront(rGate)</code> is
                        identical to <code>AddGate(Begin(), rGate)</code>.
                        Similarly, <code>AddGateBack(rGate)</code> is
                        identical to <code>AddGate(End(), rGate)</code>.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <refsect2>
            <title><classname>CAndGate</classname> methods</title>
            <para>
                An And gate is a compound gate that is satisfied only if all of
                its constituent gates are satisfied.  Short ciruit evaluation
                improves the efficiency of evaluating this gate.  Gates in
                the constituent list only get evaluated until the first
                gate fails at  which time the gate is determined not to have
                been satisifed.   If all gates are satisified, the and
                gate is satisfied.
            </para>
            <para>
                The constructors for this class mirror those of
                <classname>CCompoundGate</classname> and therefore will not be
                documented below.  Refer to the documentation of the
                constructors for <classname>CCompoundGate</classname> for more
                information about the constructors for this class.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>std::string </type>
                            <methodname> Type</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the string <literal>*</literal>.  This is the
                            symbol for an and gate because the logical and
                            operation is normally called the logical product.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>Bool_t </type>
                            <methodname>inGate</methodname>
                            <methodparam>
                                <type>CEvent&amp; </type><parameter>rEvent</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier>const </modifier>
                                <type>std::vector&lt;UInt_t&gt;&amp; </type><parameter>Params </parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>Bool_t </type>
                            <methodname>inGate</methodname>
                            <methodparam>
                                <type>CEvent&amp; </type><parameter>rEvent</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Determines if the gate is satisfied.  Since this is
                            not a gamma gate, the first of these methods
                            simply calls the second.  The second method
                            evaluates the gate by recursively evaluating
                            the minimum set of constituents needed to determine if the
                            gate is satisfied.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect2>
        <refsect2>
            <title><classname>COrGate</classname> methods</title>
            <para>
                The Or gate is satisfied if any of its consituents is satisfied.
                As with <classname>CAndGate</classname>, short circuit evaluation
                is used to minimize the computation required to evaluate this
                gate.  Constituent gates are evaluated until the first satisfied
                gate at which point, the gate is deemed satisified.  If no
                gates in the list of consitutents are satisfied, the gate is
                deemed to have not been satisfied.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>std::string </type>
                            <methodname>Type</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the string <literal>+</literal>.  This is the
                            type for a an or gate because the logical OR operation
                            is often called the logical sum of its product
                            terms.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual  </modifier>
                            <type> Bool_t</type>
                            <methodname> inGate</methodname>
                            <methodparam>
                                <type>CEvent&amp;</type><parameter> rEvent</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier>const </modifier>
                                <type>std::vector&lt;UInt_t&gt;&amp;</type><parameter> Params</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual </modifier>
                            <type>  Bool_t </type>
                            <methodname>inGate</methodname>
                            <methodparam>
                                <type>CEvent&amp; </type><parameter>rEvent</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Recursively evaluates the constituent gates.  As soon
                            as a constituent gate is determined to  be satisfied,
                            this method returns <literal>kfTRUE</literal>,
                            if no constituent gates are satisfied, the method
                            return <literal>kfFALSE</literal>
                        </para>
                        <para>
                            As the gate does not have fold/gamma gate
                            semantics, the first of these methods simply
                            calls the second.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>            
        </refsect2>
    </refsect1>
    <refsect1>
        <title><classname>CNot</classname> Methods</title>
        <para>
            A Not gate is a gate that is true if its single constituent
            gate is false.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CNot</methodname>
                        <methodparam>
                            <type>CGatContainer&amp; </type><parameter>rGate</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        The <parameter>rGate</parameter> is the single constituent
                        gate.  This gate will
                        only be true for events that satisfy
                        this constituent.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>const </modifier>
                        <type>CGateContainer* </type>
                        <methodname>getGate</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the gate container of the
                        gate whose logical sense is  inverted by this gate.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>CConstituentIterator </type>
                        <methodname>Begin </methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier> virtual   </modifier>
                        <type>CConstituentIterator </type>
                        <methodname>End</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>UInt_t </type>
                        <methodname>Size</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Supplies the constituent iteration interface for
                        this gate type.  <methodname>Begin</methodname> and
                        <methodname>End</methodname> provide iterators for
                        the start of iteration and the end respectively.
                        <methodname>Size</methodname> returns the number
                        of constituents (<literal>1</literal>).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>std::string </type>
                        <methodname>GetConstituent</methodname>
                        <methodparam>
                            <type>CConstituentIterator&amp; </type><parameter>rp</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the constituent pointed at the iterator
                        <parameter>rp</parameter>.  For the iterator
                        returned by <methodname>Begin</methodname>, this returns
                        the name of the constituent gate. Otherwise an empty string
                        is returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>std::string </type>
                        <methodname>Type</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the string <literal>-</literal> which is the
                        type strig for a not gate. The string indicates negation
                        of the constituent gate.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type>Bool_t </type>
                        <methodname>inGate</methodname>
                        <methodparam>
                            <type>CEvent&amp; </type><parameter>rEvent</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>std::vector&lt;UInt_t&gt;&amp; </type><parameter>Params</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type> Bool_t </type>
                        <methodname>inGate</methodname>
                        <methodparam>
                            <type>CEvent&amp; </type><parameter>rEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Rturns <literal>kfTRUE</literal> if
                        <parameter>rEvent</parameter> satisfies the gate
                        (does not satisfy the constituent gate).
                        Otherwise returns <literal>kfFALSE</literal>.
                        The gate is not a gamma gate so the first overload of
                        this method just invokes the second.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CGateContainer</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CGateContainer</refname>
        <refpurpose>Pointer like class for Gates.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;GateContainer.h&gt;
class CGateContainer : public CNamedItem {
 public:

  CGateContainer() ;
  CGateContainer (const std::string&amp; sName, UInt_t nNumber, 
		  CGate&amp; rGate);  
  CGate* getGate() const;   
  void setGate (CGate* am_pGate);
  CGate&amp; operator* () ;

  CGate* operator-> () ;
  Bool_t operator() (CEvent&amp; rEvent);
};

        </synopsis>        
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            SpecTcl gates are mutable.  Not only can the constituents be modified,
            but the gate type can also be changed.  If objects depending on
            gates held a pointer or reference to that gate, SpecTcl would need
            to update all references to a gate whenever the gate was modified,
            a potentially costly and error prone process.
        </para>
        <para>
            It would be possible for gate clients to have a pointer to a pointer.
            That would work.  Changing a gate would change the underlying pointer
            and the pointer to that pointer could remain valid.  That would lead
            to notational abominations like <code>(*pGate)->operator()</code>.
        </para>
        <para>
            Instead of this, SpecTcl employes a pointer like object called a
            gate container.  The gate container contains a gate and wraps it
            with pointer like semantics.   Gate containers are derived from
            <classname>CNamedItem</classname> so it is the container that
            holds the name of a gate, not the gate itself.  Clients of the
            gate can hold either a reference to the gate container (if the
            gate they are clients of won't change names) or a pointer to the
            gate container if, like spectra, they can.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CGateContainer</methodname>
                        <void />
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Default constructors must be defined for objects that
                        will be inserted into STL container classes (such
                        as <classname>std::Map</classname>).  The default
                        constructor constructs a gate container that will
                        segfault when attempts are made to access the underlying
                        gate.
                    </para>
                    <para>
                        Once constructed, assignment can be used to give the
                        container and id, name and gate.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CGateContainer </methodname>
                        <methodparam>
                            <type>const std::string&amp; </type><parameter>sName</parameter>
                        </methodparam>
                        <methodparam>
                            <type>UInt_t </type><parameter>nNumber</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CGate&amp; </type><parameter>rGate</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs with a gate; <parameter>rGate</parameter>,
                        an id;
                        <parameter>nNumber</parameter> and a gate instance
                        <parameter>rGate</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CGate* </type>
                        <methodname>getGate</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the gate that is encapsulated
                        by the gate container.  Normally you won't need to
                        call this as you can manipulate the gate via the
                        methods supplied by the container.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>setGate</methodname>
                        <methodparam>
                            <type>CGate* </type><parameter>am_pGate</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Used by SpecTcl to replace the gate in the container.
                        Note that when a gate is constructed into a gate
                        container, containers are assigned or this method is
                        called, the pointer passed in is not stored.  Instead a
                        clone of the gate is made and <emphasis>that</emphasis>
                        is what's stored in the container.
                    </para>
                    <para>
                        Note that destroying the container also implicitly
                        destroys the cloned gate.    All of this means
                        it's perfectly safe to have code like:
                    </para>
                    <programlisting>
{
    Float_t xcoords[4] = {0.0, 100.0, 100.0, 0.0};
    Float_t ycoords[4] = {0.0, 0.0, 100.100, 100.100};
    CContour square(1, 2, 4, xcoords, ycoords);
    CGateContainer gc = new CGateContainer("rectangle", 100, square);
    
    return gc;
}                     // square object was destroyed here but gc's clone lives.
                    </programlisting>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CGate&amp;</type>
                        <methodname> operator*</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Implements the first part of pointer semantics;
                        plain dereference.
                        This returns a reference to the encapsulated gate.
                        This allows code like:
                    </para>
                    <programlisting>
CGateContainer gc;
...                       // Gate/name etc. set here.
CGate& gate(*gc);
std::string t = gate.Type();
                    </programlisting>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CGate*</type>
                        <methodname>operator-></methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the gate.  This implements
                        the second part of pointer semantics, member dereference.
                        The method allows operations like:
                    </para>
                    <programlisting>
CGateContainer gc;
...                      // Gate name etc. set here.

std::string t = gc->Type();       // Fetch gate type.

                    </programlisting>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodsynopsis>
                    <modifier></modifier>
                    <type>Bool_t</type>
                    <methodname> operator()</methodname>
                    <methodparam>
                        <type>CEvent&amp; </type><parameter>rEvent</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis></term>
                <listitem>
                    <para>
                        This is a convenience method that evaluates the underlying
                        gate for the event <parameter>rEvent</parameter>.
                        Since the gate is encapsulated as a pointer, the
                        actual gate's <methodname>operator()</methodname> is
                        invoked.  This allows code like:
                    </para>
                    <programlisting>
// Assume spec is a CSpectrum reference and rEvent a CEvent reference.

Bool_t gateMade = (*spec.getGate())(rEvent);          // Evaluate the gate

                    </programlisting>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CGateObserver</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CGateObserver</refname>
        <refpurpose>Observe changes in the gate dictionary.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;Histogrammer.h&gt;

template &lt;class T&gt;
class DictionaryObserver 
{
public:
  virtual void onAdd(std::string   name,   T&amp; item) {}
  virtual void onRemove( std::string name,    T&amp; item) {}

};
typedef CDictionary&lt;CGateContainer&gt;             CGateDictionary;
typedef CGateDictionary::DictionaryIterator     CGateDictionaryIterator;
typedef DictionaryObserver&lt;CGateContainer&gt;      GateDictionaryObserver;

class CGateObserver : public GateDictionaryObserver {
public:
  virtual void onChange(std::string name, CGateContainer&amp; gateContainer) = 0;
};

#include &lt;SpecTcl.h&gt;
class SpecTcl
{
public:
...
    void addGateDictionaryObserver(GateObserver* observer);
    void remove GateDictionaryObserver(Gateobservr* observer);
};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Before looking at the documentation for the gate observer;
            if you are not familiar with the <firstterm>Observer</firstterm>
            software pattern, it's worth taking some time to udnerstand it.
            On introduction is available at the wikipedia at:
            <ulink url='https://en.wikipedia.org/wiki/Observer_pattern' />.
        </para>
        <para>
            Gate dictionary observers allow you to become aware of changes made
            to the gate dictionary. The changes you can observer are:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Insertions of gate containers into the dictionary.
                </para>
            </listitem>
            <listitem>
                <para>
                    Changes to existing gate containers already in the
                    dictionary (usually this means the gate contained by
                    that observer is being changed for a new one).
                </para>
            </listitem>
            <listitem>
                <para>
                    Removals of gate containers from the dictionary
                    (this is never done at this time).
                </para>
            </listitem>
        </itemizedlist>
        <para>
            As the synopsis shows, gate containers are added and removed
            fromt he gate dictionary via the SpecTcl API class
            <classname>SpecTcl</classname>.  Observers consitute an ordered list
            of objects attached to the gate dictionary.  When an observable
            change occurs, each of these observers is invoked in the order
            in which they were added
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            The <classname>CGateObserver</classname> is derived from
            the more general templated base class
            <classname>DictionaryObserver</classname>.  This section documents, not only the methods
            defined in <classname>CGateObserver</classname> but the
             methods of <classname>CDictionaryObserver</classname>
            a concrete class can override.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>onAdd</methodname>
                        <methodparam>
                            <type>std::string   </type><parameter>name</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CGateContainer&amp; </type><parameter>item</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when a new gate container is added to the
                        dictionary.  <parameter>name</parameter> is the name
                        of the item in the dictionary (this need not be
                        but currently always is the same as the name of the
                        gate container).
                    </para>
                    <para>
                        <parameter>item</parameter> is a reference to the gate container
                        being added to the dictionary.  The base class
                        implements this as an empty method.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>onRemove</methodname>
                        <methodparam>
                            <type> std::string </type><parameter>name</parameter>
                        </methodparam>
                        <methodparam>
                            <type> CGateContainer&amp; </type><parameter>item</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when an item is removed from the dictionary.
                        At present this does not happen as gate deletion
                        simply replaces the gate with a False gate.
                        The <parameter>name</parameter> of the
                        gate and the gate container <parameter>item</parameter>
                        are passed in as parameters.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>onChange</methodname>
                        <methodparam>
                            <type>std::string</type><parameter> name</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CGateContainer&amp;</type><parameter> gateContainer</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when an item in the dictionary is changed.
                        For the gate dictionary.  This means a gate container
                        is encapsulating a new gate object because the
                        gate has been modified.
                    </para>
                </listitem>
            </varlistentry>

        </variablelist>
    </refsect1>
    <refsect1>
        <title>EXAMPLE</title>
        <para>
            This toy example just prints out some text when for each
            gate observation.  The example includes the class definition
            for the gate dictionary observer as well as a snippet of code
            that registers an instance of that observer with the SpecTcl
            gate dictionary.
        </para>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CFit</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CFit</refname>
        <refpurpose>Base class for spectrum fitting subsystem.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>

#include &lt;CFit.h&gt;
class CFit : public  CNamedItem     
{
public:
  struct Point {		
    double x;
    double y;
    int operator==(const Point&amp; rhs) const;
    int operator!=(const Point&amp; rhs) const;
  };
  
  typedef std::vector&lt;Point&gt; PointArray; 
  typedef PointArray::iterator PointIterator;

  typedef std::pair&lt;std::string, double&gt; FitParameter;
  typedef std::vector&lt;FitParameter&gt; FitParameterList;
  typedef FitParameterList::iterator FitParameterIterator;

  typedef enum {
    Accepting,
    Performed
  } FitState;			//!< State of the fit.

  

  void AddPoint (Point p)   ; 
  PointIterator begin ()   ; 
  PointIterator end ()   ; 
  size_t size ()   ; 
  FitState GetState ()  const ; 

  virtual CFit* clone() = 0;
  virtual   void Perform ()   = 0 ; 
  virtual  double operator() (double x)  =0 ; 
  virtual  FitParameterList GetParameters () =0  ; 
  virtual  std::string Type() const  = 0;
 
protected:
  void SetFitState(FitState state) ;
};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            SpecTcl has an extensible fitting program.  Fits can be
            created and updated based on the current data.  SpecTcl
            also interacts with the display program to display any fits
            on appropriate spectra, if that display program is capable of that.
        </para>
        <para>
            The core of the fitting subsystem is the <classname>CFit</classname>
            abstract base class.  Each object that performs a fit must be a
            concrete class derived from <classname>CFit</classname>
        </para>
        <para>
            Fits are stateful objects.   There are two states a fit can
            be in.  The <literal>Accepting</literal> state means that the
            fit has had at least one point added without a call to
            <methodname>Perform</methodname>.  In this state the fit parameters
            cannot be retrieved.  Once <methodname>Perform</methodname> is called,
            the fit is in the <literal>Performed</literal> state and the fit
            parameters can be extracted from the object.
        </para>
        <para>
            Note that since <classname>CFit</classname> is a
            <classname>CNamedItem</classname>, it inherits a constructor
            that have name and id as parameters.
        </para>
    </refsect1>
    <refsect1>
        <title>DATA TYPES</title>
        <para>
            The class defines a few contained data types.  By contained,
            we mean a data type that is defined inside the class definition.
            Contained data type names must be resolved in the scope of the
            class.  E.g. <code>PointArray a;</code> will cause a compiler
            error but <code>CFit::PointArray a;</code> will not.
        </para>
        <refsect2>
            <title><structname>Point</structname> a data point.</title>
            <para>
                The <structname>Point</structname> struct represents a point
                of data that needs to be fitted.  For spectrum fits, each
                point is a channel coordinate (<structfield>x</structfield>)
                and the counts in that channel (<structfield>y</structfield>).
                At present, SpecTcl fits are restricted to 1-d data sets.
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>double </type><structfield>x</structfield></term>
                    <listitem>
                        <para>
                            The X coordinate of the point. Normally this
                            represents a channel number in the spectrum
                            being fitted.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>double</type> <structfield> y</structfield></term>
                    <listitem>
                        <para>
                            The Y coordinate of the point. Normally this is the
                            number of points in the channel selected by
                            <structfield>x</structfield>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>int </type>
                            <methodname>operator==</methodname>
                            <methodparam>
                                <modifier>const</modifier>
                                <type> Point&amp; </type><parameter>rhs</parameter>
                            </methodparam>
                            <modifier> const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns non zero (<literal>1</literal>) if
                            the <structfield>x</structfield> and
                            <structfield>y</structfield> fields of the
                            <structname>Point</structname> referred to by
                            <parameter>rhs</parameter> are equal to that of this
                            object.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>int </type>
                            <methodname>operator!=</methodname>
                            <methodparam>
                                <modifier>const</modifier>
                                <type> Point&</type><parameter> rhs</parameter>
                            </methodparam>
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Inverse of <methodname>operator==</methodname>.
                        </para>
                    </listitem>
                </varlistentry> 
            </variablelist>
        </refsect2>
        <refsect2>
            <title>Typedefs related to <structname>Point</structname></title>
            <variablelist>
                <varlistentry>
                    <term><code>typedef std::vector&lt;Point&gt; PointArray</code></term>
                    <listitem>
                        <para>
                            <type>PointArray</type> objects maintain the set
                            of points gathered for a fit. 
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><code>typedef PointArray::iterator PointIterator</code></term>
                    <listitem>
                        <para>
                            Support iteration in the container that
                            defines <type>PointArray</type>.  Using iterators
                            rather than indexing allows software to be written
                            independent of the actual underlying container that
                            is <type>PointArray</type>.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect2>
        <refsect2>
            <title>Fit parameter data types.</title>
            <para>
                Fit parameters are a bit tricky.  Each fit type will have its
                own set of parameters.  Thus a fit parameter is defined not
                just by its value but by its meaning in the context of the
                fit type.
            </para>
            <para>
                <code>typedef std::pair&lt;std::string, double&gt; FitParameter</code>
                represents a single fit parameter.  The first part of the pair
                is a name that identifies the meaning of the parameter.
                The second part of the pair is the value itself.  For example,
                for a linear fit, the first item of the pair might be the string
                <literal>slope</literal> and the second part the fitted
                slope.
            </para>
            <para>
                Most fits have more than one parameter.   Therefore:
                <code>typedef std::vector&lt;FitParameter&gt; FitParameterList</code>
                is a container of fit parameters.  
            </para>
            <para>
                In order to allow the container type to change later;
                <type>FitParameterList</type> instances should not be indexed.
                Instead, use iterators defined by
                <code>typedef FitParameterList::iterator FitParameterIterator</code>.
                <type>FitParameterList</type> instances have the standard
                iterator support methods <methodname>begin</methodname>
                and <methodname>end</methodname> to support this.
            </para>
        </refsect2>
        <refsect2>
            <title>FitState</title>
            <para>
                Fit objects are stateful.  They distinguish between accepting
                points and having fit those points.  The fit state is captured
                by <type>FitState</type> which is an enumerated type
                with the following values:
            </para>
            <variablelist>
                <varlistentry>
                    <term><literal> Accepting</literal></term>
                    <listitem>
                        <para>
                            The fit is in the process of accepting points.
                            If it has sufficient points;
                            <methodname>Perform</methodname> can be invoked.
                            In this state, the fit is not able to deliver fit parameters.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>Performed</literal></term>
                    <listitem>
                        <para>
                            The fit has been performed and can deliver
                            parameters.  This is the state right after a call
                            to <methodname>Perform</methodname> and before the
                            fit is invalidated by adding more points.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect2>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>AddPoint </methodname>
                        <methodparam>
                            <type>Point </type><parameter>p</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a point to the internal list of points.  This
                        places the object in the <literal>Accepting</literal>
                        state, if it's not already in that state.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>PointIterator</type>
                        <methodname> begin</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>PointIterator </type>
                        <methodname>end</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>size_t </type>
                        <methodname>size</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        These three methods support iteration over the internal
                        <type>PointArray</type>.  Iteration is supported in the
                        same sense as for C++ container types.  At present,
                        the iterator returned is a pointer like object that
                        points to a <structname>Point</structname> struct.
                    </para>
                    <para>
                        <methodname>begin</methodname> returns an iterator that
                        'points' to the beginning of the
                        <type>PointArray</type>.  <methodname>end</methodname>
                        returns an iterator pointing just off the end of the
                        <type>PointArray</type>.  <methodname>size</methodname>
                        returns the number of points in that container.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>FitState </type>
                        <methodname>GetState </methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the current fit state.  This has been
                        previously described.  
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>CFit* </type>
                        <methodname>clone</methodname>
                        <void />
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Pure virtual method that is supposed to dynamically
                        create a copy of this object.  If the object
                        supports copy construction, this is like a virtual
                        copy constructor and can be implemented like this:
                    </para>
                    <programlisting>
CFit*
CMyFitType::clone()
{
    return new CMyFitType(*this);
}
                    </programlisting>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>void </type>
                        <methodname>Perform</methodname>
                        <void />
                        <modifier> = 0 </modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Performs the fit with the set of points that
                        have been added to the object.  An exception
                        should be thrown if there are not sufficient points to
                        determine the fit.
                    </para>
                    <para>
                        If the fit is successfully performed, this method
                        should invoke <methodname>SetFitState</methodname>
                        to set the new fit state to <literal>Performed</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type> double </type>
                        <methodname>operator() </methodname>
                        <methodparam>
                            <type>double </type><parameter>x</parameter>
                        </methodparam>
                        <modifier>=0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If the fit is not in the <literal>Performed</literal>
                        state this method should throw an exception.  If the
                        fit has been performed, this method should return the
                        value of the fit function evaluated at
                        <parameter>x</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier> virtual  </modifier>
                        <type>FitParameterList </type>
                        <methodname>GetParameters</methodname>
                        <void />
                        <modifier>=0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If the fit is not in the <literal>Performed</literal>
                        state this should throw an exception.  Otherwise it
                        should return the fit specific list of fit parameters.
                        Note that one of them should always be (regardless
                        of fit type) <literal>chisquare</literal>, the Chi Square
                        goodness of fit.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type>std::string </type>
                        <methodname>Type</methodname>
                        <void />
                        <modifier>const  = 0;</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a textual fit type.   This should be
                        a string descriptive of the fit; e.g.
                        <literal>gaussian</literal> is returned by
                        <classname>CGaussianFit</classname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>protected</modifier>
                        <type>void </type>
                        <methodname>SetFitState</methodname>
                        <methodparam>
                            <type>FitState </type><parameter>state</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Allows concrete subclasses to set the fit state.
                        In all cases, this should be used by
                        <methodname>Perform</methodname> to set the state to
                        <literal>Performed</literal> once the fit is actually
                        computed.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>Predefined CFit classes</refentrytitle>
        <manvolnum></manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CGaussianFit</refname>
        <refname>CLinearFit</refname>
        <refpurpose>3SpecTcl</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CGaussianFit.h&gt;

class CGaussianFit : public CFit
{
public:
  CGaussianFit(std::string name, int id = 0);

  virtual void Perform();
  virtual double operator()(double x);
  virtual CFit::FitParameterList GetParameters();
  virtual std::string Type() const;
  virtual std::string makeTclFitScript();
  virtual CFit* clone();

};

<beginpage />

#include &lt;CLinearFit.h&gt;

class CLinearFit  : public CFit        
{

public:
  CLinearFit ();		 //!< Constructor.

  virtual   void Perform ()   ; 
  virtual   double operator() (double x)   ; 
  virtual   CFit::FitParameterList GetParameters ()   ; 
  virtual   std::string Type() const;
  virtual CFit* clone();


};



        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            SpecTcl provides two simple fit functions.  The programming manual
            describes how to add additional fit types to the fit subsystem.
            The fit functions provided are classes that implement a Gaussian
            fit on a constant background and a linear fit.  
        </para>
        <para>
            The linear fit class is mostly provided as an example while the
            gaussian fit has some actual usefulness.
        </para>
        <para>
            The fit classes SpecTcl predefines use the GSL (GNU Scientific
            Library) to perform their fits.  It is easy enough to extend
            SpecTcl's fitting subsystem with fits performed by Root.
        </para>
    </refsect1>
    <refsect1>
        <title><classname>CGaussianFit</classname> METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CGaussianFit</methodname>
                        <methodparam>
                            <type>std::string </type><parameter>name</parameter>
                        </methodparam>
                        <methodparam>
                            <type>int </type><parameter>id </parameter>
                            <initializer> 0</initializer>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        The constructor initializes the base class
                        <classname>CNamedObject</classname> providing a name
                        and an ID.  This is not strictly speaking needed for
                        the SpecTcl fitting system, but was used in another
                        application of this class not relevant to current
                        SpecTcls.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>Perform</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Performs the fit using the available points.
                        At least 5 points must  have been accepted to support
                        performing the gaussian fit.  
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>double </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                            <type>double</type><parameter> x</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the value of the fitted function at the point
                        <parameter>x</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>CFit::FitParameterList </type>
                        <methodname>GetParameters</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the fit parameters.  The fit
                        performed is of the form:
                    </para>
                    <informalexample>
                        <literallayout>
y  = b + he<superscript>-((x-x0)/&#x03c3;)<superscript>2</superscript>/2</superscript>
                        </literallayout>
                    </informalexample>
                    <para>
                        In this equation, the parameters returned are:
                        <literal>baseline</literal> for <literal>b</literal>.
                        <literal>height</literal> for <literal>h</literal>.
                        <literal>centroid</literal> for <literal>x0</literal>.
                        <literal>sigma</literal> for <literal>&#x03c3;</literal>.
                    </para>
                    <para>
                        In addition the parameter <literal>chisquare</literal>
                        contains the chi square of the fit.
                    </para>
                    <para>
                        This method throws an exception if the fit is not in the
                        <literal>Performed</literal> state.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>std::string </type>
                        <methodname>Type</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the string <literal>gaussian</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>std::string</type>
                        <methodname> makeTclFitScript</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Throws an exception if the fit is not
                        <literal>Performed</literal>.   Returns a string that
                        defines a tcl proc named <literal>fitline</literal>.
                        The proc accepts a single double parameter and returns
                        the fit value at the point passed in.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title>CLinearFit</title>
        <para>
            Linear fit is intended just to be a sample.  It performs a fit to the
            function:
        </para>
        <informalexample>
            <literallayout>
y = mx  + b
            </literallayout>
            <para>
                Where the fit parameters are the slope, <varname>m</varname>
                and Y axis intercept; <varname>b</varname>.  The important
                methods for this class are:
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual  </modifier>
                            <type>void </type>
                            <methodname>Perform</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs the fit.   If at least two points have not
                            been accepted; an exception is thrown.  If the fit
                            has two points and they are on a vertical line,
                            an exception is thrown since the slope is not defined.
                        </para>
                        <para>
                            The Gnu Scientific Library function
                            <function>gsl_fit_linear</function> is used
                            to perform the fit.  If successful, the state of the
                            fit is set to <literal>CFit::Performed</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>double </type>
                            <methodname>operator()</methodname>
                            <methodparam>
                                <type>double </type><parameter>x</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            If the fit is not in the <literal>CFit::Performed</literal>
                            state an exception is thrown.  Otherwise, the value
                            of the fit function at <parameter>x</parameter> is
                            returned.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>CFit::FitParameterList</type>
                            <methodname> GetParameters</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            If the fit is not <literal>CFit::Performed</literal>
                            an exception is thrown.  If it has been,
                            the fit parameters are returned.  The fit parameters
                            are named <literal>slope</literal> and
                            <literal>offset</literal> with obvious meanings and
                            the fit provides the required
                            <literal>chisquare</literal> "parameter".
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual   </modifier>
                            <type>std::string </type>
                            <methodname>Type</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the text <literal>linear</literal>
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </informalexample>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CSpectrumFit</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CSpectrumFit</refname>
        <refpurpose>Fit of spectrum channels.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CSpectrumFit.h&gt;

class CSpectrumFit : public CNamedItem
{
public:
  CSpectrumFit(std::string spectrumName, int myId,
	       int low, int high, 
	       CFit&    fit);

  CFit::PointIterator begin();
  CFit::PointIterator end();
  size_t              size();
  CFit::FitState      GetState(); 
  double              operator()(double x);
  CFit::FitParameterList getParameters();
  std::string         fitType();
  std::string         makeTclFitScript();
  std::string         fitName();
  CSpectrumFit*       clone();	// Clone self.
  void                update();
  int                 low() const;
  int                 high() const;
  
};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Joins together a spectrum and a fit performed over some region of
            interest.  The fit is performed when an object is constructed
            and when requested via its <methodname>update</methodname> method.
            This fit should always be in the <literal>CFit::Performed</literal>
            state.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            Note that several of these methods delegate to the underlying
            fit object.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CSpectrumFit(</methodname>
                        <methodparam>
                            <type>std::string </type><parameter>spectrumName</parameter>
                        </methodparam>
                        <methodparam>
                            <type>int </type><parameter>myId</parameter>
                        </methodparam>
                        <methodparam>
                            <type>int </type><parameter>low</parameter>
                        </methodparam>
                        <methodparam>
                            <type>int </type><parameter>high</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CFit&    </type><parameter>fit</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        <parameter>spectrumName</parameter> is the name of
                        a spectrum in the SpecTcl spectrum dictionary.
                        An exception is thrown if the name is not valid.
                        The name is also used to provide a name for the Spectrum
                        Fit object (see, however <classname>CFitDictionary</classname>).
                    </para>
                    <para>
                        <parameter>myId</parameter> is the id used to construct
                        the base class named item.
                    </para>
                    <para>
                        <parameter>low</parameter> and <parameter>high</parameter>
                        specify a region of interest (ROI), in channels, in the spectrum.  If either
                        limit is outside of the spectrum channel limits an exception
                        is thrown.  If there are not sufficient channels in the ROI,
                        an exception will be thrown.
                    </para>
                    <para>
                        <parameter>fit</parameter> is a fit object in the
                        <literal>CFit::Accepting</literal> state.  On
                        construction, among other things, the spectrum channels
                        in the ROI are entered as points into this fit and the
                        and the fit is performed.  The fit must stay in scope
                        for the duration of the lifetime of this object.
                        The fit's destruction is, however the responsibility
                        of client code.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CFit::PointIterator </type>
                        <methodname>begin</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CFit::PointIterator </type>
                        <methodname>end</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>size_t  </type>
                        <methodname>size</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        These methods delegate to the underlying fit object's
                        methods of the same name.  They support iteration through
                        the fit points.  The X coordinate of each point is a
                        channel number.  The Y coordinate is the counts in that
                        channel as of the last time a fit was performed.
                    </para>
                    <para>
                        Fits are performed at construction time and when the
                        <methodname>update</methodname> method is invoked.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>  CFit::FitState      </type>
                        <methodname>GetState</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the underlying fit's state. This should
                        always be <literal>CFit::Performed</literal>.  If it is
                        not, some external actor must be playing with the
                        encapsulated fit.  Something that should not be done.
                    </para>
                    <para>
                        This method delegates to the underlying fit.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>double              </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                            <type>double </type><parameter>x</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Delegates to the underlying fit's <methodname>operator()</methodname>
                        which evaluates the fitted function at <parameter>x</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier> </modifier>
                        <type>CFit::FitParameterListx</type>
                        <methodname>CFit::FitParameterList</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Delegates to <classname>CFit::</classname><methodname>FitParameterList</methodname>.
                        Returns the fit parameters from the current fit.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>std::string         </type>
                        <methodname>fitType</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        in the underlying fit.
                        Delegates to <classname>CFit::</classname><methodname>Type</methodname>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>std::string</type>
                        <methodname>makeTclFitScript</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Delegates to the underlying fit's
                        <methodname>makeTclFitScript</methodname> method
                        to get a proc that can be used by scripts to operate on
                        the fit.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>std::string         </type>
                        <methodname>fitName</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Name of the underlying fit.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CSpectrumFit*</type>
                        <methodname>clone</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a dynamically allocated clone of this object.
                        Note that the fit is cloned as well.  Objects with cloned
                        fits will destroy the fit when they themselves are
                        destroyed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void                </type>
                        <methodname>update</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Fetches the new points from the fit's ROI and performs
                        the fit using them.
                    </para>
                </listitem>
 
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>int                 </type>
                        <methodname>low</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>int                 </type>
                        <methodname>high</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Return the limits of the ROI over hich the fit
                        is computed.
                    </para>
                </listitem>
            </varlistentry>    
        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CFitFactory</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CFitFactory</refname>
        <refname>CFitCreator</refname>
        <refname>CGaussianFitCreator</refname>
        <refname>CLinearFitCreator</refname>
        <refpurpose>Creating fit objects by name</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CFitFactory.h&gt;

class CFitFactory 
{
  // Public data types:
public:
  typedef std::map&lt;std::string, CFitCreator*&gt; FitCreatorMap;
  typedef FitCreatorMap::iterator  FitCreatorIterator;

  typedef std::map&lt;std::string, CFit*&gt;        FitMap;
  typedef FitMap::iterator          FitIterator;

public:


  static void AddFitType (const std::string&amp; rType, CFitCreator* pCreator)   ; 
  static CFit* Create (std::string sFitType, std::string sFitName)   ; 
  static bool Delete (std::string sName)   ; 
  static bool Perform (std::string sName)   ; 
  static bool AddPoints (std::string sName,
			 std::vector&lt;FPoint&gt; vPoints)   ; 
  static double Evaluate (std::string sName, double x)   ; 
  static FitCreatorIterator beginCreators();
  static FitCreatorIterator endCreators();
  static int    sizeCreators();
  static FitCreatorIterator FindFitCreator (std::string sType)   ; 
  static int size ()   ; 
  static FitIterator begin ()   ; 
  static FitIterator end ()   ; 
  static FitIterator FindFit (std::string sName) ; 


};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The <classname>CFitFactory</classname> is both a factory for
            fits and a registry/dictionary
            of the fits it creates.  Note that this is
            an extensible factory.  Extensible factories are not standalone
            entities.  They rely on objects called <firstterm>Creators</firstterm>
            to recognize specific type specifiers and to create the specific
            type on behalf of the factory.
        </para>
        <para>
            Associated with the fit factory is a class hierarhcy of
            <classname>CFitCreator</classname>s.  This hierarchy exactly
            mirrors the <classname>CFit</classname> class hierarchy.  Concrete
            classes of the <classname>CFitCreator</classname> are instantiated
            and registered with the factory to create the corresponding fits.
        </para>
        <para>
            The remainder of this man page will describe the data types
            introduced by this class, the methods this class exports and
            the fit creator hierarchy and pre-defined concrete
            creator classes.
        </para>
        <para>
            Note that all methods of this class are static.  It's therefore
            not necessary to create an instance of this class.  Furthermore,
            this implies that the factory containers are application wide.
        </para>
    </refsect1>
    <refsect1>
        <title>Data types</title>
        <para>
            The class defines several nested data types.  These
            define a keyed container and iterator for the creators,
            and a keyed container and iterator for the fits themselves.
            Note that iterators 'point' to an
            <type>std::pair&lt;std::string, T*&gt;</type>  where
            <classname>T</classname> represents the type of itemin the
            container (e.g. a <classname>CFitCreator</classname>
            or <classname>CFit</classname>).
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <literal>
typedef std::map&lt;std::string, CFitCreator*&gt; FitCreatorMap;
                    </literal>
                </term>
                <listitem>
                    <para>
                        <classname>CFitFactory</classname>::<type>FitCreatorMap</type>
                        is the keyed container that holds fit creators.  Fit creators,
                        recall are objects that will create a fit that corresponds
                        to the key at which they live in the container.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <literal>
 typedef FitCreatorMap::iterator  FitCreatorIterator;                       
                    </literal>
                </term>
                <listitem>
                    <para>
                        Iterator into the <type>FitCreator</type> container.
                        See <literal>DESCRIPTION</literal> for information
                        about this.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <literal>
typedef std::map&lt;std::string, CFit*&gt;        FitMap
                    </literal>
                </term>
                <listitem>
                    <para>
                        <classname>CFitFactory</classname>::<type>FitMap</type>
                        defines the container for the fits themselves.  This is
                        a container that is indexed by a string that names
                        the fit.  This name need not be the same as the name of the
                        fit itself.  See, e.g. <methodname>Create</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <literal>
typedef FitMap::iterator          FitIterator;
                    </literal>
                </term>
                <listitem>
                    <para>
                        Iterator into the fit container
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            All methods are class level (static) methods.  They do not require an
            object to invoke e.g.
            <code>FitFactory::sizeCreators()</code> returns the number of fit
            creators registered.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>void</type>
                        <methodname> AddFitType </methodname>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>std::string&amp; </type><parameter>rType</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CFitCreator* </type><parameter>pCreator</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Registers a new fit type with the factory.
                        <parameter>rType</parameter> will be the name of the
                        fit type.  This value, when passed to
                        <methodname>Create</methodname> will cause the
                        creator passed in as <parameter>pCreator</parameter>
                        to be asked to produce a fit object.
                    </para>
                    <para>
                        If a fit of the same type as
                        <parameter>rType</parameter> has already been
                        registered, an exception is thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>CFit* </type>
                        <methodname>Create </methodname>
                        <methodparam>
                            <type>std::string </type><parameter>sFitType</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::string </type><parameter>sFitName</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Asks the factory to crate a new fit of the type
                        <parameter>sFitType</parameter> and to give it the name
                        <parameter>sFitName</parameter>.  The resulting fit
                        is returned.  The resulting fit is also registered
                        with the factory.
                    </para>
                    <para>
                        If a fit of the name <parameter>sFitName</parameter>
                        already exists, an exception is thrown.  If not
                        creator matches the fit type; <parameter>sFitType</parameter>,
                        a null pointer is returned.
                    </para>
                    <para>
                        The fit is dynamically created by <literal>new</literal>,
                        however you should not directly <literal>delete</literal>
                        it.  See the <methodname>Delete</methodname> method
                        below.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>bool </type>
                        <methodname>Delete </methodname>
                        <methodparam>
                            <type>std::string </type><parameter>sName</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Deletes the fit named <parameter>sName</parameter> from
                        the fit dictionary.   If the fit existed (and had to be
                        deleted) <literal>true</literal> is returned.  If the
                        fit did not exist <literal>false</literal> is
                        returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>bool </type>
                        <methodname>Perform</methodname>
                        <methodparam>
                            <type>std::string </type><parameter>sName</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Requests that the fit named
                        <parameter>sName</parameter> be performed with the
                        current set of points,  This locates the fit in the
                        fit dictionary and just delegates to that fit's
                        <methodname>Perform</methodname> method.
                    </para>
                    <para>
                        If the fit exists, and canbe performed successfully,
                        <literal>true</literal> is returned.  If the
                        fit does not exist or exists but fails,
                        <literal>false</literal> is returned instead.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>bool </type>
                        <methodname>AddPoints</methodname>
                        <methodparam>
                            <type>std::string </type><parameter>sName</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;FPoint&gt; </type><parameter>vPoints</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a vector of points to the fit.  See
                        <filename>Point.h</filename> for the definition of a
                        <type>FPoint</type> object.  This call puts the underlying
                        fit in the <literal>CFit::Accepting</literal> state.
                    </para>
                    <para>
                        If the fit named by <parameter>sName</parameter> was
                        found the the points in
                        <parameter>vPoints </parameter>are added via successive callse to
                        the underlying fit's <methodname>AddPoint</methodname>
                        method and
                         <literal>true</literal> is returned.  If the
                         fit is not found; <literal>false</literal> is returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>double </type>
                        <methodname>Evaluate</methodname>
                        <methodparam>
                            <type>std::string </type><parameter>sName</parameter>
                        </methodparam>
                        <methodparam>
                            <type> double </type><parameter>x</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Evaluates the fit <parameter>sName</parameter> at
                        the X coordinate <parameter>x</parameter>.  The
                        value of the fit function at that point is returned.
                        Note that the fit must be in the
                        <literal>CFit::Performed</literal> state.
                    </para>
                    <para>
                        An exception is thrown if the fit does not exist.
                        If the fit is not in the
                        <literal>CFit::Performed</literal> state, an exception
                        is thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>FitCreatorIterator </type>
                        <methodname>beginCreators</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>FitCreatorIterator </type>
                        <methodname>endCreators</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        These methods support iteration of the container of
                        fit creators.  They both return pointer like objects that
                        point to an <classname>std::pair&lt;std::string, CFitCreator*&gt;</classname>.
                    </para>
                    <para>
                        <methodname>beginCreators</methodname> returns an iterator
                        to the "first" item of the container.  Successive increments
                        will step the  iterator through all items until
                        the increment results in a iterator that is equal to that
                        returned by <methodname>endCreators</methodname> which
                        points just past the end of the container.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>int    </type>
                        <methodname>sizeCreators</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of fit creators that have been
                        registered with the factory.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>FitCreatorIterator </type>
                        <methodname>FindFitCreator </methodname>
                        <methodparam>
                            <type>std::string </type><parameter>sType</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an iterator to the container item that has
                        the fit for the fit type <parameter>sType</parameter>.
                        If there is no matching fit creator, an iterator equal
                        to that returned by
                        <methodname>endCreators</methodname> is returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>FitIterator</type>
                        <methodname> begin </methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>FitIterator</type>
                        <methodname> end </methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Supports iteration over the container that is the
                        dictionary of fits.  These methods return
                        iterators that are pointer like objects.  Each
                        iterator points to an object of the type:
                        <classname>std::pair&lt;std::string, CFit*&gt;</classname>.
                    </para>
                    <para>
                        <methodname>begin</methodname> points to the first object
                        in the container.  Incrementing it will step sequentially
                        through the items in the container.  When all items
                        have been visited, the increment will result in an
                        iterator equal to that returned by <methodname>end</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>int </type>
                        <methodname>size</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of fits in the fit dictionary.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>FitIterator </type>
                        <methodname>FindFit </methodname>
                        <methodparam>
                            <type>std::string </type><parameter>sName</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an iterator that points to the object in the
                        fit dictionary that matches the name <parameter>sName</parameter>.
                        If there is no matching fit, an object equal to that
                        returned by <methodname>end</methodname> is returned.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title>Fit Creators</title>
        <para>
            This section describes the abstract base class the defines
            the fit creator interface.  SpecTcl defines two concrete fit
            creator classes.  The first of these; <classname>CGaussianFitCreator</classname>
            creates <classname>CGaussianFit</classname> objects.  The second;
            <classname>CLinearFitCreator</classname>  creates <classname>CLinearFit</classname>
            objects
        </para>
        <synopsis>
#include &lt;CFitCreator.h&gt;
#include &lt;CGaussianFitCreator.h&gt;
#include &lt;CLinearFitCreator.h&gt;

class CFitCreator      
{

public:
  CFitCreator ();
  
  virtual   CFit* operator() ()   = 0; 
  virtual   std::string DescribeFit()  = 0;
};
        </synopsis>
        <para>
            The methods that must be implemented by concrete classes are:
        </para>
            
        <variablelist>
            <varlistentry>
                <term><methodsynopsis>
                    <modifier>virtual   </modifier>
                    <type>CFit* </type>
                    <methodname>operator() </methodname>
                    <void />
                    <modifier>= 0</modifier>
                </methodsynopsis></term>
                <listitem>
                    <para>
                        Must create the fit of the appropriate type and return it.
                        The fit should be dynamically created.  It will be
                        the client's responsibility to destroy it.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodsynopsis>
                    <modifier>virtual   </modifier>
                    <type>std::string </type>
                    <methodname>DescribeFit</methodname>
                    <void />
                    <modifier>= 0</modifier>
                </methodsynopsis></term>
                <listitem>
                    <para>
                        Returns some brief text to describe the type of fit object
                        produced by the creator.  SpecTcl's
                        <command>fit</command> command iterates through the
                        fit creators and uses these texts when constructing
                        the command help.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CFitDictionary</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CFitDictionary</refname>
        <refpurpose>Fitting subsystem dictionary.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CFitDictionary.h&gt;

class CFitDictionary {

public:
  typedef std::map&lt;std::string, CSpectrumFit*&gt; FitMap;
  typedef FitMap::iterator      iterator;

  class CObserver {
  public:
    virtual void Add(CSpectrumFit&amp; fit) =0;
    virtual void Delete(CSpectrumFit&amp; fit) = 0;
    virtual void Update(CSpectrumFit&amp; fit) = 0;

  };

public:
  static CFitDictionary&amp; getInstance();
  void add(CSpectrumFit&amp; fit);
  void addOrReplace(CSpectrumFit&amp; fit);
  void Delete(std::string name);

  iterator begin();
  iterator end();
  size_t   size();
  iterator find(std::string name);
  void     erase(iterator here);
  void     erase(iterator first, iterator last);

  void updateFits(std::string name=std::string(&quot;*&quot;)); 

  void addObserver(CObserver&amp; obs);
  void removeObserver(CObserver&amp; obs);

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The <classname>CFitDictionary</classname> defines a singleton
            class.  The provides a dictionary of fits derived from
            <classname>CSpectrumFit</classname> and is the dictionary SpecTcl
            uses to store its fits.  In addition to supporting addition
            and removal operations, the iterator, oberver and search operations
            are supported.  It is also possible to request the dictionary
            update fits that match some pattern.
        </para>
        <para>
            Note that the SpecTcl <classname>CHistogrammer</classname> class
            establishes an observer so that it can ensure that Xamine
            can display any fits that have been defined on displayed spectra.
            Note that the Spectra displayer does not yet support the display
            of fit lines.
        </para>
    </refsect1>
    <refsect1>
        <title>
            METHODS
        </title>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>CFitDictionary&amp; </type>
                        <methodname>getInstance</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Gets a  pointer to the singleton instance of the
                        fit dictionary.  This singleton uses lazy creation in
                        that the first invocation of <methodname>getInstance</methodname>
                        is what actually creates the fit dictionary singleton
                        instance.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type> void </type>
                        <methodname>add</methodname>
                        <methodparam>
                            <type>CSpectrumFit&amp; </type><parameter>fit</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a new fit to the dictionary.  The fit must live for
                        the life of its existence in the dictionary as it's not
                        cloned.  The name of the fit is taken from the fit itself.
                    </para>
                    <para>
                        If a fit by this name already exists, an exception is
                        thrown.  If the fit is successfully added, all observers
                        are informed of this via their <methodname>Add</methodname>
                        method.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>addOrReplace</methodname>
                        <methodparam>
                            <type>CSpectrumFit&amp; </type><parameter>fit</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds the fit <parameter>fit</parameter> to the fit dictionary.
                        The name assigned to the fit comes from the fit itself.
                        If the fit already exists, the previous fit is replaced
                        in the dictionary wih <parameter>fit</parameter>.
                    </para>
                    <para>
                        This is treated as an addition and therefore the
                        observers are notified via their <methodname>Add</methodname>
                        methods.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>Delete</methodname>
                        <methodparam>
                            <type>std::string </type><parameter>name</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes the fit named <parameter>name</parameter> from
                        the dictinoary  It's still up to the clients of the
                        dictionary to manage the storage for this fit.
                        If fits are dynamically allocated, removal/deletion should
                        take the form of using <methodname>find</methodname>
                        to get a pointer to the fit, deleting the fit from
                        the dictionary (either with <methodname>erase</methodname>
                        or <methodname>Delete</methodname>), and then
                        using <code>delete</code> to delete the actual fit
                        object.
                    </para>
                    <para>
                        If there is no fit named <parameter>name</parameter> in
                        the dictionary, 
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>iterator </type>
                        <methodname>begin</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>iterator </type>
                        <methodname>end</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>size_t</type>
                        <methodname>size</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        These methods implement an interation interface
                        for the fits.  The iterators return pointer like
                        objects to objects of the type:
                        <classname>std::pair&lt;std:;string, CSpectrumFit&gt;</classname>
                    </para>
                    <para>
                        <methodname>begin</methodname> returns an interator that
                        points to the first item in the fit dictionary container.
                        Incrementing this object steps sequentially through the
                        container until the object is equal to the value
                        returned by <methodname>end</methodname>.  At that point
                        the iteration over the container is complete.
                    </para>
                    <para>
                        <methodname>size</methodname> returns the number of
                        objects in the container.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>iterator </type>
                        <methodname>find</methodname>
                        <methodparam>
                            <type>std::string </type><parameter>name</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an iterator to the item in the gate dictionary
                        container that has a name; <parameter>name</parameter>.
                        If there is no matching item in the gate dictionary
                        container, an iterator that is equal to the one
                        returned by <methodname>end</methodname> is returned.
                        See <methodname>begin</methodname> above for a description
                        of the iterator object.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void     </type>
                        <methodname>erase</methodname>
                        <methodparam>
                            <type>iterator </type><parameter>here</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Given an iterator into the gate container dictionary,
                        removes that entry from the dictionary.  Note that the
                        gate is not deleted.  If the gate was dynamically created
                        the client must delete it.   Suppose we want to delete
                        the gate named <literal>deleteme</literal> and free
                        its storage.  This can be done as follows:
                    </para>
                    <informalexample>
                        <programlisting>
CFitDictionary* pDict = CFitDictionary::getInstance();
CFitDictionary::iterator p = pDict->find("deleteme");
if (p != pDict->end()) {
    CSpectrumFit* pFit = p->second;
    pDict->erase(p);
    delete pFit;
} else {
   // Action to take when the fit does not exist.
}
                        </programlisting>
                    </informalexample>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>updateFits</methodname>
                        <methodparam>
                            <type>std::string </type><parameter>name</parameter>
                            <initializer>std::string(&quot;*&quot;)</initializer>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Updates the fits that have names matching the
                        glob pattern <parameter>name</parameter>.  Note that this
                        defaults to <literal>*</literal> which matches all fits.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>addObserver</methodname>
                        <methodparam>
                            <type>CObserver&amp; </type><parameter>obs</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds an observer to the dictionary.  The observer object
                        methods will be invoked as a result of specific actions
                        performed by the dictionary.  See
                        <literal>Nested Types and Classes</literal> for
                        a description of observers and their  methods.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>removeObserver</methodname>
                        <methodparam>
                            <type>CObserver&amp; </type><parameter>obs</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes the observer <parameter>obs</parameter> from the
                        dictionary.  Once done, <parameter>obs</parameter> will
                        no longer receive method calls from the dictionary.
                        Removing the observer does not destroy it.  That is the
                        responsibility of the dictionary client software.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title>Nested Types and Classes</title>
        <para>
            <classname>CFitDictionary</classname> defines two types and a
            an abstract base class. The types are used to support dictionary
            iterastion and the class to support the observer pattern.
        </para>
        <para>
            <classname>CSpectrumDictionary::FitMap</classname> is the type of
            the container used to store the fit dictionary. While this is
            currently an <classname>std::map</classname>, the only thing you should
            assume is that this object is an associative container of
            <classname>CSpectrumFit*</classname> with keys that are
            <classname>std::string</classname> objects.   The keys are the
            name of the fit.
        </para>
        <para>
            <classname>CSpectrumDictionary::iterator</classname> is an interator
            into the fit container.  As with all iterators for STL associative
            containers it is a pointer-like object.  Dereferencing a
            <classname>::CSpectrumDictionary::iterator</classname> provides
            a reference to a <classname>std::pair&lt;std::string, CSpectrumFit*&gt;</classname>.
            This is also consistent with STL iterators into associative containers.
        </para>
        <para>
            Incrementing an instance of <classname>CSpectrumDictionary::iterator</classname>
            produces a pointer-like object that points to the "next" item in the
            dictionary.  The special iterator value returned by
            <methodname>end</methodname> can be thought of as pointing just
            off the end of the container.  <methodname>begin</methodname>
            can be thought of pointing at the first item in the container.
        </para>
        <para>
            Therefore typical dictionary iteration follows the pattern below:
        </para>
        
        <informalexample>
            <programlisting>
CFitDictionary* pDict = CFitDictionary::getInstance();
for (auto p = pDict->begin(); p != pDict->end(); p++) {
    std::string fitname = p->first;
    CSpectrumfit* pFit  = p->second;
    
    doSomethingWithTheFitAndOrName(fitname, pFit);
}
            </programlisting>

        </informalexample>
        <para>
            Note that this sort of iteration is also perfectly compatible
            with standard library generic algorithms like
            <function>std::for_each</function>.
        </para>
        <para>
            The <classname>CFitDictionary</classname> supports the observer pattern.
            The observer pattern (see <ulink url='https://en.wikipedia.org/wiki/Observer_pattern' />)
            provides a mechanism that allows other objects to be informed
            when important state changes occur in <classname>CFitDictionary</classname>.
            Observers are objects in an ordered list that are derived from the
            abstract base class <classname>CFitDictionary::CObserver</classname>.
            This abstract base class provides a set of method definitions that
            define the set of events that will be observed.
        </para>
        <para>
            The definition of the class is shown below (note this is defined
            within the definition of <classname>CFitDictionary</classname>):
        </para>
        <informalexample>
            <programlisting>
class CObserver {
public:
  virtual void Add(CSpectrumFit&amp; fit) =0;
  virtual void Delete(CSpectrumFit&amp; fit) = 0;
  virtual void Update(CSpectrumFit&amp; fit) = 0;

};            
                
            </programlisting>
        </informalexample>
        <para>
            You can observe the <classname>CFitDictionary</classname> by
        </para>
        <orderedlist>
            <listitem>
                <para>
                    Deriving a class from <classname>CFitDictionary::CObserver</classname>
                </para>
            </listitem>
            <listitem>
                <para>
                    Creating an instance of that class that lives for as long
                    as you want the observation to continue.
                </para>
            </listitem>
            <listitem>
                <para>
                    Using <methodname>addObserver</methodname> to add that object
                    to the ordered list of observers.
                </para>
            </listitem>
            <listitem>
                <para>
                    If the observer is ever no longer needed, use
                    <methodname>removeObserver</methodname> to remove it
                    after which, if appropriate you should ensure
                    the observer's destruction.
                </para>
            </listitem>
        </orderedlist>
        <para>
            The methods you must implement in your observer are:
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void</type>
                        <methodname> Add</methodname>
                        <methodparam>
                            <type>CSpectrumFit&amp; </type><parameter>fit</parameter>
                        </methodparam>
                        <modifier>=0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is invoked when a fit as been successfully added
                        to the dictionary.  <parameter>fit</parameter> is a
                        referenceto the fit just added.  Note that since
                        <parameter>fit</parameter> is a <classname>NamedObject</classname>;
                        <methodname>getName</methodname> can be used to get
                        the fit's name if needed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>Delete</methodname>
                        <methodparam>
                            <type>CSpectrumFit&amp; </type><parameter>fit</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is called when
                        <parameter>fit</parameter> is about to be erased
                        from the fit dictionary.  When called, the fit is still
                        in the dictionary.   Once all observers are run,
                        the fit is erased from the dictionary.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>Update</methodname>
                        <methodparam>
                            <type>CSpectrumFit&amp; </type><parameter>fit</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is invoked when <parameter>fit</parameter>
                        has been updated.  By update we mean that
                        <parameter>fit</parameter> has been recomputed in light
                        of the current spectrum data.  The observer is invoked
                        <emphasis>after</emphasis> the update.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>

</refentry>
       
<refentry>
    <refmeta>
        <refentrytitle>CEventSink</refentrytitle>
        <manvolnum>3Spectcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CEventSink</refname>
        <refpurpose>Base class for event sink pipeline elements</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <synopsis>
#include &lt;EventSink.h&gt;

class CEventSink {
 public:
  CEventSink();
  virtual ~CEventSink();
  CEventSink(const CEventSink&amp; aCEventSink);
  CEventSink&amp; operator=(const CEventSink& aCEventSink);
  int operator==(const CEventSink&amp; aCEventSink);
  virtual void OnAttach(CAnalyzer&amp; rAnalyzer);
  virtual void OnDetach(CAnalyzer&amp; rAnalyzer);

  virtual void operator()(CEventList&amp; rEvents) = 0;
};
</synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            SpecTcl's event sink pipeline is passed events once the event
            processing pipeline has created and filled in the
            <classname>CEvent</classname> for the raw event.  It consists
            of instances of classes derived fromt he abstract base class
            <classname>CEventSink</classname>.  
        </para>
        <para>
            The most interesting element of the pipeline for most SpecTcl users
            is the <classname>CHistogrammer</classname> instance.  That
            object does the heavy lifting of determining which channels of
            which spectra should be incremented for each
            <classname>CEvent</classname> instance.  Other event sink pipeline
            elements can be created and added dynamically.  Of special interest
            are event filters which write out subsets of decoded events that
            satisfy some gate in a specific format.
        </para>
        <para>
            Similarly the 5.0 root integration classes allow Root trees
            to be produced by objects derived from <classname>CEventSink</classname>.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>

                        <type>void </type>
                        <methodname>OnAttach</methodname>
                        <methodparam>
                            <type>CAnalyzer&amp; </type><parameter>rAnalyzer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>

                        This method has a empty implementation making its
                        for derived classes.   It is invoked when an instance
                        is added to the event sink pipeline.  The
                        <parameter>rAnalyzer</parameter> parameter refers to the
                        SpecTcl analyzer.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>

                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnDetach</methodname>
                        <methodparam>
                            <type>CAnalyzer&amp; </type><parameter>rAnalyzer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>

                        This method has an empty base class implementation.
                        Therefore its implementation in derived classes is
                        optional.  It is invoked whenever an instance
                        is removed from the event sink pipeline.
                        <parameter>rAnalyzer</parameter> refers to the
                        analyzer in operating at the time of the
                        removal.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>

                        <type>void </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                            <type>CEventList&amp; </type><parameter>rEvents</parameter>
                        </methodparam>
                        <modifier>=0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This pure virtual method must be implemented
                        by concrete event sink classes.  It is invoked whenever
                        the event processing pipeline delivers a list of
                        events to the event sink pipeline.  Note that
                        lists of events are delivered in order to promote
                        referential locality in SpecTcl (hopefully improving
                        cache hit rates).
                    </para>
                    <para>
                        <parameter>rEvents</parameter> is the event list
                        the sink should process.  
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>

</refentry>

<refentry>
    <refmeta>
        <refentrytitle>CEventFilter</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CEventFilter</refname>
        <refpurpose>Abstract base class for event filters.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
class CEventFilter : public CEventSink {
protected:
   Bool_t m_fEnabled;                           
   std::string              m_sFileName;        
   std::vector&lt;std::string&gt; m_vParameterNames; 
   std::vector&lt;UInt_t&gt;      m_vParameterIds;   
   CFilterOutputStage*      m_pOutput;         
 public:
  CEventFilter(std::string&amp; rFileName);
  std::vector&lt;std::string&gt; getParameterNames() const;
  std::vector&lt;UInt_t&gt; getParameterIds() const;
  Bool_t CheckEnabled() const;
  std::string getFileName() const;
  CFilterOutputStage* getOutputStream();

  void setParameterNames(const std::vector&lt;std::string&gt;&amp; names);
  void setOutputStream(CFilterOutputStage* str);
  
  void Enable();
  void Disable();
  void setFileName(std::string&amp;);
  void setOutputFormat(CFilterOutputStage* format);
  std::string outputFormat() const;
  virtual void operator()(CEventList&amp; rEvents);
  virtual void operator()(CEvent&amp; rEvent);      

protected:
   virtual Bool_t CheckCondition(CEvent&amp; rEvent) = 0;
   static std::string DefaultFilterFilename();   
   void NamesToIds();                       
   std::vector&lt;std::string&gt; IdsToNames() 

};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Filters are objects that, since they are derived from
            <classname>CEventSink</classname>, can be added to the
            event sink pipeline.  Filters are expected to operate on
            decoded events.  They have:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    A file to which output data are written
                </para>
            </listitem>
            <listitem>
                <para>
                    A list of parameters that will be output.
                </para>
            </listitem>
            <listitem>
                <para>
                    A condition that determines which events are written
                </para>
            </listitem>
            <listitem>
                <para>
                    A formatting object that determines how the events
                    are written to the output file.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            Thus filters create subsets of the raw input data. The output
            of filters both subset the events (writing only those events that
            satisfy their condition), and the parameters (writing only the
            specified parameters).
        </para>
        <para>
            Filters can speed up subsequent event processing both by reducing
            the volume of data produced and by writing data in a format much
            easier to decode than the original raw event data.  People using
            filters have reported over an order of magnitude improvement in
            the processing of e.g. XDR formatted filtered data over raw data,
            even when no selection has been performed.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term><constructorsynopsis>
                    <methodname>CEventFilter</methodname>
                    <methodparam>
                        <type>std::string&amp; </type><parameter>rFileName</parameter>
                    </methodparam>
                </constructorsynopsis></term>
                <listitem>
                    <para>
                        Constructor.  <parameter>rFilename</parameter> references
                        the name of the file that filtered data will be written
                        into.  The file is not opened by the constructor.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
  );
  std::vector&lt;std::string&gt; getParameterNames() const;
  std::vector&lt;UInt_t&gt; getParameterIds() const;
  Bool_t CheckEnabled() const;
  std::string getFileName() const;
  CFilterOutputStage* getOutputStream();

  void setParameterNames(const std::vector&lt;std::string&gt;&amp; names);
  void setOutputStream(CFilterOutputStage* str);
  
  void Enable();
  void Disable();
  void setFileName(std::string&amp;);
  void setOutputFormat(CFilterOutputStage* format);
  std::string outputFormat() const;
  virtual void operator()(CEventList&amp; rEvents);
  virtual void operator()(CEvent&amp; rEvent);      

protected:
   virtual Bool_t CheckCondition(CEvent&amp; rEvent) = 0;
   static std::string DefaultFilterFilename();   
   void NamesToIds();                       
   std::vector&lt;std::string&gt; IdsToNames() 
            </para>
    </refsect1>
    <refsect1>
        <title>Data Available to subclasses</title>
        <para>
   Bool_t m_fEnabled;                           
   std::string              m_sFileName;        
   std::vector&lt;std::string&gt; m_vParameterNames; 
   std::vector&lt;UInt_t&gt;      m_vParameterIds;   
   CFilterOutputStage*      m_pOutput;         
        </para>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>Root tree building</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>Root tree building</refname>
        <refpurpose>Classes to build root trees.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;TreeBuilder.h&gt;

class TreeItemBaseClass {
public:
    TreeItemBaseClass(const char* name);
    std::string getName() const;
    virtual bool isFolder() const = 0;     // True if item is a container.
};

class TreeFolder : public TreeItemBaseClass
{
public:
    TreeFolder(const char* name);
    void addItem(TreeItemBaseClass* pItem);
    const Contents&amp; getContents()    const;
    Contents::const_iterator begin() const;
    Contents::const_iterator end()   const;
    size_t size()                    const;
    void freeStorage(bool yesno);
    virtual bool isFolder() const ;

};

class TreeTerminal : public TreeItemBaseClass
{
public:
    TreeTerminal(const char* name, unsigned parameterId);    
    unsigned id() const;
    virtual bool isFolder() const;
    
};

class ParameterTree : public TreeFolder
{
public:
    typedef struct _ParameterDef {
        std::string s_name;
        unsigned    s_id;
        _ParameterDef(const char* name, unsigned id) :
            s_name(name), s_id(id) {}
            
    } ParameterDef, *pParameterDef;
    ParameterTree();
    ParameterTree(const std::vector&lt;ParameterDef&gt;&amp; params);
    
    void buildTree(const std::vector&lt;ParameterDef&gt;&amp; params);
    void clearTree();
};


class ParameterMarshaller
{
public:
    ParameterMarshaller(std::size_t numParameters);    
    void marshall(CEvent&amp; event);
    void reset(CEvent&amp; event);
    Double_t* pointer();
    unsigned* mapping();
};

class SpecTclRootTree
{
public:
    SpecTclRootTree(
        std::string treeName,
        const std::vector&lt;ParameterTree::ParameterDef&gt;&amp; params
    );
    void Fill(CEvent&amp; event);
};


        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This set of classes provides support for turning the SpecTcl
            parameter space into a true hierarchy. This hierarchy can then
            be mapped onto the branches and leaves of a CERN Root tree.
        </para>
        <para>
            Subsequent sections of this document will describe each class and its
            methods.  To orient, however, there are two main sets of
            classes defined in this header.
        </para>
        <para>
            The first set capture the
            parameter hierarchy as a top level folder with contents that
            can consist recursively of folders and terminal nodes.
            Each terminal node is a parameter.
        </para>
        <para>
            The second set of classes provide support for building a
            ROOT Tree from the folders and terminals of the first set of
            classes and for marshalling parameters from a SpecTcl
            <classname>CEvent</classname> object into the flattened array
            expected by Root.  Note that while Root Trees are dense, SpecTcl
            <classname>CEvent</classname> objects, in general are
            sparse.  Unset slots in a <classname>CEvent</classname> object
            result in corresponding leaves that have the value
            <literal>NaN</literal>.  The standard C function
            <function>isnan</function> (C++ <methodname>std::isnana</methodname>),
            can determine if a leaf value is a NaN for a specific event.
        </para>
    </refsect1>
    <refsect1>
        <title>TreeItemBaseClass</title>
        <para>
            The <classname>TreeItemBaseClass</classname> is the root of the
            folder/terminal class hierarhcy.  It supplies a generic object
            that can appear in a parameter tree and services that must
            be provided by all such object.
        </para>
        <para>
            <classname>TreeItemBaseClass</classname> is an abstract base class.
        </para>
        <refsect2>
            <title>METHODS</title>
            <variablelist>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>TreeItemBaseClass</methodname>
                            <methodparam>
                                <modifier>const </modifier>
                                <type>char* </type><parameter>name</parameter>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Base class constructor.  All items in the parameter
                            tree have names.  The name is either the terminal name
                            of the parameter or it is the name of a folder
                            containing other <classname>CTreeItemBaseClass</classname>
                            objects.
                        </para>
                        <para>
                            The base class holds the object name for all derived
                            classes.  The constructor parameter <parameter>name</parameter>
                            is given to the object.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>std::string </type>
                            <methodname>getName</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the name of the objecst.  This is the
                            value of the <parameter>name</parameter>
                            parameter passed to the constructor.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual </modifier>
                            <type>bool </type>
                            <methodname>isFolder</methodname>
                            <void />
                            <modifier>const = 0</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Objects in the tree are either containers of
                            other objects (folders) or they are terminals
                            (parameters).  Concrete classes must implement this
                            method to return <literal>true</literal> if they
                            contain other items or <literal>false</literal>
                            if not.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect2>
    </refsect1>
    <refsect1>
        <title>TreeFolder</title>
        <para>
            The <classname>TreeFolder</classname> class defines a type of object
            that can hold an unordered set of other objects.  The objects held
            are pointers to <classname>TreeItemBaseClass</classname> which
            means <classname>TreeFolder</classname> objects can recursively
            contain other <classname>TreeFolder</classname> objects.
        </para>
        <para>
            This allows a hierarchy of folders to be created much like the
            folder hierarchy of a filesystem (or root file for that matter).
        </para>
        <refsect2>
            <title>METHODS</title>
            <variablelist>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>TreeFolder</methodname>
                            <methodparam>
                                <modifier>const </modifier>
                                <type>char* </type><parameter>name</parameter>
                               
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Tree folders are derived from
                            <classname>TreeItemBaseClass</classname>.  Thus they
                            must provide a <parameter>name</parameter>
                            to their base class constructor to give themselves
                            a name.  <parameter>name</parameter> will be the
                            name of the folder constructed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>addItem</methodname>
                            <methodparam>
                                <type>TreeItemBaseClass* </type><parameter>pItem</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Adds a new item, <parameter>pItem</parameter>
                            to the container.  Note that the order of additions
                            does not imply an ordering within the container.
                        </para>
                        <para>
                            Note that <parameter>pItem</parameter>s are all
                            assumed to be dynamically allocated (via
                            <literal>new</literal>) and ownership of
                            the objects are transferred to the container
                            (delete is called for each contained item on
                            destruction).  This behavior can be modified
                            by calling <methodname>freeStorage</methodname>
                            below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>const Contents&amp; </type>
                            <methodname>getContents</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns a reference to the container of the
                            objects the folder has.  Note that the container
                            is indexed by the names of the objects
                            added to the container.
                        </para>
                        
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>Contents::const_iterator </type>
                            <methodname>begin</methodname>
                            <void />
                            <modifier> const</modifier>
                        </methodsynopsis>
                    </term>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>Contents::const_iterator </type>
                            <methodname>end</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Supports iteration over the container of
                            <classname>TreeItemBaseClass</classname>
                            objects managed by this folder object.
                            Note that <classname>Contents::const_iterator</classname>
                            objects are pointer-like objects that point to
                            a <classname>std::pair&lt;std::string, TreeItemBaseClass*&gt;</classname>
                            objects.  The first element of each pair is the name
                            of the object.  The second, is a pointer to the object
                            contained.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>size_t </type>
                            <methodname>size</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the number of items in the container.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>freeStorage</methodname>
                            <methodparam>
                                <type>bool </type><parameter>yesno</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Modifies the ownershp of the items contained
                            (see <methodname>addItem</methodname>).
                            if <parameter>yesno</parameter> is
                            <literal>true</literal>, the object
                            will destroy all contained items when it is
                            itself destroyed.  If <literal>false</literal>,
                            the object will not destroy those objectds.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual </modifier>
                            <type>bool </type>
                            <methodname>isFolder</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns <literal>true</literal> as this
                            class implements a container.
                        </para>
                    </listitem>
                </varlistentry>
                    
            </variablelist>
        </refsect2>
        <refsect2>
            <title>Data Types</title>
            <para>
                The <classname>TreeFolder::Contents</classname>  type
                defines a name indexed container of
                <classname>TreeItemBaseClass</classname> pointers.
                This is implemented currently as:
                <classname>std::map&lt;std::string, TreeItemBaseClass*&gt;</classname>.
            </para>
        </refsect2>
    </refsect1>
    <refsect1>
        <title>TreeTerminal</title>
        <para>
            <classname>TreeTerminal</classname> objects represent terminal
            nodes of a tree.  For parameter trees in SpecTcl, parameters
            are represented by the parameter id of the parameter name.
        </para>
        <refsect2>
            <title>
                METHODS
            </title>
            <variablelist>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>TreeTerminal</methodname>
                            <methodparam>
                                <modifier>const </modifier>
                                <type>char* </type><parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>unsigned</type><parameter> parameterId</parameter>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Constructing a terminal requires the parameter
                            <parameter>name</parameter> and its
                            <parameter>parameterId</parameter>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>unsigned </type>
                            <methodname>id</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the id of the parameter supplied when it was
                            constructed.  For SpecTcl this represents a
                            slot in a <classname>CEvent</classname> object.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual</modifier>
                            <type> bool </type>
                            <methodname>isFolder</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns <literal>false</literal> as terminals are
                            not containers.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect2>
    </refsect1>
    <refsect1>
        <title>ParameterTree</title>
        <para>
            A <classname>ParameterTree</classname> is a hierarchy of parameters.
            In SpecTcl, hierarchy is implied by <literal>.</literal> path separators,
            for example, a parameter named <literal>s800.fp.e1up</literal>
            would be the terminal <literal>e1up</literal> in the folder
            <literal>fp</literal> in turn inside the folder <literal>s800</literal>.
        </para>
        <para>
            You can imagine, therefore a top level (root) folder with contents.
            The root folder does not have a name in SpecTcl.
            <classname>ParameterTree</classname> represents the root level
            folder and further supplies methods to allow you to
            build the complete folder/terminal hierarhcy given a flat
            description of a set of parameters.
        </para>
        <refsect2>
            <title>METHODS</title>
            <para>
                Note that this derives from <classname>TreeFolder</classname>.
                When the tree is built, the object becomes the top level folder
                of that tree.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>ParameterTree</methodname>
                            <void />
                        </constructorsynopsis>
                    </term>
                    <term>
                        <constructorsynopsis>
                            <methodname>ParameterTree</methodname>
                            <methodparam>
                                <modifier>const</modifier>
                                <type> std::vector&lt;ParameterDef&gt;&amp; </type>
                                <parameter>params</parameter>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The second form of the constructor is like the first
                            form followed by a call to
                            <methodname>buildTree</methodname>.  See below.
                            <parameter>params</parameter> are the parameters to be
                            built into the tree.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>buildTree</methodname>
                            <methodparam>
                                <modifier>const</modifier>
                                <type> std::vector&lt;ParameterDef&gt;&amp; </type>
                                <parameter>params</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Constructs the parameter tree from the
                            parameter definitions given by
                            <parameter>params</parameter>.  The
                            <literal>.</literal> character is used
                            as a path separator when building this tree.
                        </para>
                        <para>
                            Any previously existing parameter this object
                            holds is destroyed before building the new tree.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>clearTree</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Clears the tree. Once this is complete, the object
                            is an empty folder.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect2>
        <refsect2>
            <title>DATA TYPES</title>
            <para>
                The <classname>ParameterDef</classname> contains
                the name of a parameter and its parameter id:
            </para>
            <programlisting>
typedef struct _ParameterDef {
    std::string s_name;
    unsigned    s_id;
    _ParameterDef(const char* name, unsigned id) :
        s_name(name), s_id(id) {}
        
} ParameterDef, *pParameterDef;                
            </programlisting>
            <para>
                A constructor is provided so that you can initialize the
                type without needing to know the order of its members.
            </para>

        </refsect2>
    </refsect1>
    <refsect1>
        <title>ParameterMarshaller</title>
        <para>
            Root expects you to marshall all values that need to be put into a tree
            either into an object that Root's interpreter knows about or into
            an array of values.   This class is provided to take a
            <classname>CEvent</classname>
            object and marshall its set values into an array that has been
            initialized to <literal>NaN</literal>.
        </para>
        <para>
            The
            <classname>CEvent</classname>'s dope vector is used both to minimize the work required
            to marshall the data and the work required to reset the array
            to contain only <literal>NaN</literal>.
        </para>
        <refsect2>
            <title>METHODS:</title>
            <variablelist>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>ParameterMarshaller</methodname>
                            <methodparam>
                                <type>std::size_t</type><parameter>numParameters</parameter>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The constructor requires <parameter>numParameters</parameter>
                            to let it know how large a flat array to reserve.
                            <parameter>numParameters</parameter> should
                            be the number of elements in the tree branch written.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>marshall</methodname>
                            <methodparam>
                                <type>CEvent&amp; </type><parameter>event</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Marshall's the parameter values in
                            <parameter>event</parameter> into the flat storage
                            reserved for the tree values.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>reset</methodname>
                            <methodparam>
                                <type>CEvent&amp; </type><parameter>event</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Assumed to be called after
                            <methodname>marshall</methodname> on the same
                            <parameter>event</parameter>.  The dope  vector of
                            <parameter>event</parameter> is used to know which values
                            of the flattened parameter array have been set to
                            actual values.  Those values are reset to
                            <literal>NaN</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>Double_t* </type>
                            <methodname>pointer</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the pointer to the flattened parameters.
                            This can be passed in to a
                            <classname>TTRee::Branch</classname> method
                            that uses this marshaller.
                        </para>
                    </listitem>
                </varlistentry>            
            </variablelist>
        </refsect2>
    
    </refsect1>
    <refsect1>
        <title>SpecTclRootTree</title>
        <para>
            This class builds a Root tree from a set of SpecTcl parameters and
            provides a mechanism to fill it from a <classname>CEvent</classname>
            object.
        </para>
        <refsect2>
            <title>methods</title>
             <variablelist>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>SpecTclRootTree</methodname>
                            <methodparam>
                                <type>std::string </type><parameter>treeName</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier>const</modifier>
                                <type>std::vector&lt;ParameterTree::ParameterDef&gt;&amp; </type>
                                <parameter>params</parameter>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            <parameter>treeName</parameter> is the name
                            that will be given to the
                            <classname>TTree</classname> that will be created.
                            <parameter>params</parameter> define the parameters
                            that will put into this tree.
                        </para>
                        <para>
                            Note that the constructor creates the
                            <classname>TTree</classname> object.  This means
                            that at construction time, the current working
                            "directory" in root must be set to where you want
                            that tree to be stored.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>Fill</methodname>
                            <methodparam>
                                <type>CEvent&amp; </type><parameter>event</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Fills the underlying tree from the parameters in
                            <parameter>event</parameter>.  Note that the
                            underlying marshaller that marshalls parameters into
                            a flat array has a mapping of parameter numbers to
                            indices so that the flat array only has to be as
                            large as the number of parameters in the tree.
                        </para>
                    </listitem>
                </varlistentry>
             </variablelist>           
        </refsect2>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>RootTreeSink</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>RootTreeSink</refname>
        <refpurpose>Event sink that writes root trees.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <programlisting>
class RootTreeSink : public CEventSink
{

public:
    RootTreeSink(
        std::string name, const std::vector&lt;std::string&gt;&amp; patterns,
        CGateContainer* m_pGate
    );
    void OnOpen(TFile* pNewFile);
    void OnAboutToClose();
    virtual void operator()(CEventList&amp; rEvents);
    const std::vector&lt;std::string&gt;&amp; getParameterPatterns() const;
    CGateContainer&amp; getGate();
    
};
        </programlisting>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This class is an event sink that writes root trees.  It works in
            close cooperation with the <classname>RootEventProcessor</classname>.
            In normal SpecTcl operation you won't need to interact programmatically
            with these classes.
        </para>
        <para>
            Since event sinks know nothing of run boundaries, the paring of
            <classname>RootTreeSink</classname> with a managing event processor,
            <classname>RootEventProcessor</classname>, allows that information
            to be communicated between the event processing pipeline and
            the event sink.
        </para>
        
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>RootTreeSink</methodname>
                        <methodparam>
                            <type>std::string </type><parameter>name</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier> const </modifier>
                            <type>std::vector&lt;std::string&gt;&amp; </type>
                            <parameter>patterns</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CGateContainer* </type><parameter>pGate</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs a sink.  Note that the constructing code must
                        still add the sink to the event sink pipeline. Construction
                        generates sufficient information to automatically construct
                        a <classname>TTree</classname> object when the root file
                        is opened and automatically fill it as event are
                        seen.
                    </para>
                    <para>
                        <parameter>name</parameter> is used as the  name of the
                        <classname>TTree</classname> object when it is constructed.
                    </para>
                    <para>
                        <parameter>patterns</parameter> is a vector of glob
                        patterns.  These describe the parameters that will be written
                        to the tree.  To write all parameters,
                        for example,just
                        have a single element vector contaning
                        <literal>*</literal>.
                    </para>
                    <para>
                        <parameter>pGate</parameter> is a pointer to the gate
                        container used to conditionalize filling events into the
                        tree.  Note that if you want to write all events
                        to the tree, supply a pointer to a gate container
                        that contains a <literal>true</literal> gate.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>OnOpen</methodname>
                        <methodparam>
                            <type>TFile* </type><parameter>pNewFile</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        <classname>RootTreeSink</classname> objects rely on their
                        <classname>RootEventProcessor</classname> to manage
                        their connections to files.  This event processor
                        will open the output root file at the beginning of a run
                        and invok <methodname>OnOpen</methodname> for each
                        <classname>RootTreeSink</classname> it knows about.
                    </para>
                    <para>
                        The sink then creates its <classname>TTree</classname>
                        objects and associated branches into the file
                        <parameter>pNewFile</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>OnAboutToClose</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called by the associated event processor when the
                        <classname>TFile*</classname> handed to this
                        object on the previous call to
                        <methodname>OnOpen</methodname> is about to be closed.
                        This method allows the sink to flush any unwritten
                        data to file.
                    </para>
                    <para>
                        On return the file the sink's tree was created into
                        will be closed.  After that it's not safe to write
                        any data until another call to <methodname>OnOpen</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                            <type>CEventList&amp; </type><parameter>rEvents</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when the event sink has data to process.
                        Each event in the <parameter>rEvents</parameter>
                        that satisfies the gate,
                        should be filled into the tree.
                    </para>
                    <para>
                        It is important that there be an open file
                        (call to <methodname>OnOpen</methodname> that is not
                        paired with a <methodname>OnAboutToClose</methodname>).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>const </modifier>
                        <type>std::vector&lt;std::string&gt;&amp; </type>
                        <methodname>getParameterPatterns</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the set of patterns that describe the
                        parameters written to trees.  Note that this is not
                        the set of parameters but the set of glob patterns
                        on which this object was constructed,
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CGateContainer&amp; </type>
                        <methodname>getGate</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a reference to the gate container that
                        contains the gate which is used to determine which
                        events are written to file.  Note that the reference
                        is not <literal>const</literal> so it is possible
                        to change the gate contained by the container.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>                
        </para>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>RootEventProcessor</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>RootEventProcessor</refname>
        <refpurpose>Event processor to manage root event sinks</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <programlisting>
class RootEventProcessor : public CEventProcessor
{
public:    
    void addTreeSink(const char* name, RootTreeSink* sink);
    RootTreeSink* removeTreeSink(const char* name);
    
    std::map&lt;std::string, RootTreeSink*>&gt;:const_iterator begin() const;
    std::map&lt;std::string, RootTreeSink*&gt;::const_iterator end() const;

    
};
        </programlisting>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <classname>RootEventProcessor</classname> is an event processor that
            manages <classname>RootTreeSink</classname> objects.  Its purpose is to know
            when files need to be opened and closed and to inform all registered
            <classname>RootTreeSink</classname> objects of those events.
        </para>
        <para>
            The <command>roottree</command> command automatically creates and
            adds a <classname>RootEventProcessor</classname> object to manage
            the <classname>RootTreeSink</classname> objects it creates,
            manipulates and destroys.
        </para>
        <para>
            If you write subsystem that manages its own set of
            <classname>RootTreeSink</classname> objects you may want to provide
            your own managing event sinnk.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            The event processor interface methods are not shown.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>addTreeSink</methodname>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>char* </type><parameter>name</parameter>
                        </methodparam>
                        <methodparam>
                            <type>RootTreeSink*</type><parameter> sink</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Registeres a new <classname>RootTreeSink</classname> object,
                        <parameter>sink</parameter>,
                        with this manager associating it with the name
                        <parameter>name</parameter>.
                    </para>
                    <para>
                        If analysis of a run is ongoing, <parameter>sink</parameter>'s
                        <methodname>OnOpen</methodname> method is called
                        to inform it of the file into which data are being written.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>RootTreeSink*</type>
                        <methodname> removeTreeSink</methodname>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>char* </type><parameter>name</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Locates the root tree sink associated with
                        <parameter>name</parameter>.  If a file is open,
                        that object's <methodname>OnAboutToClose</methodname>
                        is invoked and the object is removed from the
                        set of managed sinks.
                    </para>
                    <para>
                        If the object is not found, a
                        <classname>std::invalid_argument</classname> exception
                        is thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>std::map&lt;std::string, RootTreeSink*>&gt;:const_iterator </type>
                        <methodname>begin() </methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an iterator that allows the caller to iterate
                        over the set of registered sinks and their names.
                        See also <methodname>end</methodname>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>std::map&lt;std::string, RootTreeSink*&gt;::const_iterator </type>
                        <methodname>end() </methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an iterator that allows the caller to determine
                        when iteration over the container containing the
                        sinks is complete.  Typical usage pattern might be:
                    </para>
                    <informalexample>
                        <programlisting>
RootEventProcessor* pProc = getMyEventProcessor(); // to get a pointer to the proc.

for (auto p = pProc-&gt;begin(); p != pProc-&gt;end(); p++) {
    std::string name = p-&gt;first;
    const RootTreeSink&amp; sink(p-&gt;second);
    
    // Do something with the sink and or name
    
    ...
}
                        </programlisting>
                    </informalexample>
                    <para>
                        Naturally STL iteration patterns (e.g.
                        <methodname>std::for_each</methodname>) can be used
                        as well.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CPipelineManager</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CPipelineManager</refname>
        <refpurpose>v5.1+ Dynamic pipeline management</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CPipelineManager.h&gt;
#include &lt;TCLAnalyzer.h&gt;
#include &lt;stdexcept&gt;

class CPipelineManager {
  
public:

  typedef std::map &lt;std::string, CTclAnalyzer::EventProcessingPipeline* &gt;
                                                    MapEventProcessingPipeline;
  typedef std::map &lt;std::string, CEventProcessor*&gt;
                                                    MapEventProcessors;

public:
  static CPipelineManager* getInstance();
  
  void registerEventProcessor(const std::string&amp; name, CEventProcessor* pProcessor);
  void createPipeline(const std::string&amp; name);
  
  void appendEventProcessor(const std::string&amp; pipeName, const std::string&amp; evpName);
  void insertEventProcessor(
    const std::string&amp; pipename, const std::string&amp; evpname,
    CTclAnalyzer::EventProcessorIterator where
  );

  void removeEventProcessor(const std::string&amp; pipename, const std::string&amp; evpname);
  void removeEventProcessor(const std::string&amp; pipename, CTclAnalyzer::EventProcessorIterator here);
  
  void setCurrentPipeline(const std::string&amp; pipename);
  
  void clonePipeline(const std::string&amp; from, const std::string&amp; to);

  // inquiries:
  
  CTclAnalyzer::EventProcessingPipeline* getCurrentPipeline();
  std::string                            getCurrentPipelineName() const;
  std::vector&lt;std::string&gt;               getPipelineNames() const;
  std::vector&lt;std::string&gt;               getEventProcessorNames() const;
  std::vector&lt;std::string&gt;               getEventProcessorsInPipeline(const std::string&amp; pipename) const;
  std::string                            lookupEventProcessor(const CEventProcessor* p) const;
  
  size_t pipelineCount() const;
  size_t eventProcessorCount() const;
  
  MapEventProcessingPipeline::const_iterator pipelineBegin() const;
  MapEventProcessingPipeline::const_iterator pipelineEnd() const;
  
  MapEventProcessors::const_iterator processorsBegin() const;
  MapEventProcessors::const_iterator processorsEnd() const;

};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The <classname>CPipelineManager</classname> class is a singleton
            class.   As such it has a private construtor and a
            <methodname>getInstance</methodname> static method used to
            obtain a pointer to the single instance of the class.
        </para>
        <para>
            <classname>CPipelineManager</classname> along with the
            <command>pman</command> command ensemble are used to provide
            support for dynamic event processing pipeline manipulation.
            Using this object you can register event processors, create
            and stock event processing pipelines as well as select an
            event processing pipeline for use by the analyzer.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>CPipelineManager* </type>
                        <methodname>getInstance</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is used to obtain a pointer to the one
                        and only instance of a <classname>CPipelineManager</classname>
                        class.  The <classname>CPipelineManager</classname> class
                        constructor is <literal>private</literal>,
                        as is its destructor.  Thus, this
                        is the only way to obtain a <classname>CPipelineManager</classname>
                        instance.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>registerEventProcessor</methodname>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>std::string&amp; </type><parameter>name</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CEventProcessor*</type><parameter>pProcessor</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Makes an event processor instance available to the
                        pipeline manager. <parameter>name</parameter> is the
                        name that will be associated with the event processor.
                        <parameter>pProcessor</parameter> points to the instance
                        of the processor.  The event processor  lifetime must
                        be the lifetime of SpecTcl's run.
                    </para>
                    <para>
                        <parameter>name</parameter> must be unique amongst all
                        event processors registered with the pipeline manager.
                        If an event processor with the same <parameter>name</parameter>
                        has alread been registered,
                        this method will throw a <classname>std::logic_error</classname>
                        exception.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>createPipeline</methodname>
                        <methodparam>
                            <modifier>const</modifier>
                            <type> std::string&amp; </type><parameter>name</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates a new event processing pipeline.  The pipeline
                        is created without any event processors
                        (see however <methodname>clonePipeline</methodname> below).
                        <parameter>name</parameter> is the name that will be used
                        to identify the pipeline and must be unique among
                        all event processing pipelines managed by the pipeline
                        manager.  If a processing pipeline with the same
                        <parameter>name</parameter> already exists,
                        a <classname>std::logic_error</classname>
                        exception is thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void</type>
                        <methodname>appendEventProcessor</methodname>
                        <methodparam>
                            <modifier>const</modifier>
                            <type> std::string&amp; </type><parameter>pipeName </parameter>
                        </methodparam>
                        <methodparam>
                            <modifier>const</modifier>
                            <type> std::string&amp; </type><parameter>evpName</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Appends an event processor to the set of event processors
                        in an event processing pipeline.
                        <parameter>pipeName</parameter> is the name of an
                        event processing pipeline that must already have been
                        made (note that when the pipeline manager is created,
                        it defines a pipeline named <literal>default</literal>).
                        <parameter>evpName</parameter> is the name of an event
                        processor that was registered with the pipeline manager.
                    </para>
                    <para>
                        If <parameter>pipeName</parameter> is not the name
                        of a pipeline or <parameter>evpName</parameter> is
                        not the name of an event processor, a
                        <classname>std::logic_error</classname> exception
                        is thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>insertEventProcessor</methodname>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>std::string&amp; </type><parameter>pipename</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>std::string&amp; </type><parameter>evpname</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CTclAnalyzer::EventProcessorIterator </type>
                            <parameter>where</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Inserts an event processor in an arbitrary position
                        in an event processing pipeline.  This is deliberately
                        difficult.  <parameter>pipename</parameter>
                        is the name of an event processing pipeline that
                        already exists.  If it does not exist
                        a <classname>std::logic_error</classname> exception
                        is thrown.
                    </para>
                    <para>
                        <parameter>evpname</parameter> is the name of the
                        event processor to insert.  This event processor
                        instance must already have been registered or
                        a <classname>std::logic_error</classname> exception
                        is thrown.
                    </para>
                    <para>
                        <parameter>where</parameter> is an iterator into the
                        event processsing pipeline that specifies where the
                        where the processor while be inserted.  The processor
                        will be inserted after the <parameter>where</parameter>
                        iterator, unless it's an end iterator in which case
                        behavior is identical to <methodname>appendEventProcessor</methodname>
                    </para>
                    <para>
                        This method is discouraged and intentioally difficult to use.
                        To use it you'd need to obtain a pointer to an event processing
                        pipeline (either by getting the current one if that's what
                        you want to operate on or by iterating over the set of
                        pipelines).  Next you'd have to iterate over the pipeline
                        to obtain the insertion iterator.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>removeEventProcessor</methodname>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>std::string&amp; </type><parameter>pipename</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier> const </modifier>
                            <type>std::string&amp; </type><parameter>evpname</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes the event processor named <parameter>evpname</parameter>
                        from the event processing pipeline named
                        <parameter>pipename</parameter>.  This is the preferred
                        way to remove an event processor from an processing
                        pipeline.
                    </para>
                    <para>
                        If <parameter>pipename</parameter> is not the  name
                        of an event proessing pipeline a
                        <classname>std::logic_error</classname> exception
                        is thrown.  If <parameter>evpname</parameter> is not
                        the name of an event processor that's in
                        <parameter>pipename</parameter>, a
                        <classname>std::logic_error</classname> exception
                        is thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>removeEventProcessor</methodname>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>std::string&amp; </type><parameter>pipename</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CTclAnalyzer::EventProcessorIterator </type><parameter>here</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes the event processor "pointed to" by the
                        iterator <parameter>here</parameter> from the
                        event processing pipeline named <parameter>pipename</parameter>.
                    </para>
                    <para>
                        If <parameter>pipename</parameter> is not the name of an
                        event processing pipeline, a
                        <classname>std::logic_error</classname> exception
                        is thrown.  Note that <parameter>here</parameter> must
                        be an iterator into the pipeline named by
                        <parameter>here</parameter> or else the results are
                        not defined.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>setCurrentPipeline</methodname>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>std::string&amp; </type><parameter>pipename</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Makes the pipeline named <parameter>pipename</parameter>
                        the current analysis pipeline. Beginning with the
                        next event, the analyzer will use this pipeline
                        to turn events into parameters.
                    </para>
                    <para>
                        If <parameter>pipename</parameter> is not an
                        analysis pipeline, a
                        <classname>std::logic_error</classname> exception is
                        thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type> void </type>
                        <methodname>clonePipeline</methodname>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>std::string&amp; </type><parameter>from</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>std::string&amp; </type><parameter>to</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates a clone of the processing pipeline named
                        <parameter>from</parameter> named <parameter>to</parameter>.
                        The <parameter>to</parameter> pipeline will have all of
                        the event processors <parameter>from</parameter> has
                        (in the same order) and starts life off identical
                        to <parameter>from</parameter> in every way.
                    </para>
                    <para>
                        If <parameter>from</parameter> is not the name of
                        an event processing pipeline, a
                        <classname>std::logic_error</classname> exception
                        is thrown.  If <parameter>to</parameter> is already
                        the name of an event processing pipeline, a
                        <classname>std::logic_error</classname> exception
                        is thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CTclAnalyzer::EventProcessingPipeline* </type>
                        <methodname>getCurrentPipeline</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the current event processing
                        pipeline.  
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>std::string</type>
                        <methodname>getCurrentPipelineName</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the name of the current event processing pipeline.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>std::vector&lt;std::string&gt; </type>
                        <methodname>getPipelineNames</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a vector containing the names of the
                        event processing pipelines that have been defined.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>std::vector&lt;std::string&gt;</type>
                        <methodname>getEventProcessorNames</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the names of all of the event processors that
                        have been registered.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>std::vector&lt;std::string&gt;</type>
                        <methodname>getEventProcessorsInPipeline</methodname>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>std::string&amp; </type><parameter>pipename</parameter>
                        </methodparam>
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a vector containing the names of event processors
                        in the pipeline named <parameter>pipename</parameter>.
                        The elements of the vector are the same as the
                        order of the corresponding event processors in the
                        pipeline.  If <parameter>pipename</parameter> is not
                        an event processing pipeline, a
                        <classname>std::logic_error</classname> exception
                        will be thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>std::string </type>
                        <methodname> lookupEventProcessor</methodname>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>CEventProcessor*</type><parameter> p</parameter>
                        </methodparam>
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Given a pointer to an event processor that is registered
                        with the pipeline manager, returns the name under which
                        the processor was registered.  If there is no corresponding
                        event processor, a
                        <classname>std::logic_error</classname> exception is
                        thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>size_t </type>
                        <methodname>pipelineCount</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of event processing pipelines that
                        are defined.  Note that the
                        <literal>default</literal> pipeline always exists so
                        this is going to be no less than 1.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>size_t </type>
                        <methodname>eventProcessorCount</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of event processors that have been
                        registered with the pipeline manager.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>MapEventProcessingPipeline::const_iterator</type>
                        <methodname> pipelineBegin</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>MapEventProcessingPipeline::const_iterator </type>
                        <methodname>pipelineEnd</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Support iteration through the collection that contains
                        the event processing pipelines. See
                        <literal>DATA TYPES</literal> for a description of the
                        <type>MapEventProcessingPipeline</type> data type.
                        <type>const_iterator</type> implies the creation of a
                        pointer like object whose target is read-only.
                    </para>
                    <para>
                        <methodname>pipelineBegin</methodname> produces a
                        pointer-like object to the first element of the
                        collection.  <methodname>pipelineEnd</methodname>
                        produces a pointer like object just off the end
                        of the collection.  If an iterator is incremented and the
                        result is the return value from <methodname>pipelineEnd</methodname>,
                        iteration must be terminated.   Note that any additions to the
                        pipeline colletion invalidate any and all iterators into it.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>MapEventProcessors::const_iterator </type>
                        <methodname>processorsBegin() </methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <term>
                  <methodsynopsis>
                    <modifier></modifier>
                        <type>MapEventProcessors::const_iterator </type>
                        <methodname>processorsEnd() </methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Supports iteration through the collection that
                        contains registered event processors.
                        <methodname>processorsBegin</methodname> returns a
                        pointer-like object to the beginning of the collection
                        and <methodname>processorsEnd</methodname> 'points'
                        just past the end of the collection.
                    </para>
                    <para>
                        See <literal>DATA TYPES</literal> below for more
                        information on what these iterators point at.
                    </para>
                </listitem>
            </varlistentry>
            
        </variablelist>
    </refsect1>
    <refsect1>
        <title>DATA TYPES</title>
        <para>
            The <classname>CPipelneManager</classname> singleton exports
            data types for the containers that hold pipelines and event processors.
            The containser themselves are only accessible via constant
            iterators, however you need to know what those iterators 'point' to
            in order to use them.
        </para>
        <variablelist>
            <varlistentry>
                <term><type>CPipelineManager::MapEventProcessingPipeline</type></term>
                <listitem>
                    <para>
                        This is an <classname>std::map</classname> whose
                        contents are pointers to event processing pipelines
                        and whose keys are the names of those pipelines.
                        An iterator into this container will therefore look
                        like a pointer to
                        <classname>std::pair&lt;std::string, CTclAnalyzer::EventProcessingPipeline*&gt;</classname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>CPipelineManager::MapEventProcessors</type></term>
                <listitem>
                    <para>
                        This container is a map whose contents are pointers to
                        event processor instances and whose keys are the names under which
                        those instances were registered.  An iterator into this
                        container will threrefore look like a pointer to
                        <classname>std::pair&lt;std::string, CEventProcessor*&gt;</classname>.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CPipelineEventProcessor</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CPipelineEventProcessor</refname>
        <refpurpose>Encapsulate an event processing pipeline as a processor.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CPipelineEventProcessor.h&gt;

class CPipelineEventProcessor : public CEventProcessor
{
public:
    CPipelineEventProcessor(CTclAnalyzer::EventProcessingPipeline* pipe);
    virtual ~CPipelineEventProcessor();

public:
  virtual Bool_t operator()(const Address_t pEvent,
                            CEvent&amp; rEvent,
                            CAnalyzer&amp; rAnalyzer,
                            CBufferDecoder&amp; rDecoder); // Physics Event.

  // Functions:
  virtual Bool_t OnAttach(CAnalyzer&amp; rAnalyzer); // Called on registration.
  virtual Bool_t OnDetach(CAnalyzer&amp; rAnalyzer);
  virtual Bool_t OnBegin(CAnalyzer&amp; rAnalyzer,
                         CBufferDecoder&amp; rDecoder); // Begin Run.
  virtual Bool_t OnEnd(CAnalyzer&amp; rAnalyzer,
                       CBufferDecoder&amp; rBuffer); // End Run.
  virtual Bool_t OnPause(CAnalyzer&amp; rAnalyzer,
                         CBufferDecoder&amp; rDecoder); // Pause Run.
  virtual Bool_t OnResume(CAnalyzer&amp; rAnalyzer,
                          CBufferDecoder&amp; rDecoder); // Resume Run.
  virtual Bool_t OnOther(UInt_t nType,
                         CAnalyzer&amp; rAnalyzer,
                         CBufferDecoder&amp; rDecoder); // Unrecognized buftype.

  virtual Bool_t OnEventSourceOpen(std::string name);
  virtual Bool_t OnEventSourceEOF();
  virtual Bool_t OnInitialize();

};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Sometimes it's convenient to encapsulate an entire event processing
            pipeline in an event processor of its own.  For example, the
            <classname>CEventBuilderEventProcessor</classname> only allows
            an event processor to be registered to handle data from a source id.
            If your analysis of that raw data is a pipeline, you can use
            this class to encapsulate that pipeline and the register
            a <classname>CPipelineEventProcessor</classname> to handle
            the source id.
        </para>
        <para>
            This class implements all Event processor methods.  When constructed,
            it's passed a pointer to a
            <classname>CTclAnalyzer::EventProcessingPipeline</classname>.  For each
            method, the pipeline is iterated over and the corresponding method
            called for each element.  If a pipeline element indicates failure,
            iteration is aborted and the failure is propagated to the caller.
        </para>
    </refsect1>

</refentry>
    </part>
<part>
  <title>SpecTcl Displays</title>
  <partintro>
    <title>Introduction</title>
    <para>
      The original SpecTcl only supported a single, hard coded visualization
      program, Xamine.  While Xamine is still supported, the internal support for
      visualizers has been generalized to provide the ability to extend SpecTcl
      to use other display programs.  
    </para>
    <para>
      The Spectra, root based display program was written and abandoned before
      gaining much traction because the CERN/Root team abandoned QTGsi and went in
      a much different GUI direction.  A Python/Qt based displayer using
      MatPltoLib is being developed and will live on top of these classes documented
      below.
    </para>
  </partintro>

  <refentry>
     <refmeta>
        <refentrytitle>CDisplay</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
     </refmeta>
     <refnamediv>
        <refname>CDisplay</refname>
        <refpurpose>Display interface base class</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
        <programlisting>
#include &lt;Display.h&gt;

class CDisplay
{
public:
    typedef std::pair&lt;int, std::string&gt; BoundFitline;
    typedef std::list&lt;BoundFitline&gt;     FitlineList;
    typedef std::vector&lt;FitlineList&gt;    FitlineBindings;

public:
    virtual CDisplay* clone() const = 0;
    virtual void start() = 0;
    virtual void stop() = 0;
    virtual bool isAlive() = 0;
    virtual void restart() = 0;

    virtual SpectrumContainer getBoundSpectra() const = 0;
    virtual void addSpectrum(CSpectrum&amp; rSpectrum, CHistogrammer&amp; rSorter) = 0;
    virtual void removeSpectrum(CSpectrum&amp; rSpectrum, CHistogrammer&amp; rSorter) = 0;
    virtual bool spectrumBound(CSpectrum* pSpectrum) = 0;

    virtual void addFit(CSpectrumFit&amp; fit) = 0;
    virtual void deleteFit(CSpectrumFit&amp; fit) = 0;
    virtual void addGate(CSpectrum&amp; rSpectrum, CGateContainer&amp; rGate) = 0;
    virtual void removeGate(CSpectrum&amp; rSpectrum, CGateContainer&amp; rGate) = 0;
    virtual std::vector&lt;CGateContainer&gt; getAssociatedGates(const std::string&amp; spectrumName,
                                                           CHistogrammer&amp; rSorter) = 0;

    virtual std::string createTitle(CSpectrum&amp; rSpectrum, UInt_t maxLength,
    virtual void setInfo(CSpectrum&amp; rSpectrum, std::string name) = 0;
    virtual void setTitle(CSpectrum&amp; rSpectrum, std::string name) = 0;
    virtual UInt_t getTitleSize() const = 0;

    virtual void updateStatistics() = 0;
};


        </programlisting>
      </refsynopsisdiv>
      <refsect1>
             <title>DESCRIPTION</title>
            <para>
              <classname>CDisplay</classname> is an abstract
              base class that defines the interfaces every display
              class must implement.  concrete display classes
              implement the interfaces between SpecTcl and a displayer.
            </para>
            <para>
              Displayers can be internal or external.  By internal,
              we mean that they run in the same process address
              space as SpecTcl. External displayers run in a separate
              address space and interface with SpecTcl via shared
              memory, the SpecTcl REST interface and/or other
              communication schemes that are specific to the
              display program.   Xamine is an external displayer,
              there are currently no internal displayers.
            </para>
            <para>
              The interface methods come in several groups that
              manipulate objects that are the concerns of
              displayers; 
            </para>
            <itemizedlist>
              <listitem>
                 <para>
                    Methods are provided to control the displayer iself,
                    an external (or internal for that matter) displayer
                    will need to be started, stopped and restarted.
                 </para>
              </listitem>
              <listitem>
                 <para>
                    Methods are provided to make the displayer know
                    the spectra it should display.  For example,
                    Xamine uses a fixed sized shared memory region
                    to gain access to bulk spectrum information,
                    as such, these interface methods can shuttle
                    the contents of spectra in and out of that
                    shared memory.
                 </para>
              </listitem>
              <listitem>
                 <para>
                    Displayers can have the ability to display
                    <firstterm>graphical</firstterm> objects that
                    annotate spectra.  These can be gates, markers,
                    and fitlines.  Methods are provided to define
                    these to the displayer.
                 </para>
              </listitem>
              <listitem>
                 <para>
                    Finally, each spectrum has both a title and information
                    string.  The displayer must implement methods that support
                    the creation of and display of these strings.
                 </para>
              </listitem>
            </itemizedlist>
      </refsect1>
      <refsect1>
        <title>METHODS</title>
        <para>
          Note that all methods are pure virtual making this an interface
          definition class.
        </para>
        <variablelist>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>virtual CDisplay* </type>
                 <methodname>clone() </methodname>
                 <void />
                 <modifier>const = 0</modifier>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Display interfaces must be able to duplicate themselves.
                  Unless multiple concurrent displayers are supported
                  (SpecTcl is neutral about this), this must usually
                  be a shallow, referential copy maintaining some
                  scheme that knows when data can be safely destroyed.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>virtual void </type>
                 <methodname>start</methodname>
                 <void />
                 <modifier> = 0</modifier>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  This method must start the displayer.  Until
                  <methodname>start</methodname> is called, the displayer
                  should not have a visual presence on the
                  screen.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>virtual void </type>
                 <methodname>stop</methodname>
                 <void />
                 <modifier> = 0</modifier>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  This method must stop the displayer.  Once called,
                  the displayer should not have a visual presence on the
                  screen.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>virtual bool </type>
                 <methodname>isAlive</methodname>
                 <void />
                 <modifier> = 0</modifier>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Should return <literal>true</literal> if
                  the displayer is running.  This allows
                  SpecTcl to detect the display has exited
                  without <methodname>>stop</methodname>
                  being called e.g.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>virtual void </type>
                 <methodname>restart</methodname>
                 <void />
                 <modifier> = 0</modifier>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  This method is normally a short-hand for
                  invoking <methodname>stop</methodname>
                  immediately followed by
                  <methodname>start</methodname>
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>virtual CDisplay::SpectrumContainer </type>
                 <methodname>getBoundSpectra</methodname>
                 <void />
                 <modifier>const = 0;</modifier>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  This method is expected to return the spectra
                  that are known to the displayer.  The
                  <type>CDisplay::SpectrumContainer</type>
                  data type is descried in
                  <literal>PUBLIC DATA TYPES</literal> below.
                  For the purposes of this discussion, it's enough
                  to know this is a container that has integer
                  indices.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>virtual void </type>
                 <methodname>addSpectrum</methodname>
                 <methodparam>
                     <type>CSpectrum&amp;</type><parameter> rSpectrum</parameter>
                    <initializer></initializer>
                 </methodparam>
                 <methodparam>
                     <type>CHistogrammer&amp;</type><parameter> rSorter</parameter>
                    <initializer></initializer>
                 </methodparam>
                 <modifier>= 0;</modifier>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Called to make a spectrum known to the displayer.
                  The <command>sbind</command> command will ultimately call
                  this method in an active displayer.
                  <parameter>rSpectrum</parameter> is a reference to the
                  spectrum to add and <parameter>rSorter</parameter>
                  is a reference to the active histogrammer.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>virtual void </type>
                 <methodname>removeSpectrum</methodname>
                 <methodparam>
                     <type>CSpectrum&amp; </type><parameter>rSpectrum</parameter>
                    <initializer></initializer>
                 </methodparam>
                 <methodparam>
                     <type>CHistogrammer&amp; </type><parameter>rSorter</parameter>
                    <initializer></initializer>
                 </methodparam>
                 <modifier>= 0;</modifier>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Called to informt the displayer it no longer
                  needs to display a spectrum.  Note that there
                  are two events that normally invoke this method:
                <command>unbind</command> is invoked on the spectrum,
                or the spectrum was deleted.
                <parameter>rSpectrum</parameter> is a reference to the
                spectrum to remove while, <parameter>rSorter</parameter>
                references the current histogrammer.
               </para>
            </listitem>
          </varlistentry>
          
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>virtual bool</type>
                 <methodname> spectrumBound</methodname>
                 <methodparam>
                     <type>CSpectrum* </type><parameter>pSpectrum</parameter>
                    <initializer></initializer>
                    <modifier>= 0</modifier>
                 </methodparam>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Returns <literal>true</literal> if the spectrum
                  is known by the displayer.  In general this means
                  that the spectrum,  <parameter>pSpectrum</parameter>
                  was passed to <methodname>addSpectrum</methodname>
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>virtual void </type>
                 <methodname>addFit</methodname>
                 <methodparam>
                     <type>CSpectrumFit&amp; </type><parameter>fit</parameter>
                    <initializer></initializer>
                 </methodparam>
                 <modifier>
                  = 0
                 </modifier>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Displayers can display informationa relevant to the
                  spectrum as well as the spectrum.
                  <parameter>fit</parameter> contains fit line information
                  that SpecTcl is requiesting the displayer to display
                  on the spectrum named by the fit.  A fit line is just a set of
                  channel/count pairs that can be extracte from the
                  <parameter>fit</parameter> object to render the
                  fit.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>virtual void </type>
                 <methodname>deleteFit</methodname>
                 <methodparam>
                     <type>CSpectrumFit&amp; </type><parameter>fit</parameter>
                    <initializer></initializer>
                 </methodparam>
                 <modifier> = 0</modifier>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Requests that the diplayer remove the
                  fit line specified by
                  <parameter>fit</parameter> from the spectrum
                  specified by <parameter>fit</parameter>.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>virtual void </type>
                 <methodname>addGate</methodname>
                 <methodparam>
                     <type>CSpectrum&amp; </type><parameter>rSpectrum</parameter>
                    <initializer></initializer>
                 </methodparam>
                 <methodparam>
                     <type>CGateContainer&amp; </type><parameter>rGate</parameter>
                    <initializer></initializer>
                 </methodparam>
                 <modifier>= 0;</modifier>
              </methodsynopsis></term>
             <listitem>
                 <para>
                 Spectra on which gates have been accepte can be made
                 to display the gates. The actual rendition of the gate
                 depends on the gate and the spectrum.
               </para>
                 <para>
                  This method requests that the gate
                  <parameter>rGate</parameter> be displayed on
                  the spectrum <parameter>rSpectrum</parameter>.
                  Note that the actual gate and even gate type may
                  change.  The gate container object
                  <parameter>rGate</parameter> serves as a pointer-like
                  object that is a fixed reference to the gate regardless
                  of the changes it undergoes.  It is legitimate for the
                  displayer to refuse to display a gate.
                 </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>virtual void </type>
                 <methodname>removeGate</methodname>
                 <methodparam>
                     <type>CSpectrum&amp; </type><parameter>rSpectrum</parameter>
                    <initializer></initializer>
                 </methodparam>
                 <methodparam>
                     <type>CGateContainer&amp; </type><parameter>rGate</parameter>
                    <initializer></initializer>
                 </methodparam>
                 <modifier>= 0</modifier>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Requests that the gate <parameter>rGate</parameter>
                  no longer be displayed on <parameter>rSpectrum</parameter>
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>virtual std::vector&lt;CGateContainer&gt;</type>
                 <methodname> getAssociatedGates</methodname>
                 <methodparam>
                     <type>const std::string&amp; </type><parameter>spectrumName</parameter>
                    <initializer></initializer>
                 </methodparam>
                 <methodparam>
                     <type>CHistogrammer&amp; </type><parameter>rSorter) </parameter>
                    <initializer></initializer>
                 </methodparam>
                 <modifier>= 0</modifier>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Returns a vector that contains the gate containers
                  of the gates that are supposed to be displayed
                  on <parameter>rSpectrum</parameter>.
                  <parameter>rSorter</parameter> is a reference to he
                  
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>virtual std::string </type>
                 <methodname>createTitle</methodname>
                 <methodparam>
                     <type>CSpectrum&</type><parameter> rSpectrum</parameter>
                    <initializer></initializer>
                 </methodparam>
                 <methodparam>
                     <type>UInt_t</type><parameter>maxLength</parameter>
                    <initializer></initializer>
                 </methodparam>
                 <methodparam>
                     <type>CHistogrammer& </type><parameter>rSorter</parameter>
                    <initializer></initializer>
                 </methodparam>
                 <modifier> = 0</modifier>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Creates a title string for the specturm
                  <parameter>rSpectrum</parameter>.
                  The title string must be no more than
                  <parameter>maxLength</parameter> characters
                  long. <parameter>rSorter</parameter> provides
                  a reference to the histogramming object.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>virtual void </type>
                 <methodname>setInfo</methodname>
                 <methodparam>
                     <type>CSpectrum&amp; </type><parameter>rSpectrum</parameter>
                    <initializer></initializer>
                 </methodparam>
                 <methodparam>
                     <type>std::string </type><parameter>name</parameter>
                    <initializer></initializer>
                 </methodparam>
                 <modifier>= 0</modifier>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Sets the infornmation string for
                  <parameter>rSpectrum</parameter> to
                  <parameter>name</parameter>. 
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>virtual void </type>
                 <methodname>setTitle</methodname>
                 <methodparam>
                     <type>CSpectrum&amp; </type><parameter>rSpectrum</parameter>
                    <initializer></initializer>
                 </methodparam>
                 <methodparam>
                     <type>std::string </type><parameter>name) </parameter>
                    <initializer></initializer>
                 </methodparam>
                 <modifier>= 0</modifier>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Sets the title string for <parameter>rSpectrum</parameter>
                  to <parameter>name</parameter>.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                  <type>virtual UInt_t </type><methodname>getTitleSize</methodname>
                  <void />
                <modifier>const = 0</modifier>
              </methodsynopsis></term>
             <listitem>
                 <para>
                  Returns the number of characters that can be displayed
                  in the title string. Note that in the case where
                  the title is in e.g. UTF-8 or UTF-16, the number of
                  characters and number of bytes differ
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>virtual void </type>
                 <methodname>updateStatistics</methodname>
                 <void />
                 <modifier>=0</modifier>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Spectra maintain under and overflow counters.
                  This method is supposed to scan the set of bound
                  spectra and update any internal knowledge of those
                  statistics the displayer may have
               </para>
            </listitem>
          </varlistentry>
        </variablelist>
        <para>

    
        </para>
      </refsect1>
      <refsect1>
        <title>PUBLIC DATATYPES</title>
        <para>
          Three data types are exported by the base class.
        </para>
        <formalpara>
          <title><type>typedef std::pair&lt;int, std::string&gt; BoundFitline</type></title>
          <para>
            This  provides the names of the fit lines and the internal id
            that the displayer assigns to them.
          </para>
        </formalpara>
        <formalpara>
          <title><type>typedef std::list&lt;BoundFitline&gt;     FitlineList</type></title>
          <para>
            A list of fitlines.  This is used to represent the fit lines
            that are bound to a specific spectrum.
          </para>
        </formalpara>
        <formalpara>
          <title><type>typedef std::vector&lt;FitlineList&gt;    FitlineBindings;</type></title>
          <para>
            Captures the fitlines assigned to all spectra. Each element is
            the list of fit lines assigned to a single spectrum.
          </para>
        </formalpara>
        
      </refsect1>
  </refentry>
  <refentry>
     <refmeta>
        <refentrytitle>CNullDisplay</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
     </refmeta>
     <refnamediv>
        <refname>CNullDisplay</refname>
        <refpurpose>Batch mode displayer</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
        <programlisting>
#include &lt;NullDisplay.h&gt;

        </programlisting>
      </refsynopsisdiv>
      <refsect1>
             <title>DESCRIPTION</title>
            <para>
              SpecTcl must always have a displayer.  The
              <classname>CNullDisplay </classname> class
              provides a displayer that is no displayer.
              This displayer is suitable for running
              SpecTcl in batch mode, divorced from a display.
            </para>
      </refsect1>
  </refentry>
  <refentry>
     <refmeta>
        <refentrytitle>CXamine</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
     </refmeta>
     <refnamediv>
        <refname>CXamine</refname>
        <refpurpose>Displayer class for Xamine</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
        <programlisting>
#include &lt;Xamineplus.h&gt;

class CXamine : public CDisplay
{
public:
  CXamine (std::shared_ptr&lt;CXamineSharedMemory&gt; pSharedMem);

  void EnterPeakMarker (UInt_t nSpectrum, 
                        UInt_t nId,
                        const std::string&amp; rsName,
                        Float_t fCentroid, Float_t fWidth)  ;
  UInt_t GetEventFd ()  ;
  Bool_t PollEvent (Int_t nTimeout, CXamineEvent&amp; rEvent)  ;

  void DefineButtonBox (UInt_t nColumns=8, UInt_t NRows=3)  ;
  void DefineButton (UInt_t nColumn, UInt_t nRow, 
                        const CXamineButton&amp; rButton)  ;
  void ModifyButton (UInt_t nColumn, UInt_t nRow, 
                        const CXamineButton&amp; rButton)  ;
  void EnableButton (UInt_t nColumn, UInt_t nRow)  ;
  void DisableButton (UInt_t  nColumn, UInt_t nRow)  ;
  void DeleteButton (UInt_t nColumn, UInt_t nRow)  ;
  void DeleteButtonBox ()  ;
  CXamineButton* InquireButton (UInt_t nColumn, UInt_t nRow)  ;


};




        </programlisting>
      </refsynopsisdiv>
      <refsect1>
             <title>DESCRIPTION</title>
            <para>
              <classname>CXamine</classname> is a displayer for
              the Xamine display program.  Xamine runs as a separate
              process using both shared memory and named pipes
              to communicate with SpecTcl.
            </para>
      </refsect1>
      <refsect1>
        <title>METHODS</title>
        <para>
          We only describe the methods that are provided in addition
          to the interface required by <classname>CDisplay</classname>.
        </para>
        <variablelist>
          <varlistentry>
             <term>
              <constructorsynopsis>
                  <methodname>CXamine</methodname>
                <methodparam>
                    <type>std::shared_ptr&lt;CXamineSharedMemory&gt; </type><parameter>pSharedMem);</parameter>
                    <initializer></initializer>
                </methodparam>
              </constructorsynopsis>
             </term>
             <listitem>
                 <para>
                  Constructs the displayer. The parameter,
                  <parameter>pShMem</parameter> is a shared pointer to an
                  object that encapsulates the shared memory used to
                  shared memory that Xamine and SpecTcl use to transfer
                  bullk spectrum data.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>void </type>
                 <methodname>EnterPeakMarker</methodname>
                 <methodparam>
                     <type>UInt_t </type><parameter>nSpectrum</parameter>
                    <initializer></initializer>
                 </methodparam>
                 <methodparam>
                     <type>UInt_t</type><parameter> nId</parameter>
                    <initializer></initializer>
                 </methodparam>
                 <methodparam>
                     <type>const std::string&amp; </type><parameter>rsName</parameter>
                    <initializer></initializer>
                 </methodparam>
                 <methodparam>
                     <type>Float_t </type><parameter>fCentroid</parameter>
                    <initializer></initializer>
                 </methodparam>
                 <methodparam>
                     <type>Float_t</type><parameter> fWidth</parameter>
                    <initializer></initializer>
                 </methodparam>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Xamine can display <firstterm>peak markers</firstterm>
                  on spectra it displays.  A peak marker is an indicator of
                  the peak position and peak width.
                  <parameter>nId</parameter> is the Xamine internal id
                  of the spectrum. <parameter>rsName</parameter> is the
                  name of the peak marker <parameter>fCentroid </parameter>
                  is the peak's centroid in channels and <parameter>fWidth</parameter>
                  the width of the maker.
               </para>
                 <para>
                  If you think of a peak marker as an inverted T, the vertical
                  stroek of the T is at <parameter>fCentroid</parameter>
                  and the cross bar of the T is <parameter>fWidth</parameter>
                  wide.
                 </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>UInt_t </type>
                 <methodname>GetEventFd</methodname>
                 <void />
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Returns the file descriptor open on the named pipe
                  Xamine uses to communicate new events of interest
                  to SpecTcl.  This can be used to set a file event
                  in the Tcl event loop to handle input from Xamine.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>Bool_t </type>
                 <methodname>PollEvent </methodname>
                 <methodparam>
                     <type>Int_t</type><parameter> nTimeout</parameter>
                    <initializer></initializer>
                 </methodparam>
                 <methodparam>
                     <type>CXamineEvent&amp; </type><parameter>rEvent</parameter>
                    <initializer></initializer>
                 </methodparam>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Polls for an event from Xamine.  The method will
                  block for at most <parameter>nTimeout</parameter>
                  seconds waiting for an event from Xamine.  If
                  one arrives within that timeout, <parameter>rEvent</parameter>
                  is filled in with information about the event and
                  the method returns <literal>kfTRUE</literal>.
                  Otherwise it returns <literal>kfFALSE</literal>
                  and the contents of <parameter>rEvent</parameter>
                  have no meaning.
               </para>
                <para>
                  If <parameter>nTimeout</parameter> is 0, the
                  method does not block and returns
                  <literal>kfTRUE</literal> only if an event is
                  ready at the time of the call.  If
                  <parameter>nTimeout</parameter> is negative,
                  the method will wait indefinitely for the next event.
                  </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>void </type>
                 <methodname>DefineButtonBox </methodname>
                 <methodparam>
                     <type>UInt_t </type><parameter>nColumns</parameter>
                    <initializer>8</initializer>
                 </methodparam>
                 <methodparam>
                     <type>UInt_t </type><parameter>NRows</parameter>
                    <initializer>3</initializer>
                 </methodparam>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Xamine can display a set of buttons that can be programmed to
                  send events for custom operations back to its client.
                  These buttons are arranged in a top level window
                  that has <parameter>nColumns</parameter>
                  columns of buttons and <parameter>NRows</parameter>
                  of buttons.  This method tells Xamine to display
                  the button box and the column/row geometry of the box.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>void </type>
                 <methodname>DefineButton</methodname>
                 <methodparam>
                     <type>UInt_t </type><parameter>nColumn</parameter>
                    <initializer></initializer>
                 </methodparam>
                 <methodparam>
                     <type>UInt_t </type><parameter>nRow</parameter>
                    <initializer></initializer>
                 </methodparam>
                 <methodparam>
                     <type>const CXamineButton&amp; </type><parameter>rButton</parameter>
                    <initializer></initializer>
                 </methodparam>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Defines a button at the button box coordinats
                  <parameter>nColumn</parameter>, <parameter>nRow</parameter>.
                  The button's appearance and action depend on
                  the contents of the <parameter>rButton</parameter>
                  object. Several types of buttons are permitted
                  including  buttons that induce Xamine to
                  prompt the user.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>void </type>
                 <methodname>ModifyButton</methodname>
                 <methodparam>
                     <type>UInt_t </type><parameter>nColumn</parameter>
                    <initializer></initializer>
                 </methodparam>
                 <methodparam>
                     <type>UInt_t nRow, </type><parameter></parameter>
                    <initializer></initializer>
                 </methodparam>
                 <methodparam>
                     <type> const CXamineButton&amp; </type><parameter>rButton</parameter>
                    <initializer></initializer>
                 </methodparam>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Same as <methodname>CreateButton</methodname>, but
                  an existing button is modified to match the specifications
                  in <parameter>rButton</parameter>.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>void </type>
                 <methodname>EnableButton</methodname>
                 <methodparam>
                     <type>UInt_t </type><parameter>nColumn</parameter>
                    <initializer></initializer>
                 </methodparam>
                 <methodparam>
                     <type>UInt_t </type><parameter>nRow</parameter>
                    <initializer></initializer>
                 </methodparam>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  User buttons displayed by Xamine can be either enabled,
                  in which case they have normal rendition and respond to
                  clicks, or disbabled, in which case they are ghosted and
                  do not respond to clicks.  This method enables the
                  button specifiec by <parameter>nColumn</parameter>
                  and <parameter>nRow</parameter>.  This method is a harmless
                  no-op if the button is already enabled.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>void </type>
                 <methodname>DisableButton</methodname>
                 <methodparam>
                     <type>UInt_t  </type><parameter>nColumn</parameter>
                    <initializer></initializer>
                 </methodparam>
                 <methodparam>
                     <type>UInt_t </type><parameter>nRow</parameter>
                    <initializer></initializer>
                 </methodparam>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Disables the Xamine user button specified by
                  <parameter>nColumn</parameter> and
                  <parameter>nRow</parameter>.  This is a harmless
                  no-op if the4 button is already disbled.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>void </type>
                 <methodname>DeleteButton</methodname>
                 <methodparam>
                     <type>UInt_t </type><parameter>nColumn</parameter>
                    <initializer></initializer>
                 </methodparam>
                 <methodparam>
                     <type> UInt_t </type><parameter>nRow</parameter>
                    <initializer></initializer>
                 </methodparam>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Deletes the Xamine client button specified by
                  <parameter>nColumn</parameter> and
                  <parameter>nRow</parameter>.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>void</type>
                 <methodname> DeleteButtonBox</methodname>
                 <void />
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Deletes the entire button box and all of the user
                  defined Xamine buttons.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>CXamineButton* </type>
                 <methodname>InquireButton</methodname>
                 <methodparam>
                     <type>UInt_t</type><parameter> nColumn, UInt_t nRow</parameter>
                    <initializer></initializer>
                 </methodparam>
                 <methodparam>
                     <type> UInt_t</type><parameter> nRow</parameter>
                    <initializer></initializer>
                 </methodparam>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Returns a pointer to the button desription of the
                  Xamine
                  user button specified by
                  <parameter>nColumn</parameter> and
                  <parameter>nRow</parameter>.
                  If the button does not exist a
                  <classname>CXamineButtonException</classname> is
                  thrown.  The returned pointer is  to a dynamically
                  allocated object which must, therefore, be deleted
                  when it is no longer needed.
               </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </refsect1>
  </refentry>
  <refentry>
     <refmeta>
        <refentrytitle>Xamine Gates</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
     </refmeta>
     <refnamediv>
        <refname>CXamineGate</refname>
        <refname>CDisplayCut</refname>
        <refname>CDisplayBand</refname>
        <refname>CDisplayContour</refname>
        <refpurpose>Represent gates in Xamine</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
        <programlisting>
#include &lt;XamineGate&gt;


class CXamineGate
{
  
public:

  CXamineGate(const msg_object&amp; rGateInfo);
  CXamineGate(UInt_t nSpectrum, UInt_t nId,
		const std::string&amp; rName);

  UInt_t getSpectrum() const;
  UInt_t getId() const;
  std::string getName() const;
  GateType_t getGateType() const;
  PointArray getPoints() const;
  
  void setId (UInt_t am_nId);
  void setName (std::string am_sName);

  PointIterator begin ()  ;
  PointIterator end ()  ;
  UInt_t size ()  const;
  CPoint&amp; operator[] (UInt_t n)  ;
  void AddPoint (const CPoint&amp; rPoint)  ;
  void AddPoint(int x, int y) 
  void RemovePoints (UInt_t n=1)  ;

  CDisplayCut* Cut ()  ;
  CDisplayBand* Band ()  ;
  CDisplayContour* Contour ()  ;

  void FormatMessageBlock(msg_object&amp; rMsg) const;

};

class CDisplayCut : public CXamineGate {
public:
  CDisplayCut(const msg_object&amp; rGate); 
  CDisplayCut(UInt_t nSpectrum, UInt_t nId, const std::string&amp; rName);
};

class CDisplayBand : public CXamineGate {
public:
  CDisplayBand(const msg_object&amp; rgate) ;
  CDisplayBand(UInt_t nSpectrum, UInt_t nId, const std::string&amp; rName) ;

};

class CDisplayContour : public CXamineGate {
public:
  CDisplayContour(const msg_object&amp; rgate);
  CDisplayContour(UInt_t nSpectrum, UInt_t nId, const std::string&amp; rName); 
};

        </programlisting>
      </refsynopsisdiv>
      <refsect1>
             <title>DESCRIPTION</title>
            <para>
              This family of classes capture the structure and functionality
              of gates as seen by Xamine.   The classes are able to
              instantiate either from an Xamine gate accepted event
              or from inforrmation about the gate.  Once
              instantiated, gate objects are able to format the
              message that Xamine expects to receive when a gate
              is entered by a client.
            </para>
            <para>
              In addition to the base class, subclasses are
              provided to make instantiating the basic gate types
              simple.
            </para>
      </refsect1>
      <refsect1>
        <title>METHODS</title>
        <variablelist>
          <varlistentry>
             <term>
              <constructorsynopsis>
                  <methodname>CXamineGate</methodname>
                <methodparam>
                    <type>const msg_object&amp; </type><parameter>rGateInfo</parameter>
                    <initializer></initializer>
                </methodparam>
              </constructorsynopsis>
             </term>
             <listitem>
                 <para>
                  Constructs the object from the object event message
                  sent by Xamine to the client when a gate is accepted by
                  the user. <parameter>rGateInfo</parameter>
                  encapsulates that message and is defined in the
                  Xamine API headers.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <constructorsynopsis>
                  <methodname>CXamineGate</methodname>
                <methodparam>
                    <type>UInt_t </type><parameter>nSpectrum</parameter>
                    <initializer></initializer>
                </methodparam>
                <methodparam>
                    <type>UInt_t </type><parameter>nId</parameter>
                    <initializer></initializer>
                </methodparam>
                <methodparam>
                    <type>const std::string&amp; </type><parameter>rName</parameter>
                    <initializer></initializer>
                </methodparam>
              </constructorsynopsis>
             </term>
             <listitem>
                 <para>
                  Constructs the base class gate object that will be displayed
                  on the spectrum with Xamine id <parameter>nSpectrum</parameter>.
                  The gate id is <parameter>nId</parameter>,
                  and its name is <parameter>rName</parameter>.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>UInt_t </type>
                 <methodname>getSpectrum</methodname>
                 <void />
                 <modifier>const</modifier>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Returns the Xamine Id on which the gate is displayed.
                  Two important differences between Xamine gates and
                  SpecTcl gates.  SpecTcl primitive gates are defined on parameters
                  that are checked.  Xamine gates are displayed on Spectr.
                  Spectra in SpecTcl are identified by a named object
                  <classname>CSpectrum</classname>, Xamine spectra
                  are identified by an integer slot number.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>UInt_t </type>
                 <methodname>getId</methodname>
                 <void />
                 <modifier>const</modifier>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Returns the id of the gate.  The gate id is
                  what identifies the gate to Xamine.
                  The use of gate ids, rather than a named
                  object to identify gates in Xamine is another
                  difference between Xamine gates and SpecTcl
                  gates.
                 </para>
              </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>std::string </type>
                 <methodname>getName</methodname>
                 <void />
                 <modifier>const</modifier>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Returns the name of the gate.  Gate names in Xamine
                  are used for documentation purposes only.
                 </para>
              </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>GateType_t </type>
                 <methodname>getGateType</methodname>
                 <void />
                 <modifier>const</modifier>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Returns the SpecTcl gate type of the gate.
                 </para>
              </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>PointArray </type>
                 <methodname>getPoints</methodname>
                 <void />
                 <modifier>const</modifier>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Returns the array of points that make up the
                  gate shape.  The <type>PointArray</type> type
                  is defined in <filename>Point.h</filename>.
                 </para>
              </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>void </type>
                 <methodname>setId</methodname>
                 <methodparam>
                     <type>UInt_t </type><parameter>am_nId</parameter>
                  <initializer></initializer>
                 </methodparam>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Normally used internally while constructing this type
                  of object from a <type>msg_object</type>, this
                  method sets the Xamine id of the gate.
                 </para>
              </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>void </type>
                 <methodname>setName </methodname>
                 <methodparam>
                     <type>std::string </type><parameter>am_sName</parameter>
                  <initializer></initializer>
                 </methodparam>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Normally used internally while constructing this type
                  of gate from a <type>msg_object</type>, this
                  method sets the Xamine gate name.
                 </para>
              </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>PointIterator </type>
                 <methodname>begin</methodname>
                 <void />
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Returns an iterator to the front of the container
                  that holds the gate points.  The
                  <type>PointIterator</type> type is defined in
                  <filename>Point.h</filename>.
                 </para>
              </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>PointIterator </type>
                 <methodname>end</methodname>
                 <void />
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Returns an iterator just off the end of the
                  container that holds the gate points.
                 </para>
              </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>UInt_t </type>
                 <methodname>size</methodname>
                 <void />
                 <modifier>const</modifier>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Returns the number of points in the container
                  that holds the gate points.
                 </para>
              </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>CPoint&amp;</type>
                 <methodname> operator[] </methodname>
                 <methodparam>
                     <type>UInt_t </type><parameter>n</parameter>
                  <initializer></initializer>
                 </methodparam>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Returns a reference to the <parameter>n</parameter>'th
                  point in the set of points that define the shape of the
                  gate.  <type>CPoint</type> is defined in
                  <filename>Point.h</filename>.  The reference is not const
                  so this allows existig gate points to be modified.
                 </para>
              </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>void </type>
                 <methodname>AddPoint</methodname>
                 <methodparam>
                     <type>const CPoint&amp; </type><parameter>rPoint</parameter>
                  <initializer></initializer>
                 </methodparam>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Adds a new point to the end of the list of points that
                  define the appearance of the gate.
                  <parameter>rPoint</parameter> describes the point
                  to add.
                 </para>
              </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>void </type>
                 <methodname>AddPoint</methodname>
                 <methodparam>
                     <type>int </type><parameter>x</parameter>
                  <initializer></initializer>
                 </methodparam>
                 <methodparam>
                     <type>int</type><parameter> y</parameter>
                  <initializer></initializer>
                 </methodparam>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Adds a point to the end of the points that
                  define the shape of the gate to Xamine.
                  <parameter>x</parameter> and <parameter>y</parameter>
                  are in channel coordinates.  For slices, only the
                  <parameter>x</parameter> matters.
                 </para>
              </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>void </type>
                 <methodname>RemovePoints</methodname>
                 <methodparam>
                     <type>UInt_t </type><parameter>n</parameter>
                  <initializer>1</initializer>
                 </methodparam>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Removes the last <parameter>n</parameter> points
                  from the set of points that define the shape of
                  the gate.
                 </para>
              </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>CDisplayCut*</type>
                 <methodname> Cut</methodname>
                 <void />
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Peforms a type-safe up-cast to the <classname>CDisplayCUt</classname>
                  class. If the gate is not a cut, a null pointer is
                  returned.  Otherwise a pointer to the same object
                  but cast as a <classname>CDisplayCut</classname>*
                 </para>
              </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>CDisplayBand*</type>
                 <methodname> Band </methodname>
                 <void />
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Same as <methodname>Cut</methodname> but up-casts to a
                  <classname>CDisplayBand</classname> pointer.
                 </para>
              </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>CDisplayContour* </type>
                 <methodname>Contour</methodname>
                 <void />
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Same as <methodname>Cut</methodname> but
                  up-casts to a <classname>CDisplayContour</classname>
                  pointer.
                 </para>          
              </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <methodsynopsis>
                 <type>void </type>
                 <methodname>FormatMessageBlock</methodname>
                 <methodparam>
                     <type>msg_object&amp; </type><parameter>rMsg</parameter>
                  <initializer></initializer>
                 </methodparam>
                 <modifier>const</modifier>
              </methodsynopsis>
             </term>
             <listitem>
                 <para>
                  Takes the data in the gate object and
                  writes the Xamine message into <parameter>rMsg</parameter>
                  needed to enter that gate into Xamine.
                 </para>
              </listitem>
          </varlistentry>
          
        </variablelist>
      </refsect1>
      <refsect1>
        <title><classname>CDisplayCut</classname></title>
        <para>
          <classname>CDisplayCut</classname> is a convenience class
          that constructs the base class with parameters appropriate
          to a cut.  Here are the two constructors it supports:
        </para>
        <variablelist>
          <varlistentry>
             <term>
              <constructorsynopsis>
                  <methodname>CDisplayCut</methodname>
                  <methodparam>
                      <type>const msg_object&amp; </type><parameter>rGate</parameter>
                     <initializer></initializer>
                  </methodparam>
              </constructorsynopsis>
             </term>
             <listitem>
               <para>
                Constructs from an Xamine message.  
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <constructorsynopsis>
                  <methodname>CDisplayCut</methodname>
                  <methodparam>
                      <type>UInt_t </type><parameter>nSpectrum</parameter>
                    <initializer></initializer>
                  </methodparam>
                  <methodparam>
                      <type>UInt_t </type><parameter>nId</parameter>
                    <initializer></initializer>
                  </methodparam>
                  <methodparam>
                      <type> const std::string&amp;</type><parameter> rName</parameter>
                    <initializer></initializer>
                  </methodparam>
              </constructorsynopsis>
             </term>
             <listitem>
                 <para>
                 Constructs from
                 <parameter>nSpectrum</parameter>, the Xamine Id  of the
                 spectrum to display the gate,
                 <parameter>nId</parameter> an Id assigned to the gate to
                 identify it, and <parameter>rName</parameter>
                 the name of the gate.
               </para>
               <para>
                  Once constructed, a left and right limit point can
                  be added to define the sape of the gate.
                </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </refsect1>
     <refsect1>
        <title><classname>CDisplayBand</classname></title>
        <para>
            This class represents a band. The ponts in a band
            are a polyline.  In SpecTcl, the gate region of acceptance
            is the region below the gate points.
            Here are the constructors <classname>CDisplayBand</classname>
            offers:
        </para>
        <variablelist>
            <varlistentry>
               <term>
                <constructorsynopsis>
                    <methodname>CDisplayBand</methodname>
                    <methodparam>
                        <type>const msg_object&amp; </type><parameter>rgate</parameter>
                        <initializer></initializer>
                    </methodparam>
                </constructorsynopsis>
               </term>
               <listitem>
                   <para>
                    Constructs the object from the
                    message,
                    <parameter>rgate</parameter>received from Xamine reporting the acceptance
                    of the gate.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <constructorsynopsis>
                    <methodname>CDisplayBand</methodname>
                    <methodparam>
                        <type>UInt_t </type><parameter>nSpectrum</parameter>
                        <initializer></initializer>
                    </methodparam>
                    <methodparam>
                        <type>UInt_t </type><parameter>nId</parameter>
                        <initializer></initializer>
                    </methodparam>
                    <methodparam>
                        <type> const std::string&amp; </type><parameter>rName</parameter>
                        <initializer></initializer>
                    </methodparam>
                </constructorsynopsis>
               </term>
               <listitem>
                   <para>
                    Constructs the band from the
                    <parameter>nSpectrum</parameter>, the id of the
                    spectrum on which it will be displayed,
                    <parameter>nId</parameter>, the id of the gate
                    and <parameter>rName</parameter>, the name of the
                    gate.  
                   </para>
                   <para>
                    Once constructed, points must be added. A band is defined by at
                    least two points (a line segment). In general, for a band,
                    the points should be strictly monotonically increasing in
                    x coordinate.
                   </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title><classname>CDisplayContour</classname></title>
        <para>
            This class captures a contour.  A contour is a closed polygon.
            The polygon is closed by drawing a line segment connecting the last
            point to the first point.  For SpecTcl the gate acceptance region
            is the set of points such that a line drawn from that point
            to infinity in any direction crosses an odd number of line segments
            that make up the polygon.  This allows for a consistent definition
            of the interior of arbitratily pathalogical polygons.
        </para>
        <para>
            The constructors are essentially the same as for
            <classname>CDisplayBand</classname>.
        </para>
    </refsect1>
  </refentry>
  <refentry>
     <refmeta>
        <refentrytitle>XamineButton</refentrytitle>
        <manvolnum>3SpecTcl</manvolnum>
     </refmeta>
     <refnamediv>
        <refname>XamineButton</refname>
        <refpurpose>Describe a client button</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
        <programlisting>
#include &lt;XamineButton.h&gt;
#include &lt;clientops.h&gt;

class CXamineButton      
{

public:
  CXamineButton (  int am_nReturnCode,  
		   const std::string&amp; am_sLabel,  
		   Bool_t am_fEnabled,  
		   ButtonSensitivity am_eWhenSensitive,
		   CXamineButtonPrompt&amp; rPrompter);
  CXamineButton(  int am_nReturnCode,  
		   const char* pLabel,  
		   Bool_t am_fEnabled,  
		   ButtonSensitivity am_eWhenSensitive,
		   CXamineButtonPrompt&amp; rPrompter);

  int getReturnCode() const;
  const std::string&amp; getLabel() const;
  Bool_t getEnabled() const;
  ButtonSensitivity getWhenSensitive();
  CXamineButtonPrompt* getPrompter() const;
  
  virtual   void FormatMessageBlock (ButtonDescription&amp; rButton) const  ;
  virtual   CXaminePushButton*   PushButton();   // Type safe upcasts
  virtual   CXamineToggleButton* ToggleButton(); // Type safe upcasts.
};

        </programlisting>
      </refsynopsisdiv>
      <refsect1>
             <title>DESCRIPTION</title>
            <para>
              <classname>XamineButton</classname> is used to describe
              Xamine client buttons.  Xamine can display a box of buttons
              that, when pressed, simply send messages to the client.
              Actual buttons come in two shapes, push buttons and toggle buttons.
            </para>
            <para>
                Buttons can also have prompters associated with them.
                If a button has a prompter, Xamine will interact via that
                prompter with the user to gather additional data to be
                fed back to the application.
                For example, a prompter might request that points be
                accepted on a spectrum which, on acceptance cause the points and
                the spectrum id to be included in the message to the client.
            </para>
            <para>
                Finally buttons can also have sensitivity specifications.
                These determine when a button is enabled by Xamine,
                for example, a Fit button might only be enabled if a
                1-d spectrum is currently selected by Xamine.
            </para>
      </refsect1>
      <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
               <term>
                <constructorsynopsis>
                    <methodname>CXamineButton </methodname>
                    <methodparam>
                        <type>int </type><parameter>am_nReturnCode</parameter>
                        <initializer></initializer>
                    </methodparam>
                    <methodparam>
                        <type>const std::string&amp; </type><parameter>am_sLabel</parameter>
                        <initializer></initializer>
                    </methodparam>
                    <methodparam>
                        <type>Bool_t </type><parameter>am_fEnabled</parameter>
                        <initializer></initializer>
                    </methodparam>
                    <methodparam>
                        <type>ButtonSensitivity </type><parameter>am_eWhenSensitive</parameter>
                        <initializer></initializer>
                    </methodparam>
                    <methodparam>
                        <type>CXamineButtonPrompt&amp; </type><parameter>rPrompter</parameter>
                        <initializer></initializer>
                    </methodparam>
                </constructorsynopsis>
               </term>
               <listitem>
                   <para>
                    Constructs a button object.  Note that the button
                    object just describes the button. Once created it must
                    be entered into Xamine.
                    <parameter>am_nReturnCode</parameter> is the button code
                    that will be included in the event message Xamine sends
                    to the client when the button is pressed. Each button should
                    be given a unique code.
                    <parameter>am_sLabel</parameter> is the text Xamine
                    should painto n the button.  <parameter>am_fEnabled</parameter>
                    should be <literal>true</literal> if the button is
                    enabled or <literal>false</literal> if not.
                   </para>
                   <para>
                    Buttons have two levels of enable.  The first level is
                    determined by the enable state (initially the value
                    of <parameter>am_fEnabled</parameter>).  If this
                    is <literal>false</literal>, the button cannot be
                    clicked by the user.  Even if enabled, the button
                    might have a sensitivity (<parameter>am_eWhenSensitive</parameter>),
                    which further determines when a button can be used based
                    on the state of Xamine.    The values that the
                    <type>ButtonSensitivity</type> enumerated type
                    can take are defined in <filename>clientops.h</filename>.
                   </para>
                   <para>
                    <parameter>rPrompter</parameter> is a reference
                    to a prompting object that determines what, if any
                    prompting Xamine will do before returning a button
                    message to the client program.  
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <constructorsynopsis>
                    <methodname> CXamineButton(</methodname>
                    <methodparam>
                        <type>  int </type><parameter>am_nReturnCode</parameter>
                        <initializer></initializer>
                    </methodparam>
                    <methodparam>
                        <type>const char* </type><parameter>pLabel</parameter>
                        <initializer></initializer>
                    </methodparam>
                    <methodparam>
                        <type>Bool_t </type><parameter>am_fEnabled</parameter>
                        <initializer></initializer>
                    </methodparam>
                    <methodparam>
                        <type>ButtonSensitivity </type><parameter>am_eWhenSensitive</parameter>
                        <initializer></initializer>
                    </methodparam>
                    <methodparam>
                        <type>CXamineButtonPrompt&amp; </type><parameter>rPrompter</parameter>
                        <initializer></initializer>
                    </methodparam>
                </constructorsynopsis>
               </term>
               <listitem>
                   <para>
                    Same as above but the button label string is passed
                    as a <type>const char*</type>.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <methodsynopsis>
                   <type>int </type>
                   <methodname>getReturnCode</methodname>
                   <void />
                   <modifier>const</modifier>
                </methodsynopsis>
               </term>
               <listitem>
                   <para>
                    Returns the return code of the button. This
                    code uniquely idenfies the button both to Xamine
                    and to the client when being told which button
                    was clicked in a button event.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <methodsynopsis>
                   <type>const std::string&amp; </type>
                   <methodname>getLabel</methodname>
                   <void />
                   <modifier>const</modifier>
                </methodsynopsis>
               </term>
               <listitem>
                   <para>
                    Returns the string that's used to label
                    the button.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <methodsynopsis>
                   <type>Bool_t </type>
                   <methodname>getEnabled</methodname>
                   <void></void>
                   <modifier>const</modifier>
                </methodsynopsis>
               </term>
               <listitem>
                   <para>
                    Returns the enabled flag from the object.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <methodsynopsis>
                   <type> ButtonSensitivity </type>
                   <methodname>getWhenSensitive</methodname>
                   <void />
                   <modifier>const</modifier>
                </methodsynopsis>
               </term>
               <listitem>
                   <para>
                    Returns the selector that describes when the
                    button is sensitive if enabled.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <methodsynopsis>
                   <type>CXamineButtonPrompt* </type>
                   <methodname>getPrompter</methodname>
                   <void />
                   <modifier>const</modifier>
                </methodsynopsis>
               </term>
               <listitem>
                   <para>
                    Returns a pointer to the button prompter object.
                    Note that while this method is const the pointer
                    returned is to the object's prompter allowing
                    modifications to be made by the caller.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <methodsynopsis>
                   <type> virtual   void </type>
                   <methodname>FormatMessageBlock</methodname>
                   <methodparam>
                       <type>ButtonDescription&amp; </type><parameter>rButton</parameter>
                    <initializer></initializer>
                   </methodparam>
                </methodsynopsis>
               </term>
               <listitem>
                   <para>
                    Formats the message required to define the button
                    to Xamine.  The formatted message is placed in
                    <parameter>rButton</parameter>.
                   </para>
                            </listitem>
            </varlistentry>
        </variablelist>
        <para>
            In addition, two methods are provided to perform
            type-safe upcasts:  <methodname>PushButton</methodname>
            and <methodname>ToggleButton</methodname> wich
            return pointers to <classname>CXaminePushButton</classname>
            and <classname>CXamineToggleButton</classname>
            respectively.  These methods return null pointers if the
            cast is not correct.  Note that the ponters point to the
            original object, making these actual cast-like operations.
      </para>

      </refsect1>
  </refentry>
<refentry>
   <refmeta>
      <refentrytitle>CXamineButtonPrompt</refentrytitle>
      <manvolnum>3SpecTcl</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>CXamineButtonPrompt</refname>
      <refpurpose>Base class for button prompter descriptions</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <programlisting>
#include &lt;XamineButtonPrompt.h&gt;

class CXamineButtonPrompt      
{
  
public:

  CXamineButtonPrompt (const std::string&amp; am_sPromptString  );
  CXamineButtonPrompt(const char* pPrompt);
  

  std::string getPromptString() const;
 
  virtual   void FormatPrompterBlock(ButtonDescription&amp; rButton) const   = 0;
};

        </programlisting>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
          <para>
            <classname>CXamineButtonPrompt</classname> is an abstract base
            class that's used to describe prompting that Xamine must do
            prior to dispatching a button event to the client.
            The prompter is specified as part of the button definition
            message sent to Xamine.  Prompters have a string associated
            with them, and this string is maintained by this base class.
          </para>
          <para>
            The point of this class hierarchy is to provide the
            <methodname>FormatPrompterBlock</methodname> method
            interface definition.  In concrete subclasses, this method
            is expected to fill in the part of a
            <type>ButtonDescription</type> structure that pertains
            to describing the button prompter.
          </para>
    </refsect1>
</refentry>
<refentry>
   <refmeta>
      <refentrytitle>CXamineNoPrompt</refentrytitle>
      <manvolnum>3SpecTcl</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>CXamineNoPrompt</refname>
      <refpurpose>Prompter that does not prompt</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <programlisting>
class CXamineNoPrompt  : public CXamineButtonPrompt        
{
  
public:
  CXamineNoPrompt ();  
  virtual   void FormatPrompterBlock (ButtonDescription&amp; rPrompt) const  ;

  
 
};
        </programlisting>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTON</title>
          <para>
            This button prompter should be used when an Xamine client
            button does not require any prompting from Xamine
            Buttons with this prompter attached will simply send their
            button message immediately to the client when clicked.
          </para>
    </refsect1>
</refentry>
   <refentry>
      <refmeta>
         <refentrytitle>CXamineConfirmPrompt</refentrytitle>
         <manvolnum>3SpecTcl</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CXamineConfirmPrompt</refname>
         <refpurpose>Prompt for confirmation</refpurpose>
       </refnamediv>
       <refsynopsisdiv>
        <programlisting>
#include &lt;XamineConfirmPrompt.h&gt;


class CXamineConfirmPrompt  : public CXamineButtonPrompt        
{
  
public:

  CXamineConfirmPrompt (const std::string&amp; rPrompt );
  CXamineConfirmPrompt(const char* pPrompt);
  virtual void FormatPrompterBlock (ButtonDescription&amp; rButton) const  ;
 
};
        </programlisting>
       </refsynopsisdiv>
       <refsect1>
             <title>DESCRIPTION</title>
             <para>
               <classname>CXamineConfirmPrompt</classname>
               simply uses its prompt string to ask the user if
               they are certain they want to perform the action
               requested by the button.  If the usr declines,
               no message is sent.  One use case is, for example,
               if you provide a button to clear the contents of the
               selected spectrum, you might want to give the user a
               chance to consider if they really want to do that.
             </para>
       </refsect1>
   </refentry>
<refentry>
   <refmeta>
      <refentrytitle>CXamineTextPrompt</refentrytitle>
      <manvolnum>3SpecTcl</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>CXamineTextPrompt</refname>
      <refpurpose>Prompt for a text string</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <programlisting>
#include &lt;XamineTextPrompt.h&gt;

class CXamineTextPrompt  : public CXamineButtonPrompt        
{
  
public:

			//Constructor with arguments

  CXamineTextPrompt (const std::string&amp; rPrompt);
  CXamineTextPrompt(const char* pPrompt) ;
  virtual   void FormatPrompterBlock (ButtonDescription&amp; rButton) const  ;
 
};


        </programlisting>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
          <para>
            Encapsulates a string prompter.  When a button requesting
            a string prompter is clicked, the prompt string is
            treated as prompting text for free form string input.
            When the string is accepted, it is passed to the client in
            the button event message.
          </para>
    </refsect1>
</refentry>
<refentry>
   <refmeta>
      <refentrytitle>CXamineSpectrumPrompt</refentrytitle>
      <manvolnum>3SpecTcl</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>CXamineSpectrumPrompt</refname>
      <refpurpose>Prompt for a spectrum</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <programlisting>
#include &lt;XamineSpectrumPrompt.h&gt;
#include &lt;clientops.h&gt;

class CXamineSpectrumPrompt  : public CXamineButtonPrompt        
{
  
public:

  CXamineSpectrumPrompt (const std::string&amp; rPrompt,
			 DialogSpectrumType_t am_eSpectrumType = keAny);
  CXamineSpectrumPrompt(const char* pPrompt,
			DialogSpectrumType_t eSpectrumType = keAny);
            
  int getSpectrumType() const;
  
  virtual   void FormatPrompterBlock (ButtonDescription&amp; rButton) const  ;
 
};

        </programlisting>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            <classname>CXamineSpectrumPrompt</classname> when
            attached to a button, prompts the user to select a
            spectrum from a spectrum chooser dialog prior to
            sending the button event message.  The selected
            spectrum is sent in the message.
          </para>
          <para>
            The <type>DialogSpectrumType_t</type> is defined in
            <filename>histotypes.h</filename>.  It provides
            for the list of spectra in the chooser to be filtered
            by types.  The default <literal>keAny</literal>
            does no filtering.
          </para>
          <para>
            Note that <methodname>getSpectrumType</methodname>
            actuall returns a <type>DialogSpectrumType_t</type> and
            may at some later version be modified to do exactly that.
          </para>
    </refsect1>
</refentry>
   <refentry>
      <refmeta>
         <refentrytitle>CXamineFilePrompt</refentrytitle>
         <manvolnum>3SpecTcl</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CXamineFilePrompt</refname>
         <refpurpose>Prompt for a filename.</refpurpose>
       </refnamediv>
       <refsynopsisdiv>
        <programlisting>
#include &lt;XamineFilePrompt.h&gt;

class CXamineFilePrompt  : public CXamineButtonPrompt        
{
  
public:

  CXamineFilePrompt (const std::string&amp; rPrompt);
  CXamineFilePrompt(const char* pPrompt);
                       
  virtual   void FormatPrompterBlock (ButtonDescription&amp; rButton) const  ;
 
};

        </programlisting>
       </refsynopsisdiv>
       <refsect1>
             <title>DESCRIPTION</title>
             <para>
               Xamine buttons that have this propmter, prompt
               for a filename using a file prompter prior to
               dispatching the button event messgae to the client.
               Note that the name selected will be sent in the message.
             </para>
       </refsect1>
   </refentry>
<refentry>
   <refmeta>
      <refentrytitle>CXaminePointsPrompt</refentrytitle>
      <manvolnum>3SpecTcl</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>CXaminePointsPrompt</refname>
      <refpurpose>Prompt for points</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <programlisting>
#include &lt;XaminePointsPrompt.h&gt;

class CXaminePointsPrompt  : public CXamineButtonPrompt        
{
  
public:

  CXaminePointsPrompt (const std::string&amp; rPrompt, 
		       UInt_t nMinPoints = 1,
		       UInt_t nMaxPoints = GROBJ_MAXPTS);
  CXaminePointsPrompt(const char* pPrompt,
		      UInt_t nMinPoints = 1,
		      UInt_t nMaxPoints = GROBJ_MAXPTS);
  int getMinPoints() const;
  int getMaxPoints() const;
  virtual   void FormatPrompterBlock (ButtonDescription&amp; rButton) const  ;
 
};

        </programlisting>
    </refsynopsisdiv>
    <refsect1>
         <title>DESCRIPTION</title>
          <para>
            Buttons that have <classname>CXaminePointsPrompt</classname>
            attached as a prompter will prompt the user to select
            points from a spectrum prior to posting the button
            event message.  The spectrum id and the point coordinates
            are passed back to the client.
            The <parameter>nMinPoints</parameter> specifies a minimum
            number of points that must be selected and
            <parameter>nMaxPoints</parameter> a maximum number of
            points that can be accepted.
          </para>
    </refsect1>
</refentry>
   <refentry>
      <refmeta>
         <refentrytitle>CXamineEvent</refentrytitle>
         <manvolnum>3SpecTGcl</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CXamineEvent</refname>
         <refpurpose>Encapsulate events from Xamine.</refpurpose>
       </refnamediv>
       <refsynopsisdiv>
        <programlisting>
#include &lt;XamineEvent.h&gt;

class CXamineEvent      
{
  
public:
  CXamineEvent(); 
				       
  CXamineEvent (  msg_XamineEvent am_EventData  );

  const msg_XamineEvent&amp; getm_EventData() const;

   CXamineGate* GateCast ()  ;
   CButtonEvent* ButtonCast ()  ;
 
};

        </programlisting>
       </refsynopsisdiv>
       <refsect1>
             <title>DESCRIPTION</title>
             <para>
               <classname>CXamineEvent</classname> encapsulates
               the messages Xamine sends to report events to the client.
               Currently there are two such event types:
             </para>
             <variablelist>
                <varlistentry>
                   <term><literal>Gate acceptance</literal></term>
                   <listitem>
                       <para>
                        Inidicates a user has accepted a gate drawnon a spectrum.
                        This event is encapsulated by the
                        <classname>CXamineGate</classname> class
                        documented previously
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>Client button events</literal></term>
                   <listitem>
                       <para>
                        Indicates a user has clicked a button on the user
                        defined button box and successfully navigated
                        any attached prompter.  This event is
                        encapsulated by the <classname>CButtoneVENT</classname>
                        class documented next.
                       </para>
                    </listitem>
                </varlistentry>
             </variablelist>
             <para>
                The base class is just a holder of the event message.
                <methodname>GateCast</methodname> and
                <methodname>ButtonCast</methodname> construct dynamically
                allocated <classname>CXamineGate</classname> and
                <classname>CButonEvent</classname> objects respectively
                from the object in a type-safe way.  If the underlying message
                is not of the appropriate sort, these methods return
                a null pointer.  Once the application no longer needs
                the pointes returned from these methods, it should
                delete the objects they point to.
             </para>
       </refsect1>
   </refentry>
   <refentry>
      <refmeta>
         <refentrytitle>CButtonEvent</refentrytitle>
         <manvolnum>3SpecTcl</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CButtonEvent</refname>
         <refpurpose>Encapsulate button press events</refpurpose>
       </refnamediv>
       <refsynopsisdiv>
        <programlisting>
#include &lt;ButtonEvent.h&gt;

class CButtonEvent      
{
  
public:

  CButtonEvent(const msg_ButtonPress&amp; rButtonInfo);

  Int_t getId() const;
  Int_t getCurrentSpectrum() const;
  Bool_t getToggleState() const;
  Int_t getPromptedSpectrum() const;
  std::string getm_sPromptedString() const;
  
  const PointArray&amp; getPoints() const;
  PointIterator begin ();
  PointIterator end ();
  UInt_t size ();
  const CPoint&amp; operator[] (UInt_t nI)  const;
 
};

        </programlisting>
       </refsynopsisdiv>
       <refsect1>
             <title>
                DESCRIPTION
             </title>
             <para>
               Button press events are sent by Xamine when
               a user button has been clicked and any prompters successfully
               navigated by the user.  The <classname>CButtonEvent</classname>
               class can be instantiated on a button press message and
               decodes/makes available the pertinent information in the
               event.  Note that to know what to pull out of the event, the
               software must know prompter type was used to create the button.
             </para>
       </refsect1>
       <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
               <term>
                <constructorsynopsis>
                    <methodname>CButtonEvent</methodname>
                    <methodparam>
                        <type>const msg_ButtonPress&amp;</type><parameter> rButtonInfo</parameter>
                        <initializer></initializer>
                    </methodparam>
                </constructorsynopsis>
               </term>
               <listitem>
                   <para>
                    Constructs the object from the raw button
                    press event received from Xamine.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <methodsynopsis>
                   <type>Int_t </type>
                   <methodname>getId() </methodname>
                   <void />
                   <modifier>const</modifier>
                </methodsynopsis>
               </term>
               <listitem>
                   <para>
                    Retrieves the id of the button that was pressed to
                    create this ievent.  The button Id is how you determine
                    which button was clicked.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <methodsynopsis>
                   <type>Int_t </type>
                   <methodname>getCurrentSpectrum</methodname>
                   <void />
                   <modifier>const</modifier>
                </methodsynopsis>
               </term>
               <listitem>
                   <para>
                    Returns the Xamine id of the currently selected
                    spectrum.  <literal>-1</literal> is
                    returned if there is no currently selected spectrum.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <methodsynopsis>
                   <type>Bool_t </type>
                   <methodname>getToggleState</methodname>
                   <void />
                   <modifier>const</modifier>
                </methodsynopsis>
               </term>
               <listitem>
                   <para>
                    If the button is a toggle button, returns the
                    state of the toggle. <literal>kfTRUE</literal>
                    means that the toggle is lit up.  This method
                    does not return a meaningful result if the
                    button was not a toggle button.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <methodsynopsis>
                   <type>Int_t </type>
                   <methodname>getPromptedSpectrum</methodname>
                   <void />
                   <modifier>const</modifier>
                </methodsynopsis>
               </term>
               <listitem>
                   <para>
                    If the button has a spectrum prompter associated
                    with it, the Xamine id of the selected spectrum is
                    returned.  This method does not return a meaningful
                    result if the button does not use a spectrum
                    prompter.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <methodsynopsis>
                   <type>std::string </type>
                   <methodname>getm_sPromptedString</methodname>
                   <void />
                   <modifier>const</modifier>
                </methodsynopsis>
               </term>
               <listitem>
                   <para>
                    Returns the string prompt value.  This is for both
                    the string prompter and the filename prompter
                    (in which case it's the path of the selected filename).
                    If the prompter does not return a string value, the
                    return value of this method is not meaningful.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <methodsynopsis>
                   <type>const PointArray&amp; </type>
                   <methodname>getPoints</methodname>
                   <void />
                   <modifier>const</modifier>
                </methodsynopsis>
               </term>
               <listitem>
                   <para>
                    If the button had a point prompter associated with it,
                    the points clicked in by the user are returned.
                    See <filename>Point.h</filename> for type
                    definitions in this and other point methods.
                   </para>
                   <para>
                    No guarantees are provided for the results of this
                    method if the button did not have a point prompter (e.g.
                    don't assume the points array is empty).
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <methodsynopsis>
                   <type>PointIterator </type>
                   <methodname>begin</methodname>
                   <void />
                </methodsynopsis>
               </term>
               <listitem>
                   <para>
                    Returns an iterator to the
                    front of the container that holds
                    the points inputted by the user in response to
                    a point prompter.  If the button did not use
                    a point prompter, while this may be a valid
                    iterator, the contents of the container are
                    not well defined.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <methodsynopsis>
                   <type>PointIterator </type>
                   <methodname>end</methodname>
                   <void />
                </methodsynopsis>
               </term>
               <listitem>
                   <para>
                    Returns an iterator off the end of the
                    points container.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <methodsynopsis>
                   <type>UInt_t </type>
                   <methodname>size</methodname>
                   <void />
                </methodsynopsis>
               </term>
               <listitem>
                   <para>
                    Returns the number of elements in the points
                    container.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <methodsynopsis>
                   <type>const CPoint&amp; </type>
                   <methodname>operator[] </methodname>
                   <methodparam>
                       <type>UInt_t </type><parameter>nI</parameter>
                    <initializer></initializer>
                   </methodparam>
                   <modifier> const</modifier>
                </methodsynopsis>
               </term>
               <listitem>
                   <para>
                    Returns a readonly reference to the point
                    index <parameter>nI</parameter>.
                   </para>
                </listitem>
            </varlistentry>
  
        </variablelist>
       </refsect1>
   </refentry>
     <refentry>
      <refmeta>
         <refentrytitle>CDisplayInterface</refentrytitle>
         <manvolnum>3SpecTcl</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CDisplayInterface</refname>
         <refpurpose>Manages displayers</refpurpose>
       </refnamediv>
       <refsynopsisdiv>
        <programlisting>
#include &lt;DisplayInterface.h&gt;

class CDisplayInterface
{
public:
    enum Result { DISPLAY_EXISTS, NO_CREATOR, SUCCESS };


public:
    CDisplayInterface();
    
    Result createDisplay(const std::string&amp; name, const std::string&amp; type);
    CDisplay* getDisplay(const std::string&amp; name);
    CDisplay* getCurrentDisplay();
    bool      setCurrentDisplay(const std::string&amp; name);
    const CDisplayCollection&amp; getCollection() const;
    CDisplayFactory&amp; getFactory() ;

};
        </programlisting>
       </refsynopsisdiv>
       <refsect1>
             <title>DESCRIPTION</title>
             <para>
               SpecTcl maintains a <classname>CDisplayInterface</classname>
               object.  This object understands all of the display types
               and how, via a <classname>CDisplayFactory</classname>
               it encapsulates, to create instances.  In addition,
               the interface has the concept of a
               <firstterm>current display</firstterm>.  This is an instance
               of a <classname>CDisplay</classname> that is SpecTcl's current
               display engine.
             </para>
             <para>
                This class is closely allies with <classname>SpecTclDisplayManager</classname>
                which is derived from it (see <filename>SpecTclDisplayManager.h</filename>),
                and, when instantiated, stocks the display factory with
                an appropriate set of creator objects so that all of the
                 known display types can be instantiated.
             </para>
             <para>
                Adding another display is really  a matter of adding a
                new <classname>CDisplay</classname> descendent to implement
                the interface between that displayer and SpecTcl,
                write a creator for that displayer and either by
                modifying <filename>SpecTclDisplayManager.cpp</filename>
                if you are an internals programmer or adding the
                desired display type to the factory if this is
                a user written displayer.
             </para>
       </refsect1>
       <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
               <term>
                <methodsynopsis>
                   <type>Result </type>
                   <methodname>createDisplay</methodname>
                   <methodparam>
                       <type>const std::string&amp; </type><parameter>name</parameter>
                    <initializer></initializer>
                   </methodparam>
                   <methodparam>
                       <type>const std::string&amp; </type><parameter>type</parameter>
                    <initializer></initializer>
                   </methodparam>
                </methodsynopsis>
               </term>
               <listitem>
                   <para>
                    Creates a display of type <parameter>type</parameter>,
                    assigns it the name <parameter>name</parameter>
                    and remembers it so that it can be later selected,
                    or set ast the current display.
                   </para>
                   <para>
                    The factory is consulted for a creator for the display
                    type <parameter>type</parameter>.  The creator is then used
                    to create the displayer which is registered within
                    this object.
                   </para>
                   <para>
                    <type>CDisplayInterface::Result</type>  is an enumerated type
                    that returns the status of this method. Returned values
                    are one of
                   </para>
                   <variablelist>
                    <varlistentry>
                       <term><literal>CDisplayInterface::DISPLAY_EXISTS</literal></term>
                       <listitem>
                           <para>
                            If a display named <parameter>name</parameter>
                            has already been created, regardless of its
                            type.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>CDisplayInterface::NO_CREATOR</literal></term>
                       <listitem>
                           <para>
                            If the factor does not know how to create
                            a displayer of type <parameter>type</parameter>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>CDisplayInterface::SUCCESS</literal></term>
                       <listitem>
                           <para>
                            If all went well.
                           </para>
                        </listitem>
                    </varlistentry>
                   </variablelist>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <methodsynopsis>
                   <type>CDisplay*</type>
                   <methodname> getDisplay</methodname>
                   <methodparam>
                       <type>const std::string&amp; </type><parameter>name</parameter>
                    <initializer></initializer>
                   </methodparam>
                </methodsynopsis>
               </term>
               <listitem>
                   <para>
                    Looks up the named display that was created/registered
                    via <methodname>createDisplay</methodname>.
                    If there is no matching display object,
                    <literal>nullptr</literal> is returned.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <methodsynopsis>
                   <type>CDisplay* </type>
                   <methodname>getCurrentDisplay</methodname>
                   <void />
                </methodsynopsis>
               </term>
               <listitem>
                   <para>
                    Returns a pointer to the current display
                    or <literal>nullptr</literal> if no current display
                    as been established.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <methodsynopsis>
                   <type>bool      </type>
                   <methodname>setCurrentDisplay</methodname>
                   <methodparam>
                       <type>const std::string&amp;</type><parameter> name</parameter>
                    <initializer></initializer>
                   </methodparam>
                </methodsynopsis>
               </term>
               <listitem>
                   <para>
                    Sets the current display to be the display
                    named by <parameter>name</parameter>.  This
                    display must have already been created via
                    <methodname>createDisplay</methodname>.
                    Note that <parameter>name</parameter>
                    refers to the display <emphasis>name</emphasis>
                    not type.
                   </para>
                   <para>
                    If no display with the requested name has been
                    created, the method returns
                    <literal>false</literal>, other wise it returns
                    <literal>true</literal>.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <methodsynopsis>
                   <type>const CDisplayCollection&amp; </type>
                   <methodname>getCollection</methodname>
                   <void />
                   <modifier>const</modifier>
                </methodsynopsis>
               </term>
               <listitem>
                   <para>
                    Returns a reference to the display collection.
                    This is the container that has the set of
                    created display.  It will be described later.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <methodsynopsis>
                   <type>CDisplayFactory&amp; </type>
                   <methodname>getFactory</methodname>
                   <void />
                </methodsynopsis>
               </term>
               <listitem>
                   <para>
                    Returns a modifiable reference to the
                    display factory.  This allows additional
                    display creators to be registered by
                    purely user level code, supporting user
                    written displayers.
                   </para>
                </listitem>
            </varlistentry>
        </variablelist>        
       </refsect1>
   </refentry>
   <refentry>
      <refmeta>
         <refentrytitle>CDisplayCollection</refentrytitle>
         <manvolnum>3SpecTcl</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CDisplayCollection</refname>
         <refpurpose>Maintain a named set of display objects.</refpurpose>
       </refnamediv>
       <refsynopsisdiv>
        <programlisting>
#include &lt;DisplayCollection.h&gt;

class CDisplayCollection
{

public:
    CDisplayCollection();
    bool displayExists(CDisplay* pDisplay);
    void addDisplay(CDisplay* pDisplay);
    void removeDisplay(CDisplay* pDisplay);
    CDisplay* getCurrentDisplay();
    void      setCurrentDisplay(CDisplay* pDisplay);

    Iterator begin();
    Iterator end();
    size_t size();
};


        </programlisting>
       </refsynopsisdiv>
       <refsect1>
             <title>DESCRIPTION</title>
             <para>
               Keeps a named set of objects. Normally
               this is encapsulated in a
               <classname>CDisplayInterface</classname> object which
               marries it to a factory used to create new display
               objects and scheme to associate names with displays.
             </para>
             <para>
                <classname>CDisplayCollection</classname>
                objects have a concept of a current
                displayer.
             </para> 
       </refsect1>
       <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
               <term>
                <methodsynopsis>
                   <type>bool </type>
                   <methodname>displayExists</methodname>
                   <methodparam>
                       <type>CDisplay* </type><parameter>pDisplay</parameter>
                    <initializer></initializer>
                   </methodparam>
                </methodsynopsis>
               </term>
               <listitem>
                   <para>
                    Returns <literal>true</literal> if the display
                    pointed to by <parameter>pDisplay</parameter>
                    is present in the collection.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <methodsynopsis>
                   <type>void </type>
                   <methodname>addDisplay(</methodname>
                   <methodparam>
                       <type>CDisplay* </type><parameter>pDisplay</parameter>
                    <initializer></initializer>
                   </methodparam>
                </methodsynopsis>
               </term>
               <listitem>
                   <para>
                    Adds the display pointed to by <parameter>pDisplay</parameter>'
                    to the collection.  Note that:
                   </para>
                   <orderedlist>
                    <listitem>
                       <para>
                          The actual display object must remain in scope for the
                          lifetime of the collection as no copy is made.
                       </para>
                    </listitem>
                    <listitem>
                       <para>
                          Adding a duplicate entry is silently ignored
                          (that is the collection will still hold only
                          one copy of the pointer).
                       </para>
                    </listitem>
                   </orderedlist>
                </listitem>
               
            </varlistentry>
            <varlistentry>
               <term>
                <methodsynopsis>
                   <type>void </type>
                   <methodname>removeDisplay</methodname>
                   <methodparam>
                       <type>CDisplay* </type><parameter>pDisplay</parameter>
                    <initializer></initializer>
                   </methodparam>
                </methodsynopsis>
               </term>
               <listitem>
                   <para>
                    Removes <parameter>pDisplay</parameter> from the
                    collection. If the display does not exist
                    this silently does nothing.  If the display
                    is current, the state of the system is set so that
                    there is no current display.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <methodsynopsis>
                   <type>CDisplay*</type>
                   <methodname> getCurrentDisplay</methodname>
                   <void />
                </methodsynopsis>
               </term>
               <listitem>
                   <para>
                    Returns a pointer to the current display.
                    If there is no current display,
                    <literal>nullptr</literal> is returned.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <methodsynopsis>
                   <type>void      </type>
                   <methodname>setCurrentDisplay</methodname>
                   <methodparam>
                       <type>CDisplay* </type><parameter>pDisplay</parameter>
                    <initializer></initializer>
                   </methodparam>
                </methodsynopsis>
               </term>
               <listitem>
                   <para>
                    Sets the current display to
                    <parameter>pDisplay</parameter>.
                    If <parameter>pDisplay</parameter> is not in the
                    collection, it is added.  If pDisplay
                    is null, a
                    <classname>std::runtime_error</classname> is thrown.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <methodsynopsis>
                   <type>Iterator </type>
                   <methodname>begin</methodname>
                   <void />
                </methodsynopsis>
               </term>
               <listitem>
                   <para>
                    Begin iterator.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <methodsynopsis>
                   <type>Iterator</type>
                   <methodname> end</methodname>
                   <void />
                </methodsynopsis>
               </term>
               <listitem>
                   <para>
                    Returns an end iterator.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <methodsynopsis>
                   <type>size_t </type>
                   <methodname>size</methodname>
                   <void />
                </methodsynopsis>
               </term>
               <listitem>
                   <para>
                    Returns the number of elements in the collection
                   </para>
                </listitem>
            </varlistentry>
        </variablelist>
       </refsect1>
   </refentry>   
</part>
</book>
