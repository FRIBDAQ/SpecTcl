<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                      "file:///usr/share/xml/docbook/schema/dtd/4.5/docbookx.dtd
"
>
<book>
    <bookinfo>
      <title>SpecTcl Programming Guide.</title>
      <author><firstname>Ron</firstname><surname>Fox</surname></author>
      <revhistory>
          <revision>
             <revnumber>1.0</revnumber>
             <date>June 12, 2017 and following</date>
             <authorinitials>RF</authorinitials>
             <revremark>Original Release</revremark>
          </revision>
      </revhistory>
    </bookinfo>

<chapter>
    <title>Introduction</title>
    <para>
        This book is intended to cover several topics people programming
        within the SpecTcl histogramming framework might need.  The intended audience
        are those who might be tailoring SpecTcl to analyze the data from a
        specific experiment from the NSCLDAQ as well as those who may want to
        go further.  This guide is intended to be used in conjunction with the
        programming reference manual which provides detailed class reference
        information for the key classes.
    </para>
    <para>
        Topics we are going to consider in this manual include:
    </para>
    <variablelist>
        <varlistentry>
            <term>
                <link linkend='chap.processingmodel' endterm='chap.processingmodel.title' />
            </term>
            <listitem>
                <para>
                    Which covers the processing model used by SpecTcl.  This will
                    be covered in a bit greater detail than in the user guide.
                    Understanding this model, and where to attach your code
                    to it can be important to following the path of least resistance
                    in accomplishing your programming goals.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <link linkend='chap.eventprocessingpipeline' endterm='chap.eventprocessingpipeline.title' />
            </term>
            <listitem>
                <para>
                    The event processing pipeline is the set of objects that
                    transform raw events into parameters that SpecTcl processes.
                    We'll take a look at this and describe how to write event
                    process pipeline elements as well as how to prepare SpecTcl
                    to anlyze filtered data.  Along the way the SpecTclAPI object
                    will be introduced.  It provides stable interfaces to several
                    important subsystems of SpecTcl
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <link linkend='chap.eventsinkpipeline' endterm='chap.eventsinkpipeline.title' />
            </term>
            <listitem>
                <para>
                    The event sink pipeline takes over where the event
                    processing pipeline leaves off.  It performs all processing
                    on the unpacked event.  The built in processing includes
                    Histograming and processing any filters that are active.
                    You can, however, hook your own code to the event sink
                    pipeline.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <link linkend='chap.addingcommands' endterm='chap.addingcommands.title' />
            </term>
            <listitem>
                <para>
                    SpecTcl uses the Tcl scripting language as its base command
                    language.  There are cases where adding a compiled command
                    to SpecTcl is useful.  This chapter introduces the
                    Tcl++ C++ wrapping of the Tcl interpreter and how to use
                    it to add commands and interface with other interpreter
                    elements.
                </para>
            </listitem>
        </varlistentry>
        
        <varlistentry>
            <term>
                <link linkend='chap.spectrumfileformat' endterm='chap.spectrumfileformat.title' />
            </term>
            <listitem>
                <para>
                    The SpecTcl <command>sread</command> and <command>swrite</command>
                    commands write spectra to file.  They have a
                    <option>-format</option> option that determines the format
                    in which spectra are written.    This chapter describes
                    how to add spectrum formats to the <command>swrite</command>
                    and <command>sread</command> commands.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <link linkend='chap.filterformat' endterm='chap.filterformat.title' />
            </term>
            <listitem>
                <para>
                    The format of files written by SpecTcl filters is extensible.
                    In this chapter we'll show how to extend the set of formats
                    available.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <link linkend='chap.fittypes' endterm='chap.fittypes.title' />
            </term>
            <listitem>
                <para>
                    The SpecTcl fitting subsystem allows you to add additional
                    fit types.  In this chapter we'll show how to add a new
                    fit-type to SpecTcl.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <link linkend='chap.dataformat' endterm='chap.dataformat.title' />
            </term>
            <listitem>
                <para>
                    SpecTcl is data acquisition system neutral.  This chapter
                    will explore how this is managed and describe how to extend
                    SpecTcl so that it can handle data from another data acquisition
                    system.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <link linkend='chap.dynamicpipe' endterm='chap.dynamicpipe.title' />
            </term>
            <listitem>
                <para>
                    Describes new features for SpecTcl 5.1 which allow you to
                    dynamically alter the event processing pipeline.
                </para>
            </listitem>
        </varlistentry>
    </variablelist>
</chapter>
<chapter id='chap.processingmodel'>
    <title id='chap.processingmodel.title'>
        The SpecTcl processing model.    
    </title>
    <para>
        This chapter describes the SpecTcl processing model.  In order to
        effectively write SpecTcl based software it is important to have some
        understanding of how SpecTcl organizes its computing.  The intent of this
        chapter is to provide an overview of this processing model.  Each of the
        remaining chapters in this book will then zoom in on one section of
        that model and describe how to write software that extends or lives inside
        of that section.
    </para>
    <para>
        The figure below graphically shows the major components of SpecTcl
        and their main interactions.
    </para>
    <figure id='fig.processingmodel' >
        <title id='fig.processingmodel.title'>SpecTcl processing model</title>
        <graphic format='PNG' fileref='processingmodel.png' />
    </figure>
    <para>
        The core of SpecTcl is a command interpreter that is an extended
        version of the Tcl/Tk scripting language (<ulink url='http://www.tcl.tk' />).
        Tcl is a general purpose programming language with a very simple syntax.
        You can learn most of what you need about Tcl in under an hour.  The Tk
        toolkit bolts on to Tcl providing a mechanism for Tcl scripts to create
        rich graphical user interfaces.
    </para>
    <para>
        SpecTcl extents the Tcl interpreter.  It adds commands to the interpreter
        that provide the ability to create and manipulate the objects SpecTcl
        needs.  The most prominent of these objects are parameters, spectra, gates
        and gate applications.  Parameters, spectra and gates are held in
        dictionaries indexed by their names.  Gate applications are stored
        with their spectra.
    </para>
    <para>
        Tcl/Tk's processing model provides an event loop.  An event loop
        reacts to events and dispatches them to appropriate handlers.
        SpecTcl's Tcl extensions establish a source of events.  When the data
        source has data avaialable, the event loop dispatches it to a processing
        pipeline.
    </para>
    <para>
        The first stage of event processing knows about the high level format of
        the data. This is used to unpack blocks of data into units that consist
        of, among other things events.  This is represented by the diagram's
        <literal>High level parsing</literal>  box.  In most cases
        you will not need to provide or modify that code.  That code only needs
        to be touched if you are adapting SpecTcl to data from a new data acquisition
        system not supported by SpecTcl.
    </para>
    <para>
        The high data parsing stage locates blocks of events (a block may be
        a single event long as it is for ring buffer data).  Events from
        this block are passed one by one to the event processing pipeline.
    </para>
    <para>
        The event processing pipeline is the code you will normally have to write.
        It takes a raw event and extracts meaningful parameters from it.
        The format of a raw event and the definition of meaningful parameter
        are both experiment specific.  
    </para>
    <para>
        The event processing pipeline consists of an arbitrary number of stages.
        Each stage has access to the raw event and to the parameters that have
        been unpacked from it by the prior stages.  Careful organization of
        the functionality of your event processors can be key both to allowing
        your detector system to be easily reconfigured and to layering the extraction
        of computed parameters on top of raw parameters in a meaningful and organized
        way.
    </para>
    <para>
        The parameters produced by the event processing pipeline are then passed
        to the event sink pipeline.  The main component of that is the
        histogramming kernel.  It uses the parameters, parameter definitions,
        spectrum definitions, gate applications and relevant gate definitions
        to determine which histograms will be incremented and where.
    </para>
    <para>
        At this point, the only other elements that live in the event sink
        pipeline are filters.  Filters produce a reduced data set by outputing
        some set of parameters for events that satisfy a gate.  It is very
        unusual for application specific code to need to add elements to the
        event sink pipeline, though that is  possible.
    </para>
    <para>
        Histograms are stored by SpecTcl as arrays of data with descriptive
        metadata.  SpecTcl has no built in visualization component.  It can
        store spectrum bulk data in a shared  memory region and supports a few
        well defined communications mechanisms that allow external displayers
        to let you visualize and interact with the data.  The two visualizers
        that are currently supported are Xamine and Spectra.  Xamine is an
        X-11/Motif application, while spectra is based on Root
        (<ulink url='http://root.cern.ch' />).
    </para>
    <para>
        We won't say anything about Spectra in this document, however
        Xamine provides hooks to allow your code to interact with it and the
        data it displays.  We'll describe how to take advantage of those
        hooks.
    </para>
</chapter>
<chapter id='chap.eventprocessingpipeline'>
    <title id='chap.eventprocessingpipeline.title'>
        The SpecTcl event processing pipeline.
    </title>
    <para>
        Most people programming SpecTcl will only need to write code in the
        SpecTcl event processing pipeline.  In this chapter we will:
    </para>
    <itemizedlist>
        <listitem>
            <para>
                Describe the purpose and function of the SpecTcl event processing
                pipeline
            </para>
        </listitem>
        <listitem>
            <para>
                Describe event processors which are elements of the
                event processing pipeline, and how to statically configure
                the pipeline.
            </para>
        </listitem>
        <listitem>
            <para>
                Describe how to set up an event processing pipeline that
                can analyze data from filter files. 
            </para>
        </listitem>
        <listitem>
            <para>
                Give an overview of the advanced topic of dynamically managing
                the event processing pipeline.
            </para> 
        </listitem>
    </itemizedlist>
    <para>
        A simplified version of much of this material can be found in the
        SpecTcl user guide.  That document also describes how to modify the
        SpecTcl skeleton Makefile to incorporate your code in the your
        tailored SpecTcl executable.
    </para>
    <para>
        The event processing pipeline is responsible for analyzing a raw
        event and turning it into a set of parameters that are passed to the
        event sink pipeline.  The histogrammer is one of the elements of the
        event sink pipeline.  To first order, you can view the purpose of
        the event analysis pipeline as preparing raw event data for histogramming.
    </para>
    <para>
        The event processing pipeline consists of an ordered set of
        <firstterm>Event processors</firstterm>.  Each event processor
        has access to the raw event as well as to the parameters that have
        been unpacked by prior elements of the pipeline.
    </para>
    <para>
        Event pipelines are usually defined statically at compilation time
        by registering the pipeline stages in the <methodname>CreateAnalysisPipeline</methodname>
        method of <filename>MySpecTclApp.cpp</filename>. The SpecTcl API also
        allows you to dynamically manipulate the pipeline.
    </para>
    <para>
        Due to the historical development of SpecTcl, there are two possible
        representation of parameters.  The first, and original/native version
        is as a flat array like object called a <classname>CEvent</classname>.
        A <classname>CEvent</classname> object is passed in to the
        each event processor.  It's a dynamically expanding array whose slots
        are <classname>ValidValue</classname> objects.  <classname>ValidValue</classname>
        objects are double precision real values that know when if they've been
        given a value since some reset time.
    </para>
    <para>
        The second version is a set of <classname>CTreeParameter</classname>
        and <classname>CTreeParameterArray</classname> objects.  This
        version was introduced by Daniel Bazin to attach additiona meta data
        to parameters and to allow parameters to be organized into structures
        that better reflect the organization of the experiment being analyzed.
        The tree paramter subsystem was adopted by SpecTcl and is now supported
        software.
    </para>
    <para>
        Currently we recommend the use of tree parameters over the flat
        representation of the <classname>CEvent</classname> array as they
        are much easier to manage.  This manual is written with tree parameters
        in mind.
    </para>
    <section>
        <title>Event Processors</title>
        <para>
            Event processors are objects that are instances of classes
            derived from the <classname>CEventProcessor</classname> 
            base class.  This class is defined in the SpecTcl header:
            <filename>EventProcessor.h</filename>
        </para>
        <para>
            The class provides the interface between the high level parser and
            the event processing pipeline.  The high level parsing subsystem
            will invoke methods of each event processor as determined by its
            high level analysis of the contents of the data.  Let's have a
            look at the important parts of the <filename>EventProcessor.h</filename>
            header.
        </para>
        <example>
            <title>CEventProcessor definition</title>
            <programlisting>

#ifndef MYEVENTPROCESSOR_H
#define MYEVENTPROCESSOR_H
#include &lt;config.h&gt;
#include &lt;EventProcessor.h&gt;


class MyEventProcessor : public CEventProcessor
{
public:
  MyEventProcessor();

  virtual Bool_t operator()(const Address_t pEvent,
                            CEvent&amp; rEvent,
                            CAnalyzer&amp; rAnalyzer,
                            CBufferDecoder&amp; rDecoder); // Physics Event.

  // Functions:
  virtual Bool_t OnAttach(CAnalyzer&amp; rAnalyzer); // Called on registration.
  virtual Bool_t OnBegin(CAnalyzer&amp; rAnalyzer,
                         CBufferDecoder&amp; rDecoder); // Begin Run.
  virtual Bool_t OnEnd(CAnalyzer&amp; rAnalyzer,
                       CBufferDecoder&amp; rBuffer); // End Run.
  virtual Bool_t OnPause(CAnalyzer&amp; rAnalyzer,
                         CBufferDecoder&amp; rDecoder); // Pause Run.
  virtual Bool_t OnResume(CAnalyzer&amp; rAnalyzer,
                          CBufferDecoder&amp; rDecoder); // Resume Run.
  virtual Bool_t OnOther(UInt_t nType,
                         CAnalyzer&amp; rAnalyzer,
                         CBufferDecoder&amp; rDecoder); // Unrecognized buftype.

  virtual Bool_t OnEventSourceOpen(std::string name);
  virtual Bool_t OnEventSourceEOF();
  virtual Bool_t OnInitialize();

};

                
            </programlisting>
        </example>
        <para>
            First note that none of the virtual methods are pure virtual.
            All have default implementations that do nothing.  This allows you
            to only implement the methods you need. 
        </para>
        <para>
            Second, note that all methods return a <type>Bool_t</type> value.
            This is an enumerated type that can have the values
            <literal>kfTRUE</literal> or <literal>kfFALSE</literal>.  The return
            value indicates whether SpecTcl should continue processing the
            event that caused the method to be called.  If
            <literal>kfTRUE</literal> is returned, processing continues and,
            for a physics event, the event sink pipeline will be entered if all
            elements returned that.  If <literal>kfFALSE</literal> is returned,
            event processing is halted immediately.  No further stages of the
            event processing pipeline will be called and the event sink pipeline
            won't be invoked for physics events.
        </para>
        <para>
            Before looking at these methods; we can see a couple of data types
            are passed to many of these methods;  an instance of a 
            <classname>CBufferDecoder</classname> and an instance of a
            <classname>CAnalyzer</classname>
        </para>
        <para>
            These objects are components of the high level parsing subsystem.
            The <classname>CBufferDecoder</classname> is responsible for
            picking apart the raw data into elements of known types.  The
            <classname>CAnalyzer</classname> is passed elements or groups of
            elements and is responsible for running the event processing
            pipeline.   For most event processor methods, you can ignroe these
            parameters.   The physics event processor, however has some
            requirements that must be met.  We will describe those requirements
            in a bit.
        </para>
        <para>
            A quick point about these high level parsing subsystem objects.
            They do provide services that may be useful to some event processing
            methods.  The <classname>CAnalyzer</classname> used in SpecTcl by
            default is actually a <classname>CTclAnalyzer</classname> object.
            When we describe the event processor's responsibilities we will
            come back to this latter fact.
        </para>
        <para>
            Let's look at each event processor method in turn.  The order
            below is the approximate order in which these methods will be called.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type>Bool_t</type>
                        <methodname>OnAttach</methodname>
                        <methodparam>
                            <type>CAnalyzer&amp; </type> <parameter>rAnalyzer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        For an event processor to be called it must be attached
                        to the analyzer.  This is done either statically,
                        in <methodname>CreateAnalysisPipeline</methodname>
                        of <filename>MySpecTclApp</filename> or by dynamic
                        registration after SpecTcl is started.
                    </para>
                    <para>
                        This method is called when the event processor is attached
                        to the analyzer. <parameter>rAnalyzer</parameter> is
                        a reference to the analyzer to which the processor
                        is attached.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type>Bool_t</type>
                        <methodname>OnInitialize</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If an event processor is statically added to the
                        event processor pipeline, it will be added p rior
                        to SpecTcl's complete initialization.   This means there
                        are some SpecTcl facilities that are not available.
                    </para>
                    <para>
                        Once SpecTcl is initialized, and once a dynamically
                        attached event processor is attached, SpecTcl
                        invoked <methodname>OnInitialize</methodname>.
                        This method can perform any initialization that requires
                        full SpecTcl initialization as a prerequisite.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type>Bool_t</type>
                        <methodname>OnEventSourceOpen</methodname>
                        <methodparam>
                            <type>std::string</type> <parameter>name</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        SpecTcl analyzes data from event sources.  This
                        method is called to indicate to the event processor
                        that a new event source has been opened. This is one of
                        the few methods not invoked by the analyzer object.
                    </para>
                    <para>
                        The <parameter>name</parameter> parameter describes
                        the event source that's being opened.  The first words
                        of this will be one of <literal>File: </literal> for
                        a file data source or <literal>Pipe from: </literal>
                        for pipe data sources.  The remainder of the string
                        depends on the data source type.
                    </para>
                    <para>
                        For <literal>File: </literal> data sources the remainder
                        of the string is the name of the file attached, as it was
                        supplied to the <command>attach</command> command.
                    </para>
                    <para>
                        For <literal>Pipe from: </literal> data source, the remainder
                        of the string are the command words that define the program
                        and command line parameters of the program that is on the
                        other end of the pipe.
                    </para>
                    <para>
                        The string is essentially what the
                        <command>attach</command> <option>-list</option> SpecTcl
                        command returns.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type>Bool_t</type>
                        <methodname>OnEventSourceEOF</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when an end of file is encountered on an event source.
                        This happens for a pipe when the program attached to the
                        pipe exits.  It happens for file data sources when all
                        of the data in the file have been processed by SpecTcl.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type>Bool_t</type>
                        <methodname>OnBegin</methodname>
                        <methodparam>
                            <modifier></modifier>
                            <type>CAnalyzer&amp;</type><parameter>rAnalyzer</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier></modifier>
                            <type>CBufferDecoder&amp;</type><parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when a begin run item is encountered on the
                        data source.  Note that this may not get called because
                        there are data acquisition systems that don't produce
                        begin run items.  Furthermore if SpecTcl uses a pipe
                        data source to access online data in the middle of a run,
                        there won't be a begin item for that run.
                    </para>
                    <para>
                        The <parameter>rAnalyzer</parameter> and
                        <parameter>rDecoder</parameter> paramters are references
                        to the analyzer and buffer decoder objects respectively.
                        The services these objects offer will be described in
                        <link linkend='chap.dataformat' endterm='chap.dataformat.title' />.
                        Their use at this time is beyond the scope of this chapter.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodsynopsis>
                    <modifier>virtual</modifier>
                    <type>Bool_t</type>
                    <methodname>OnPause</methodname>
                    <methodparam>
                            <modifier></modifier>
                            <type>CAnalyzer&amp;</type><parameter>rAnalyzer</parameter>
                    </methodparam>
                    <methodparam>
                        <modifier></modifier>
                        <type>CBufferDecoder&amp;</type><parameter>rDecoder</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis></term>
                <listitem>
                    <para>
                        Called if a run has been paused. Note that not all data
                        acquisition systems support temporarily pausing runs.
                        The <parameter>rAnalyzer</parameter> and
                        <parameter>rDecoder</parameter> are once more the
                        analyzer and buffer decopder components of the high level
                        parsing stage of pipeline that processes data from
                        the data source.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type>Bool_t</type>
                        <methodname>OnResume</methodname>
                        <methodparam>
                            <modifier></modifier>
                            <type>CAnalyzer&amp;</type><parameter>rAnalyzer</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier></modifier>
                            <type>CBufferDecoder&amp;</type><parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        For systems that support temporary pauses of data taking
                        runs, this is called when the data from the run indicates
                        one of those pauses has resumed.
                        The <parameter>rAnalyzer</parameter> and
                        <parameter>rDecoder</parameter> are once more the
                        analyzer and buffer decopder components of the high level
                        parsing stage of pipeline that processes data from
                        the data source.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type>Bool_t</type>
                        <methodname>OnEnd</methodname>
                        <methodparam>
                            <modifier></modifier>
                            <type>CAnalyzer&amp;</type><parameter>rAnalyzer</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier></modifier>
                            <type>CBufferDecoder&amp;</type><parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier></modifier>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called at the end of run indication from the data
                        source.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type>Bool_t</type>
                        <methodname>operator()</methodname>
                        <methodparam>
                            <modifier>const</modifier>
                            <type>Address_t</type><parameter>pEvent</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier></modifier>
                            <type>CEvent&amp;</type><parameter>rEvent</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier></modifier>
                            <type>CAnalyzer&amp;</type><parameter>rAnalyzer</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier></modifier>
                            <type>CBufferDecoder&amp;</type><parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier></modifier>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called for each physics event.  In addtion to the
                        <parameter>rAnalyzer</parameter> and
                        <parameter>rDecoder</parameter> parameters the
                        <parameter>pEvent</parameter> parameter is a pointer to
                        the start of the event body.  For data formats,
                        that provide headers to the event, the decoder
                        object will typically provide methods to access those
                        headers.
                    </para>
                    <para>
                        The <parameter>rEvent</parameter> parameter is a reference
                        to the event array that is the ultimate output of the
                        event processing pipeline for physics events.
                        <parameter>rEvent</parameter> is an array-like object
                        of <classname>ValidValue</classname> objects.
                        You can think of <parameter>rEvent</parameter> as an
                        array that automatically expands as  needed to fit
                        the largest index it's passed.
                    </para>
                    <para>
                        On the left hand side of an assignment, you can think of
                        elements of <parameter>rEvent</parameter> as double
                        precision reals.   In an expression, however the
                        additional properties of a <classname>ValidValue</classname>
                        object become visible.  Specifically these objects
                        can be reset to an undefined state and will throw
                        an exception if referenced prior to having been assigned
                        a new value (having become valid).
                    </para>
                    <para>
                        At the beginning of event processing; and as elements
                        are added to <varname>rEvent</varname>, the valid values
                        in it are reset to be invalid by SpecTcl.  Prior to using
                        an element of <varname>rEvent</varname> within an
                        expression, you need to ensure that it is valid.  This can
                        be done either by reasoning about the flow of the computation
                        or by invoking the <methodname>isValid</methodname> method
                        which returns <literal>true</literal> if the element
                        was assigned.  Performing a read reference on a
                        <classname>ValidValue</classname> that has not
                        yet been assigned a value results in an exception.
                    </para>
                    <para>
                        Using tree parameters allows you to avoid direct referencing
                        of the <varname>rEvent</varname> array, referencing
                        instead specific <classname>CTreeParameter</classname>
                        objects or elements of specific <classname>CTreeParameterArray</classname>
                        objects that have been bound to <varname>rEvent</varname>
                        elements.  The comments about validity checking are still
                        relevent however.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type>Bool_t</type>
                        <methodname>OnOther</methodname>
                        <methodparam>
                            <modifier></modifier>
                            <type>UInt_t</type><parameter>nType</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier></modifier>
                            <type>CAnalyzer&amp;</type><parameter>rAnalyzer</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier></modifier>
                            <type>CBufferDecoder&amp;</type><parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when some other type of data is encountered from the
                        data source.  In NSCLDAQ, for example, this is called
                        for scaler data.  In addition to the
                        <parameter>rAnalzer</parameter> and <parameter>rDecoder</parameter>
                        parameters, <parameter>nType</parameter> is an integer
                        code that indicates the type of data being provided.
                    </para>
                    <para>
                        This method and the decoder object  must interact in
                        order to get the data in the item.  Type codes
                        are data acquisition system (and even maybe version)
                        specific.
                    </para>
                    <para>
                        Processing this method requires an understanding
                        of the decoder for your data set and the formats
                        of the data types you want ot handle.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            In the remainder of this section, we're going to look at an event
            processor that is a bit more involved than the one shown in the
            SpecTcl User guide.   We'll do this to show specifically how the
            event processor may interact with the analyzer and the decoder.
            This example is given in the context of NSCLDAQ version 11.x
        </para>
        <para>
            As we now recommend, this example will use Tree Parameters rather than
            directly accessing the <parameter>rEvent</parameter> object.
        </para>
        <example>
            <title>
                Our event processor header.
            </title>
            <programlisting>
#ifndef MYEVENTPROCESSOR_H
#define MYEVENTPROCESSOR_H
#include &lt;config.h&gt;
#include &lt;EventProcessor.h&gt;
#include &lt;TreeParameter.h&gt;

class MyEventProcessor : public CEventProcessor
{
private:
  CTreeParameter sum;
  CTreeParameterArray raw;

public:
  MyEventProcessor();
  
  virtual Bool_t operator()(const Address_t pEvent,
                            CEvent&amp; rEvent,
                            CAnalyzer&amp; rAnalyzer,
                            CBufferDecoder&amp; rDecoder); // Physics Event.

  // Functions:
  virtual Bool_t OnAttach(CAnalyzer&amp; rAnalyzer); // Called on registration.
  virtual Bool_t OnBegin(CAnalyzer&amp; rAnalyzer,
                         CBufferDecoder&amp; rDecoder); // Begin Run.
  virtual Bool_t OnEnd(CAnalyzer&amp; rAnalyzer,
                       CBufferDecoder&amp; rBuffer); // End Run.
  virtual Bool_t OnPause(CAnalyzer&amp; rAnalyzer,
                         CBufferDecoder&amp; rDecoder); // Pause Run.
  virtual Bool_t OnResume(CAnalyzer&amp; rAnalyzer,
                          CBufferDecoder&amp; rDecoder); // Resume Run.
  virtual Bool_t OnOther(UInt_t nType,
                         CAnalyzer&amp; rAnalyzer,
                         CBufferDecoder&amp; rDecoder); // Unrecognized buftype.

  virtual Bool_t OnEventSourceOpen(std::string name);
  virtual Bool_t OnEventSourceEOF();
  virtual Bool_t OnInitialize();

};

#endif

            </programlisting>
        </example>
        <para>
            Since our example will show some (possibly trivial) examples of all
            of the methods an event processor can implement, we needed to show the
            compiler that we're going to override all possible virtual methods.
        </para>
        <formalpara>
            <title>Constructor</title>
            <para>
                We could initialize the tree parameters in the constructor,
                but in order to illustrate <methodname>OnInitialize</methodname>
                we'll do it there.   Therefore our constructor is empty:
            </para>
        </formalpara>
        <example>
            <title>Constructor for <classname>MyEventProcessor</classname></title>
            <programlisting>
MyEventProcessor::MyEventProcessor()
{}
            </programlisting>
        </example>
        <formalpara>
            <title><methodname>OnAttach</methodname></title>
            <para>
                <methodname>OnAttach</methodname> is called quite early in SpecTcl's
                initialization.  We're going to use it to check an assumption
                that will be made in <methodname>operator()</methodname>, namely
                that the analyzer is actually an instance of a
                <classname>CTclAnalyzer</classname>.
            </para>
        </formalpara>
        <para>
            <classname>CTclAnalyzer</classname> is the analyzer used by SpecTcl
            for typical analysis cases.  It manages the flow of control through
            the event processing pipeline.  It also imposes some requirements
            on the event processor's <methodname>operator()</methodname> that
            we will talk about when we get to that method's implementation.
        </para>
        <example>
            <title><methodname>OnAttach</methodname></title>
            <programlisting>
Bool_t
MyEventProcessor::OnAttach(CAnalyzer&amp; rAnalyzer)
{
  try {                                     <co id='onattach.dyncast' />
    CTclAnalyzer&amp; rTclAnalyzer(dynamic_cast&lt;CTclAnalyzer&amp;&gt;(rAnalyzer));
  }
  catch (std::bad_cast e) {                 <co id='onattach.badcast' />
    std::cerr &lt;&lt; "MyEventProcessor::OnAttach - not the right type of analyzer ";
    std::cerr &lt;&lt; e.what() &lt;&lt;std::endl;
    return kfFALSE;
  }
  catch (...) {                             <co id='onattach.otherfails' />
    std::cerr &lt;&lt; "MyEventProcessor::OnAttach - dynamic_cast failed\n";
    return kfFALSE;
  }
  return kfTRUE;                           <co id='onattach.good' />

}
            </programlisting>
        </example>
        <calloutlist>
            <callout arearefs='onattach.dyncast'>
                <para>
                    As indicated we're going to check that the analyzer
                    is an instance of <classname>CTclAnalyzer</classname>.
                    We could compare typenames but, in fact, it's just fine
                    if the  analyzer is a subclass of <classname>CTclAnalyzer</classname> too.
                </para>
                <para>
                    <literal>dynamic_cast</literal> attempts to perform a type cast
                    between pointers or references of differing actual types of
                    a class hiearchy.  If the cast is permissible it succeeds.
                    If not it fails.  If casting pointers, the result of a falure
                    is a null pointer.  If casting references, as in our code,
                    the result of failure is an exception of type
                    <classname>std::bad_cast</classname>.
                </para>
            </callout>
            <callout arearefs='onattach.badcast' >
                <para>
                    If a bad cast exception was thrown, this block of code
                    emits an error message that includes the error message
                    stored in the <classname>std::bad_cast</classname> object
                    (accessible via the <methodname>what</methodname> method).
                </para>
                <para>
                    Since this element of the pipeline failed, <literal>kfFalse</literal>
                    is returned.
                </para>
            </callout>
            <callout arearefs='onattach.otherfails'>
                <para>
                    If the cast throws any other exceptions, these two are caught
                    and reported.
                </para>
            </callout>
            <callout arearefs='onattach.good'>
                <para>
                    If no exceptions were thrown, the <literal>dynamic_cast</literal>
                    worked and we can return <literal>kfTRUE</literal> to indicate
                    to the analyzer it can continue processing with the next
                    element of the event processing pipeline.
                </para>
            </callout>
        </calloutlist>
        <formalpara>
            <title>OnInitialize</title>
            <para>
                We will use <methodname>OnInitialize</methodname> to intialize
                our tree parameter members.  Tree parameters and tree parameter
                arrays an be constructed with initialization or constructed
                with e.g. a default constructor and then initialized later.
            </para>
        </formalpara>
        <para>
            At some point in the life of a tree parameter it must be bound to
            an underlying SpecTcl parameter.  You can think of this as a process
            that makes a correspondence between the tree parameter and a slot
            number in the <classname>CEvent</classname> array like object
            passed to <methodname>operator()</methodname>.
        </para>
        <para>
            In the code that follows, we don't make any assumptions about
            whether SpecTcl has already done its mass binding of Tree parameters
            during its initialization.
        </para>
        <example>
            <title>OnInitialize - Set up the tree parameters.</title>
            <programlisting>
Bool_t
MyEventProcessor::OnInitialize()
{
  sum.Initialize("myevp.sum", 8192, 0.0, 8199.0, "arbitrary");  <co id='oninit.inittp' />
  raw.Initialize("myevp.raw", 4096, 0.0, 4096.0, "arbitrary", 16, 0); 

  if (!sum.isBound()) {                                 <co id='oninit.indivbound' />
    sum.Bind();
  }
  for (int i = 0; i &lt; 16; i++) {
    if (!raw[i].isBound()) {
      raw[i].Bind();                                  <co id='oninit.araraybound' />
    }
  }
  return kfTRUE;                                    <co id='oninit.ok' />
}
                
            </programlisting>
        </example>
        <calloutlist>
            <callout arearefs='oninit.inittp' >
                <para>
                    This pair of statements completes the initialization of
                    the tree parameter and array characteristics.  The
                    array has 16 elements whose values are in the range
                    <literal>[0, 4096)</literal>.    The
                    single parameter has a range of <literal>[0, 8192)</literal>.
                </para>
            </callout>
            <callout arearefs='oninit.indivbound'>
                <para>
                    This section of code binds the individual parameter to the
                    event array like object if not.
                </para>
            </callout>
            <callout arearefs='oninit.araraybound' >
                <para>
                    There are no aggregate <methodname>isBound</methodname>
                    or <methodname>Bind</methodname> methods for tree parameter
                    arrays at the time this is being written.  This section
                    of code iterates over the elements of the array (which are
                    after all tree parameters).  All unbound parameters are bound.
                </para>
                <para>
                    Note that binding parameters if necessary, creates a SpecTcl
                    parameter making the use of the <parameter>parameter</parameter>
                    SpecTcl command largely unecessary.
                </para>
            </callout>
        </calloutlist>
        <formalpara>
            <title>OnBegin, OnEnd, OnPause, OnResume</title>
            <para>
                These methods monitor what are collectively called
                <firstterm>Run state transitions</firstterm>.  We'll emit a message
                to stdout describing the transition.  We are going to use
                the facilities all buffer decoders must supply to get information
                about the run.
            </para>
        </formalpara>
        <para>
            In our case, we're just going to report the state transition.
            This allows us to factor out the code for handling a state
            transition into a utility method.  In more realistic cases you
            can't do this:
        </para>
        <example>
            <title>State transition processing</title>
            <para>
                Added to MyEventProcessor.h:
            </para>
            <programlisting>
private:
  Bool_t describeStateTransition(const char* type, CBufferDecoder&amp; rDecoder);


            </programlisting>
            <para>
                The utility method implementation in MyEventprocessor.cpp:
            </para>
            <programlisting>
Bool_t
MyEventProcessor::describeStateTransition(const char* type, CBufferDecoder&amp; rDecoder)
{
  UInt_t runNumber = rDecoder.getRun();
  std::string title = rDecoder.getTitle();

  std::cerr &lt;&lt; "Run number " &lt;&lt; runNumber &lt;&lt; " just " &lt;&lt; type
	    &lt;&lt; " title: " &lt;&lt; title &lt;&lt; std::endl;

  return kfTRUE;
}
            </programlisting>
            <para>
                Implementation of the Onxxx methods for state transitions:
            </para>
            <programlisting>
Bool_t
MyEventProcessor::OnBegin(CAnalyzer&amp; rAnalyzer,CBufferDecoder&amp; rDecoder)
{
  return describeStateTransition("began", rDecoder);
}
Bool_t
MyEventProcessor::OnEnd(CAnalyzer&amp; rAnalyzer, CBufferDecoder&amp; rDecoder)
{
  return describeStateTransition("ended", rDecoder);
}
Bool_t
MyEventProcessor::OnPause(CAnalyzer&amp; rAnalyzer, CBufferDecoder&amp; rDecoder)
{
  return describeStateTransition("paused", rDecoder);
}
Bool_t
MyEventProcessor::OnResume(CAnalyzer&amp; rAnalyzer, CBufferDecoder&amp; rDecoder)
{
  return describeStateTransition("resumed", rDecoder);
}

            </programlisting>
        </example>
        <para>
            The <methodname>describeStateTransition</methodname> utility
            illustrates using a pair of the buffer decoder service methods to
            obtain the run title and run number.  Each specific state transition
            handler then passes in the text describiung the state transition
            that actually occured so that it can be plugged into the method.
        </para>
        <para>
            We push the choice of whether or not to return
            <literal>kfTRUE</literal> or <literal>kfFALSE</literal> to the
            utility as well.
        </para>
        <formalpara>
            <title><methodname>operator()</methodname></title>
            <para>
                This method is called once per physics triggered event.  This is
                the only method that needs to know something about the format
                of data from the experiment.  This method has the following
                responsibilities:
            </para>
        </formalpara>
        <itemizedlist>
            <listitem>
                <para>
                    Transform the raw event into parameters that can be histogrammed.
                    Parameters can be some mixture of elements of a parameter
                    array like object or tree parameters.  Current practices
                    prefer tree parameters.
                </para>
            </listitem>
            <listitem>
                <para>
                    Indicate by return value if the event pipeline should
                    continue processing.  Note that terminating the pipeline
                    also keeps the event from entering the event sink pipeline
                    and therefore prevents histogramming.
                </para>
            </listitem>
            <listitem>
                <para>
                    Determine the number of bytes occupied by the event.  This is
                    required because events are considered to come in blocks.
                    SpecTcl itself has no idea of the size of physics events
                    and therefore needs the event processing pipeline to
                    tell it where the next event in a block starts.
                    <footnote>
                        <para>
                            Well for ringbuffer data this is actually a lie
                            since blocks of events contain exactly one event and
                            the size of that event is known from the ring item
                            size.  For nscldaq-8.0 and earlier data this is
                            required.
                        </para>
                        <para>
                            For data from non NSCLDAQ systems, the necessity
                            of this depends on the system.
                        </para>
                    </footnote>
                </para>
            </listitem>
        </itemizedlist>
        <para>
            Since <methodname>operator()</methodname> depends on the internal
            format of the event, we need to know what that's going to be for
            our "experiment" before we can write it.  We're going to assume
            that events consist of the following:
        </para>
        <orderedlist>
            <listitem>
                <para>
                   A <type>uint32_t </type> containing the event size.  This
                   size will be the number of <type>uint16_t</type> items
                   in the event and will include the count itself (which is
                   two <type>uint16_t</type> items long).
                </para>
            </listitem>
            <listitem>
                <para>
                    A fixed format block of parameters.  There will be at
                    most 16 parameters.
                </para>
            </listitem>
            <listitem>
                <para>
                    Each parameter will occupy one <type>uint16_t</type> item
                    and fill consecutive elements of a tree parameter array named
                    <literal>myevp.raw</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    If elements 0 and 3 of <literal>myevp.raw</literal> have
                    been defined by the event, they will be summed and
                    stored in <literal>myevp.sum</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    The event size in bytes will be passed to the analyzer.
                </para>
            </listitem>
        </orderedlist>
        <note>
            <title>
                NOTE
            </title>
            <para>
                The code is going to assume that the data are being analyzed on
                a system with the same byte ordering as the system on which the
                data were acquired.  If that assumption is not valid, production
                code should use the Translating pointer classes described in the
                programmer reference rather than raw pointers.  Those pointers
                use byte order information in NSCLDAQ data to transparently
                perform any ordering transformations required.
            </para>
        </note>
        <example>
            <title>Event processor <methodname>operator() method.</methodname></title>
            <programlisting>
Bool_t
MyEventProcessor::operator()(
    const Address_t pEvent, CEvent&amp; rEvent,
    CAnalyzer&amp; rAnalyzer, CBufferDecoder&amp; rDecoder
)
{
  uint32_t* pSize = reinterpret_cast&lt;uint32_t*&gt;(pEvent);
  uint32_t  nWords = *pSize++;
  CTclAnalyzer&amp; rTclAnalyzer = dynamic_cast&lt;CTclAnalyzer&amp;&gt;(rAnalyzer); <co id='evp.fcnsize' />
  rTclAnalyzer.SetEventSize(nWords * sizeof(uint16_t));

  uint16_t* pData = reinterpret_cast&lt;uint16_t*&gt;(pSize);   <co id='evp.fcndataptr' />
  nWords         -= sizeof(uint32_t)/sizeof(uint16_t);

  for (int i = 0; i &lt; nWords; i++) {
    raw[i] = *pData++;                                         <co id='evp.fcnrawparams' />
  }

  if (raw[0].isValid() &amp;&amp; raw[3].isValid()) {          <co id='evp.fcncomputedparam' />
    sum = raw[0] + raw[3];
  }


  return kfTRUE;
}

            </programlisting>
        </example>
        <calloutlist>
            <callout arearefs='evp.fcndataptr'>
                <para>
                    The <parameter>pEvent</parameter> is an
                    <type>Address_t</type> type.  This is an
                    <firstterm>opaque pointer</firstterm> (<type>void*</type>).
                    In order to use it it must first be cast to a pointer to a
                    specific type.
                </para>
                <para>
                    This section of code casts it to point to an unsigned 32
                    bit integer and uses the resulting pointer to extract the
                    event size in <type>uint16_t</type> units.  We then fulfil
                    our obligation to tell the <classname>CTclAnalyzer</classname>
                    the event size so that, if necessary, it can locate the
                    next event in the block of events its iterating over.
                </para>
            </callout>
            <callout arearefs='evp.fcndataptr'>
                <para>
                    <varname>pSize</varname> now points to the data in the event,
                    but we need a pointer to the <type>uint16_t</type> items
                    we want to extract.  The cast takes care of this.  The
                    number of words of data is also computed from the event size.
                    The expression <literal>sizeof(uint32_t)/sizeof(uint16_t)</literal>
                    is the number of 16 bit words required to store a 32 bit word.
                    We could use the value <literal>2</literal>, but this
                    expression makes it a bit clearer what that
                    <literal>2</literal> means.
                </para>
            </callout>
            <callout arearefs='evp.fcnrawparams'>
                <para>
                    The body of this loop stores each parameter into the
                    appropriate tree parameter arrary element.  The tree parameter
                    array has been bound to a set of slots in
                    <parameter>rEvent</parameter> by SpecTcl and takes care of
                    setting the appropriate elements of that array-like
                    object for us.
                </para>
                <para>
                    Note that each assignment also transparently sets that
                    element's validity so that it's <methodname>isValid</methodname>
                    method will return <literal>true</literal>.
                </para>
            </callout>
            <callout arearefs='evp.fcncomputedparam'>
                <para>
                    The sum an only be computed if both of the paramters it
                    depends on have been given values in this event.  It's a
                    common problem in SpecTcl event processors not to perform
                    this sort of check.  If we attemted to perform this sum
                    and either addend had not been given a value, the
                    reference to the un-set value would result in an exception.
                </para>
                <para>
                    Uncaught exceptions in SpecTcl event processors, obviously
                    abort that pipeline element, but they also abort the remainder
                    of the pipeline (if any).  
                </para>
            </callout>
        </calloutlist>
        <formalpara>
            <title><methodname>OnOther</methodname></title>
            <para>
                This method is called when something other than the named
                item types is encountered.  You will need to know something
                about the format of each item type you'd like to handle.
                You will also need to interact with the buffer decoder to
                obtain pointers to the actual data.
            </para>
        </formalpara>
        <para>
            In our example we will:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Indicate we've gotten an item by outputting a message that
                    will incldue the item type.
                </para>
            </listitem>
            <listitem>
                <para>
                    If our item was a scaler item, we'll dump it to SpecTcl's
                    stdout.  Note that this involved linking SpecTcl to the
                    NSCLDAQ so that the <classname>CRingScalerItem</classname>
                    class definition and implementation will also be available.
                    We also are assuming this data comes from NSCLDAQ  in the first
                    place.
                </para>
            </listitem>
        </itemizedlist>
        <example>
            <title>Event processor <methodname>OnOther</methodname></title>
            <programlisting>
Bool_t
MyEventProcessor::OnOther(UInt_t nType, CAnalyzer&amp; rAna, CBufferDecoder&amp; rDecoder)
{
  std::cout &lt;&lt; "Got an 'OnOther' item type is: " &lt;&lt; nType &lt;&lt; std::endl;

  CRingBufferDecoder* pRingDecoder = dynamic_cast&lt;CRingBufferDecoder*&gt;(&amp;rDecoder); <co id='evp.onother.decoder' />


  if (pRingDecoder) {
    if (nType == PERIODIC_SCALERS) {                       <co id='evp.onother.scalertype' />
      CRingItem* pItem = CRingItemFactory::createRingItem(pRingDecoder-&gt;getItemPointer());  <co id='evp.onother.createitem' />
      CRingScalerItem* pScaler = dynamic_cast&lt;CRingScalerItem*&gt;(pItem);                  <co id='evp.onother.castscaler' />
      if (pScaler) {
        std::cout &lt;&lt; "Scaler item: \n";
        std::cout &lt;&lt; pItem->toString() &lt;&lt; std::endl;                               <co id='evp.onother.tostring' />
      } else {
        std::cerr &lt;&lt; "OnOther - type was a scaler but could not make the ring item\n";
      }
      delete pItem;                                            <co id='evp.onother.delitem' />
    }
  } else {
    std::cerr &lt;&lt; "Data does not come from nscldaq 10+ - can't do any more\n";
  }

  return kfTRUE;                                          <co id='evp.onother.dontforgetthis' />
}

            </programlisting>
        </example>
        <calloutlist>
            <callout arearefs='evp.onother.decoder'>
                <para>
                    In order to be able to do all of the processing we want to
                    do, we need to invoke members of the decoder that are
                    specific to the decoder for ring buffers;
                    <classname>CRingBufferDecoder</classname>.  This dynamic
                    cast takes the generic decoder and attempts to coerce its
                    address into a pointer to a <classname>CRinBufferDecoder</classname>.
                </para>
                <para>
                    Dynamic casts make use of run time type information (RTTI)
                    embedded in objects to ensure that the cast being attempted
                    is legal.  If the <parameter>rDecoder</parameter> object
                    actual type cannot be treated as a
                    <classname>CRingBufferDecoder</classname>, the cast returns
                    a null pointer.  
                </para>
                <para>
                    If a null pointer is returned, a message indicating the
                    data doesn't come from a  ring buffer based system is
                    regturned.
                </para>
            </callout>
            <callout arearefs='evp.onother.scalertype'>
                <para>
                    We only want to do something other than to output a
                    message if the data is a periodic scaler item. Note that
                    this also matches the data type for
                    nscldaq-10.x incremental scalers.
                </para>
            </callout>
            <callout arearefs='evp.onother.createitem'>
                <para>
                    The <classname>CRingItemFactory</classname> is a class
                    with several static methods that create ring item objects.
                    The version of the creational method we use takes a pointer
                    to the raw data in a ring item.  The
                    <classname>CRingBufferDecoder</classname>::<methodname>getItemPointer</methodname>
                    method returns a pointer to the ring item the buffer decoder
                    is processing, has handed off to the analyzer which in turn
                    invoked our <methodname>OnOther</methodname> method.
                </para>
                <para>
                    The factory gives us a pointer to a dynamically
                    allocated <classname>CRingItem</classname>, though the
                    actual underlying object is of the appropriate
                    ring item class type.
                </para>
            </callout>
            <callout arearefs='evp.onother.castscaler'>
                <para>
                    This dynamic cast turns the <classname>CRingItem</classname>
                    object into a <classname>CRingScalerItem</classname> pointer.
                    We know that's what we should get by our analysis of the
                    ring item type.
                </para>
                <para>
                    Although we should get a <classname>CRingScalerItem</classname>,
                    we ensure that this is the case.  The dynamic_cast operator
                    will return a null pointer if the cast fails.
                </para>
            </callout>
            <callout arearefs='evp.onother.tostring'>
                <para>
                    Once we've gotten this far we can use the
                    <methodname>toString</methodname> method every
                    <classname>CRingItem</classname> derived class implements
                    to turn the ring item into a human readable dump string
                    which we print out.
                </para>
            </callout>
            <callout arearefs='evp.onother.delitem'>
                <para>
                    Since the factory dynamically allocated the ring item,
                    we need to delete it in all code paths through the
                    method.
                </para>
            </callout>
            <callout arearefs='evp.onother.dontforgetthis'>
                <para>
                    Since this is an event processor method, we need to return
                    <literal>kfTRUE</literal> so that other pipeline elements
                    that follow ours will be run as well.
                </para>
            </callout>
        </calloutlist>
        <formalpara>
            <title>The <methodname>OnEventSourceOpen</methodname> and <methodname>OnEventSourceEOF</methodname></title>
            <para>
                These two methods are called, when SpecTcl
                is connected to a new event source (via the
                <command>attach</command> command), and when an end file
                indication is encountered on the active event source.
                In our event processor, we'll just output some text to indicate
                these events have occured.
            </para>
        </formalpara>
        <example>
            <title><methodname>OnEventSourceOpen</methodname> and <methodname>OnEventSourceEOF</methodname></title>
            <programlisting>
Bool_t
MyEventProcessor::OnEventSourceOpen(std::string name)
{
  std::cout &lt;&lt; "SpecTcl has connected to a new event source : " &lt;&lt; name &lt;&lt; std::endl;
  return kfTRUE;
}
Bool_t
MyEventProcessor::OnEventSourceEOF()
{
  std::cout &lt;&lt; "SpecTcl's event source processing reached and end-file\n";
}



            </programlisting>
        </example>
    </section>
    <section>
        <title>Setting up an event analysis pipeline (the simple version)</title>
        <para>
            Once an event processor, such as the one created in the previous
            section has been written, in order to use it we must:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Compile and link our event processor into our tailored SpecTcl.
                </para>
            </listitem>
            <listitem>
                <para>
                    Add the event processor to the event processing pipeline
                    as SpecTcl initializes.
                </para>
            </listitem>
        </itemizedlist>
        <formalpara>
            <title>Building code into SpecTcl</title>
            <para>
                The skeleton software in the SpecTcl <filename>Skel</filename>
                subdirectory includes a template Makefile.  In order
                The Makefile is intended to be easily modified to add new
                modules, complilation and link switches to the build.
            </para>
        </formalpara>
        <para>
            Changing the Makefile is simplified by providing several
            Makefile variables:
        </para>
        <variablelist>
            <varlistentry>
                <term><literal>USERCXXFLAGS</literal></term>
                <listitem>
                    <para>
                        The text on this line is added to all C++ compilations.
                        Use this to add compiler flags and options you need
                        for your compilations.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>USERCCFLAGS</literal></term>
                <listitem>
                    <para>
                        Same as <literal>USERCXXFLAGS</literal> but used in
                        C compilations.  The Makefile predefines this as the
                        value of <literal>USERCXXFLAGS</literal> which in most
                        cases is correct.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>USERLDFLAGS</literal></term>
                <listitem>
                    <para>
                        The text on this line is added to the final link of
                        SpecTcl libraries to object modules.  Use this variable
                        to add loader flags and options you need for your
                        tailored SpecTcl.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>OBJECTS</literal></term>
                <listitem>
                    <para>
                        A space separated list of object modules that have
                        to be built.  The Makefile and Make establish
                        default rules to build C and C++ modules.  If you
                        have other special needs, you can certainly add your
                        own explicit build rules.
                    </para>
                    <para>
                        Usually you can just put the names of your source
                        modules with the .cxx, cpp, or .c changed to .o
                        and make will figure things out.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            In the sample event file processor from the previous section,
            our <methodname>OnOther</methodname> implementation required
            components of NSCLDAQ. This requirement allows us
            to show how these variables are used. We need to
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Establish the version of NSCLDAQ we intend to use compile
                    and link to.
                </para>
            </listitem>
            <listitem>
                <para>
                    Add compilation flags so that the NSCLDAQ headers we need
                    can be found.
                </para>
            </listitem>
            <listitem>
                <para>
                    Add link flags so that the NSCLDAQ libraries we need are also
                    linked into SpecTcl
                </para>
            </listitem>
            <listitem>
                <para>
                    Add our Event processor to the set of objects SpecTcl must
                    build and link to its library and framework files.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            Let's have a look at the first lines of the SpecTcl Makefile
            appropriately modified.  Comments have been edited out
            for brevity.
        </para>
        <example>
            <title>SpecTcl Makefile modifications</title>
            <programlisting>
include $(INSTDIR)/etc/SpecTcl_Makefile.include      <co id='makefile.include' />

NSCLDAQDIR=/usr/opt/daq/11.2                         <co id='makefile.daqversion' />

USERCXXFLAGS=-I$(NSCLDAQDIR)/include                 <co id='makefile.cxxflags' />
USERCCFLAGS=$(USERCXXFLAGS)

USERLDFLAGS=-L$(NSCLDAQDIR)/lib -ldataformat -Wl,-rpath=$(NSCLDAQDIR)/lib        <co id='makefile.ldflags' />

OBJECTS=MySpecTclApp.o MyEventProcessor.o            <co id='makefile.objects' />

...
            </programlisting>
        </example>
        <calloutlist>
            <callout arearefs='makefile.include'>
                <para>
                    This include is part of the standard Makefile.  It pulls in
                    definitions of the set of SpecTcl libraries needed as well
                    as default compilation rules for common source to object
                    transformatinos.
                </para>
            </callout>
            <callout arearefs='makefile.daqversion'>
                <para>
                    I added this line.  It allows me to change which version of
                    NSCLDAQ simply by changing this line. 
                </para>
            </callout>
            <callout arearefs='makefile.cxxflags'>
                <para>
                    Adds compilation flags to search the NSCLDAQ's
                    <filename>include</filename> directory for header files.
                    By making this definition relative to <literal>NSCLDAQDIR</literal>,
                    the DAQ top level directory is only specified in one place
                    making it simpler to change.  This is an example of the
                    DRY principle (Don't Repeat Yourself) of software
                    engineering.  If you find you've written the same code
                    or definition twice, consider reorganizing (refactoring)
                    so that you eliminate this duplication.
                </para>
            </callout>
            <callout arearefs='makefile.ldflags'>
                <para>
                    We define this symbol to ensure that the NSCLDAQ libraries we
                    need are located and linked into our executable.  The
                    <literal>-Wl,-rpath</literal> directive ensures that at
                    run time, the run time loader searches the NSCLDAQ
                    <filename>lib</filename> directory for shared libraries.
                </para>
            </callout>
            <callout arearefs='makefile.objects' >
                <para>
                    We add <filename>MyEventProcessor.o</filename> to the list of
                    objects.  The framework initialization file
                    <filename>MySpecTclApp.o</filename> should always be present
                    (or its equivalent).  This addition ensures that our event
                    processor module will be compiled and linked into the tailored
                    SpecTcl we are building.
                </para>
            </callout>
        </calloutlist>
        <formalpara>
            <title>Static event processing pipeline management</title>
            <para>
                If we made SpecTcl afterr modifying the Makefile as described
                above, our event processor would still not be run.  SpecTcl
                requires explicity management of the event processing pipeline.
                This management can be static, establishing the pipeline at
                initialization, or dynamic, modifying the pipeline during
                SpecTcl's run.
            </para>
        </formalpara>
        <para>
            In this section, we'll use static event processing pipeline management
            to tell SpecTcl to run our event processor.  To do this, we must
            modify the framework file that came from the skeleton,
            <filename>MySpecTclApp.cpp</filename>.  This class is a
            specialization of a class that provides SpecTcl with application
            specific initialization strategy callouts.
        </para>
        <para>
            As SpecTcl starts it invokes methods in this class at specific times
            and for specific purposes.  <methodname>CreateAnalysisPipeline</methodname>
            is invoked when it's time to establish the initial analysis pipeline.
            For most cases, the initial analysis pipeline is all you need.
            It is possible, however to modify the pipeline in flight.
        </para>
        <para>
            The base class for <classname>CMySpecTclApp</classname>, provides
            services.  One of those service methods,
            <methodname>RegisterEventProcessor</methodname> appends an instance
            of an event processor to the end of the analysis pipeline.
        </para>
        <para>
            Therfore, to create a SpecTcl that has an event processing pipeline
            with only our event processor, we need to:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Add an <literal>#include</literal> directive to include
                    our event processor's header to
                    <filename>MySpecTclApp.cpp</filename>
                </para>
            </listitem>
            <listitem>
                <para>
                    Edit <methodname>CreateAnalysisPipeline</methodname>
                    in <filename>MySpecTclApp.cpp</filename> so that
                    only our event processor is registered.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            At the top of <filename>MySpecTclApp.cpp</filename>
        </para>
        <informalexample>
            <programlisting>
#include &lt;config.h&gt;
#include "MySpecTclApp.h"
#include "EventProcessor.h"
#include "TCLAnalyzer.h"
#include &lt;Event.h&gt;
#include &lt;TreeParameter.h&gt;
#include "MyEventProcessor.h"                 // &lt;- add this line.
            </programlisting>
        </informalexample>
        <para>
            Note that <filename>MySpecTclApp.cpp</filename> is an example
            and includes a sample event processing pipeline setup that must be
            removed.
            Make the body of <methodname>CreateAnalysisPipeline</methodname>
            look like this:
        </para>
        <example>
            <title>Creating a static event processing pipeline</title>
            <programlisting>

void
CMySpecTclApp::CreateAnalysisPipeline(CAnalyzer&amp; rAnalyzer)
{
  RegisterEventProcessor(*(new MyEventProcessor), "Raw-unpacker");

}
            </programlisting>
        </example>
        <para>
            The <methodname>RegisterEventProcessor</methodname> method is
            described completely in the programmer reference.   It takes
            a mandatory prameter and and optional one.
        </para>
        <para>
            The first parameter is a reference to the event processor object
            that should be appended to the the pipeline of processors.  The
            lifetime of the object must be the time it is in the analysis pipeline.
            Unless you are doing dynamic pipeline managemenet, this is the
            run time of the program.
        </para>
        <para>
            The second parameter is optional.  It is a character string name
            that is associated with the processor.  If an uncaught exception
            is thrown by an event processor, the exception is reported along
            with the name of the event processor that threw it.  If no
            name is provided one is selected for the processor.  Providing
            a name makes it a bit easier to determine the source of an
            exception.
        </para>
        <para>
            Once these changes have been made, SpecTcl can be compiled and
            the resulting tailored SpecTcl will have an event processing pipeline
            that consists of only our event processor.
        </para>
    </section>
    <section>
        <title>Playing back filter data</title>
        <para>
            A SpecTcl filter is a mechanism that allows you to transform a raw
            data set into a decoded subset of the data.  By decoded subset we mean
            that:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Only events that satisfy the filter's gate are written to the
                    filtered data set.
                </para>
            </listitem>
            <listitem>
                <para>
                    A subset of the parameters decoded from each event are
                    written to the data set.
                </para>
            </listitem>
            <listitem>
                <para>
                    The structure of the raw event is lost.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            Since the structure of the raw event is lost, and since any parameter
            can be written to the output file, the event processing pipeline
            used to analyze data from a raw event file is not useful in analyzing
            filter files:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    There is no raw event to decode into raw parameters.
                </para>
            </listitem>
            <listitem>
                <para>
                    Parameters computed by later stages of the pipeline can
                    already be present in the event file.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            When analyzing filter files you must therefore:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Register an initial stage of the event analysis pipeline
                    that can read the filter file.
                </para>
            </listitem>
            <listitem>
                <para>
                    Register subsequent stages that compute parameters that
                    are not already present in the filter file.  You could think
                    of analysis as performing an initial broad cut on the data
                    and then subsequently only producing physically meaningful
                    parameter on this subset.  The event processor that computes
                    these parameters would be in the pipeline for analyzing
                    filtered data.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            In this section, we're going to look at how to set up the first
            element of an analysis pipeline that can analyze filter data.  In
            the next section, we'll look at an extension to SpecTcl that allows
            you to dynamically switch SpecTcl between the analysis of raw data
            and filtered data.
        </para>
        <para>
            SpecTcl provides an event processor that can decode any filter file.
            The parameters in the filter file are decoded into parameters of
            the name they had when they were written..
            If a parameter is found in the filter file, but
            is not defined in SpecTcl when the filter is read back, it is
            ignored without reporting an error.
        </para>
        <para>
            The filter event processor element must be registered as the first
            element of the SpecTcl event processing pipeline.  To use it we must:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    <literal>#include</literal> the filter file decoder
                    event processor into <filename>MySpecTclApp.cpp</filename>.
                    This header is named <filename>FilterEventProcessor.h</filename>
                    and defines the class
                    <classname>CFilterEventProcessor</classname>.
                </para>
            </listitem>
            <listitem>
                <para>
                    Replace the event processing pipeline definition
                    in <methodname>CreateAnalysisPipeline</methodname>
                    so that it contains an instance of
                    a <classname>CFilterEventProcessor</classname> class.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            Note that it does no harm to leave our raw event processors linked
            in with SpecTcl. Towards the top of <filename>MySpecTclApp.cpp</filename>:
        </para>
        <informalexample>
            <programlisting>
//////////////
#include &lt;config.h&gt;
#include "MySpecTclApp.h"
#include "EventProcessor.h"
#include "TCLAnalyzer.h"
#include &lt;Event.h&gt;
#include &lt;TreeParameter.h&gt;
#include "MyEventProcessor.h"                // &lt;- this line can stay in
#include &lt;ilterEventProcessor.h&gt;       // &lt;- add this line
            </programlisting>
        </informalexample>
        <para>
            Make <methodname>CreateAnalysisPipeline</methodname> look like
            this:
        </para>
        <example>
            <title>
                Event analysis pipeline for filters.
            </title>
            <programlisting>
void
CMySpecTclApp::CreateAnalysisPipeline(CAnalyzer&amp; rAnalyzer)
{
  RegisterEventProcessor(*(new CFilterEventProcessor), "Filter-unpacker");


}
                
            </programlisting>
            <para>
                Recompiling this SpecTcl (via <command>make</command>) will
                result in a SpecTcl instance that can analyze filter files.
            </para>
        </example>
    </section>
</chapter>
<chapter id='chap.spectclapi'>
    <title>The SpecTcl API</title>
    <para>
        The <classname>SpecTcl</classname> class provides an application programming
        interface (API) to SpecTcl's internals.  If you use it rather than poking
        about directly in SpecTcl's data structures, we can promise you your
        program will be immune from internal re-organizations of SpecTcl's
        parameter, spectrum and gate dictionaries.
        <classname>SpecTcl</classname> also provides access to the event analysis
        pipeline, the event sing pipeline
        (described in <link linkend='chap.eventsinkpipeline' endterm='chap.eventsinkpipeline.title' />),
        filters and several other objects.
    </para>
    <para>
        In this chapter we'll take a brief tour of the <classname>SpecTcl</classname>
        class facilities and provide examples of its use.  Full reference information
        is provided in the programmer reference manual. 
    </para>
    <para>
        The <classname>SpecTcl</classname> class impleements the
        <firstterm>singleton pattern</firstterm>.
        Wikipedia provides a nice page on the singleton pattern
        <ulink url='https://en.wikipedia.org/wiki/Singleton_pattern'>
            Wikipedia provides a nice page on the singleton pattern
        </ulink>.  Check it out.
    </para>
    <para>
        What you mostly need to know about singletons is that the class is written
        in a way to ensure that only one instance of the class is ever created.
        The mechanics of this are to:
    </para>
    <itemizedlist>
        <listitem>
            <para>
                Make the constructor private so that you cannot ever use it
                to create an instance.
            </para>
        </listitem>
        <listitem>
            <para>
                Provide a method (<methodname>getInstance</methodname>) that
                returns a pointer to the single instance of the class, creating
                it if needed.
            </para>
        </listitem>
    </itemizedlist>
    <para>
        This means that to use the <classname>SpecTcl</classname> class, rather
        than constructing an object you'll have code like:
    </para>
    <informalexample>
        <programlisting>
            ...
SpecTcl&amp; api = *(SpecTcl::getInstance());
            ...
        </programlisting>
    </informalexample>
    <para>
        To obtain the singleton instance of the API class.  Once gotten, you
        can then invoke methods on that API object just like any other object.
    </para>
    <para>
        In the remainder of this chapter we'll look at the families of methods
        provided by the <classname>SpecTcl</classname> class:
    </para>
    <variablelist>
        <varlistentry>
            <term>
                <link linkend='sec.api.parameters' endterm='sec.api.parameters.title'/>
            </term>
            <listitem>
                <para>
                    The API provides methods to inspect and maniuplate the
                    SpecTcl parameter dictionary.  These parametrs are the
                    low level parameter definitions, not tree parameters.
                </para>
                <para>
                    In  most cases, since tree parameters with the same name
                    map to the same low level parameter, an API for the tree
                    parameters are not needed.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <link linkend='sec.api.spectra' endterm='sec.api.spectra.title' />
            </term>
            <listitem>
                <para>
                    The API provides methods that allow you to query and
                    manipulate the SpecTcl spectrum dictionary.    These
                    methods include methods that can create spectra of any
                    type.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <link linkend='sec.api.gates' endterm='sec.api.gates.title' />
            </term>
            <listitem>
                <para>
                    The API provides methods that allow you to query, define
                    and apply gates.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <link linkend='sec.api.evpipeline' endterm='sec.api.evpipeline.title' />
            </term>
            <listitem>
                <para>
                    The API provides methods to query and manipulate the event
                    processing pipeline.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <link linkend='sec.api.espipeline' endterm='sec.api.espipeline.title' />
            </term>
            <listitem>
                <para>
                    The API provides methods to query and manipulate the event sink
                    pipeline.  This part of the API includes methods to
                    create and manipulate filters.  Filters are a special case of
                    event sink pipeline elements, as is the histogrammer.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <link linkend='sec.api.objects' endterm='sec.api.objects.title' />
            </term>
            <listitem>
                <para>
                    The API provides methods to gain access to several important
                    SpecTcl objects.  Probably the most important of these is
                    the main Tcl interpreter.
                </para>
            </listitem>
        </varlistentry>
    </variablelist>
    <section id='sec.api.parameters'>
        <title id='sec.api.parameters.title'>The API and the parameter dictionary</title>
        <para>
            The SpecTcl parameter dictionary maintains the set of low level
            parameters.  Each parameter's definition is contained by an
            instance of the class <classname>CParameter</classname>.
        </para>
        <para>
            A family of <methodname>AddParameter</methodname> methods provides
            mechanisms for defining parameters.  Each of those methods has
            parameters that map on to the parameters of the
            <command>parameter</command> command.  
        </para>
        <para>
            All parameters have at least a name and an ID.  The id
            of a parameter is the slot in the <classname>CEvent</classname>
            array like object the parameter.  The name of the parameter is
            what you use to refer to it by in interactions with SpecTcl.
        </para>
        <para>
            Depending on how they were defined, parameters may have additional
            properties.  The function shown below uses the API to list the names
            and id's of all defined parameters to stdout.
        </para>
        <example>
            <title>Using the API to access parameter definitions</title>
            <programlisting>
#include &lt;SpecTcl.h&gt;
#include &lt;Histogrammer.h&gt;                     <co id='api.params.inchist' />
#include &lt;Parameter.h&gt;                        <co id='api.params.incparams' />
#include &lt;iostream&gt;

void listParameter()
{
  SpecTcl&amp; api = *(SpecTcl::getInstance());    <co id='api.params.getapi' />

  for (auto p = api.BeginParameters(); p != api.EndParameters(); p++) {  <co id='api.params.iteration' />
    std::string name  = p->first;                   <co id='api.params.iterefirst' />
    CParameter* param = &amp;p->second;             <co id='api.params.itersecond' />
    std::cout &lt;&lt; "Parameter " &lt;&lt; name
              &lt;&lt; " id = " &lt;&lt; param->getNumber() &lt;&lt; std::endl;  <co id='api.params.getnumber' />
  }
}             
            </programlisting>
        </example>
        <calloutlist>
            <callout arearefs='api.params.inchist'>
                <para>
                    The <classname>CHistogrammer</classname> class is a repository for
                    the dictionaries SpecTcl maintains.  it also defines their
                    structures and iterators.  Therefore wwe need to include
                    its definition in our program.
                </para>
                <para>
                    More on iterators in a bit.
                </para>
            </callout>
            <callout arearefs='api.params.incparams'>
                <para>
                    The parameter dictionary contains <classname>CParameter</classname>
                    objects indexed by parameter name.  We're gong to need to know
                    the methods and shape of this class, therefore we
                    include its header here.
                </para>
            </callout>
            <callout arearefs='api.params.getapi'>
                <para>
                    We've already discussed this bit of code earlier.  This
                    code gets a reference to the singleton API object.
                </para>
            </callout>
            <callout arearefs='api.params.iteration'>
                <para>
                    A lot is going on in this line.  The
                    <methodname>SpecTcl::BeginParameters</methodname> and
                    <methodname>SpecTcl::EndParameters</methodname> methods
                    return <firstterm>iterators</firstterm> into the parameter
                    dictionary.  Iterators are a generalization of pointers for
                    any ordered container.  The main thing to know about
                    them for this example is that they can be dereferenced to
                    give something in the container and they can be incremented
                    to get you to the next contained object.
                </para>
                <para>
                    Dictionaries in SpecTcl consist of pairs.  The first element
                    of each pair is the name of the object in the dictionary.
                    The second element is the object itself.
                </para>
                <para>
                    The <literal>auto</literal> keywords as used here, is a
                    part of the C++ 2011 standard.  It can be used instead of
                    a specific type when the compiler should be able to
                    infer a type from the expression.  In this case,
                    since <methodname>SpecTcl::BeginParameters()</methodname>
                    returns a <classname>ParameterDictionaryIterator</classname>,
                    the compiler can infer that this should be the type of
                    <varname>p</varname>.
                </para>
                <para>
                    To use this type inferenece you need to add
                    <literal>-std=c++11</literal> indicating that Gnu C++
                    should compile to the 2011 standard.
                </para>
            </callout>
            <callout arearefs='api.params.iterefirst'>
                <para>
                    The contents of a parameter dictionary are
                    <type>std::pair&lt;std::string, CParameter&gt;</type>.
                    Pairs have two members <structfield>first</structfield>
                    is the first item in the pair.
                    <structfield>second</structfield> is the second item
                    in the pair.
                </para>
                <para>
                    This pulls the parameter name out of the pair.
                </para>
            </callout>
            <callout arearefs='api.params.itersecond'>
                <para>
                    The second element of the pair in a parameter dictionary
                    is <classname>CParameter</classname> object.  This saves
                    the address of the parameter object of the dictionary
                    entry.
                </para>
            </callout>
            <callout arearefs='api.params.getnumber'>
                <para>
                    The <methodname>getNumber</methodname> method of a
                    <classname>CParameter</classname> comes from its base class
                    (<classname>CNamedItem</classname>).  It returns the number
                    used as the Id of the parameter.
                </para>
            </callout>
        </calloutlist>
    </section>
    <section id='sec.api.spectra'>
        <title id='sec.api.spectra.title'>The API and the spectrum dictionary</title>
        <para>
            The Spectrum part of the API allows you to manipulate the spectrum
            dictionary.  This allows you to define spectra of all supported
            spectrum types as  well as to enter them in the spectrum dictionary
            and to iterate over that dictionary.
        </para>
        <para>
            Another important capability is the ability to add spectrum dictionary
            observers.  A spectrum dictionary observer is invoked whenever the
            spectrum dictionary changes either due to a spectrum creation or
            a spectrum deletion.
        </para>
        <para>
            Suppose, for example, we have some imaging detector and want to
            make SpecTcl display an image (such as the projection of track in
            a TCP onto some plane).  We could do this by defining an dummy
            2-d spectrum (a 2-d spectrum on parameters that are never set), and
            filling in that spectrum with the appropiate image when requested.
        </para>
        <para>
            Assuming we have an event processor that can put the projection
            data into some array.
            Doing this is could be as simple as an event processor that:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Monitors the vale of a tree variable used to indicate we
                    want a snapshot of the projection.
                </para>
            </listitem>
            <listitem>
                <para>
                    When an event is encountered and
                    the tree variable is non zero locates the
                    dummy spectrum and fills it in with the projection.
                </para>
            </listitem>
            <listitem>
                <para>
                    Resets the tree parameter to zero so that the spectrum
                    remains static until next set by the user.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            We will show the code for this assuming that:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Some other event processor has produced an object
                    containing the projection. 
                </para>
            </listitem>
            <listitem>
                <para>
                    That object has an iterator that provides x,y,z values.
                    Where x and y are the coordinates of the spectrum in channels
                    and z is the value to store.  We'll assume that only the
                    non-zero channels will be returned by the iterator.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            Imagine, therefore a class like the one whose header is shown
            below to contain the projection.  The object in this class will
            be stored globally in the object <varname>projection</varname>
        </para>
        <example>
            <title>The projection class header</title>
            <programlisting>
#ifndef PROJECTION_H
#define PROJECTION_H


class Projection {
private:
  void* m_projectionData;
  int   m_xdim;                           <co id='api.spectra.projattr' />
  int   m_ydim;

public:
  typedef struct  _Pixel {
    int    x, y;
    int    z;                            <co id='api.spectra.pixel' />
  } Pixel, *pPixel;

  
  
public:
  Projection();
  ~Projection();                        

  // Setting the projection data:
  
  void clear();                         <co id='api.spectra.projclear' />
  void setDimension(int x, int y);      <co id='api.spectra.projsetdim' />
  void setPixel(int x, int y, int z);   <co id='api.spectra.setpixel' />

  // Iterating nonzero pixels of the projection.
  
  pPixel begin();                       <co id='api.spectra.projbegin' />
  pPixel end();                         <co id='api.spectra.projend'   />
  pPixel next(pPixel p);                <co id='api.spectra.projnext' />
};

#endif
                
            </programlisting>
        </example>
        <calloutlist>
            <callout arearefs='api.spectra.projattr'>
                <para>
                    This class is just a placeholder, so don't take it too
                    seriously. We assume it contains information about the
                    dimensionality of the image and the pixels. 
                </para>
            </callout>
            <callout arearefs='api.spectra.pixel'>
                <para>
                    As described in the lead in to this example, we'll assume
                    that we can get a set of non zero pixels defined by their
                    coordinates in the image and intensities.  This struct
                    defines how this looks programmtically.  We use a typedef
                    to define both the <classname>Pixel</classname> types
                    and a type that is a pointer, <classname>pPixel</classname> to
                    <classname>Pixel</classname>.
                </para>
            </callout>
            <callout arearefs='api.spectra.projclear'>
                <para>
                    This method is intended to be used by code we're not going
                    to show.  Calling it releases the image storage and
                    should be done prior to creating a new projection
                    image.
                </para>
            </callout>
            <callout arearefs='api.spectra.projsetdim'>
                <para>
                    Once an image is cleared, the code that creates the image
                    is going to call this to define the image size and allocate
                    storage for it.
                </para>
            </callout>
            <callout arearefs='api.spectra.setpixel' >
                <para>
                    Again intended to be used by the images setting code to
                    set the value of a  pixel in the image.
                </para>
            </callout>
            <callout arearefs='api.spectra.projbegin'>
                <para>
                    This method is part of the iteration interface.  It returns
                    a pointer to the first pixel with a nonzero value.  If there
                    are no non-zero pixels, the result will be the same as that
                    returned from the <methodname>end</methodname>.
                </para>
            </callout>
            <callout arearefs='api.spectra.projend'>
                <para>
                    This method is also part of the iteration interface. It returns
                    the pointer that e.g. <methodname>begin</methodname> or
                    <methodname>next</methodname> would return if iteration
                    has completed.  It is important to note that the
                    end pointer does not point to a valid pixel and should
                    not be dereferenced (very likely it's the <literal>nullptr</literal>).
                </para>
            </callout>
            <callout arearefs='api.spectra.projnext'>
                <para>
                    Given a pixel pointer, returns a pointer to the next nonzero
                    pixel.  Note that if there are no more non zero pixels,
                    this will return the same value that
                    <methodname>end</methodname> returns.  This means a typical
                    iteration over the image might look like:
                </para>
                <informalexample>
                    <programlisting>
Projection*  someProjection=gProjection;
for (pPixel p = someProjection-&gt;begin(); p != pProjection-&gt;end(); p = pProjection-&gt;next()) {
    // do something with the pixel pointed to by p.
}
                    </programlisting>
                </informalexample>
            </callout>
            
        </calloutlist>
        <para>
            Now that we have an API to program against, let's look at the header
            for our event processor.  We're going to need to store a few bits
            of information:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    A pointer or reference to the projection object we'll
                    pull data from.
                </para>
            </listitem>
            <listitem>
                <para>
                    The name of a spectrum that we'll put the data into
                </para>
            </listitem>
            <listitem>
                <para>
                    The tree variable that will serve as the flag to tell us
                    to update the image..
                </para>
            </listitem>
        </itemizedlist>
        <example>
            <title>Header for an event processor that fills in a spectrum.</title>
            <programlisting>
#ifndef FILLIMAGE_H
#define FILLIMAGE_H

#include &lt;EventProcessor.h&gt;
#include &lt;string&gt;
#include &lt;TreeParameter.h&gt;

class Projection;

class FillImage : public CEventProcessor
{
private:
  Projection&amp;    m_rProjection;
  std::string        m_spectrumName;
  CTreeVariable      m_updateFlag;

public:
  FillImage(Projection&amp; p, const char* spName, const char* flagName);

  Bool_t operator()(const Address_t pEvent, CEvent&amp; rEvent,
                    CAnalyzer&amp; rAnalyzer, CBufferDecoder&amp; rDecoder
                    );



};

#endif
                
            </programlisting>
        </example>
        <para>
            This should be reasonably self explanatory.  The constructor will
            initialize the member variables and the <methodname>operator()</methodname>
            function call operator will get called for each event.
        </para>
        <para>
            The constructor implementation is trivial:
        </para>
        <example>
            <title>FillImage event processor constructor</title>
            <programlisting>
#include "FillImage.h"
#include "projection.h"


FillImage:: FillImage(Projection&amp; p, const char* spName, const char* flagName) :
  m_rProjection(p),
  m_spectrumName(spName),
  m_updateFlag(flagName, 0.0, "Flag")
{}

            </programlisting>
        </example>
        <para>
            This should also be fairly self explanatory.
        </para>
        <para>
            Now let's see what the function call operator looks like it'll need to:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Do nothing if the m_updateFlag variable is zero. Otherwise:
                </para>
            </listitem>
            <listitem>
                <para>
                    Reset the m_updateFlag to zero.
                </para>
            </listitem>
            <listitem>
                <para>
                    Find the spectrum, ensure it's a 2d spectrum and clear it.
                </para>
            </listitem>
            <listitem>
                <para>
                    Iterate over the pixels in the projection and set them in
                    the spectrum if their coordinates fit.  Clip the image if not.
                </para>
            </listitem>
            <listitem>
                <para>
                    Return <literal>kfTrue</literal> indicating event processing
                    can continue with the next element of the pipeline.
                </para>
            </listitem>
        </itemizedlist>
        <example>
            <title><methodname>FillImage::operator()</methodname> implementation</title>
            <programlisting>
Bool_t
FillImage::operator()(const Address_t pEvent, CEvent&amp; rEvent,
                      CAnalyzer&amp; rAna, CBufferDecoder&amp; rDecoder)
{
  if (m_updateFlag) {
    m_updateFlag = 0.0;                           <co id='api.spec.op.flag' />
    SpecTcl*   pApi  = SpecTcl::getInstance();
    CSpectrum* pSpec = pApi-&gt;FindSpectrum(m_spectrumName);  <co id='api.spec.op.find' />

    if (pSpec) {
      CSpectrum2DL* p2d = dynamic_cast&lt;CSpectrum2DL*&gt;(pSpec); 
      if (p2d) {                                   <co id='api.spec.op.is2d' />
        p2d-&gt;Clear();                           <co id='api.spec.op.clear' />
        Size_t xdim = p2d-&gt;Dimension(0);      
        Size_t ydim = p2d-&gt;Dimension(1);        <co id='api.spec.op.dims' />
        UInt_t indices[2];


        Projection::pPixel p;
        for (p = m_rProjection.begin(); p != m_rProjection.end(); p = m_rProjection.next(p)) {
          if ((p-&gt;x &lt; xdim) &amp;&amp; (p-&gt;y &lt; ydim)) {  <co id='api.spec.op.clip' />
            indices[0] = p-&gt;x;
            indices[1] = p-&gt;y;
            p2d->set(indices, p-&gt;z);            <co id='api.spec.op.set' />
          }
        }

      }
    }
  }
  return kfTRUE;                                  <co id='api.spec.op.dontforget' />
}
                
            </programlisting>
        </example>
        <calloutlist>
            <callout arearefs='api.spec.op.flag'>
                <para>
                    The if checks for a on zero flag value.  If the flag is
                    non zero, it is set back to zero so that this code
                    only happens once..
                </para>
            </callout>
            <callout arearefs='api.spec.op.find'>
                <para>
                    Attempts to find the spectrum whose name we were constructed on.
                    This method of the API will either return a pointer to the
                    spectrum's <classname>CSpectrum</classname> object or it
                    will return a <literal>nullptr</literal>.  Only if the spectrum
                    is found can we go further.
                </para>
            </callout>
            <callout arearefs='api.spec.op.is2d'>
                <para>
                    The dynamic cast converts the generic spectrum into a
                    pointer into a 2-d longword spectrum.  This is really only
                    needed to ensure the spectrum is, in fact a 2-d longword
                    spectrum. If it isn't the dynamic cast returns a
                    <literal>nullptr</literal> and the remaining
                    code is bypassead.
                </para>
            </callout>
            <callout arearefs='api.spec.op.clear'>
                <para>
                    Only once wwe know we have a 2-d long spectrum, one we can
                    work with, do we clear any prior image from the spectrum.
                </para>
            </callout>
            <callout arearefs='api.spec.op.dims'>
                <para>
                    Since we need to ensure we don't write past the ends of the
                    spectrum, we fetch the X and Y dimensions of the spectrum.
                </para>
            </callout>
            <callout arearefs='api.spec.op.clip'>
                <para>
                    Clips the pixel against the limits of the spectrum.  The
                    assumption is that the x and y coordinates are actually
                    unsigned.
                </para>
            </callout>
            <callout arearefs='api.spec.op.set' >
                <para>
                    Copies the pixel value into the spectrum.
                </para>
            </callout>
            <callout arearefs='api.spec.op.dontforget'>
                <para>
                    Be sure to always return <literal>kfTRUE</literal> from
                    event processor methods if you don't wan the event
                    processing pipeline to abort.
                </para>
            </callout>
        </calloutlist>
    </section>
    <section id='sec.api.gates'>
        <title id='sec.api.gates.title'>The API and the gates dictionary</title>
        <para>
            The SpecTcl class provides a family of creationals that
            allow you to create any of the types of gates SpecTcl supports and
            to add them to the gate dictionary.
        </para>
        <para>
            Gates in SpecTcl are mutable.  That is once defined a gate can be
            modified.  This modification may change the gate type.   In order
            to allow gate checking to be done without regard to this mutability,
            software that checks gates should hold <classname>CGateContainer</classname>
            objects rather than directly holding <classname>CGate</classname>
            objects.
        </para>
        <para>
            <classname>CGateContainer</classname> objects provide an additional
            level of indirection.  Linguistically , they look like pointers.
            What they point to, however, can be dynamically modified by
            SpecTcl.   Thus a gate container that points to a specific named
            can be used to check that named gate regardless of changes
            that may have been made to that gate.
        </para>
        <para>
            This means that if you create a gate and add it to the dictionary,
            rather than holding on to the <classname>CGate*</classname> object
            and checking that, you should, instead, then use
            <methodname>FindGate</methodname> to obtain a gate container
            that you can use to reference the new gate.
        </para>
        <para>
            The example we're going to use demonstrates this;  We're going to
            show how to create a parameter whose value reflects which of several
            gate (if any) an event satisfied.  One use for this is to create
            a particle ID 1-d spectrum where the channels of the spectrum
            represent individual particle types.
        </para>
        <para>
            Our example will implement an event processor that will:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Create several gates and enter them into the gate dictionary
                    so that the user can modify them.  For simplicity, these will
                    be cuts on a single parameter: <literal>raw.00</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    Obtain gate containers for the gates and put them in an
                    <type>std::vector</type> of gate containers.
                </para>
            </listitem>
            <listitem>
                <para>
                    Create a new tree parameter named <literal>PID</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    For each event, if at least one gate is satisfied, the
                    <literal>PID</literal> tree parameter is given the index
                    of the gate container for that gate in the vector.
                </para>
            </listitem>
        </itemizedlist>
        <note>
            <title>NOTE</title>
            <para>
                The discussion above means that our event processor must be
                placed in the event processing pipeline <emphasis>after</emphasis>
                all parameters have been set.  This is because gates are
                evaluated on the parameters of the event, not on the
                raw event data.
            </para>
        </note>
        <para>
            Before turning to code, there's a bit more background that must
            be provided.
        </para>
        <para>
            Gate evaluations get cached.    That is once a gate is evaluated,
            a second evaluation just refers to the cached value.  The
            event sink pipeline invalidates the cached values prior to each event.
            This is done so that costly gate evaluations are only done once
            even though there may be several compound gates that refer to them.
        </para>
        <para>
            This is a problem because in order to improve program cache hit
            performance in SpecTcl, several events are run through the
            event processing pipeline before being passed on as a bunch to
            the evetn sink pipeline.
        </para>
        <para>
            What this means for us is that we have to invalidate the cache
            for each gate each event manually in our event processor.  If we don't
            our code will seem to run properly but we'll get runs of the same
            PID for groups of events where only the first event in each run
            is properly identified.
        </para>
        <para>
            Let's look at the header for our event processor.
        </para>
        <example>
            <title><classname>GateProcessor</classname> header.</title>
            <programlisting>
#ifndef GATEPROCESSOR_H
#define GATEPROCESSOR_H

#include &lt;EventProcessor.h&gt;
#include &lt;TreeParameter.h&gt;
#include &lt;vector&gt;

class CGateContainer;


class GateProcessor : public CEventProcessor
{
private:
  CTreeParameter m_pid;
  std::vector&lt;CGateContainer*&gt; m_gates;
public:
  GateProcessor();
  Bool_t OnInitialize();

  Bool_t operator()(const Address_t pEvent, CEvent&amp; rEvent,
		    CAnalyzer&amp; rAna, CBufferDecoder&amp; rDec);
};

#endif

            </programlisting>
        </example>
        <para>
            About the only thing I'm going to say about the header is that
            the constructor will create the tree parameter, but
            <methodname>OnInitialize</methodname> will be used to
            create the gates to ensure that enough of SpecTcl has been put together
            to support that operation.
        </para>
        <para>
            The constructor is trivial:
        </para>
        <example>
            <title><classname>GateProcessor</classname> constructor implementation</title>
            <programlisting>
#include "GateProcessor.h"
#include &lt;SpecTcl.h&gt;
#include &lt;GateContainer.h&gt;
#include &lt;Gate.h&gt;


GateProcessor::GateProcessor() :
  m_pid("PID")
{}

            </programlisting>
        </example>
        <para>
            <methodname>OnInitialize</methodname> creates the gates, gets
            gate containers for them and builds the vector
            <varname>m_gates</varname>:
        </para>
        <example>
            <title><methodname>GateProcessor::OnInitialize</methodname> implementation</title>
            <programlisting>
static const char* gateNames[] = {
  "Protons", "Deuterons", "Tritons", "3He", "Alphas", 0
};                                                <co id='api.gates.tabledriven' />
static float lows[] = {0, 100, 200, 300, 400};
static float highs[]  = {50, 150, 250, 350, 450};

static const char* pGateParam="raw.00";           <co id='api.gates.gateparam' />

Bool_t
GateProcessor::OnInitialize()
{
  SpecTcl&amp; api(*SpecTcl::getInstance());

  const char** pNames(gateNames);
  float* pLows(lows);
  float* pHighs(highs);

  while (*pNames) {
    CGate* pCut = api.CreateCut(pGateParam, *pLows, *pHighs); <co id='api.gates.create' />
    api.AddGate(*pNames, pCut);                               <co id='api.gates.adddict' />

    CGateContainer* pContainer = api.FindGate(*pNames);       <co id='api.gates.getcontainer' />
    assert(pContainer);                   // Must have a matching container.

    m_gates.push_back(pContainer);                           <co id='api.gates.savecontainer' />
    
    pNames++;
    pLows++;
    pHighs++;
  }
  return kfTRUE;
}

            </programlisting>
        </example>
        <calloutlist>
            <callout arearefs='api.gates.tabledriven'>
                <para>
                    These data are tables that we'll use to set up the initial
                    gates.  <varname>gateNames</varname> are the  names
                    of the gates.  The <varname>lows</varname> and
                    <varname>highs</varname> are an initial set of limits
                    for the cut gates we'll make. 
                </para>
            </callout>
            <callout arearefs='api.gates.gateparam'>
                <para>
                    <varname>pGateParam</varname>
                    is the name of the parameter the cuts will check.  Remember
                    that all gates are defined on one or more parameters.
                    This example is intended to demonstrate a set of techniques,
                    not be realistic.  Typically particle identification gates
                    would be contours on some pair of parameters.
                </para>
            </callout>
            <callout arearefs='api.gates.create'>
                <para>
                    Creates one of the gates. The loop over the names will create
                    all of the gates.   Each cut gate is defined by the
                    parameter it checks and the low/high limits of the cut.
                </para>
            </callout>
            <callout arearefs='api.gates.adddict'>
                <para>
                    Adds the new gate to the SpecTcl gate dictionary.  This
                    wraps the gate in a gate container as well so that
                    the gate has a fixed point of reference (its container)
                    even though the gate itself may change.  
                </para>
            </callout>
            <callout arearefs='api.gates.getcontainer'>
                <para>
                    Gets the gate container that wraps the gate we just made.
                    This must succeed since we just entered the gate.  The
                    <literal>assert</literal> statement that follows defends
                    against failure.
                </para>
            </callout>
            <callout arearefs='api.gates.savecontainer' >
                <para>
                    Gate containers gotten are pushed into the vector for use
                    in <methodname>operator()</methodname>.  This means that
                    the PID value for events that satisfy the <literal>Protons</literal>
                    gate will be zero, the <literal>Deuterons</literal> gate 1
                    and so on through the <literal>Alphas</literal> gate
                    which will have the value 4.
                </para>
            </callout>
        </calloutlist>
        <para>
            This preparation makes the <methodname>operator()</methodname>
            relatively simple.  We must
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Clear the cache in each gate via its stored gate container
                </para>
            </listitem>
            <listitem>
                <para>
                    Loop over the gate containers asking each gate to check itself.
                    If we find a match we can set the value of
                    the <literal>PID</literal> parameter and exit the loop.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            Here's the code for that:
        </para>
        <example>
            <title><methodname>GateProcessor::operator()</methodname> implementation</title>
            <programlisting>
Bool_t
GateProcessor::operator()(const Address_t pEvent, CEvent&amp; rEvent,
			  CAnalyzer&amp; rAnA, CBufferDecoder&amp; rDecoder)
{
  for (int i = 0; i &lt; m_gates.size(); i++) {
    CGateContainer&amp; p(*(m_gates[i]));            <co id='api.gates.op.getcontainer' />
    p-&gt;Reset();                                   <co id='api.gates.op.clearcache' />
    if ((*p)(rEvent)) {                              <co id='api.gates.op.check' />
      m_pid = i;                                     <co id='api.gates.op.setparam' />
      break;
    }
  }
  return kfTRUE;
}
            </programlisting>
        </example>
        <calloutlist>
            <callout arearefs='api.gates.op.getcontainer'>
                <para>
                    For each pass through the loop, we get a reference to the
                    appropriate gate container.  The reference can be treated
                    as if it were a pointer to the underlying gate.
                    We will make use of this.  Notationally this is much
                    simpler than dealing with the pointer to the gate container
                    directly.
                </para>
            </callout>
            <callout arearefs='api.gates.op.clearcache'>
                <para>
                    For each gate, we must clear its cached value before
                    checking it.  This was explained previously.
                </para>
            </callout>
            <callout arearefs='api.gates.op.check'>
                <para>
                    This statement checks the gate.  As you can see the gate
                    check method requires a reference to the
                    <classname>CEvent</classname> being built for this event.
                    This is why our event processor must be registered
                    <emphasis>after</emphasis> <classname>CEvent</classname>
                    has been filled in for this event.
                </para>
                <para>
                    Remember that the gate we created may not be the gate we're
                    checking.  It can have different limit points, it can
                    be a different gate type. It could be on a different parameter
                    or set of parameters, depending on what the user has done.
                </para>
            </callout>
            <callout arearefs='api.gates.op.setparam'>
                <para>
                    If the gate check operation returns true, the gate has
                    been satisfied by the contents of the <classname>CEvent</classname>
                    object it was given.  In this case, we set the
                    <literal>PID</literal> parameter to the index of the gate
                    which was satisfied.  If no gate is satisfied, the
                    <literal>PID</literal> parameter has no value for this event.
                    Any spectrum on it won't be incremented.
                </para>
                <para>
                    Note that after checking the gates we don't need to reset
                    their cache.  This is because, if there are more events
                    to be processed prior to starting the event sink pipeline,
                    we'll reset the cache as part of gate processing.
                    If the event sink pipeline will be called, it will reset
                    the cache on all defined gates prior to running that pipeline
                    for each event.
                </para>
            </callout>
        </calloutlist>
    </section>
    <section id='sec.api.evpipeline'>
        <title id='sec.api.evpipeline.title' >The API and the event processing pipeline</title>
        <para>
            The API provides methods that allow you to dynamically change
            the contents of the event processing pipeline.  You can add
            event processors at any point in the pipeline, remove them
            from any point in the pipeline and iterate the pipeline.
        </para>
        <para>
            The example we will show in this section will be one that can
            swap out, and back, entire event processing pipelines.  Our
            specific use case will be to save the contents of an event processing
            pipeline so that it can be restored later, clear the pipeline
            and insert the event processor that can unpack filter files.
        </para>
        <para>
            In <link linkend='chap.addingcommands' endterm='chap.addingcommands.title' />,
            we will combine the class we're writing here with a Tcl command
            added to SpecTcl to allow us to switch dynamically between analyzing
            raw event files and analyzing filter files.
        </para>
        <para>
            The class we're going to write has the following interface specification:
        </para>
        <example>
            <title>Class to switch event analysis pipelines</title>
            <programlisting>
#ifndef EVPSWITCHER_H
#define EVPSWITCHER_H
#include &lt;vector&gt;
#include &lt;string&gt;

class CEventProcessor;
class CFilterEventProcessor;
class EVPSwitcher {
private:
  std::vector&lt;std::pair&lt;std::string, CEventProcessor*&gt; &gt; m_savedPipeline;
  CEventProcessor&amp;                                m_FilterProcessor;
public:
  EVPSwitcher();
  ~EVPSwitcher();
  
  void save();
  void restore();
  void useFilterProcessor();

};

#endif

            </programlisting>
        </example>
        <para>
            The concept is fairly simple.  The <methodname>save</methodname>
            method will save the current event processing pipeline processor
            names and object pointers into the m_savedPipeline member.
            Similarly <methodname>restor</methodname>, restore will replace
            the current event processing pipeline with the processors
            saved in <varname>m_savedPipeline</varname>.
        </para>
        <para>
            <methodname>useFilterProcessor</methodname> will save the pipeline
            and replace it with one that contains the filter event processor
            in <varname>m_FilterProcessor</varname>.  This attribute will
            be created by the constructor and destroyed by the destructor.
        </para>
        <para>
            Let's have a look at the constructor and destructor as they're closely
            linked:
        </para>
        <example>
            <title>EVPSwitcher constructor and destrutor</title>
            <programlisting>
  #include "EVPSwitcher.h"
#include &lt;EventProcessor.h&gt;
#include &lt;FilterEventProcessor.h&gt;
#include &lt;SpecTcl.h&gt;
#include &lt;TCLAnalyzer.h&gt;


EVPSwitcher::EVPSwitcher() :
  m_FilterProcessor(*(new CFilterEventProcessor))
{}

EVPSwitcher::~EVPSwitcher()
{
  delete &amp;m_FilterProcessor;
}
              
            </programlisting>
        </example>
        <para>
            Straightforward code.  The constructor creates a filter event
            processor, saving a reference to it in <varname>m_FilterProcessor</varname>.
            The destructor prevents this from being a memory leak if we are
            destroyed.
        </para>
        <para>
            The <methodname>save</methodname> method will:
        </para>
        <orderedlist>
            <listitem>
                <para>
                    Clear the <varname>m_savedPipeline</varname> vector.
                    We only need to clear the vector.  We don't destroy any objects.
                </para>
            </listitem>
            <listitem>
                <para>
                    Walk the event processing pipeline using the
                    <methodname>SpecTcl::ProcessingPipelineBegin</methodname>
                    and <methodname>SpecTcl::ProcessingPeiplineEnd</methodname>
                    methods to get iterators that "point" to successive
                    event processign pipeline elements.
                </para>
                <para>
                    Each event processing pipeline element is a pair
                    containing the name of the pipeline element and
                    a pointer to the event processor in that position.
                    Ths is exactly what we need.
                </para>
            </listitem>
        </orderedlist>
        <para>
            The <methodname>std::vector::insert</methodname> method makes
            this all pretty trivial:
        </para>
        <example>
            <title><methodname>EVPSwitcher::save</methodname> implementation</title>
            <programlisting>
void
EVPSwitcher::save()
{
  m_savedPipeline.clear();
  SpecTcl&amp; api(*SpecTcl::getInstance());

  m_savedPipeline.insert(m_savedPipeline.end(),
			 api.ProcessingPipelineBegin(),
			 api.ProcessingPipelineEnd());
}

            </programlisting>
        </example>
        <para>
            <methodname>restore</methodname> is a matter of:
        </para>
        <orderedlist>
            <listitem>
                <para>
                    Removing event processing pipeline elements until the
                    event processing pipeline is empty.
                </para>
            </listitem>
            <listitem>
                <para>
                    Inserting each event processor into the now emptied
                    event processing pipeline.
                </para>
            </listitem>
        </orderedlist>
        <para>
            Since emptying the event processing pipeline is also needed
            for <methodname>useFilterProcessotr</methodname>, we'll
            introduce a utility method; <methodname>clearPipeline</methodname>.
            Here's the implementatiuon of that utility and
            <methodname>restore</methodname>.
        </para>
        <example>
            <title><methodname>EVPSwitcher::restore</methodname> implementation</title>
            <programlisting>
void
EVPSwitcher::clearPipeline()
{
  SpecTcl&amp; api(*SpecTcl::getInstance());

  while(api.ProcessingPipelineBegin() != api.ProcessingPipelineEnd()) {
    api.RemoveEventProcessor(api.ProcessingPipelineBegin());
  }
}

void
EVPSwitcher::restore()
{
  clearPipeline();
  SpecTcl&amp; api(*SpecTcl::getInstance());

  for (int i = 0; i &lt; m_savedPipeline.size(); i++) {
    api.AddEventProcessor(*m_savedPipeline[i].second, m_savedPipeline[i].first.c_str());
  }
}

            </programlisting>
        </example>
        <para>
            Much of this should be straightforward.  The only bits that are
            interesting is that the call to
            <methodname>SpecTcl::AddEventProcessor</methodname> requires
            a reference to the event processor and a <type>const char*</type>
            name.
        </para>
        <para>
            Finally to set up SpecTcl to read data from filtered data files,
            we need to:
        </para>
        <orderedlist>
            <listitem>
                <para>
                    Clear the event processing pipeline
                </para>
            </listitem>
            <listitem>
                <para>
                    Add our filter event processor to the pipeline.
                </para>
            </listitem>            
        </orderedlist>
        <para>
            In all of this, the assumption is that prior to this,
            if someone wants the event processing pipeline restored,
            they will have first invoked
            <methodname>save</methodname> to do that.
        </para>
        <example>
            <title><methodname>EVPSwitcher::useFilterProcessor</methodname> implementation</title>
            <programlisting>
void
EVPSwitcher::useFilterProcessor()
{
  clearPipeline();
  SpecTcl::getInstance()-&gt;AddEventProcessor(m_FilterProcessor, "Filter-decoder");
}
            </programlisting>
        </example>
        <para>
            I think again, no explanation is needed.
        </para>
    </section>
    <section id='sec.api.espipeline'>
        <title id='sec.api.espipeline.title'>The API and the event sink pipeline</title>
        <para>
            The event sink pipeline is a pipeline of processors that receives
            control when there are unpacked events to process.  Unpacked events
            are the results of execution of the event analysis pipeline.
            The are represented in SpecTcl by filled <classname>CEvent</classname>
            objects.    Alternatively, they represent tree parameters and tree
            parameter arrays that have been set by the stages of the event
            analysis pipeline.
        </para>
        <para>
            SpecTcl has two types of built in event sink pipeline
            elements.  
        </para>
        <orderedlist>
            <listitem>
                <para>
                    The histogrammer, which checks gates and increments histograms
                    as directed by gate definitions, histogram definitions and
                    gate applications.  This object is the core of SpecTcl's
                    built per event analysis.
                </para>
            </listitem>
            <listitem>
                <para>
                    Filters which can be created dynamically and added to the
                    event processing pipeline.  Filters are objects that
                    can output a subset of the parameters of a subset of events
                    to file.
                </para>
            </listitem>
        </orderedlist>
        <para>
            The event sink pipeline is described more completely in
            <link linkend='chap.eventsinkpipeline' endterm='chap.eventsinkpipeline.title' />.
        </para>
        <para>
            The API provides methods to edit and visit each element ofthe event sink
            pipeline.  The example in this section will be a function that lists
            the names of event sink pipeline elements.  This function could,
            once you know how, be invoked by a Tcl command extension to SpecTcl.            
        </para>
        <example>
            <title>Listing the event sink pipeline elements</title>
            <programlisting>
#include &lt;SpecTcl.h&gt;
#include &lt;EventSinkPipeline.h&gt;
#include &lt;iostream&gt;


void
ListEventSinkPipeline()
{
  SpecTcl&amp; api(*SpecTcl::getInstance());

  for(auto p = api.EventSinkPipelineBegin(); p != api.EventSinkPipelineEnd(); p++) {
    std::cout &lt;&lt; p->first &lt;&lt; std::endl;
  }
}
            </programlisting>
        </example>
        <para>
            About the only thing that needs to be said about this rather classic
            use of iterators is that the event sink pipeline iterator can be
            treated as a pointer to
            <type>std::pair&lt;std::string, CEventSink*&gt;</type>.  The first
            element of the pair, the string, is the name given to that pipeline
            element, either by SpecTcl, if none was provided, or by the
            code that registered that element.
        </para>
    </section>
    <section id='sec.api.objects'>
        <title id='sec.api.objects.title'>The API and SpecTcl Objects.</title>
        <para>
            In this section we're going to look at a few of the other SpecTcl
            objects that the SpecTcl API can return:
        </para>
        <variablelist>
            <varlistentry>
                <term><methodname>getInterpreter</methodname></term>
                <listitem>
                    <para>
                        Returns the <classname>CTCLInterpreter*</classname> pointer
                        that wraps SpecTcl's main Tcl interpreter.  You can use
                        this to create new command, access variables and, in
                        general perform any operation supported by the
                        Tcl++ library and Tcl API.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>GetHistogrammer</methodname></term>
                <listitem>
                    <para>
                        In most cases you don't need this.  The histogrammer
                        object is a special element of the event sink pipeline.
                        It does all the gate checking and histogramming on
                        <classname>CEvent</classname> objects produced
                        by the event processing pipeline.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>GetAnalyzer</methodname></term>
                <listitem>
                    <para>
                        Returns the <classname>CAnalyzer*</classname> pointer to
                        the analyzer that's controlling the flow of
                        analysis.  In SpecTcl 5.0, unless replaced this is
                        a <classname>CTclAnalyzer</classname> object.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>GetEventSinkPipeline</methodname></term>
                <listitem>
                    <para>
                        Returns a <classname>CEventSinkPipeline*</classname>.
                        A pointer to the event sink pipeline.
                        pointer.  In general you don't need this object.
                        You can do what you need to do with the
                        event sink pipeline part of the API.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </section>
</chapter>
<chapter id='chap.eventsinkpipeline'>
    <title id='chap.eventsinkpipeline.title'>
        The SpecTcl event sink pipeline.
    </title>
    <para>
        If the event processing pipeline takes the raw event and produces
        a set of parameters, the event sink pipeline operates on those
        parameters.  The most important event sink pipeline element is the
        hisotogrammer.  That's the part of SpecTcl that increments histograms
        depending on the definitions in the parameter, spectrum and gate dictionaries
        as well as the application of gates t spectra.
    </para>
    <para>
        Filters are another important class of event sink pipeline element.
        Each filter is appended to the event sink pipeline and allowed to
        process event lists to produce filtered event files.
    </para>
    <para>
        It is also possible to add processors to the even sink pipeline.
        Processors in the event sink pipeline are subclassed from
        <classname>CEventSink</classname> defined in
        <filename>EventSink.h</filename>.  They can override the following
        virtual methods:
    </para>
    <variablelist>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier> virtual </modifier>
                    <type>void </type>
                    <methodname>OnAttach</methodname>
                    <methodparam>
                        <modifier></modifier>
                        <type>CAnalyzer&amp;</type>
                        <parameter>rAnalyzer</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Called when the element is added to the event sink pipeline.
                    <parameter>rAnalyzer</parameter> is a reference to the
                    SpecTcl analyzer.  The analyzer controls the flow of
                    analysis through SpecTcl.  Note that in most cases, this
                    is actually an instance of a
                    <classname>CTCLAnalyzer</classname>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier> virtual</modifier>
                    <type>void </type>
                    <methodname>OnDetach</methodname>
                    <methodparam>
                        <modifier></modifier>
                        <type>CAnalyzer&amp;</type>
                        <parameter>rAnalyzer</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Called if an element is removed from the event sink pipeline
                    (It's not unusual for elements to remain in the pipeline
                    for the duration of the program run).  Once more
                    <parameter>rAnalyzer</parameter> is a reference to the
                    analyzer object that controls the analysis of data by
                    SpecTcl.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>virtual</modifier>
                    <type> void</type>
                    <methodname>operator()</methodname>
                    <methodparam>
                        <modifier></modifier>
                        <type>CEventList&amp; </type><parameter>rEvents</parameter>
                    </methodparam>
                    <modifier>= 0</modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    This method is pure virtual in the base class and therefore
                    must be implemented in the specific classes that get
                    instantiated.   It is called for each burst of events from
                    the event processing pipeline.
                </para>
                <para>
                    <classname>CEventList</classname> is defined in
                    <filename>EventList.h</filename>.  You can either get the
                    underlying vector of <classname>CEvent</classname> pointers
                    or iterate through it using its iterator interface.
                </para>
            </listitem>
        </varlistentry>
    </variablelist>
    <para>
        Let's look at an example event sink processor.  The processor will
        be pretty simple.  It's going to maintain, and periodically output,
        the number of events processed and the total number of parameters
        that have been given values. 
    </para>
    <para>
        To do this efficiently, we're going to need to delve into the nasty
        corners of the <classname>CEvent</classname> class.  Specifically,
        while,  for each event, we can find out how many parameters
        are defined by iterating that object and asking each parameter
        if its defined, for large analysis cases this can be very inefficent.
    </para>
    <para>
        The fact that this iteration can be so inefficient brings us to an
        optimization that SpecTcl uses to ensure that the histogrammer neither
        has to iterate over the parameters in an event, nor iterate over the
        histograms that have been defined.  This optimization is incredibly
        good for <firstterm>sparse analysis</firstterm>.
    </para>
    <para>
        Sparse analysis means that for a large analysis case, large number of
        parameters, and/or large number of histograms, for any event, we really
        are only going to assign values to a small percentage of parameters
        and have to increment a very small subset of the histograms.
    </para>
    <para>
        SpecTcl's <classname>CEvent</classname> helps SpecTcl to iterate over
        the sparse parameter space by building, as each parameter is defined,
        a <firstterm>DopeVector</firstterm>.  A dope vector is just a vector
        whose elements are indices to those elements that have been defined.
        Using the dope vector makes our life simple;  The number of elements
        in a <classname>CEvent</classname> object's dope vector is the
        number of parameters that have been given values for that event.
    </para>
    <para>
        This background out of the way; lets look at the class header first:
    </para>
    <example>
        <title>Event sink processor header</title>
        <programlisting>
#ifndef EVENTCOUNTER_H
#define EVENTCOUNTER_H


#include &lt;EventSink.h&gt;
class EventCounter : public CEventSink
{
private:
  unsigned m_nEvents;
  unsigned m_nParametrs;
  unsigned m_nPeriod;
public:
  EventCounter(unsigned period);

  void operator()(CEventList&amp; rEvents);
};


#endif
            
        </programlisting>
    </example>
    <para>
        The purpose of the <varname>m_nPeriod </varname> and
        <parameter>period</parameter> attributes and variables are to
        define how often we output statistics.
        <varname>m_nEvents</varname> will count events and
        <varname>m_nParameters</varname> will total the parameters set across
        all events.
    </para>
    <para>
        The constructor is pretty simple:
    </para>
    <example>
        <title>EventCounter constructor implementation</title>
        <programlisting>
#include "EventCounter.h"
#include &lt;Event.h&gt;
#include &lt;EventList.h&gt;
#include &lt;iostream&gt;


EventCounter::EventCounter(unsigned period) :
  m_nEvents(0),
  m_nParameters(0),
  m_nPeriod(period)
{}

        </programlisting>
    </example>
    <para>
        Let's now look at <methodname>operator()</methodname>;
    </para>
    <example>
        <title><methodname>EventCounter::operator()</methodname> implemntation</title>
        <programlisting>

void
EventCounter::operator()(CEventList&amp; rEvents)
{
  for (auto p = rEvents.begin(); p != rEvents.end(); p++) {
    CEvent* pEvent = *p;
    m_nEvents++;
    m_nParameters += pEvent->getDopeVector().size();

    if((m_nEvents % m_nPeriod) == 0) {
      std::cout &lt;&lt; "Processed " &lt;&lt; m_nEvents
                &lt;&lt;" for a total of " &lt;&lt;m_nParameters &lt;&lt; " parameters\n";;
    }
  }
}

        </programlisting>
    </example>
</chapter>
<chapter id='chap.addingcommands'>
    <title id='chap.addingcommands.title'>
        libTcl++ and adding commands to SpecTcl
    </title>
    <para>
        One of the important features of the Tcl scripting language is that it
        is easily extensible.  Application specific commands can be added, not only
        as <command>proc</command>s but also as native, compiled commands.  The
        SpecTcl framework provides hooks for adding commands as SpecTcl starts.
    </para>
    <para>
        In this chapter we will revisit our <classname>EVPSwitcher</classname> class  from
        <link linkend='sec.api.evpipeline' endterm='sec.api.evpipeline.title' />.
        We'll wrap a <firstterm>command ensemble</firstterm> around an instance
        of that class so that we can use a Tcl command to dynamically
        switch between processing raw event files and filter files.
    </para>
    <para>
        We'll have to start off with a bunch of background so that the example
        is understandable.  Specifically we need to:
    </para>
    <itemizedlist>
        <listitem>
            <para>
                Introduce the Tcl++ library used by both NSCLDAQ and SpecTcl
                to provide a C++ class wrapper around elements of the
                Tcl API.
            </para>
        </listitem>
        <listitem>
            <para>
                Introduce several key classes from that library that we'll need.
            </para>
        </listitem>
        <listitem>
            <para>
                Define a command ensemble and describe the specific command
                ensemble that we'll create.
            </para>
        </listitem>
    </itemizedlist>
    <para>
        The Tcl++ provides class wrappers around many Tcl objects.  Reference
        information is provided in the NSCLDAQ reference pages.  Here we'll summarize
        key classes.
    </para>
    <formalpara>
        <title><classname>CTCLInterpreter</classname></title>
        <para>
            Wraps a Tcl Interpreter.  This class is defined in
            <filename>TCLInterpreter.h</filename>
            Note that the API provides a method
            to return the interpreter used to execute SpecTcl commands.
            Note also that applications can have more than one interpreter.
        </para>
    </formalpara>
    <para>
        The interpreter provides facilities to among other things:
    </para>
    <itemizedlist>
        <listitem>
            <para>
                Execute scripts.
            </para>
        </listitem>
        <listitem>
            <para>
                Evaluate expressions.
            </para>
        </listitem>
        <listitem>
            <para>
                Add and remove commands.
            </para>
        </listitem>
        <listitem>
            <para>
                Set a command result.
            </para>
        </listitem>
    </itemizedlist>
    <para>
        Many Tcl objects require that they be bound to an interpreter to function
        properly.  For example, a variable only makes sense within an interpreter
        as does a command.   The base class for such objects is a
        <classname>CTCLInterpreterObject</classname>, defined in
        <filename>TCLInterpreterObject.h</filename>.
    </para>
    <para>
        This class provides mechiansms to bind the object to an intepreter
        after construction and to get the interpreter to which the object
        is bound.  Subclassses can make use of
        <methodname>AssertIfNotBound</methodname> which fails an assertion
        if the object is not currently associated with an interpreter.
    </para>
    <para>
        Commands themselves are objects.  Modern Tcl commands are encapsulated
        by <classname>CTCLObjectProcessor</classname> objects.  These use the
        modern <type>Tcl_Obj*</type> interface to commands rather than the old
        argc/argv interface.
    </para>
    <formalpara>
        <title><classname>CTTCLObjectProcessor</classname></title>
         <para>
             is defined in
            <filename>TCLObjectProcessor.h</filename>.  This class is a base class
            for actual commands and:
        </para>
    </formalpara>    

    <itemizedlist>
        <listitem>
            <para>
                Provides a base class constructor that takes care of binding
                the command to an interpreter and registering it with it.
            </para>
        </listitem>
        <listitem>
            <para>
                Provides a standard interface between Tcl and your code
                when the command is executed.
            </para>
        </listitem>
        <listitem>
            <para>
                Provides several methods usable by derived classes which help
                check that the correct number of command line parameters
                are provided.
            </para>
        </listitem>
        
    </itemizedlist>
    <formalpara>
        <title><classname>CTCLobject</classname></title>
        <para>
            Tcl 8.0 introduced <firstterm>dual port objects</firstterm>.  These
            attempt to solve an efficiency problem that is due to Tcl's core
            concept that evertyhing can be treated as a string.  
        </para>
    </formalpara>
    <para>
        Prior to 8.0, variables were, in fact, stored as strings by the interpreter.
        Dual port objects provide the ability to maintain a second representation.
        This prevents costly conversions from strings to other types as needed.
        It also allows for optimized representations for types such as lists
        and dicts.
    </para>
    <para>
        The Tcl type <type>Tcl_Obj*</type> is a pointer to an opaque type
        that represents the dual ported object.  Tcl API methods allow you to
        manipulate these copy on write, reference counted objects in many ways.
        These objects are wrapped by <classname>CTCLObject</classname>
        objects.  This class is defined in <filename>TCLObject.h</filename>.
    </para>
    <para>
        Reference counting is managed automatically in assignment and
        copy construction methods.  In addition, these objects:
    </para>
    <itemizedlist>
        <listitem>
            <para>
                Provide a mechanism to get the underlying
                <type>Tcl_Obj*</type> pointer.
            </para>
        </listitem>
        <listitem>
            <para>
                Provide for assignment to the object from a variety of types.
            </para>
        </listitem>
        <listitem>
            <para>
                Provide for conversion from the object to a variety of types.
            </para>
        </listitem>
        <listitem>
            <para>
                Provide operations that treat the object like a list and supply
                several operations on lists.
            </para>
        </listitem>
    </itemizedlist>
    <para>
        The <classname>CTCLObjectProcessor</classname> derived objects
        used to represent commands pass the command line words to the
        command processor as a reference to a vector of
        <classname>CTCLObject</classname> objects.
    </para>
    <para>
        With that background, start looking at the nitty gritty of wrapping
        our <classname>EVPSwitcher</classname> class in a command ensemble.
    </para>
    <para>
        A command ensemble can be thought of as an object.  It has a command
        name and methods that are represented as sub-commands.  The sub commands
        are the first argument followig the command word.  We're going to do
        a very minimal mapping providing the following subcommands:
    </para>
    <variablelist>
        <varlistentry>
            <term><command>save</command></term>
            <listitem>
                <para>
                    Saves  the current list of event processors
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><command>restore</command></term>
            <listitem>
                <para>
                    Restores the current list of event processors from a
                    previously saved set.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><command>filter</command></term>
            <listitem>
                <para>
                    Sets the event pipeline to be a filter processor.
                </para>
            </listitem>
        </varlistentry>
    </variablelist>
    <para>
        This quite naturally gives us the following definition for our
        command processor:
    </para>
    <example>
        <title>Definition file for event processor switcher.</title>
        <programlisting>
#ifndef EVPSWITCHCOMMAND_H
#define EVPSWITCHCOMMAND_H
#include &lt;TCLObjectProcessor.h&gt;
#include "EVPSwitcher.h"
class CTCLInterpreter;
class CTCLObject;


class EVPSwitchCommand : public CTCLObjectProcessor
{
private:
  EVPSwitcher  m_switcher;                         <co id='cmd.swcommand.object' />
public:
  EVPSwitchCommand(CTCLInterpreter&amp; interp, const char* command);

  int operator()(CTCLInterpreter&amp; interp, std::vector&lt;CTCLObject&gt;&amp; objv); <co id='cmd.swcommand.entry' />

private:
  void save(CTCLInterpreter&amp; interp, std::vector&lt;CTCLObject&gt;&amp; objv);
  void restore(CTCLInterpreter&amp; interp, std::vector&lt;CTCLObject&gt;&amp; objv);  <co id='cmd.swcommand.handlers' />
  void filter(CTCLInterpreter&amp; interp, std::vector&lt;CTCLObject&gt;&amp; objv);
};

#endif
            
        </programlisting>
    </example>
    <calloutlist>
        <callout arearefs='cmd.swcommand.object'>
            <para>
                This object is going to be manipulated by the command.  This
                pattern is very common for Tcl extensions;
                First develop an API for the functionality we want implemented.
                In this case, that functionality is encapsulated in an object
                of type <classname>EVPSwitcher</classname>.  Next develop
                a Tcl command that manipulates that API.  
            </para>
            <para>
                This pattern separates the concerns of what has to be done
                from processing the commands that do it.  A clean separation
                of these concerns would allow, for example, SpecTcl and this
                extension to be migrated to a different host scripting language
                (such as Python for example).
            </para>
        </callout>
        <callout arearefs='cmd.swcommand.entry'>
            <para>
                <classname>CTCLObjectProcessor</classname> objects
                must implement a function call operator
                (<methodname>operator()</methodname>).  This method is invoked
                by the Tcl++ library when the command registered by the
                object has been invoked.
            </para>
            <para>
                The method is passed a reference to the interpreter that is
                executing the command and a vector of
                <classname>CTCLObject</classname> objects.  The vector
                represents the command words that make up the Tcl command
                being executed.  Note that element 0 of this vector is
                the command itself.
            </para>
        </callout>
        <callout arearefs='cmd.swcommand.handlers'>
            <para>
                A common pattern in command ensembles is for top level processing
                (in this case <methodname>operator()</methodname>) to
                validate there's a subcommand and dispatch to a specific
                handler for each subcommand.  We're going to follow that approach.
                These methods are the handlers for each subcommand.
            </para>
        </callout>
    </calloutlist>
    <para>
        Let's look at the constructor.  The only responsibility it has is
        to register the command with the SpecTcl interpreter.  The interpreter
        is passed in.  We're also passing in the command name string in case
        circumstances force us to use a different command name.
    </para>
    <para>
        Here's the constructor implementation, therefore:
    </para>
    <example>
        <title><classname>EVPSwitchCommand</classname> constructor implementation</title>
        <programlisting>
#include "EVPSwitchCommand.h"
#include &lt;TCLInterpreter.h&gt;
#include &lt;TCLObject.h&gt;


EVPSwitchCommand::EVPSwitchCommand(CTCLInterpreter&amp; interp, const char* command) :
  CTCLObjectProcessor(interp, command, true)
{}
        </programlisting>
    </example>
    <para>
        As you can see the base class constructor does all the work.
        <varname>m_switcher</varname> is constructed by the default
        constructor for <classname>EVPSwitcher</classname>.
    </para>
    <para>
        The function call operator must:
    </para>
    <itemizedlist>
        <listitem>
            <para>
                Ensure all command line word objects get bound to the interpreter.
            </para>
        </listitem>
        <listitem>
            <para>
                Ensure there's a subcommand.
            </para>
        </listitem>
        <listitem>
            <para>
                Dispatch to the appropriate subcommand handler.
            </para>
        </listitem>
        <listitem>
            <para>
                Perform top level error handling.
            </para>
        </listitem>
    </itemizedlist>
    <example>
        <title>Implementation of <methodname>EVPSwitchCommand::operator()</methodname></title>
        <programlisting>
int
EVPSwitchCommand::operator()(CTCLInterpreter&amp; interp, std::vector&lt;CTCLObject&gt;&amp; objv)
{
  bindAll(interp, objv);                                       <co id='cmd.op.bindall' />
  try {                                                        <co id='cmd.op.try' />
    requireAtLeast(objv, 2, "Command requires a subcommand");  <co id='cmd.op.check42' />

    std::string subcommand = objv[1];                          <co id='cmd.op.subcommand' />
    if (subcommand == "save") {
      save(interp, objv);
    } else if (subcommand == "restore") {
      restore(interp, objv);                                   <co id='cmd.op.dispatch' />
    } else if (subcommand == "filter") {
      filter(interp, objv);
    } else {                                                  <co id='cmd.op.nomatch' />
      throw std::string("Invalid subcommand must be one of 'save', 'restore', or 'filter'");
    }
  }
  catch (const char* msg) {
    interp.setResult(msg);
    return TCL_ERROR;
  }
  catch (std::string msg) {
    interp.setResult(msg);
    return TCL_ERROR;
  }
  catch (CException&amp; e) {                                 <co id='cmd.op.errorhandling' />
    interp.setResult(e.ReasonText());
    return TCL_ERROR;
  }
  catch (std::exception&amp; e) {
    interp.setResult(e.what());
    return TCL_ERROR;
  }
  catch (...) {
    interp.setResult("unanticipated exception type caught"); <co id='cmd.op.unexpectedcatch' />
    return TCL_ERROR;
  }

  return TCL_OK;                                            <co id='cmd.op.success' />
}        
            
        </programlisting>
    </example>
    <calloutlist>
        <callout arearefs='cmd.op.bindall'>
            <para>
                This operation bind the interpreter (first parameter) to all
                <classname>CTCLObject</classname> objects in the vector.
                Some operations performed on <classname>CTCLObject</classname>
                objects require the help of an interpreter.  This operation
                ensures that an interpreter is always available for those
                operations.
            </para>
        </callout>
        <callout arearefs='cmd.op.try'>
            <para>
                Exception handling is used to simplify error detection and handling.
                All errors will just be thrown as one of several exception types.
                These exceptions will be caught, turned into error messages
                in the command result and result in a return value of
                <literal>TCL_ERROR</literal> signalling failure to the
                interpreter.
            </para>
        </callout>
        <callout arearefs='cmd.op.check42'>
            <para>
                This operation ensures there's at least a subcommand present.
                If the <parameter>objv</parameter> vector does not have at least
                two elements, an exception is thrown (<classname>std::string</classname>)
                that carries along with it the error string that was passed in.
            </para>
            <para>
                <classname>CTCLObjectProcessor</classname> provides a number of
                <literal>requireXXXX</literal> methods.  These have a common
                parameter signature and will succeed if the requirement is
                met or throw an <classname>std::string</classname> if not.
                If the error string is not provided a generic default
                error string is used instead.
            </para>
        </callout>
        <callout arearefs='cmd.op.subcommand'>
            <para>
                Extracts the subcommand string from the first parameter to the
                command.   This makes use of one of the many conversion operations
                in <classname>CTCLObject</classname> that can access the
                string or non-string representations of the underlying
                <type>Tcl_Object*</type> encapsulated by
                <classname>CTCLObject</classname>.
            </para>
            <para>
                If any of these type conversions fail, a
                <classname>CTCLException</classname> is thrown, which is
                derived from <classname>CException</classname>, and therefore
                will be caught by try/catch block.
            </para>
        </callout>
        <callout arearefs='cmd.op.dispatch'>
            <para>
                This if/else chain does the actual dispatch of the subcommand
                to the proper handler.  The handlers are expected to signal
                their errors via an exception.  That allows them to be
                declared as type <type>void</type> and makes it unecessary
                to explicitly check if they've succeeded.
            </para>
        </callout>
        <callout arearefs='cmd.op.nomatch'>
            <para>
                This defends against the user providing a bad subcommand.
                We throw an exception which is caught below, turned into
                the command result and an unsuccessful return value.
            </para>
        </callout>
        <callout arearefs='cmd.op.errorhandling'>
            <para>
                These catch blocks handle various types of exceptions we might
                expect during command processing.  In each case, error text
                is extracted from the exception and turned into the interpreter
                result and <literal>TCL_ERROR</literal> is returned.  This
                tells the interpreter the command failed.  The return value
                of a failed command becomes the error message the interpreter
                will emit.
            </para>
            <para>
                In the event the command is executed with the Tcl
                <command>catch</command> command, this will be the message
                returned when the value of the <command>catch</command> is
                nonzero.
            </para>
        </callout>
        <callout arearefs='cmd.op.unexpectedcatch'>
            <para>
                This catch will get control if an exception we've not explicitly
                caught is emitted (note that <classname>CException</classname>
                and <classname>std::exception</classname> are base classes
                that can catch a wide variety of actual exceptions).
                In that case we fabricate a return value and still
                return <literal>TCL_ERROR</literal>.
            </para>
        </callout>
        <callout arearefs='cmd.op.success' >
            <para>
                If control drops all the way through the try/catch block,
                the command succeeded and <literal>TCL_OK</literal> is
                returned to indicate that to the interpreter.
                The individual command processors are responsible for
                setting the command result in that case, if appropriate.
            </para>
        </callout>
    </calloutlist>
    <para>
        In your case, the subcommand handlers are all pretty simple.  Therefore
        we'll show them all at once.
    </para>
    <example>
        <title>Implementation of subcommand processors</title>
        <programlisting>

void
EVPSwitchCommand::save(CTCLInterpreter&amp; interp, std::vector&lt;CTCLObject&gt;&amp; objv)
{
  requireExactly(objv, 2);
  m_switcher.save();
}

void
EVPSwitchCommand::restore(CTCLInterpreter&amp; interp, std::vector&lt;CTCLObject&gt;&amp; objv)
{
  requireExactly(objv, 2);
  m_switcher.restore();
}

void
EVPSwitchCommand::filter(CTCLInterpreter&amp; interp, std::vector&lt;CTCLObject&gt;&amp; objv)
{
  requireExactly(objv, 2);
  m_switcher.useFilterProcessor();
}

        </programlisting>
    </example>
    <para>
        There are really only two points of interest in these method implementations:        
    </para>
    <itemizedlist>
        <listitem>
            <para>
                <methodname>requireExactly</methodname> throws an exception if
                exaactly two command words are not present.   This exception
                is caught by the dispatching method, <methodname>operator()</methodname>,
                and turned into a <literal>TCL_ERROR</literal> return value.
            </para>
        </listitem>
        <listitem>
            <para>
                There's no need for these methods to return a value.  Either they
                throw an exception which is caught and turned into a
                <literal>TCL_ERROR</literal>, or they don't,  in which case
                the dispatcher returns <literal>TCL_OK</literal>.
            </para>
        </listitem>
    </itemizedlist>
    <para>
        Once we have written this class we need to make an instance of this
        class in a way that adds it to SpecTcl's interpreter.
    </para>
    <para>
        This is done by editing the <methodname>AddCommands</methodname>
        method in <filename>MySpecTclApp.cpp</filename>.  At the end of this
        method add the line:
    </para>
    <informalexample>
        <programlisting>
             new EVPSwitchCommand(rInterp, "evpipline");
        </programlisting>
    </informalexample>
    <para>
        This adds the command <literal>evpipeline</literal> to the interpreter
        passed in to the method.
    </para>
</chapter>
<chapter id='chap.spectrumfileformat'>
    <title id='chap.spectrumfileformat.title'>
        Extending SpecTcl spectrum file formats
    </title>
    <para>
        The SpecTcl <command>swrite</command> and <command>sread</command>
        commands support two file formats out of the box.  The
        <literal>binary</literal> format supports the old SMAUG analysis
        program spectrum format while the <literal>ascii</literal> format
        supports a simple zero suppressed ASCI format.  In this chapter we will:
    </para>
    <itemizedlist>
        <listitem>
            <para>
                Describe the infrastructure SpecTcl uses to format
                spectrum files.
            </para>
        </listitem>
        <listitem>
            <para>
                Describe what is needed to add a format to SpecTcl.
            </para>
        </listitem>
        <listitem>
            <para>
                Add a CSV formatted spectrum file to SpecTcl.0
            </para>
        </listitem>
    </itemizedlist>
    <section>
        <title>SpecTcl's spectrum file format infrastructure</title>
        <para>
            SpecTcl depends on formatting objects to actually write files.
            The <command>sread</command> and <command>swrite</command>
            commands select a formatter and expect the formatter to take
            care of either reading a spectrum from the open file or
            writing a spectrum to an open file.
        </para>
        <para>
            The two principle classes involved in selection and I/O are:
        </para>
        <variablelist>
            <varlistentry>
                <term><classname>CSpectrumFormatter</classname></term>
                <listitem>
                    <para>
                        Defined in <filename>SpectrumFormatter.h</filename>.
                        The base class for all formatters.  Each concrete
                        formatter must implement a <methodname>Read</methodname>
                        and <methodname>Write</methodname> method.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>CSpectrumFormatterFactory</classname></term>
                <listitem>
                    <para>
                        Is a class that has only static methods (alternative
                        to a singleton class) and static data.  This
                        class, given a format name, can return a formatter or
                        indicate there is no match.
                    </para>
                    <para>
                        Any added formatter types must be registered with
                        this class via its
                        <methodname>AddFormatter</methodname> method.  Registration
                        associates a formatter with a format name string.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            Reference information on these two classes is available in the
            programmer reference.  When we provide an example, you will get
            sufficient information to stumble your way through writing a
            formatter and registering it with the factory.
        </para>
    </section>
    <section>
        <title>Adding a file format to SpecTcl</title>
        <para>
            Adding a format is conceptually simple. You must
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Write  a <classname>CSpectrumFormatter</classname>
                    derived class.
                </para>
            </listitem>
            <listitem>
                <para>
                    Add an instance of your formatter to the
                    <classname>CSpectrumFormatterFactory</classname>,
                    associating it with a formatter name string.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            The key methods you must implement in your formatter class are:
        </para>
        <informalexample>
            <programlisting>
 virtual   CSpectrum* Read (std::istream&amp; rStream, 
			    ParameterDictionary&amp; rDict);
 virtual   void Write (std::ostream&amp; rStream, CSpectrum&amp; rSpectrum,
		       ParameterDictionary&amp; rDict);
            </programlisting>
        </informalexample>
        <para>
            <methodname>Read</methodname> is expected to read a spectrum
            from the input stream <parameter>rStream</parameter> and
            return a dynamically allocated spectrum.  
            <parameter>rDict</parameter> is the parameter dictionary,
            which can be used to take any metadata supplied by the
            file about parameters and spectrum types to know how to
            construct the spectrum.
        </para>
        <para>
            Similarly, <methodname>Write</methodname> takes a
            <classname>CSpectrum</classname> object and is expected to
            serialize it to an output stream <parameter>rStream</parameter>.
            <parameter>rDict</parameter> is the parameter dictionary and
            can be used by the method to generate any metadata needed to
            describe the spectrum.
        </para>
    </section>
    <section>
        <title>Adding a CSV file format to spectrum read/write</title>
        <para>
            In this section we're going to walk through the problem
            of writing a new formatter and making it known to the
            SpecTcl <command>sread</command> and <command>swrite</command>
            commands.
        </para>
        <para>
            The format will be a simple CSV file format.  For 1-d spectra,
            a spectrum contains a single line of comma separated
            channel values.  For 2-d spectra, each line is a scan line
            of the spectrum.
            For simplicity(?) no metadata will be stored or restored.  Read
            will only create 1-d and 2-d snapshot spectra.
        </para>
        <para>
            Here's the header to our <classname>CSVSpectrumFormatter</classname>
            class:
        </para>
        <example>
            <title><classname>CSVSpectrumFormatter</classname> header</title>
            <programlisting>
#ifndef CSVSPECTRUMFORMATTER_H
#define CSVSPECTRUMFORMATTER_H


#include &lt;SpectrumFormatter.h&gt;

class CSVSpectrumFormatter : public CSpectrumFormatter
{
public:
  virtual   CSpectrum* Read (STD(istream)&amp; rStream,
                            ParameterDictionary&amp; rDict) ;
  virtual   void Write (STD(ostream)&amp; rStream, CSpectrum&amp; rSpectrum,
                       ParameterDictionary&amp; rDict);
};

#endif
                
            </programlisting>
        </example>
        <para>
            Let's get our feet wet with the <methodname>Write</methodname> operation.
            Here's how we're going to do that:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Get the dimensionality of the spectrum (1 or two)
                </para>
            </listitem>
            <listitem>
                <para>
                    From the dimensionality of the spectrum construct the
                    number of scan lines to output, note that for 1-d spectra
                    this is one.
                </para>
            </listitem>
            <listitem>
                <para>
                    Iterate over each scanline, writing comma separated values
                    terminating the scanline with a <literal>\n</literal>.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            Let's look at the the implementation.  First, we introduce the
            simple utility method <methodname>writeScanline</methodname>:
        </para>
        <informalexample>
            <programlisting>
private:
  void writeScanline(std::ostream&amp; rstream, CSpectrum&amp; spec, unsigned y, unsigned n);
            </programlisting>
        </informalexample>
        <para>
            The parameters are pretty clear, <parameter>y</parameter> 
            is the y coordinate of the scanline and <parameter>n</parameter>
            the number of channels on each scanline.  Here is the  implementation
            of this helper:
        </para>
        <example>
            <title>
                Implementation of <methodname>writeScanline</methodname> method.
            </title>
            <programlisting>
#include "CSVSpectrumFormatter.h"
#include &lt;Spectrum.h&gt;

void
CSVSpectrumFormatter::writeScanline(std::ostream&amp; rstream, CSpectrum&amp; spec, unsigned y, unsigned n)
{
  UInt_t indices[] = {0, y};                 <co id='spcfmt.wscn.indices' />

  for (int i = 0; i &lt; n; i++) {
    ULong_t ch = spec[indices];              <co id='spcfmt.wscn.indexing' />
    char    delim = ',';
    if (indices[0] == (n-1)) {               <co id='spcfmt.wscn.seldelim' />
      delim = '\n';
    }
    rstream &lt;&lt; ch &lt;&lt; delim;
    indices[0]++;
  }
}
                
            </programlisting>
        </example>
        <calloutlist>
            <callout arearefs='spcfmt.wscn.indices' >
                <para>
                    This array will be an array of indices into the spectrum.
                    <classname>CSpectrum</classname> implements an
                    <methodname>operator[]</methodname> but, due to the
                    need to handle a variable number of indices, it takes
                    an array of indices rather than a single index.
                </para>
            </callout>
            <callout arearefs='spcfmt.wscn.indexing'>
                <para>
                    The indexing operator of <classname>CSpectrum</classname>
                    is supposed to return the value of the channel at the
                    coordinates provided by the index array. Note that if this
                    is a 1-d spectrum the second index is ignored.
                </para>
            </callout>
            <callout arearefs='spcfmt.wscn.seldelim' >
                <para>
                    Each channel output wil be followed by a delimeter.
                    For all but the last item on the scanline, the delimeter
                    is <literal>,</literal> for the last item, the delimeter
                    is a newline character.
                </para>
            </callout>
        </calloutlist>
    
        <para>
            Next we can write the <methodname>Write</methodname> method in terms
            of this utility:
        </para>
        <example>
            <title><methodname>CSVSpectrumFormatter::Write</methodname> implementation</title>
            <programlisting>

void
CSVSpectrumFormatter::Write (STD(ostream)&amp; rStream, CSpectrum&amp; rSpectrum,
			     ParameterDictionary&amp; rDict)
{
  UInt_t nDims = rSpectrum.Dimensionality();   <co id='spcfmt.write.dims' />
  UInt_t xDim  = rSpectrum.Dimension(0);       <co id='spcfmt.write.xdim' />
  UInt_t yDim;
  if (nDims == 1) {                     
    yDim = 1;                                 <co id='spcfmt.write.ydim1d' />
  } else {
    yDim = rSpectrum.Dimension(1);            <co id='spcfmt.write.ydim2d' />
  }
  for (int i = 0; i &lt; yDim; i++) {
    writeScanline(rStream, rSpectrum, i, xDim); <co id='spcfmt.write.writelines' />
  }
}
    
          </programlisting>
      </example>
      <calloutlist>
          <callout arearefs='spcfmt.write.dims'>
              <para>
                  Fetches the number of dimensions the spectrum has.  This is
                  one or two.  Note we must use this rather than getting the parameter
                  count or Axis count as these can be misleading for some spectrum
                  types.
              </para>
          </callout>
          <callout arearefs='spcfmt.write.xdim'>
              <para>
                  Retrieves the number of channels on the X axis.  All spectra have
                  at least an X axis.
              </para>
          </callout>
          <callout arearefs='spcfmt.write.ydim1d'>
              <para>
                  <varname>yDim</varname> is the number of scanlines we'll need to
                  write. If the spectrum has only one dimension, we're only
                  writing a single scanline.
              </para>
          </callout>
          <callout arearefs='spcfmt.write.ydim2d'>
              <para>
                  On the other hand, if the spectrum has two dimensions, the number
                  of channels in Y determines the number of scan lines to write.
              </para>
          </callout>
          <callout arearefs='spcfmt.write.writelines'>
              <para>
                  This loop writes all the scanlines we need to write.
              </para>
          </callout>
      </calloutlist>
      <para>
          Reading in a spectrum in CSV form requires that we have some way
          to parse a CSV file.  We are going to follow the time honored practice
          of using code someone already wrote to do this.  I am a firm believer
          that good programmers are lazy thieves.  
      </para>
      <para>
          The code we're going to use to parse the CSV files is sample code
          at:
          <ulink url='http://www.zedwood.com/article/cpp-csv-parser' />.
          We only need the last function on that page.  We'll incorporate
          it as a utility method in our spectrum formatter;
      </para>
      <informalexample>
          <programlisting>
  #include &lt;vector&gt;
  ...
   std::vector&lt;std::string&gt; csv_read_row(std::istream &amp;in, char delimiter=',');
          </programlisting>
      </informalexample>
      <para>
          You can look at the citation above to see the actual code for this
          method.  For the sake of brevity we're going to treat it as a black box
          and not show the code here.
      </para>
      <para>
          What we need to do to read back spectra is to:
      </para>
      <itemizedlist>
          <listitem>
              <para>
                  Read a scanline as CSV converting the strings to numbers.  It's an error
                  if all strings in the CSV decode don't parse to integers.
              </para>
          </listitem>
          <listitem>
              <para>
                  The X dimension of the spectrum is determined by the size of this
                  current scanline.
              </para>
          </listitem>
          <listitem>
              <para>
                  If there are no more scanlines, this is a 1-d spectrum create it
                  as a snapshot and store the scanline in the spectrum.
              </para>
          </listitem>
          <listitem>
              <para>
                  If there are additional scanlines, build up the 2-d array
                  scanline by scanline.  The number of scanlines determines the
                  Y dimension of the spectrum.
              </para>
          </listitem>
          <listitem>
              <para>
                  Create the 2-d snapshot spectrum and save the scanlines in it.
              </para>
          </listitem>
      </itemizedlist>
      <para>
          We're going to accumulate the data in a
          <type>std::vector&lt; std::vector &lt; unsigned &gt; &gt;</type>.
          Each element of the outer vector is a scan line.
      </para>
      <para>
          There are a few things for which it's worth providing some utility methods:
      </para>
      <informalexample>
          <programlisting>
  CSpectrum*  create1DSpectrum(int nx);
  CSpectrum*  create2DSpectrum(int nx, int ny);
  CParameter* dummyParameter(SpecTcl&amp; api);
  std::string uniqueName(const char* basename, SpecTcl&amp; api);
            </programlisting>
        </informalexample>
        <variablelist>
            <varlistentry>
                <term><methodname>create1DSpectrum</methodname></term>
                <listitem>
                    <para>
                        Creates and returns a pointer to
                        a uniquely named 1-d spectrum using a dummy
                        parameter.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>create2DSpectrum</methodname></term>
                <listitem>
                    <para>
                        Creates and returns a pointer to a uniquely named
                        2-d spectrum using a dummy parameter on both axes.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>dummyParameter</methodname></term>
                <listitem>
                    <para>
                        If a dummy parameter named
                        <literal>_csv_dummy_param</literal> exists it is returned,
                        otherwise one is created and that is returned.  This is
                        necessary because spectrum objects in SpecTcl must have
                        parameters.  We'll use this one to make it clear to
                        people listing spectra that the parameter is meaningless
                        from the point of view of other analysis,.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>uniqueName</methodname></term>
                <listitem>
                    <para>
                        Finds a spectrum name not yet in use for names like
                        <literal>basename</literal> (first one tried) and
                        <literal>basename_</literal><replaceable>integer</replaceable>.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            These methods are relatively simple:
        </para>
        <informalexample>
            <programlisting>
CSpectrum*
CSVSpectrumFormatter::create1DSpectrum(int nx)
{
  SpecTcl&amp; api(*(SpecTcl::getInstance()));

  CParameter* pDummyParam = dummyParameter(api);
  std::string spectrumName = uniqueName("csvspectrum", api);
  return api.Create1D(spectrumName, keLong, *pDummyParam, nx);
}

CSpectrum*
CSVSpectrumFormatter::create2DSpectrum(int nx, int ny)
{
  SpecTcl&amp; api(*(SpecTcl::getInstance()));

  CParameter* pDummyParam = dummyParameter(api);
  std::string spectrumName = uniqueName("csvspectrum", api);
  return api.Create2D(spectrumName, keLong, *pDummyParam, *pDummyParam, nx, ny);
  
}

CParameter*
CSVSpectrumFormatter::dummyParameter(SpecTcl&amp; api)
{
  CParameter* result = api.FindParameter("_csv_dummy_param");
  if (!result) {
    result = api.AddParameter("_csv_dummy_param", api.AssignParameterId(), "");
  }
  return result;
}

std::string
CSVSpectrumFormatter::uniqueName(const char* baseName, SpecTcl&amp; api)
{
  std::string result = baseName;
  int         index  = 0;
  while(1) {
    if(!api.FindSpectrum(result)) return result;
    std::stringstream s;
    s &lt;&lt; baseName &lt;&lt; "_" &lt;&lt; index;
    result = s.str();
    index++;
  }

  return result;
}

            </programlisting>
        </informalexample>
        <para>
            The only tricky thing is how <methodname>unique</methodname> name
            loops trying to find spectra that match candidaten ames.
            If there is no match, a unique name has been found and is returned.
            Adjusting the name and index at the bottom of the while loop allows
            for the <parameter>baseName</parameter> to be tried without any
            adornments.
        </para>
        <para>
            Armed with these utilities, let's write the <methodname>Read</methodname>
            method:
        </para>
        <example>
            <title><methodname>CSVSpectrumFormatter::Read</methodname> implementation</title>
            <programlisting>
CSpectrum*
CSVSpectrumFormatter::Read (STD(istream)&amp; rStream, 
			    ParameterDictionary&amp; rDict)
{
  std::vector&lt;std::vector&lt;unsigned&gt; &gt; scanlines;   <co id='spcfmt.read.scanlines' />
  std::vector&lt;std::string&gt;            csvline;           <co id='spcfmt.read.csvline' />

  while(!rStream.eof()) {
    csvline.clear();
    csvline = csv_read_row(rStream);                           <co id='spcfmt.read.readrow' />
    if (csvline.size()) {                                      <co id='spcfmt.read.notempty' />
      std::vector&lt;unsigned&gt; line;
      for (int i = 0; i &lt; csvline.size(); i++) {
        char* endptr;
        unsigned v = strtoul(csvline[i].c_str(), &amp;endptr, 0);  <co id='spcfmt.read.convert' />
        if (endptr == csvline[i].c_str()) {
           throw std::string("Failed conversion to integer in CSVSpectrumFormatter::Read");
        }
        line.push_back(v);                                   <co id='spcfmt.read.pushchannel' />
      }
      scanlines.push_back(line);                             <co id='spcfmt.read.pushscanline' />
    }
  }

  CSpectrum* pSpectrum(0);
                                                            <co id='spcfmt.read.makespectrum' />
  if (scanlines.size() == 1) {
    pSpectrum = create1DSpectrum(scanlines[0].size());
  } else {
    pSpectrum = create2DSpectrum(scanlines[0].size(), scanlines.size());
  }

  UInt_t indices[2];
  for (int y = 0; y &lt; scanlines.size(); y++) {          <co id='spcfmt.read.fillspectrum' />
    for (int x = 0; x &lt; scanlines[y].size(); x++) {
      UInt_t indices[] = {x, y};    
      pSpectrum->set(indices, scanlines[y][x]);
    }
  }
  
  return new CSnapshotSpectrum(*pSpectrum);               <co id='spcfmt.read.snapwrap' />
  
}

  
            </programlisting>
        </example>
        <calloutlist>
            <callout arearefs='spcfmt.read.scanlines'>
                <para>
                    <varname>scanlines</varname> will hold all of the spectrum
                    channels read fromt he file.  We can't just build the
                    spectrum into a <classname>CSpectrum</classname> object because
                    we don't know how to declare that object until we have read
                    in all the scanlines.
                </para>
                <para>
                    This variable consists of a vector whose elements are the
                    values of channels in one <firstterm>scanline</firstterm>.
                    A scanline is just the channels in a spectrum with fixed
                    y coordinate.
                </para>
            </callout>
            <callout arearefs='spcfmt.read.csvline'>
                <para>
                    <varname>csvline</varname> will hold the value of one scanline
                    read by the CSV decoding method.  Note that scanline is a
                    vector of strings which must then be converted into a
                    vector of unsigned values.
                </para>
            </callout>
            <callout arearefs='spcfmt.read.readrow'>
                <para>
                    This line decodes a line fromt he CSV file.  This will be
                    done repeatedly until we have an endfile condition on the
                    input file.  This format, does not support packing several spectra
                    into a single file.
                </para>
            </callout>
            <callout arearefs='spcfmt.read.notempty'>
                <para>
                    We only have to decode the scanline into integers and
                    store it in <varname>scanlines</varname> if there are
                    entries decoded from thel line.  Two reasons the
                    <varname>csvline</varname> might be empty are blank lines
                    embedded in the file (by a creator other than us) or
                    blank lines at the end of the file prior to the EOF condition.
                </para>
            </callout>
            <callout arearefs='spcfmt.read.convert'>
                <para>
                    This call to <function>strtoul</function> attempts to decode
                    a string in a cell from the line into an unsigned value.
                    <varname>endptr</varname>, on success, points after the
                    decoded string.  On failure, <varname>endptr</varname> will
                    point to the beginning of the string.  Any
                    failure indicates this is not a valid spectrum file.  We flag
                    this by throwing an exception.
                </para>
            </callout>
            <callout arearefs='spcfmt.read.pushchannel'>
                <para>
                    If the cell was converted successfully,  the unsigned value
                    is pushed back into the <varname>line</varname> vector in which
                    the integer values of the scanline are being accumulated.
                </para>
            </callout>
            <callout arearefs='spcfmt.read.pushscanline'>
                <para>
                    Once a scaneline has been decoded it is pushed back into the
                    <varname>scanlines</varname> vector.
                </para>
            </callout>
            <callout arearefs='spcfmt.read.makespectrum'>
                <para>
                    This section of code creates the spectrum into which the
                    data in <varname>scanlines</varname> will be stored.
                    If the file only had a single scanline, the data are
                    for a 1-d spectrum.  Otherwise the data are for a 2-d
                    spectrum.
                </para>
                <para>
                    With this simple file format we can't distinguish between
                    anything other than 2-d and 1-d spectra.  A summary spectrum,
                    for example, looks like a 2-d spectrum.  This doesn't matter
                    since we're not going to hook the spectrum up to be
                    incremented.
                </para>
            </callout>
            <callout arearefs='spcfmt.read.fillspectrum'>
                <para>
                    Fills the channels of the spectrrum with the data in
                    <varname>scanlines</varname>. We nkow the data will fit because
                    we used the dimensionality of <varname>scanlines</varname>
                    as the spectrum dimensions with creating it.
                </para>
            </callout>
            <callout arearefs='spcfmt.read.snapwrap'>
                <para>
                    The final spectrum is wrapped by a snapshot spectrum.   While
                    we used a nonesnsical parameter to construct the spectrum,
                    this makes doubly sure SpecTcl won't try to connect it to the
                    histogrammer.  
                </para>
                <para>
                    Note that the <command>sread</command> command may wrap this
                    in a snapshot spectrum but this wrapping ensures that even
                    if <option>-nosnapshot</option> is used, the spectrum will be
                    a snapshot.
                </para>
            </callout>
            
        </calloutlist>
        <para>
            Having written this extension, the only thing left to do is
            to make SpecTcl aware of this.  The API method
            <methodname>AddSpectrumFormatter</methodname> can do this.
            Probably the best place to do this is in
            <methodname>MySpecTclApp::CreateHistogrammer</methodname>.
        </para>
        <informalexample>
            <programlisting>
void
CMySpecTclApp::CreateHistogrammer()
{
  CTclGrammerApp::CreateHistogrammer();
  SpecTcl&amp; api(*(SpecTcl::getInstance()));
  api.AddSpectrumFormatter("csv", *(new CSVSpectrumFormatter));
}
            </programlisting>
        </informalexample>
    </section>
</chapter>
<chapter id='chap.filterformat'>
    <title id='chap.filterformat.title'>
        Extending SpecTcl's filter file formats
    </title>
    <para>
        Filters are objects int he event sink pipeline that produce
        reduced data set output files.  Filters reduce data by a combination
        of selecting events and selecting a subset of parameters in each selected
        event.
    </para>
    <para>
        Typically filtered data is self describing and, therefore, faster to analyze
        because parsing is simplified.  SpecTcl supports a native filter format
        based on the SUN XDR source independent data representation.  Data in
        XDR files can be decoded regardless of the byte ordering of the source
        and sink systems.
    </para>
    <para>
        The filter formats supported by SpecTcl are extensible.  In fact,
        a plugin allows filtered data to be written in a format friendly to
        the CERN <ulink url='http://root.cern.ch'>ROOT</ulink> program.  (See
        <link linkend='chap.plugins' endterm='chap.plugins.title' />
        for information about SpecTcl plugins and how to write them).
    </para>
    <para>
        In this chapter we will:
    </para>
    <itemizedlist>
        <listitem>
            <para>
                Look at the classes and objects that make filter formats
                extensible (
                <link linkend='sec.filterformatobjects' endterm='sec.filterformatobjects.title' />).
            </para>
        </listitem>
        <listitem>
            <para>
                Walk through writing an extension to the set of filter formats
                supported by SpecTcl.
                <link linkend='sec.filterformatexample' endterm='sec.filterformatexample.title' />
            </para>
        </listitem>
    </itemizedlist>
    <section id='sec.filterformatobjects'>
        <title id='sec.filterformatobjects.title'>
            Filter formatting objects.
        </title>
        <para>
            Filters rely on a <classname>CFilterOutputStage</classname> object
            to actually output data to the filter file.  This is defined
            in the header <filename>CFilterOutpuStage.h</filename>.
        </para>
        <para>
            <classname>CFilterOutputStage</classname> is a base class.  It
            defines the following interface:
        </para>
        <example>
            <title><classname>CFilterOutputStage</classname> class definition</title>
            <programlisting>
class CFilterOutputStage
{
public:

public:
  virtual void open(std::string filename) = 0;
  virtual void close() = 0;
  virtual void onAttach(CEventFilter&amp; filter);
  virtual void DescribeEvent(std::vector&lt;std::string&gt; parameterNames,
			     std::vector&lt;UInt_t&gt;      parameterIds) =0;
  virtual void operator()(CEvent&amp; event) = 0;
  virtual std::string  type() const = 0;
};
            </programlisting>
        </example>
        <para>
            Since all of these methods are pure virtual, a new filter output
            stage  must provide all of them:
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>open</methodname>
                        <methodparam>
                            <modifier></modifier>
                            <type>std::string </type><parameter>filename</parameter>
                        </methodparam>
                        <modifier> = 0;</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This is called to open a filter file.
                        <parameter>filename</parameter> is the name of the file
                        to open.  The object must then maintain whatever is used
                        to write to the file (stream, file pointer, or file number)
                        internally until <methodname>close</methodname> is called.
                    </para>
                    <para>
                        The object is assured that future calls to
                        <methodname>DescribeEvent</methodname> and
                        <methodname>operator()</methodname> will need to refer
                        to the opened file.  The object is also assured that
                        neither of these will be called without a prior call
                        to <methodname>open</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>close</methodname>
                        <void />
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called to close a filter file.  The file most
                        recently opened via <methodname>open</methodname>
                        should be closed.  Any resources associated with that
                        file can be released.  Any internally buffered events
                        should be flushed to the file prior to actually
                        closing it.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>onAttach</methodname>
                        <methodparam>
                            <modifier></modifier>
                            <type>CEventFilter&amp; </type><parameter>filter)</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when the formatter is attached to a filter.  The
                        attached filter is the object that will be invoking the
                        methods of this object.   This has a default implementation
                        that does nothing.  Very frequently that's sufficient.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>DescribeEvent</methodname>
                        <methodparam>
                            <modifier></modifier>
                            <type>std::vector&lt;std::string&gt;</type>
                            <parameter>parameterNames</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier></modifier>
                            <type>std::vector&lt;UInt_t&gt;</type>
                            <parameter>parameterIds</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called just prior to recording data to the filter.
                        The method parameters describe the parameters to be
                        written. <parameter>parameterNames</parameter> is
                        a vector of the names of the parameters to be written
                        to the filter.  <parameter>parameterIds</parameter> are
                        the corresponding Ids (indices in the event array like
                        object).
                    </para>
                    <para>
                        Normally the filter output format objects should
                        write information to the output file that allows
                        a reader to determine which parameters are present and
                        how to unpack them from filter files.
                        <parameter>parameterIds</parameter> should usually
                        be retained to know which parameters in
                        an event array like object <methodname>operator()</methodname>
                        should write.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                            <modifier></modifier>
                            <type>CEvent&amp; </type><parameter>event</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called for every event that satisfies the filter's gate.
                        Its now up to the object to write the parameters the
                        filter cares about to the output file.  Note that prior
                        to this, the filter would have invoked
                        <methodname>DescribeEvent</methodname> and the
                        vector of indices into <parameter>event</parameter>
                        will have been passed to that method.
                    </para>
                </listitem>
            </varlistentry>            
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>std::string  </type>
                        <methodname>type</methodname>
                        <void />
                        <modifier> const = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Invoked to get a short textual string that specifies the
                        output type.
                    </para>
                </listitem>
            </varlistentry>         
        </variablelist>
        <para>
            It's not enoubh to have a filter output stage.  The <command>filter</command>
            command ensemble must know about it and be able to instantiate it
            given a value for the <command>filter -format</command> command.
            This is done by registering a <classname>CFilterOutputStageCreator</classname>
            with a singleton <classname>CFilterOutputStageFactory</classname>.
        </para>
        <para>
            The <classname>CFilterOutputStageFactory</classname> serves two
            purposes.  It provides the <command>filter</command> command
            with a list of formats and their descriptions for use in the
            help text.  It also, given a format name, produces the appropriate
            <classname>CFilterOutputStage</classname> object to attach to
            a filter to provide that format.
        </para>
        <para>
            The <classname>CFilterOutputStageCreator</classname> is normally
            quite trivial:
        </para>
        <example>
            <title><classname>CFilterOutputStageCreator</classname> specification</title>
            <programlisting>
class CFilterOutputStageCreator
{
public:
  virtual CFilterOutputStage*  operator()(std::string type) = 0;
  virtual std::string document() const = 0;
  virtual CFilterOutputStageCreator* clone() = 0;
};
            </programlisting>
        </example>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>CFilterOutputStage*  </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                            <modifier></modifier>
                            <type>std::string</type><parameter>type</parameter>
                        </methodparam>
                        <modifier>=0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If <parameter>type</parameter> is a formatter type the
                        concrete output creator can create, it will return a pointer
                        to a new, dyanmically  created <classname>CFilterOutputStage</classname>
                        object that outputs data in accordance to the requested
                        format <parameter>type</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>std::string </type>
                        <methodname>document</methodname>
                        <void />
                        <modifier>const = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a documentation string that describes the types
                        created and their meaning.  This text is output by the
                        <command>filter</command> command as part of its help
                        text.  The XDR creator, for example, returns:
                        <literal>xdr        - NSCL XDR system independent filter file format</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>CFilterOutputStageCreator* </type>
                        <methodname>clone</methodname>
                        <void />
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to a dynamically created clone of
                        the object.  This provides an effectively virtual
                        copy construction.  Note, however, unlike copy
                        construction of temporaries, the caller will need
                        to explicitly <command>delete</command> the object
                        returned.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            Creator objects are made known to the filter subsystem by
            registering them in the <classname>CFilterOutputStageFactory</classname>
            singleton object.  This class is defined in
            <filename>CFilterOutputStageFactory.h</filename>.  The key
            parts of that file look like this:
        </para>
        <example>
            <title><classname>CFilterOutputStageFactory</classname> definition</title>
            <programlisting>
class CFilterOutputStageFactory {

  
public:
  static CFilterOutputStageFactory&amp; getInstance();
  
  CFilterOutputStage* create(std::string type) const;
  void                Register(CFilterOutputStageCreator&amp; creator);
  std::string         document() const;
};

            </programlisting>
        </example>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static ;</modifier>
                        <type>CFilterOutputStageFactory&amp; </type>
                        <methodname>getInstance</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This static method returns a reference to the singleton
                        object.  Once you have that object you can invoke
                        other, non static, methods on the singleton.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CFilterOutputStage* </type>
                        <methodname>create</methodname>
                        <methodparam>
                            <modifier></modifier>
                            <type>std::string </type><parameter>type</parameter>
                        </methodparam>
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Given a format type, this returns a pointer to a
                        dynamically created output stage object that can
                        be attached to a filter to produce an output file
                        of the type requested by the <parameter>type</parameter>
                        parameter.
                    </para>
                    <para>
                        This method is intended to be called by the
                        code that executes the
                        <command>filter -format</command> command.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>Register</methodname>
                        <methodparam>
                            <modifier></modifier>
                            <type>CFilterOutputStageCreator&amp; </type>
                            <parameter>creator</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a new creator, and hence a new format type to the
                        factory.  This is intended to be used by programmers
                        that write new filter output formats.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>std::string</type>
                        <methodname>document</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method aggregates all of the documentation
                        strings returned by all creators into a string
                        that documents all of the format types and their meanings.
                        The list of creators is visited and each visitor
                        contributes its documentation string to the result string.
                    </para>
                </listitem>
            </varlistentry>  
         </variablelist>
    </section>
    <section id='sec.filterformatexample'>
        <title id='sec.filterformatexample.title'>
            Example filter formatter.
        </title>
        <para>
            In this section, we'll build a simple filter formatter.  We're not
            going to build an unpacker for it because that raises a few issues
            beyond the scope of this part of the document.  We're just going to
            show:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    How to write a filter output stage for a simple CSV
                    form of filter file format.
                </para>
            </listitem>
            <listitem>
                <para>
                    How to write an output stage creator for the new
                    filter format we're creating
                </para>
            </listitem>
            <listitem>
                <para>
                    How and where to register the creator with the factory
                    so that the <command>filter</command> command knows about it.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            Let's look at the creator.  Here's a working definition for our class:
        </para>
        <example>
            <title>Definition of <classname>CSVFilterOutputStage</classname></title>
            <programlisting>
#ifndef CSVFILTEROUTPUTSTAGE_H
#define CSVFILTEROUTPUTSTAGE_H

#include &lt;CFilterOutputStage.h&gt;
#include &lt;fstream&gt;


class CSVFilterOutputStage : public CFilterOutputStage
{
private:
  std::ofstream    m_file;
  std::vector &lt;UInt_t&gt; m_params;

 public:
  virtual void open(std::string filename) ;
  virtual void close() ;
  virtual void DescribeEvent(std::vector&lt;std::string&gt; parameterNames,
			     std::vector&lt;UInt_t&gt;      parameterIds);

  virtual void operator()(CEvent&amp; event);
  virtual std::string type() const;
};

#endif

            </programlisting>
        </example>
        <para>
            Note that since we're doing a text, comma separated field
            file, it's completely appropriate to store the file as an
            <classname>std::ostream</classname> object.
        </para>
        <para>
            Implementations of <methodname>open</methodname> and
            <methodname>close</methodname> are trivial:
        </para>
        <example>
            <title>
                Implementation of <methodname>open</methodname> and <methodname>close</methodname> for <classname>CSVFilterOutputStage</classname>
            </title>
            <programlisting>
void
CSVFilterOutputStage::open(std::string filename)
{
  m_file.open(filename);
}
void
CSVFilterOutputStage::close()
{
  m_file.close();
}
                
            </programlisting>                
        </example>
        <para>
            <methodname>DescribeEvent</methodname> is not that harder:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Write a header to the output file.
                </para>
            </listitem>
            <listitem>
                <para>
                    Save the parameter ids for later use.
                </para>
            </listitem>
        </itemizedlist>
        <example>
            <title>Implementing <methodname>CSVFilterOutputStage::DescribeEvent</methodname></title>
            <programlisting>
void
CSVFilterOutputStage:: DescribeEvent(std::vector&lt;std::string&gt; parameterNames,
				     std::vector&lt;UInt_t&gt;      parameterIds)
{
  for (int i = 0; i &lt; parameterNames.size(); i++) {
    char delim = ',';                  // Delimeter for all but end.
    if ((i+1) == parameterNames.size()) {
      delim = '\n';                           // Last one has a newline following it.
    }
    m_file &lt;&lt; parameterNames[i] &lt;&lt; delim;
  }
  
  m_params = parameterIds;
}
                
            </programlisting>
        </example>
        <para>
            The only interesting thing about this is a bit of logic we saw
            in our filter output example and that's how the character that
            follows the data is chosen to be a <literal>,</literal> if the
            item being written is not last or <literal>\n</literal> if it is.
        </para>
        <para>
            We'll see that logic again in the <methodname>operator()</methodname>
            implementation.  There, we'll also see a check on whether an event
            has defined a parameter or not.  If not, then an empty field is written:
        </para>
        <example>
            <title>Implementing <methodname>CSVFilterOutputStage::operator()</methodname></title>
            <programlisting>
void
CSVFilterOutputStage:: operator()(CEvent&amp; event)
{
  for (int i = 0; i &lt; m_params.size(); i++) {
    int idx = m_params[i];
    char delim = ',';
    if ((i+1) == m_params.size()) {
      delim = '\n';
    }
    if (event[idx].isValid()) {
      m_file &lt;&lt; event[idx];
    }
    m_file &lt;&lt; delim;
  }
}

            </programlisting>
        </example>
        <para>
            This leavses only the <methodname>type</methodname> method and
            that too is trivial:
        </para>
        <example>
            <title>Implmenting <methodname>CSVFilterOutputStage::type</methodname></title>
            <programlisting>
std::string
CSVFilterOutputStage::type() const
{
  return "csv";
}

            </programlisting>
        </example>
        <para>
            Our next order of business is to implement a creator for this
            output stage.  The definition of this creator is:
        </para>
        <example>
            <title>Definition of <classname>CSVFilterOutputStageCreator</classname></title>
            <programlisting>
#ifndef CSVFILTEROUTPUTSTAGECREATOR_H
#define CSVFILTEROUTPUTSTAGECREATOR_H
#include &lt;CFilterOutputStageCreator.h&gt;


class CSVFilterOutputStageCreator : public CFilterOutputStageCreator
{
public:
  virtual CFilterOutputStage*  operator()(std::string type);
  virtual std::string document() const;
  virtual CFilterOutputStageCreator* clone();  
};


#endif
                
            </programlisting>
        </example>
        <para>
            Implementations of all of these are quite trivial.  We're going to
            recognize the type <literal>csv</literal> and produce a
            <classname>CSVFilterOutputStage</classname> object. Here are
            all implementations in one chunk:
        </para>
        <example>
            <title>Implementation of <classname>CSVFilterOutputStage</classname></title>
            <programlisting>
#include "CSVFilterOutputStageCreator.h"
#include "CSVFilterOutputStage.h"


CFilterOutputStage*
CSVFilterOutputStageCreator:: operator()(std::string type)
{
  if (type == "csv") {
    return new CSVFilterOutputStage;
  } else {
    return nullptr;
  }
}

std::string
CSVFilterOutputStageCreator::document() const
{
  return "csv       - Comma separated fields";
}

CFilterOutputStageCreator*
CSVFilterOutputStageCreator::clone()
{
  return new CSVFilterOutputStageCreator(*this);
}
                
            </programlisting>
        </example>
        <para>
            To register this creator with the factory, modify
            <methodname>CMySpecTclApp::AddCommands</methodname> to read:
        </para>
        <informalexample>
            <programlisting>
void
CMySpecTclApp::AddCommands(CTCLInterpreter&amp; rInterp)
{
  CTclGrammerApp::AddCommands(rInterp);
  CFilterOutputStageFactory::getInstance().Register(*(new CSVFilterOutputStageCreator));
}

            </programlisting>
        </informalexample>
        <para>
            I chose this method becaus I know that by the time
            <methodname>CTclGrammerApp::AddCommands</methodname> has run,
            the entire filter framework is set up because that call
            registers the <command>filter</command> command ensemble.
        </para>
    </section>
</chapter>
<chapter id='chap.fittypes'>
    <title id='chap.fittypes.title'>
        Extending the set of SpecTcl fit types. 
    </title>
    <para>
        The fit types available in the SpecTcl fitting subsystem are quite restricted.
        SpecTcl' fitting is not intended to replace that of full fledged offline
        analysis programs such as Root e.g.  The SpecTcl fitting subsystem is, however
        extensible.
    </para>
    <para>
        This chapter:
    </para>
    <itemizedlist>
        <listitem>
            <para>
                Describes the classes and objects used by the fitting subsystem.
            </para>
        </listitem>
        <listitem>
            <para>
                Sketches what needs to be done to add a new fit type.
            </para>
        </listitem>
    </itemizedlist>
    <para>
        Note that to show an example would get us far afield into how to use
        various fit libraries and is therefore beyond the scope of this document.
        If, however, you've added a fit type to SpecTcl, by all means send it to
        us and I'll extend the manual with your code as an example.
    </para>
    <section>
        <title>Classes and objects of the fitting subsystem.</title>
        <para>
            The base class for the set of classes that can actually create
            fits is <classname>CFit</classname>.  Your fitting class must
            derive from this class.
        </para>
        <para>
            <classname>CFit</classname> defines the operations your class
            must implement as a set of pure virtual methods.  It also provides
            utilities and services that are useful to programmers implementing
            fits.  These services include state management, point and parameter
            management.  
        </para>
        <para>
            <classname>CFit</classname> is implemented in the
            <filename>CFit.h</filename> header.  The important parts of this
            header are shown below:
        </para>
        <example>
            <title><classname>CFit</classname> class definition</title>
            <programlisting>
class CFit : public  CNamedItem
{
  // Public data types.
public:

  typedef enum {
    Accepting,
    Performed
  } FitState;


  struct Point {
    double x;
    double y;
    int operator==(const Point&amp; rhs) const {
      return (x == rhs.x) &amp;&amp; (y == rhs.y);
    }
    int operator!=(const Point&amp; rhs) const {
      return !(operator==(rhs));
    }
  };
  typedef std::vector&lt;Point&gt; PointArray; 
  typedef PointArray::iterator PointIterator;

  typedef std::pair&lt;std::string, double&gt; FitParameter;
  typedef std::vector&lt;FitParameter&gt; FitParameterList;
  typedef FitParameterList::iterator FitParameterIterator;

public:
  CFit (std::string name, int id = 0);

protected:
  void SetFitState(FitState state);
public:

  void AddPoint (Point p)   ;
  void ClearPoints();
  PointIterator begin ()   ;
  PointIterator end ()   ;
  size_t size ()   ;
  FitState GetState ()  const ;
  
public:
  virtual  CFit* clone() = 0;
  virtual  void Perform ()   = 0 ;
  virtual  double operator() (double x)  =0 ;
  virtual  FitParameterList GetParameters () =0  ;
  virtual  std::string Type() const  = 0;
  virtual  std::string makeTclFitScript() = 0;

};
            </programlisting>
        </example>
        <para>
            Let's start by looking at the data types the <classname>CFit</classname>
            base class exports;
        </para>
        <variablelist>
            <varlistentry>
                <term><type>FitState</type></term>
                <listitem>
                    <para>
                        Fit objects are state-full.  They alternate between
                        accumulating points for a fit (<literal>Accepting</literal>)
                        and having performed the fit (<literal>Performed</literal>.
                        Fit parameters can only be retrieved from the fit when it
                        is in the <literal>Performed</literal> state.
                    </para>
                    <para>
                        <methodname>ClearPoints</methodname> and construction
                        place the fit in <literal>Accepting</literal>, when
                        <methodname>AddPoint</methodname> can be called repeatedly
                        to add a data point.  Invoking <methodname>Perform</methodname>
                        is expected to perform the fit and to put the fit in to
                        the <literal>Performed</literal> state.
                    </para>
                    <para>
                        This allows the same fit object to be repeatedly used
                        on different data.  The intent in the SpecTcl fitting
                        system is that once a fit is defined on an area of
                        interest in a spectrum, it can be repeatedly performed
                        on new spectrum data.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>Point</type></term>
                <listitem>
                    <para>
                        Points encapsulate the data to be fit.  A point contains
                        an <structfield>x</structfield> and
                        <structfield>y</structfield> member.  The fit function
                        is assumed to fit a function defined on <structfield>x</structfield>.
                    </para>
                    <para>
                        For SpecTcl, <structfield>x</structfield> is a spectrum
                        channel number and <structfield>y</structfield> is the
                        number of counts in that channel.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>PointArray</type></term>
                <listitem>
                    <para>
                        A point array is just that, an ordered collection of
                        points.  This typedef disconnects the type from its
                        underlying representation.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>PointIterator</type></term>
                <listitem>
                    <para>
                        Provides an iterator in the STL sense of the term among
                        members of a <type>PointArray</type>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>FitParameter</type></term>
                <listitem>
                    <para>
                        Fits, when performed produce a set of parameters
                        that depend on the functional form of the fit.
                        Each parameter is assigned a name by the author of its
                        fit class.
                    </para>
                    <para>
                        A <type>FitParameter</type> object is a pair that
                        consists of the name of a fit parameter and its value.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>FitParameterList</type></term>
                <listitem>
                    <para>
                        In general a fit produces more than one parameter.  These
                        are organized in a <type>FitParameterList</type> and
                        passed back to the caller as one.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>FitParameterIterator</type></term>
                <listitem>
                    <para>
                        Provides clients of the class with an iterator over
                        a <type>FitParameterList</type> object.  Using iterators
                        allows the client code to not make any assumptions
                        about the implementation of
                        <methodname>operator[]</methodname> for
                        <type>FitParameterList</type>.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            Next let's look at the services the <classname>CFit</classname>
            class provides its clients and subclasses:
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>SetFitState</methodname>
                        <methodparam>
                            <modifier></modifier>
                            <type>FitState </type><parameter>state</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This is protected.  It should be used by actual, concrete,
                        fit classes to indicate a new state for the fit. For
                        example, the <methodname>Perform</methodname> method should
                        at some point all this to set the fit state to
                        <literal>Performed</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>AddPoint</methodname>
                        <methodparam>
                            <modifier></modifier>
                            <type>Point </type><parameter>p</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Normally this is called by external clients to
                        add a point to the fit.  This sets the fit state to
                        <literal>Accepting</literal>.  Note that the point
                        is added to the existing points.
                    </para>
                    <para>
                        Generally, after performing a fit,
                        <methodname>ClearPoints</methodname> should be called
                        first prior to adding new points.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>ClearPoints</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Clears the set of points that have been accumulated for
                        the fit so far.  Immediately after calling this  a
                        call to <methodname>size</methodname> will return
                        <literal>0</literal>.
                    </para>
                    <para>
                        This method also sets the fit state to
                        <literal>Accepting</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>PointIterator </type>
                        <methodname>begin</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an iterator to the beginning of the
                        <type>PointList</type> maintained by this object.
                        This is normally used by derived classes but is also
                        available to external clients.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>PointIterator </type>
                        <methodname>end </methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Provides an end of iteration iterator to the
                        <type>PointList</type> maintained by this object.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>size_t </type>
                        <methodname>size</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of elements (points) in the
                        <type>PointList</type> object maintained by the class.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>FitState </type>
                        <methodname>GetState</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the current state of the fit.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            All <classname>CFit</classname> concrete subclasses must
            implement a specific set of methods.  Below we describe the
            call signatures of these methods as well as the responsibilities and
            expectations of each of these methods.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>CFit* </type>
                        <methodname>clone</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Expected to return a dynamically allocated copy of the
                        current fit.   This is essentially a virtual copy constructor.
                    </para>
                    <para>
                        A simple way to implement this is in terms of a copy
                        constructor if one has been implemented.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>void </type>
                        <methodname>Perform </methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method should perform the fit and, if the fit
                        was successful, set the state to <literal>Performed</literal>.
                        The points to fit can be gotten via the point list iterator
                        methods the base class provides.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type>double </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                            <modifier></modifier>
                            <type>double </type><parameter>x</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method should only be legal if the state is
                        <literal>Performed</literal>.  If called when the fit
                        is <literal>Accepting</literal>, a <type>std::string</type>
                        exception should be thrown.
                    </para>
                    <para>
                        If the fit has been performed, the method should
                        evaluate the fit function at <parameter>x</parameter> and
                        return its value.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type>FitParameterList </type>
                        <methodname>GetParameters</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method can only be legitimately called when the fit
                        is in the <literal>Performed</literal> state.  It is
                        expected to return the values of the parameters of the
                        fit.
                    </para>
                    <para>
                        Each fit parameter must be given a name by the
                        concrete fit class.  The return value is an iterable
                        container of <classname>std::pair</classname> objects
                        where the first element of each pair is an
                        <classname>std::string</classname> containing the
                        parameter name and the second element is a
                        <type>double</type> that is the fit parameter.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type>std::string </type>
                        <methodname>Type</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method must return a string that identifies the
                        fit type.  The string should be unique among all
                        other fit types.  For example, the built in gaussian
                        fit on constant background returns <literal>gaussian</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier> virtual  </modifier>
                        <type>std::string </type>
                        <methodname>makeTclFitScript</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method can only be called if the state is
                        <literal>Performed</literal>.  If the fit is in the
                        <literal>Accepting</literal> state a
                        <classname>std::string</classname> exception should be
                        thrown.
                    </para>
                    <para>
                        If the fit has been <literal>Performed</literal>,  the
                        method should return a string that defines a Tcl
                        <command>proc</command> for a proc named
                        <literal>fitline</literal>.  The proc shoulid accept a
                        single parameter (an x coordinate) and should return
                        the fit evaluated at that point.
                    </para>
                    <para>
                        Note that since all fits will return a string that
                        defines the same  proc a typical Tcl usage of this
                        might be:
                    </para>
                    <informalexample>
                        <programlisting>
set procdef [fit proc somefit]
eval $procdef
rename fitline somefit
                        </programlisting>
                    </informalexample>
                    <para>
                        This sample code, once  it defines the proc renames
                        it immediately to be the same as the name of the
                        fit that produced it.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            When SpecTcl needs to instantiate a concrete fit, it asks the
            <classname>CFitFactory</classname> class
            (defined in <filename>CFitFactory.h</filename>) to create a
            dynamically allocated object given the fit type string.
            This class is made up entirely of static methods.  The important
            parts of this clss definition look like this:
        </para>
        <example>
            <title><classname>CFitFactory</classname> class definition</title>
            <programlisting>
class CFitFactory
{
  // Public data types:
public:

  typedef std::map&lt;std::string, CFitCreator*&gt; FitCreatorMap;
  typedef FitCreatorMap::iterator  FitCreatorIterator;

  // Private member data.

private:
  static FitCreatorMap m_mapCreators;

  // Note that all data are static, therefore
  // all functions are static too.

public:


  static void AddFitType (const std::string &amp; rType, CFitCreator* pCreator)   ;
  static CFit* Create (std::string sFitType, std::string sFitName, int id =  0)   ;

  static FitCreatorIterator beginCreators();
  static FitCreatorIterator endCreators();
  static int    numberOfCreators();
  static FitCreatorIterator FindFitCreator (std::string sType)   ;
};

            </programlisting>
        </example>
        <para>
            The <type>CFitCreatorIterator</type> provides an interator throgh
            the <classname>FitCreatorMap</classname>.  This container is
            an associative container of pairs.  The first element of each pair
            is the name of a registered fit type.  The second is a pointer
            to an object that knows how to create a fit of that type
            (<classname>CFitCreator*</classname>).
        </para>
        <para>
            Let's turn our attention to the methods defined by this class.
            The methods are all defined as <literal>static</literal> which means
            this class never actually needs any instances.  All methods
            can be called relative to the class name.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>void </type>
                        <methodname>AddFitType (</methodname>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>std::string &amp;</type><parameter>rType</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier></modifier>
                            <type>CFitCreator* </type><parameter>pCreator</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Registers a new fit type with the factory.  The
                        <parameter>rType</parameter> referes to a string that
                        is the type name for the fit.  This is normally what the
                        fit object's <methodname>Type</methodname> method
                        returns.
                    </para>
                    <para>
                        The <parameter>pCreator</parameter> parameter points to
                        an object that knows how to create fits of this type.
                        We'll describe <classname>CFitCreator</classname> below.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>CFit* </type>
                        <methodname>Create</methodname>
                        <methodparam>
                            <modifier></modifier>
                            <type>std::string </type><parameter>sFitType</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier></modifier>
                            <type>std::string </type><parameter>sFitName</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier></modifier>
                            <type> int </type><parameter>id </parameter>
                            <modifier>=  0</modifier>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Producs a fit type of the requested
                        <parameter>sFitType</parameter>.  The fit creator is passed
                        two parameters; <parameter>sFitName</parameter> is a
                        name to be associated with the fit and <parameter>id</parameter>
                        is a numeric id (which is, for the most part obsolete).
                    </para>
                    <para>
                        If an appropriate creator for <parameter>sFitType</parameter>
                        has been registered, it is asked to produce a fit object.
                        If no matching fit creator can be found, <literal>nullptr</literal> is
                        returned.  If a matching creator is found but returns a
                        <literal>nullptr</literal> when asked to produce a fit,
                        a <classname>std::runtime_error</classname> exception
                        is thrown.
                    </para>
                    <para>
                        The specific type of exception is defined in
                        <filename>DesignByContract.h</filename> and is an
                        <classname>AssertionException</classname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>FitCreatorIterator </type>
                        <methodname>beginCreators</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns an iterator to the beginning of
                        container that associates fit type strings with fit
                        creator objects.  Dereferencing this iterator results
                        in an 
                        <classname>std::pair&lt;std::string, CFitCreator*&gt;</classname>
                        object.  The first element of this object is a fit type.
                        The second the fit creator associated with this fit type.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>FitCreatorIterator </type>
                        <methodname>endCreators</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        An end of iteration iterator to the container that
                        associates fit type names with their creators.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>int    </type>
                        <methodname>numberOfCreators</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of creators that have been registered.
                        Note that built in creators are just creators that are
                        registered by standard SpecTcl code and therefore are
                        included in this count.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>FitCreatorIterator</type>
                        <methodname> FindFitCreator</methodname>
                        <methodparam>
                            <modifier></modifier>
                            <type>std::string </type><parameter>sType</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Given a fit type, returns an iterator to the
                        typename/creator pair in the container that associates
                        fit names with fit creators.  If there is no match, this
                        method returns the same values as
                        <methodname>endCreators()</methodname>.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            The last piece of the puzzle are fit creators.  These are expected
            to know how to create fits of a specific fit type.  They are registered
            with the fit factory and called upon when SpecTcl wants to create a
            fit.
        </para>
        <para>
            The <classname>CFitCreator</classname> is an abstract base class
            for all fit creators.  It is defined in <filename>CfitCreator.h</filename>.
            The important parts of that class definition are shown below:
        </para>
        <example>
            <title><classname>CFitCreator</classname> class definition</title>
            <programlisting>
class CFitCreator
{
public:

  virtual   CFit* operator() (std::string name, int id=0)   = 0 ;
  virtual   std::string DescribeFit()  = 0;
};

            </programlisting>
        </example>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>CFit* </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                            <modifier></modifier>
                            <type>std::string </type><parameter>name</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier></modifier>
                            <type>int </type><parameter>id</parameter>
                            <modifier>=0</modifier>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This is the main method.  It is expected to return
                        a dynamically created <classname>CFit</classname> object
                        that is specific to the type of fit it knows how to
                        create.  <parameter>name</parameter> is a name to be given
                        to the fit which it can retain or not (the fit subsystem
                        in SpecTcl puts fits into dictionary keyed by fit name
                        anyway).   The <parameter>id</parameter> is a mostly obsolete
                        integer that  is included for compatibility with older
                        versions and was intended to be a unique integer identifying
                        the fit object.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>std::string </type>
                        <methodname>DescribeFit</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Provides a string that describes the type of fit this
                        creator creates.  This allows SpecTcl to iterate
                        through the registered fit creators documenting the types
                        of fits that are supported at any instant by any
                        tailoring of SpecTcl.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </section>
    <section>
        <title>Adding a new fit type</title>
        <para>
            The preceding section should make the steps that must be taken
            to add a new fit type clear:
        </para>
        <orderedlist>
            <listitem>
                <para>
                    You must write a new fitting class.  This class
                    must be derived from <classname>CFit</classname> and must
                    implement all of the pure virtual methods of that class.
                </para>
                <para>
                    This fitting class actually performs fits.
                </para>
            </listitem>
            <listitem>
                <para>
                    You must write a fit creator.  This is a class derived from
                    <classname>CFitCreator</classname>.  Its
                    <methodname>operator()</methodname> must be able to return
                    a pointer to an object of the fitting class you created
                    in the previous step.  Each invocation must produce a new,
                    unique object (usually done with <literal>new</literal>).
                </para>
            </listitem>
            <listitem>
                <para>
                    You must register an instance of your fit creator (written
                    in the previous step) with the <classname>CFitFactory</classname>.
                </para>
                <para>
                    This registration is done by adding code to create and register
                    an instance in <methodname>MySpecTclApp::AddCommands</methodname>.
                    Use this method because by the time this method is invoked
                    you know the entire fit framework within SpecTcl has been
                    created.
                </para>
            </listitem>
            <listitem>
                <para>
                    You must make necessary changes to your <filename>Makefile</filename>
                    to compile the classes you wrote above and link them into
                    SpecTcl.  This is normally a matter of adding files to the
                    <literal>OBJECTS</literal> definition but may also require adding
                    options to <literal>USERLDFLAGS</literal> to incorporate
                    fitting libraries into SpecTcl.  Note that the SpecTcl
                    built in fitters use the GNU Scientific Library (GSL)
                    which includes a set of minimization functions.  SpecTcl
                    uses the Levenberg-Marquardt minimizer to implement its fits.
                </para>
            </listitem>
        </orderedlist>
    </section>
</chapter>
<chapter id='chap.dataformat'>
    <title id='chap.dataformat.title'>
        Interfacing SpecTcl with data from other data acquisition systems.
    </title>
    <para>
        SpecTcl tries hard to be data acquisition system agnostic.  This begins
        with not having any direct connection to specific online systems and
        extens to the way in which events received from a data source are parsed
        into chucks of events which are then passed to the analyzer which
        forwards them on to the event processing pipeline.
    </para>
    <para>
        Let's have a look at how this all hangs together:
    </para>
    <figure>
        <title>SpecTcl event decode process</title>
        <graphic format='PNG' fileref='Datadecode.png' />
    </figure>
    <para>
        SpecTcl's data comes from data sources.  Each data source type has a
        I/O class.  This class passes fixed sized blocks of data to a buffer
        decoder object.  The buffer decoder object.  
    </para>
    <para>
        The buffer decoder is supposed to understand how data are packaged by
        the source data acquisition system.   It is supposed to pass blocks
        of events to the analyzer in a way that allows that object to call the
        event processing pipeline.  Secondarily, the decoder is supposed to
        create and make avaialble information about the source system byte
        ordering so that clients of the data can construct appropriate data
        translation objects.
    </para>
    <para>
        The buffer decoder is selected by the <command>attach</command> command.
        The class that implements that provides a method for extending the
        set of values for its <option>-format</option> switch.
    </para>
    <para>
        Note that this has actually been done for two non NSCL data acquisition
        systems over the life of SpecTcl (that I know about).  Specifically,
        SpecTcl has analyzed data from IUCF XSYS (at Kansas State University's
        Macdonald Laboratory), and from the Lucid data acquisition system (at
        the Saskatchewan Accelerator Laboratory, decommissioned in 1999).
        )
    </para>
    <para>
        In the remainder of this chapter we will:
    </para>
    <itemizedlist>
        <listitem>
            <para>
                Describe in detail the key classes involved in the flow of
                data from data source to analyzer.
            </para>
        </listitem>
        <listitem>
            <para>
                Describe the steps needed to support data from another data
                acquisition systsem.
            </para>
        </listitem>
        <listitem>
            <para>
                Give a simple example supporting data from some fictitious
                data acquisition system.   The data format will be chosen
                so that the actual programming is minimal.
            </para>
        </listitem>
    </itemizedlist>
    <section>
        <title>The classes involved in getting data from source to analyzer</title>
        <para>
            SpecTcl uses classes derived from the following base classes to
            get data from data source to analyzer:
        </para>
        <variablelist>
            <varlistentry>
                <term><classname>CFile</classname></term>
                <listitem>
                    <para>
                        Represents a data source from a file descriptor.  This
                        is not an abstract base class, as it's used  to accept
                        data from file data sources.  It is also the base class
                        for <classname>CPipeFile</classname> which gets data
                        from a program helper along a pipe.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>CBufferDecoder</classname></term>
                <listitem>
                    <para>
                        Understands how items are packaged by the data
                        acquisition system.  Once the <classname>CFile</classname>
                        object has been asked to read a block of data from its
                        encapsulated file descriptor, that block of data is passed
                        to the <classname>CBufferDecoder</classname>.  That
                        object unpackes items from the data block and
                        calls appropriate methods in the
                        <classname>CAnalyzer</classname> object.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>CAnalyzer</classname></term>
                <listitem>
                    <para>
                        Dispatches items from the buffer decoder to the
                        appropriate methods of the event processors in the
                        event processing pipeline.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>TranslatorPointer</classname></term>
                <listitem>
                    <para>
                        A templated class that has the semantics of a pointer
                        but transparently performs byte reordering if needed.
                        This operates by encapsulating a
                        <classname>BufferTranslator</classname> object which
                        may or my not swap items as needed.  
                    </para>
                    <para>
                        The <classname>BufferFactory</classname> knows how to
                        instantiate the right type of <classname>BufferTranslator</classname>
                        by being given an appropriate set of signature bytes which
                        define the byte order of the originating system.
                        These are compared against signature bytes generated
                        by the running system to determine the required byte ordering.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            Let's loopk at the <classname>CFile</classname>, <classname>CBufferDecoder</classname>,
            and <classname>CAnalyzer</classname> classes individually.  The
            <classname>TranslatorPointer</classname>, <classname>BufferTranslator</classname>
            and <classname>BufferFactory</classname> are quite tightly coupled
            so we'll look at those together.
        </para>
        <formalpara>
            <title><classname>CFile</classname> data source base class</title>
            <para>
                This class and its derivations supply I/O support for SpecTcl.
                Early versions of SpecTcl supported ANSI labeled tapes as a
                data source in addition to disk files and pipes.  This support
                was removed since very few if any people want to analyze data
                directly from tape.
            </para>
        </formalpara>
        
        <para>
            The base class for I/O support is <classname>CFile</classname>
            and it is not an abstract class but supports disk file I/O.
            This class is defined in <filename>File.h</filename>
            Technically it could also be used to read data from tapes that
            have been prepositioned to the appropriate data file.
        </para>
        <para>
            Here is the important part of the definition of this class:
        </para>
        <example>
            <title><classname>CFile</classname> class definition</title>
            <programlisting>
class CFile
{
  CFile ();
  CFile (  UInt_t am_nFd,
           bool fixedLength=true);

  UInt_t getFd() const
  FileState_t getState() const
  
  virtual   Int_t Read (Address_t pBuffer, UInt_t nSize)  ;
  virtual   Int_t Write (const Address_t pBuffer, UInt_t nBytes)  ;
  virtual   void Open (const std::string&amp; rsFilename, UInt_t nAccess,
                       bool fullBlocks = true)  ;
  virtual   void Open(UInt_t nFd);
  virtual   void Close ()  ;
  virtual   Bool_t IsReadable(UInt_t nMs) const;
  void      setVariableRecord();
  void      setFixedRecord();
};

            </programlisting>
        </example>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CFile</methodname>
                        <void />
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        This is the normal constructor.  The state of the file
                        is <literal>kfsClosed</literal>, indicating the
                        object is not yet connected to a file.  The
                        <methodname>Open</methodname> method is normally
                        then used to open a file.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>
                            CFile
                        </methodname>
                        <methodparam>
                            <modifier></modifier>
                            <type>UInt_t</type><parameter>nFd</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier></modifier>
                            <type>bool</type><parameter>fixedLength</parameter>
                            <initializer>=true</initializer>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs the object in an
                        <literal>kfsOpen</literal> state.  The
                        <parameter>nFd</parameter> parameter is an already
                        file descriptor openon whatever data source the object
                        will read from or write to.
                    </para>
                    <para>
                        <parameter>fixedLength</parameter> means that the client will
                        perform reads of fixed sized blocks of data.   This
                        means, specifically, that the read operations will
                        block on a read until all requested bytes have been
                        accepted or until an error or endfile condition
                        is signaled.
                    </para>
                    <para>
                        If <parameter>fixedLength</parameter> is false, read
                        will be done in non-blocking mode.  This allows for
                        partial transfers which can be useful in some
                        applications.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>UInt_t </type>
                        <methodname>getFd</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>                    
                </term>
                <listitem>
                    <para>
                        Gets the file descriptor that's bound to the object.
                        This only has meaning if the object's state iss
                        <literal>kfsOpen</literal>.  
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>FileState_t </type>
                        <methodname>getState</methodname>
                        <void />
                        <modifier> const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the object state.  This can be on of
                        <literal>kfsOpen</literal> in which case the file can be
                        considered open.   It can also be
                        <literal>kfsClosed</literal> un which case the
                        file should be considered closed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>Int_t </type>
                        <methodname>Read</methodname>
                        <methodparam>
                            <modifier></modifier>
                            <type>Address_t </type><parameter>pBuffer</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier></modifier>
                            <type>UInt_t </type><parameter>nSize</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Attempts to read <parameter>nSize</parameter> bytes
                        from the file descriptor associated with the
                        object into <parameter>pBuffer</parameter>.
                        This throws an error if the object is in the
                        <literal>kfsClosed</literal> state.
                    </para>
                    <para>
                        The number of bytes actually read is returned.  Note
                        that the behavior of this method depends on whether or not
                        the object has been told to run in fixed block size mode.
                        In Linux reads may terminate transferring some, all or
                        none of the data.    
                    </para>
                    <para>
                        IF fixed size block mode is enabled and the underlying
                        read returns fewer than the requested number of bytes,
                        additional reads are performed until the requested number
                        of bytes have been received.  If fixed sized mode is off,
                        only one read will ever be performed.
                    </para>
                    <para>
                        All errors are signalled by throwing a
                        <classname>CErrnoException</classname>.
                        If an end file  is reached, the method returns
                        <literal>0</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>Int_t </type>
                        <methodname>Write</methodname>
                        <methodparam>
                            <modifier>const</modifier>
                            <type> Address_t </type><parameter>pBuffer</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier></modifier>
                            <type>UInt_t </type><parameter>nBytes</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Writes <parameter>nBytes</parameter> of data to the
                        file descriptor that is associated with this object.
                        The data comes from the storage pointed to by
                        <parameter>pBuffer</parameter>.  An exception is thrown
                        if the object is not in the <literal>kfsOpen</literal>
                        state.  An exception is also thrown if the write fails.
                    </para>
                    <para>
                        It is possible that the write will transfer fewer bytes
                        of data than requested.  The actual number of bytes
                        transfered is the method's return value.  Unlike
                        <methodname>Read</methodname>, only one write is ever
                        performed and the
                        <emphasis>caller</emphasis> will need to perform additional
                        transfers, if necessary,  until the entire block of
                        data is written.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>void </type>
                        <methodname>Open </methodname>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>std::string&amp; </type><parameter>rsFilename</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier></modifier>
                            <type>UInt_t</type><parameter>nAccess</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier></modifier>
                            <type>bool </type><parameter>fullBlocks </parameter>
                            <initializer>true</initializer>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Opens a file, binding its file descriptor into the
                        object.  If the state of the object is
                        <literal>kfsOpen</literal>, the existing file is
                        closed prior to opening the new file.
                    </para>
                    <para>
                        The file opened is <parameter>rsFilename</parameter>.
                        The <parameter>nAccess</parameter> parameter is a bit
                        mask of <literal>kacRead</literal> (file is readable),
                        <literal>kacWrite</literal> (file is writable) and
                        <literal>kacCreate</literal> (file can be created if
                        needed). 
                    </para>
                    <para>
                         If <parameter>fullBlocks</parameter> is true,
                        reads will be done in blocking mode and however many
                        reads needed to fill the user buffer will be performed.
                        If, on the other hand, <parameter>fullBlocks</parameter>
                        is false, reads are done with blocking turned off and
                        only one read is done to attempt to satisfy a
                        <methodname>Read</methodname> requests.
                    </para>
                    <para>
                        On success, the state of the object will be
                        <literal>kfsOpen</literal>.  On failure,
                        an exception will be thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>void </type>
                        <methodname>Open</methodname>
                        <methodparam>
                            <modifier></modifier>
                            <type>UInt_t </type><parameter>nFd</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Sets the state of the object into
                        <literal>kfsOpen</literal> and binds the
                        <parameter>nFd</parameter> parameter as the object's
                        file descriptor.  If there's already an open file descriptor
                        it is first closed.
                    </para>
                    <para>
                        The intent of this method is to allow a file descriptor
                        opened outside of <classname>CFile</classname> to
                        be used with <classname>CFile</classname> objects.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>void </type>
                        <methodname>Close </methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Closes the file descriptor bound to the object and
                        sets the state to <literal>kfsClosed</literal>.  If
                        there is no open file descriptor bound to the object,
                        an exception is thrown..
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual   </modifier>
                        <type>Bool_t </type>
                        <methodname>IsReadable</methodname>
                        <methodparam>
                            <modifier></modifier>
                            <type>UInt_t </type><parameter>nMs</parameter>
                        </methodparam>
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>kfTRUE</literal> if the file descriptor
                        bound to the object becomes readable within
                        <parameter>nMs</parameter> milliseconds.  If the
                        object state is <literal>kfsClosed</literal>,
                        <literal>kfFALSE</literal> is returned.
                    </para>
                    <para>
                        Note that the base class implementation, simply returns
                        true if the file is open and false if not.  This is suitable
                        for disk files that are always readable.  Derived classes
                        may want to override this, implementing it in terms of
                        <function>select(2)</function>.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <formalpara>
            <title>The <classname>CAnalyzer</classname> class.</title>
            <para>
                This class invokes the buffer decoder's
                <methodname>operator()</methodname> method and provides
                methods the buffer decoder calls back as it decodes
                the outer structures of the data.
            </para>
        </formalpara>
        <para>
            The sequence, in fact, is that SpecTcl, on determining a data
            source can be read reads a block of data from that event
            source and passes it to <methodname>CAnalyzer::OnBuffer</methodname>.
            The analyzer, in turn passes the buffer to the current
            <classname>CBufferDecoder</classname> object
            which does a high level parse of the buffer calling one or more
            <classname>CAnalyzer</classname> methods to process each run.
            The <classname>CBufferDecoder</classname> provides several methods
            that can be used by both the analyzer and the event processing
            pipeline.
        </para>
        <para>
            The <classname>CAnalyzer</classname> base class is defined in
            <filename>Analyzer.h</filename>.  The important parts of this
            class definition are shown below:
        </para>
        <example>
            <title><classname>CAnalyzer</classname> base class definition</title>
            <programlisting>


class CAnalyzer {
public:
  CAnalyzer(); 
  CAnalyzer(UInt_t am_nParametersInEvent,
            UInt_t nThreshold = CAnalyzer::m_nDefaultEventThreshold);
 public:
  UInt_t getEventThreshold() const;
  UInt_t getParametersInEvent() const;
  CEventList&amp; getEventList();
  CBufferDecoder* getDecoder();
  CEventSink* getSink();

 public:
  virtual void OnBuffer(UInt_t nBytes, Address_t pData);
  virtual void OnStateChange(UInt_t nType, CBufferDecoder&amp; rDecoder);
  virtual void OnPhysics(CBufferDecoder&amp; rDecoder);
  virtual void OnScaler(CBufferDecoder&amp; rDecoder);
  virtual void OnOther(UInt_t nType, CBufferDecoder&amp; rDecoder);
  virtual void OnEndFile();
  virtual void OnInitialize();

  CBufferDecoder* AttachDecoder(CBufferDecoder&amp; rDecoder);
  CBufferDecoder* DetachDecoder();
  CEventSink*     AttachSink(CEventSink&amp; rSink);
  CEventSink*     DetachSink();
  void            entityNotDone();

};

                
            </programlisting>
        </example>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CAnalyzer</methodname>
                        <void />
                    </constructorsynopsis>
                </term>
                <term>
                    <constructorsynopsis>
                        <methodname>CAnalyzer</methodname>
                        <methodparam>
                            <modifier></modifier>
                            <type>UInt_t </type><parameter>nParametersInEvent</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier></modifier>
                            <type>UInt_t </type><parameter>nThreshold</parameter>
                            <initializer> CAnalyzer::m_nDefaultEventThreshold</initializer>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        These constructors create the base class. Two parameters
                        control when the event sink is run and how events are
                        allocated.
                    </para>
                    <para>
                        <parameter>nParametersInEvent</parameter> is the number
                        of paramters that are initially in the
                        event array like object that is passed to the
                        event processig pipeline.  This gets expanded as needed.
                        Furthermore, these objects are now recycled, so the
                        impact of getting this wrong is not nearly what it
                        used to be.
                    </para>
                    <para>
                        <parameter>nThreshold</parameter> is the maximum
                        number of events that will be accumulated from
                        successive runs of the evet analysis pipeline before
                        the event sink pipeline is called.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>UInt_t </type>
                        <methodname>getEventThreshold</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of events that need to be accumulated
                        before they are passed through the event sink pipeline.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>UInt_t </type>
                        <methodname>getParametersInEvent</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the initial size for event objects.  Events are
                        dynamically expanded.  Furthermore, once used and analyzed,
                        they are invalidated, rather than destroyed and
                        re-used later. 
                    </para>
                    <para>
                        The effect of this is that eventually events grow to the
                        fit the largest numbered paramter used by the analysis case.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventList&amp; </type>
                        <methodname>getEventList</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        The analyzer collects all events into an event list
                        (a wrapped vector of events).  This event list is then
                        iterated over to send events to the analysis pipeline.
                        This method returns a reference to the event list.
                    </para>
                    <para>
                        The event list should not be confused with the event pool,
                        also maintained by the analyzer but not available externally.
                        The event pool is a <classname>CEventList</classname> that contains
                        invalidated events that may be handed to runs of the 
                        event analysis pipeline. The Analyzer passes events from
                        the event pool to the analysis pipeline, whereupon they
                        are put in the event list.  The event list is passed,
                        event by event, to the event sink pipeline whereupon
                        each event is invalidated and putback in the event pool.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CBufferDecoder* </type>
                        <methodname>getDecoder</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the current buffer decoder.  The
                        buffer decoder is selected by the <option>-format</option>
                        option of the <command>attach</command> command.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventSink* </type>
                        <methodname>getSink</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the analyzer's event sink. In
                        practice this is actually a pointer to an
                        <classname>CEventSinkPipeline</classname> which, itself,
                        contains an ordered list of <classname>CEventSink</classname>
                        objects including a <classname>CHistogrammer</classname>
                        and zero or more <classname>CEventFilter</classname> objects.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnBuffer</methodname>
                        <methodparam>
                            <modifier></modifier>
                            <type>UInt_t </type><parameter>nBytes</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier></modifier>
                            <type>Address_t </type><parameter>pData</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is invoked by SpecTcl when a block of data
                        has been read from the data source.
                        <parameter>pData</parameter> points to that block and
                        <parameter>nBytes</parameter> is the number of bytes
                        actually read. 
                    </para>
                    <para>
                        This base class simply invokes the buffer decoder's
                        <methodname>operator()</methodname> method which
                        is expected to break apart the buffer into bits the
                        analyzer cares about and make callbacks to the analyzer.
                        Many of the remaining methods are normally called by
                        the buffer decoder from within its
                        <methodname>operator()</methodname>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnStateChange</methodname>
                        <methodparam>
                            <modifier></modifier>
                            <type>UInt_t </type><parameter>nType</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier></modifier>
                            <type>CBufferDecoder&amp; </type><parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called by the buffer decoder to process state change items.
                        State change items are supposed to indicate a change in
                        run state such as begin run.  Note that not all
                        data acquisition systems emit state change items.
                        Not all analysis cases need them.
                    </para>
                    <para>
                        The <parameter>nType</parameter> parameter identifies the
                        type of state change.  For NSCLDAQ, these are
                        defined in <filename>buftypes.h</filename>.  The
                        ones that could be passed in to this method in NSCLDAQ
                        are <literal>BEGRUNBF</literal> (begin run),
                        <literal>ENDRUNBF</literal> (end run),
                        <literal>PAUSBF</literal> (pause run),
                        and <literal>RESUMEBF</literal> (resume run).
                    </para>
                    <para>
                        Note to the astute reader that the ring buffer decoder maps
                        the ring item types for state changes into these values
                        in order to retain compatibility with older analysis
                        cases.
                    </para>
                    <para>
                        <parameter>rDecoder</parameter> references the decoder.
                        The decoder can be used to fetch key bits of information
                        about the item the decoder has plucked from the item.
                    </para>
                    <para>
                        Typically the decoder can now respond to
                        calls back to
                        <methodname>getRun</methodname>, <methodname>getTitle</methodname>
                        with the run number and title of this run respectively
                        (if available).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnPhysics</methodname>
                        <methodparam>
                            <modifier></modifier>
                            <type>CBufferDecoder&amp; </type><parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is invoked by the buffer decoder when a
                        run of physics events has been detected.  The
                        buffer decoder must be prepared to reply to
                        method calls to
                        <methodname>getBody</methodname>, <methodname>getBodySize</methodname>
                        and <methodname>getEntityCount</methodname> to allow
                        <methodname>OnPhysics</methodname> to know the location,
                        extent
                        of the data and how many events to expect.
                    </para>
                    <para>
                        If the event processing pipeline attempts to run the analyzer
                        off the end of the extent of the data
                        (indicated by <methodname>getBodySize</methodname>, the analyzer
                        will throw an exception and abort processing of that chunk.
                        If the event processing pipeline does not consume all of
                        the data after analyzing the number of events indicated
                        by <methodname>getEntityCount</methodname> an error
                        message is emitted as well.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnScaler</methodname>
                        <methodparam>
                            <modifier></modifier>
                            <type>CBufferDecoder&amp;</type><parameter> rDecoder</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called by the buffer decoder when a scaler item has been
                        encountered in the input data.  Scaler items are expected
                        to have a set of counters.  The buffer decoder must be
                        ready to respond to invocations of the
                        buffer decoder's
                        <methodname>getBody</methodname>, <methodname>getBodySize</methodname>
                        and <methodname>getEntityCount</methodname> from the
                        event analysis pipeline as the analyzer makes no assumptions
                        about the format of the scaler item.
                    </para>
                    <para>
                        Convention holds that
                        <methodname>getBodySize</methodname> will give the size
                        of the scaler item pointed to by  <methodname>getBody</methodname>
                        and <methodname>getEntityCount</methodname> returns the
                        number of scalers in the item.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnOther</methodname>
                        <methodparam>
                            <modifier></modifier>
                            <type>UInt_t </type><parameter>nType</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier></modifier>
                            <type>CBufferDecoder&amp; </type><parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called by the buffer decoder for other types of
                        items.  <parameter>nType</parameter> is the type of
                        data item encountered.  This value depends on the
                        data acquisition system contributing data. Note that
                        NSCLDAQ's ring buffer decoders map ring items to
                        values in <filename>bftypes.h</filename>, buffer types
                        for the NSCLDAQ-8.x system (prior to ring buffers).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnEndFile</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Invoked by the data source, I/O subsystem when an endfile
                        was detected on the data source.  For pipe files, this
                        implies the program on the other end of the pipe
                        either exited or closed its <literal>stdout</literal>.
                        For actual disk file data sources this is invoked
                        whenthe entire file has been read.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnInitialize</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called by the SpecTcl main application object when
                        SpecTcl initialization is completed. One of the
                        expectations of this method is that it will invoke
                        <methodname>OnInitialize</methodname> for all elements
                        of the event analysis pipeline.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CBufferDecoder* </type>
                        <methodname>AttachDecoder</methodname>
                        <methodparam>
                            <modifier></modifier>
                            <type>CBufferDecoder&amp; </type><parameter>rDecoder</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called by the SpecTcl framework to attach a new buffer
                        decoder, <parameter>rDecoder</parameter>.  A pointer
                        to the prior decoder is returned.  If there is no
                        prior decoder, a null pointer should be returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CBufferDecoder* </type>
                        <methodname>DetachDecoder</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Detaches the current decoder from the the analyzer.
                        This returns a pointer to the previous decoder.  Note
                        that attempting to use the analyzer when no decoder is
                        attached will most likely cause program failure.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventSink*     </type>
                        <methodname>AttachSink</methodname>
                        <methodparam>
                            <modifier></modifier>
                            <type>CEventSink&amp; </type><parameter>rSink</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Attaches a new event sink to the analyzer.  Normally,
                        the event sink is an <classname>CEventSinkPipeline</classname>
                        (defined in <filename>EventSinkPipeline.h</filename>).
                        <classname>CEventSinkPipeline</classname> is a container
                        for an ordered set of <classname>CEventSink</classname>
                        objects (including a <classname>CHistogrammer</classname>).
                    </para>
                    <para>
                        It is rare that you'll need to invoke this method.
                        The return value of this method is a pointer to the
                        prior event sink object or <literal>nullptr</literal>
                        if there is no prior event sink.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CEventSink*</type>
                        <methodname>DetachSink</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Detaches the event sink from the analyzer.  The result
                        of this method is a pointer to the previously attached
                        event sink.  It is likely that using the
                        analyzer when no event sink is attached will cause
                        program failure.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>entityNotDone</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method can be called from within the event processing
                        pipeline's <methodname>operator()</methodname> method.
                        It  is called to indicate that when the event processing
                        pipeline is
                        complete, while the size of the event should be
                        used to advance the event pointer, the number of entities
                        should not be decremented.
                    </para>
                    <para>
                        The purpose of this method is to simplify event processing
                        for data acquisition systems that have the capability to
                        emit <firstterm>super events</firstterm>.  A super event
                        is an event like chunk of data that contains several
                        events.  An example of a use of super events would
                        be processing hardware containing multi-event buffers.
                        The devices might be drained responding to a single trigger
                        leaving a structure that contains several physics events.
                    </para>
                    <para>
                        In cases like that, the event processing pipeline needs
                        to be invoked for each event contained in the super
                        event and therefore needs control over when to report
                        that it has completed processing of the outer entity.
                    </para>
                    <para>
                        Another alternative is to produce a buffer decoder
                        that treats each super event as a run of events, however
                        that would require that the buffer decoder know enough
                        about the internal structure of the super event to
                        be able to determine the number of events each
                        super event contains.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <formalpara>
            <title>The <classname>CBufferDecoder</classname> class</title>
            <para>
                Objects of this class are attached to the analyzer.  The analyzer,
                on receiving a block of data, delegates the outer decode
                of that block of data to the buffer decoder.  In turn, the
                buffer decoder will call back methods of the analyzer
                we described above.
            </para>
        </formalpara>
        <para>
            Buffer decoders are derived from the abstract base class
            <classname>CBufferDecoder</classname>.  This class is defined in
            <filename>BufferDecoder.h</filename>.  Key parts of that header are
            shown below.
        </para>
        <example>
            <title>The <classname>CBufferDecoder</classname> abstract base class</title>
            <programlisting>
class CBufferDecoder {

 public:
  virtual BufferTranslator* getBufferTranslator()
  virtual const Address_t getBody() = 0;
  virtual UInt_t getBodySize() = 0;
  virtual UInt_t getRun() = 0;
  virtual UInt_t getEntityCount() = 0;
  virtual UInt_t getSequenceNo() = 0;
  virtual UInt_t getLamCount() = 0;
  virtual UInt_t getPatternCount() = 0;
  virtual UInt_t getBufferType() = 0;
  virtual void getByteOrder(Short_t&amp; Signature16,
                            Int_t&amp; Signature32) = 0;
  virtual std::string getTitle() = 0;
  virtual void operator() (UInt_t nBytes,
                           Address_t pBuffer,
                           CAnalyzer&amp; rAnalyzer);

  virtual void OnAttach(CAnalyzer&amp; rAnalyzer);
  virtual void OnDetach(CAnalyzer&amp; rAnalyzer);
  virtual bool blockMode();     // True if data source must deliver fixed sized blocks.

  virtual void OnSourceAttach();
  virtual void OnSourceDetach();
  virtual void OnEndFile();

};

            </programlisting>
        </example>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>BufferTranslator* </type>
                        <methodname>getBufferTranslator</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This is expected to return a <classname>BufferTranslator</classname>
                        that, in turn, can be used to instantiate
                        <classname>TranslatorPointers</classname>.  These
                        are part of SpecTcl's scheme to insulate programmers
                        from byte order differences that might exist between
                        the data source and SpecTcl.  
                    </para>
                    <para>
                        NSCL data acquisition systems provide byte order
                        signatures that allow consumers to determine if these
                        differences exist (though the mechanism differs between
                        NSCLDAQ 8 and earlier and NSCLDAQ 10 and later [there
                        is no NSCLDAQ 9).
                    </para>
                    <para>
                        If you are processing data from a system that does not
                        provide these hints, you'll need to use your knoweledge
                        of the byte order of the source system and probe the
                        system SpecTcl is running on to produce the proper
                        <classname>BufferTranslator</classname> object.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual const </modifier>
                        <type>Address_t </type>
                        <methodname>getBody</methodname>
                        <void />
                        <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This pure virtual method is expected to return the
                        body of the item currently being processed.  In many
                        cases the item has a single logical entity (e.g.
                        information about a state change), however in others,
                        such as physics event items, the item may contain
                        more than one entity in which case
                        <methodname>getBody</methodname> returns a pointer to the
                        first of these entities.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getBodySize</methodname>
                        <void />
                        <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the size of the block of data pointed to by the
                        return value of <methodname>getBody</methodname>. The
                        analyzer and event processing pipeline should ensure that
                        processing is confined to the storage defined by
                        <methodname>getBody</methodname> and
                        <methodname>getBodySize</methodname> or else the
                        results are not well defined.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getRun</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If the underlying data acquisition system has run numbers
                        that can be gotten from the data (presumably in data
                        towards the start of an event file), this is expected
                        to return the run number of the data set currently being
                        analyzed.
                    </para>
                    <para>
                        Data acquisition systems may not make it possible to determine
                        the run number from the data. In that case this method
                        should just return some value such as
                        <literal>UINT_MAX</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getEntityCount</methodname>
                        <void />
                        <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of entities present in the current item.
                        For scaler data this is, by convention, the number of
                        scalers present.  For event data this is the number of
                        events in the block of data defined by
                        <methodname>getBody</methodname> and
                        <methodname>getBodySize</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getSequenceNo</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        For data acquisition systems in which it's possible to
                        extract an event number, or buffer number, this is expected to return that
                        number.  SpecTcl's GUI's use this information to attempt
                        to provide information about the fraction of events
                        analyzed by the online system.
                    </para>
                    <para>
                        If the underlying DAQ system does not provide this
                        we recommend returning the number of physics triggers
                        seen.  This will result in an analysis fraction of
                        <literal>1.0</literal> which while wrong, at least
                        does not result in program failure (e.g. divide by
                        zero).
                    </para>
                    <para>
                        NSCLDAQ 8 and earlier provide a buffer sequence number
                        and that is used.  NSCLDAQ 10 and later emit periodic
                        trigger count records.  The number of triggers in the
                        most recent trigger count record is returne by those
                        buffer decoders.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getLamCount </methodname>
                        <void />
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        In CAMAC based system that provide masks of the LAMS
                        seen in the crates involved in an event, this provides
                        the number of LAM masks present.  This is supplied by
                        NSCLDAQ 8 and earlier but, as non CAMAC systems became
                        the rule rapidly became obsolete.
                    </para>
                    <para>
                        If your DAQ system is not able to provide this just
                        return 0.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getPatternCount</methodname>
                        <void />
                        <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        In some event formats, Readout is driven by some trigger
                        pattern register.  In those systems, this is supposed
                        to return the number of pattern register items each
                        event will have (as the decoding of the event may
                        depend on knowing this).  
                    </para>
                    <para>
                        This value is also increasingly obsolete and, you may
                        retrun <literal>0</literal> if the DAQ system you
                        are using (NSCLDAQ 10.0 and later e.g.) cannot
                        supply this information.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>UInt_t </type>
                        <methodname>getBufferType</methodname>
                        <void />
                        <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the type of entity being processed.  This
                        should be a value from
                        <filename>buftypes.h</filename>
                    </para>
                    <para>
                        If your DAQ system has packed heterogenous data into
                        'data units', the main job of the buffer decoder
                        is to break each data unit up into one or more
                        homogenously typed item.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier> virtual </modifier>
                        <type>void </type>
                        <methodname>getByteOrder </methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>Short_t&amp; </type><parameter>Signature16</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Int_t&amp; </type><parameter>Signature32</parameter>
                        </methodparam>
                        <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the 16 and 32 bit SpecTcl byte order signatures
                        for the system that sourced the data. SpecTcl uses host
                        and source byte order signatures to not only determine if
                        there is a byte order difference between the two, but
                        to map the transformation required to take data
                        in source format to data in host format.
                    </para>
                    <para>
                        The 16 bit byte order signature,
                        <parameter>Signature16</parameter>
                        will be writtenwith the value
                        <literal>0x0102</literal> in the byte order of
                        the source system.  The <parameter>Signature32</parameter>
                        32 bit signature, on the other hand, will be written
                        with the value <literal>0x01020304</literal> in the
                        byte order of the source system.
                    </para>
                    <para>
                        The values provided allow SpecTcl to determine how to
                        transform arbitrary byte order differences between 16
                        and 32 bit values.  In practice, there are two byte orderings
                        in use in computer systems throughout the world.
                        Little endian (predominates because it is what Intel uses),
                        and Big endian. 
                    </para>
                    <para>
                        If we view memory as an array of 8 bit bytes, for multi-byte
                        values, little endian systems store the low order bytes in
                        lower addresses while big endian systems store the high order
                        bytes in lower addresses.
                    </para>
                    <para>
                        Thus the byte-wise representation of <literal>0x0102034</literal>,
                        the 32 bit byte order signature for little endian systems
                        is: <literal>0x04, 0x03, 0x02, 0x01</literal> while on a
                        bit endian system, the same signature's byte-wise values are:
                        <literal>0x01, 0x02, 0x03, 0x04</literal>.
                    </para>
                    <para>
                        If the source system provides <emphasis>some</emphasis>
                        indicatiuon of its byte ordering in the data, this method
                        should transform that indicator into the byte order signatures
                        expected by SpecTcl.  If not, you have to use your knowledge
                        of the byte ordering of the source system to construct
                        these signatures out of thin air.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>std::string </type>
                        <methodname>getTitle</methodname>
                        <void />
                        <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        For data acquisition systems where runs have a textual
                        title that can be extracted from the event data, this
                        method returns this title.  If the data acquisition
                        system has no title or it cannot be extracted from the
                        data we recommend returning an empty string.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>operator()</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type><parameter>nBytes</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Address_t </type><parameter>pBuffer</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>CAnalyzer&amp; </type><parameter>rAnalyzer</parameter>
                        </methodparam>
                        <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called  when a block of data has been read from the
                        data source.   <parameter>nBytes</parameter> is the
                        number of bytes of data and <parameter>pBuffer</parameter>
                        points to the data block.  <parameter>rAnalyzer</parameter>
                        is the analyzer that's orchestrating the data analysis.
                        This method will typically some methods of this analyzer.
                    </para>
                    <para>
                        The block of data must be parsed into individual
                        items of specific data types
                        containing individual items as well as blocks of event
                        data.  Depending on the data type, the approprite analyzer
                        method(s) must be called.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnAttach</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CAnalyzer&amp; </type><parameter>rAnalyzer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                         Called when the buffer decoder is attached to the analyzer.
                         Potentially this is done each time a data source is
                         attached.  <parameter>rAnalyzer</parameter> is a reference
                         to the analyzer this buffer decoder is being attached to.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>OnDetach</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>CAnalyzer&amp;</type><parameter> rAnalyzer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called to detach the buffer decoder from the analyzer.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier> virtual </modifier>
                        <type>bool </type>
                        <methodname>blockMode</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This should return <literal>true</literal> if the
                        decoder expects fixed sized blocks and
                        <literal>false</literal> oterhwsis.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void OnSourceAttach</type>
                        <methodname></methodname>
                        <void ></void>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when a new event soruce is attached.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodsynopsis>
                    <modifier>virtual </modifier>
                    <type>void </type>
                    <methodname>OnSourceDetach</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis></term>
                <listitem>
                    <para>
                        Called when a data source is deteached from SpecTcl.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void</type>
                        <methodname> OnEndFile</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when an end file is detected on a data source.
                        For file data sources this indicates the reads of the
                        source have run into the end of the file.  For pipe
                        data sources this means either that the pipe program
                        has exited or that it has closed its
                        <literal>stdout</literal>.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <formalpara>
            <title>Byte order transformations</title>
            <para>
                SpecTcl provides a set of classes that allow programmers to
                instantiate pointer-like objects that can transparenty perform
                any required byte order transformations between the source system
                and the SpecTcl host system.    The following sets of classes are required:
                <classname>BufferTranslator</classname> encapsulates a buffer of
                data and allows fetches to be done from that bufer, returning
                data in the byte order of the executing host.  The
                <classname>BufferFactory</classname> class can provide you with
                a <classname>BufferTranslator</classname> given the 32 bit
                byte order signature of the source system.
            </para>
        </formalpara>
        <para>
            <classname>TranslatorPointer</classname> provides the actual pointer
            like object.  It encapsulates a <classname>BufferTranslator</classname>
            and uses it to provide pointer like semantics to the caller.
            Let's look first at the <classname>BufferTranslator</classname>
            class and its factory before turning our attention to the
            pointer-like <classname>Translator pointer</classname>.
        </para>
        <para>
            The <classname>BufferTranslator</classname> family of classes
            and <classname>BufferFactory</classname> class are defined in
            <filename>BufferTranslator.h</filename>.  Here are the important
            parts of that header:
        </para>
        <example>
            <title><filename>BufferTranslator.h</filename> important bits:</title>
            <programlisting>
class BufferTranslator
{

public:

  UChar_t GetByte( UInt_t );
  Short_t GetWord( UInt_t );
  Long_t GetLongword( UInt_t );
  Address_t getBuffer();
  void newBuffer(Address_t pBuffer);

  virtual void GetBlock( const Address_t, Int_t, Int_t ) = 0;
  virtual Long_t TranslateLong(ULong_t value);
  virtual uint64_t getQuad(uint64_t value) = 0;
};

class BufferFactory
{
 public:
  enum Endian {little, big};
  static BufferTranslator*
    CreateBuffer(Address_t pBuffer, Int_t Signature32);
};

BufferFactory::Endian MyEndianess();
            </programlisting>
        </example>
        <para>
            <classname>BufferTranslator</classname> is a base class for
            <classname>SwappingBufferTranslator</classname>
            which must perfrom byte translations, and
            <classname>NonSwappingBufferTranslator</classname> which
            does not need to perform any byte order transformations.
            Note that both of those classes construct with a
            (protected) buffer which is
            managed by this base class.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>UChar_t </type>
                        <methodname>GetByte</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t </type><parameter>offset</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the raw byte at the byte offset specified by
                        <parameter>offset</parameter> into the buffer on which
                        the object was constructed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Short_t </type>
                        <methodname>GetWord</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t</type><parameter>offset</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the translated 16 bit item at the
                        <emphasis>byte</emphasis> offset specified by
                        <parameter>offset</parameter>.  The method
                        invokes the virtual method
                        <methodname>GetBlock</methodname> which is implemented
                        in concrete classes and does the actual byte re-ordering
                        if needed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Long_t </type>
                        <methodname>GetLongword</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>UInt_t</type><parameter>offset</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the translated 32 bit item at the
                        <emphasis>byte</emphasis> offset specified
                        by <parameter>offset</parameter>.
                        The method invokes the virtual method
                        <methodname>GetBlock</methodname> which is
                        implemented in concrete classes to do the actual
                        byte-reordering.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>Address_t </type>
                        <methodname>getBuffer(</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        The base class contains a pointer to the
                        storage for the buffer being operated
                        on by concrete classes.  This returns a pointer to that
                        buffer. 
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>newBuffer</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>Address_t </type><parameter>pBuffer</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Replaces the pointer to the buffer operated on by
                        the object with <parameter>pBuffer</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void</type>
                        <methodname>GetBlock</methodname>
                        <methodparam>
                           <modifier>const </modifier>
                           <type>Address_t</type><parameter>pItem</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Int_t</type><parameter>size</parameter>
                        </methodparam>
                        <methodparam>
                           <modifier></modifier>
                           <type>Int_t</type><parameter>offset</parameter>
                        </methodparam>
                        <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Gets a block of data at
                        the byte offset <parameter>offset from the start of the buffer
                        into.
                        </parameter><parameter>pItem</parameter>.  The
                        block gotten is <parameter>size</parameter> bytes long.
                        For swapping translators, the bytes from the buffer are
                        reversed.  This makes this method suitable for
                        fetching multi-byte objects of 'normal' size like
                        16 bit, 32, or 64 bit integers.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>Long_t </type>
                        <methodname>TranslateLong</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>ULong_t </type><parameter>value</parameter>
                        </methodparam>
                        <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Given an arbitrary 32 bit item, <parameter>value</parameter>,
                        known to be in the source system byte ordering, returns
                        it byte translated to the calling host.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>uint64_t </type>
                        <methodname>getQuad</methodname>
                        <methodparam>
                           <modifier></modifier>
                           <type>uint64_t </type><parameter>value</parameter>
                        </methodparam>
                        <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Given the 64 bit <parameter>value</parameter> known to
                        be in the source byte order representation, returns it
                        translated into the calling host representation.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            The buffer factory has a single method:
        </para>
        <methodsynopsis>
            <modifier>  static </modifier>
            <type>BufferTranslator*</type>
            <methodname>CreateBuffer</methodname>
            <methodparam>
               <modifier></modifier>
               <type>Address_t </type><parameter>pBuffer</parameter>
            </methodparam>
            <methodparam>
               <modifier></modifier>
               <type>Int_t</type><parameter> Signature32</parameter>
            </methodparam>
            <modifier></modifier>
        </methodsynopsis>
        <para>
            This returns a pointer to a dynamically allocated,
            <classname>BufferTranslator</classname> for the buffer
            <parameter>pBuffer</parameter> from a source system with the
            32 bit byte order signature <parameter>Signature32</parameter>.
        </para>
        <para>
            There is also a utility function:
        </para>
        <methodsynopsis>
            <modifier></modifier>
            <type>BufferFactory::Endian</type>
            <methodname>MyEndianess</methodname>
            <void />
            <modifier></modifier>
        </methodsynopsis>
        <para>
            This returns the endianness of the host.  This will be one
            of the values: <literal>BufferFactory::little</literal>, or
            <literal>BufferFactory::big</literal>.
        </para>

        <para>
            In addition to creating a buffer decoder we also need to tell the
            SpecTcl attach command that the buffer decoder we created shouild
            be used for a specific format of data.   That is, we need to associate
            instances of our buffer decoder class with a specific value of the
            <option>-format</option> option of the <command>attach</command>
            comand.
        </para>
        <para>
            The <command>attach</command> command processor, defined
            in <filename>AttachCommand.h</filename> has a static method:
        </para>
        <methodsynopsis>
            <modifier></modifier>
            <type>void</type>
            <methodname>addDecoderType</methodname>
            <methodparam>
               <modifier></modifier>
               <type>std::string</type><parameter>type</parameter>
            </methodparam>
            <methodparam>
               <modifier></modifier>
               <type>CDecoderCreator*</type><parameter>creator</parameter>
            </methodparam>
            <modifier></modifier>
        </methodsynopsis>
        <para>
            This fits the well known pattern of extensible factories that
            SpecTcl employs in many other parts of its implementatiuon.
            We can register an object that knows how to create out buffer decoder
            and associate it with a keyword passed to the
            <option>-format</option> option.
        </para>
        <para>
            The <classname>CDecoderCreator</classname> class is defined as a typedef
            in the <filename>AttachCommand.h</filename> header as well:
        </para>
        <programlisting>
typedef CCreator&lt;CBufferDecoder&gt;            CDecoderCreator;            
        </programlisting>
        <para>
            <classname>CCreator</classname> is a template class defined in
            <filename>CCreator.h</filename>.  It is part of the extensible
            factory templated subsystem that was developed later in SpecTcl's life.
            <classname>CCreator</classname> looks like this:
        </para>
        <example>
            <title><classname>CCreator</classname> definition</title>
            <programlisting>
template &lt;class T&gt;
class CCreator
{
public:
  virtual T* operator()() = 0;
  virtual std::string describe() const = 0;
};

            </programlisting>
            <para>
                What all htis means is that when <methodname>operator()</methodname>
                is called for your creator, you must return a pointrer to a new
                instance of your decoder class.  When <methodname>describe</methodname>
                is called, you must provide a textual description of your decoder
                class.
            </para>
        </example>
    </section>
    <section>
        <title>Step by step recipe for adding support for a new data format</title>
        <para>
            From the discussion in the previous section, we can derive a
            step by step recipe for adding support for a new data format to
            SpecTcl.
        </para>
        <orderedlist>
            <listitem>
                <para>
                    Write a buffer decoder that invokes appropriate methods of
                    the <classname>CAnalyzer</classname> at appropriate times
                    given blocks of data from the data source.
                </para>
            </listitem>
            <listitem>
                <para>
                    Write a creator object for the buffer decoder we created in the
                    first step.
                </para>
            </listitem>
            <listitem>
                <para>
                    In <filename>MySpecTclApp.cpp</filename> create an instance
                    of our creator and associate it with a new
                    <command>attach</command> <option>-format</option> keyword
                    so that when that format is requested, the <command>attach</command>
                    command can make an instance of our buffer decoder and
                    attach it to the analyzer.
                </para>
            </listitem>
        </orderedlist>
        <para>
            In the next section, we will write code to do this for a simple
            data acquisition system data format.
        </para>
    </section>
    <section>
        <title>Worked example for supporting a new data format</title>
        <para>
            In this section we are going to build support for a simple, fictional
            data acquisition system data format.  The internal format of the data
            bears some resemblence to the ring buffer data format used by
            NSCLDAQ 10.x and later, however that resemblance is purely coincidental
            and you should not conclude from it that any of this code is actually
            used by SpecTcl to decode NSCLDAQ data.
        </para>
        <para>
            Before writing any code we need to have a clear understanding of the
            format of the data we're going to decode.  This is as true for
            a real case as it is for this imaginary case.
        </para>
        <orderedlist>
            <listitem>
                <para>
                    Data will come to us in fixed length blocks.  No item
                    will extend across block boundaries (this simplifies things'
                    tremendously).
                </para>
            </listitem>
            <listitem>
                <para>
                    Each block will have a header that consists of several
                    <type>uint32_t</type>.  These are, in order, the number
                    of 8 bit bytes occupied by useful data, the number of
                    items in the block, a sequence number that tells us the
                    number of the block in the event file or data taking run and
                    a 32 bit SpecTcl byte order signature.
                </para>
            </listitem>
            <listitem>
                <para>
                    The block is divided int items.  Each item consists of
                    a self inclusive size in bytes and a type (both are
                    <type>uint32_t</type>) followed by a  body whose structure
                    depends on the type value.
                </para>
            </listitem>
            <listitem>
                <para>
                    Type 1 indicates a run start, type 2 indicates a run end,
                    Type 3 indicates scaler data and type 4 indicates data
                    taken in response to a physics trigger.
                </para>
            </listitem>
            <listitem>
                <para>
                    The structure of type 1,2 data are the same and look
                    like this:
                </para>
                <programlisting>
                    struct {
                        header    s_header;
                        uint32_t  s_runNumber;
                        char      s_title[];
                    };
                </programlisting>
                <para>
                    Where header is the item header described above.  The title
                    is a null terminated variable length string.
                </para>
            </listitem>
            <listitem>
                <para>
                    Scaler data (type 3), has the following structure:
                </para>
                <programlisting>
                    struct {
                        header    s_header;
                        uint32_t  s_numScalers;
                        uint32_t  s_counters[];
                    };
                </programlisting>
                <para>
                    s_counters are the array of scaler values.
                    <structfield>s_numScalers</structfield> tells us how many
                    of those there are.
                </para>
            </listitem>
            <listitem>
                <para>
                    Type 4 (physics event data) is just an array of bytes
                    whose structure and meaning depend on the actual experiment
                    performed using this data acquisition system.
                </para>
            </listitem>
        </orderedlist>
        <para>
            Let's first create a header, <filename>expdata.h</filename> that
            captures the structure of the data described above.  In order
            to minimize the chances for <firstterm>name collission</firstterm>,
            we're going to put all of those definitions in a
            <firstterm>namespace</firstterm> (<literal>SomeDaqSystem</literal>):
        </para>
        <example>
            <title>Structure of data from SomeDaqSystem</title>
            <programlisting>
#ifndef EXPDATA_H
#define EXPDATA_H

#include &lt;cstdint&gt;



namespace SomeDaqSystem {
  static const unsigned BEGIN(1);
  static const unsigned END(2);
  static const unsigned SCALER(3);
  static const unsigned EVENT(4);
  
  typedef struct _Header {
    std::uint32_t    s_size;
    std::uint32_t    s_type;
  } Header;

  typedef struct _StateChange {
    Header          s_header;
    std::uint32_t   s_runNumber;
    char            s_title[];
  } StateChange;

  typedef struct _Scalers {
    Header         s_header;
    std::uint32_t  s_numScalers;
    std::uint32_t  s_counters[];
  } Scalers;

  typedef struct _Event {
    Header    s_header;
    char      s_body[];
  } Event;

  typedef struct _BufferHeader {
    std::uint32_t s_bytesUsed;
    std::uint32_t s_itemCount;
    std::uint32_t s_sequence;
    std::uint32_t s_signature;
  } BufferHeader;
    
};

#endif
                
            </programlisting>
        </example>
        <para>
            The use of <literal>static const unsigned</literal> above fulfils
            the same purpose as <literal>#define</literal> but places those
            definitions inside the namespace, rather than potentially conflicting
            with other <literal>#define</literal>s the preprocessor knows
            about.
        </para>
        <para>
            Let's look at the header for our decoder class.  We're going to
            dispatch various types to type specific handlers.
            We're going to hand events one at a time to the analyzer rather than
            trying to 
            We're also
            going to ensure we are able to deal with new item types without
            failing:
        </para>
        <example>
            <title><classname>SomeDaqBufferDecoder</classname> header.</title>
            <programlisting>
#ifndef SOMEDAQBUFFERDECODER_H
#define SOMEDAQBUFFERDECODER_H


#include &lt;BufferDecoder.h&gt;
#include "expdata.h"
#include &lt;string&gt;

class SomeDaqBufferDecoder : public CBufferDecoder
{
private:
  
  SomeDaqSystem::BufferHeader   m_lastHeader;
  std::string                   m_lastTitle;
  std::uint32_t                 m_lastRunNumber;    <co id="decoder_data" />
  unsigned                      m_entities;
  SomeDaqSystem::Header*        m_pCurrentItem;

public:                                             <co id='decoder_interface' />
  virtual BufferTranslator* getBufferTranslator();
  virtual const Address_t getBody();
  virtual UInt_t getBodySize() ;
  virtual UInt_t getRun() ;
  virtual UInt_t getEntityCount() ;
  virtual UInt_t getSequenceNo() ;
  virtual UInt_t getLamCount() ;
  virtual UInt_t getPatternCount() ;
  virtual UInt_t getBufferType() ;
  virtual void getByteOrder(Short_t&amp; Signature16,
			    Int_t&amp; Signature32) ;
  virtual std::string getTitle() ;

  virtual void operator() (UInt_t nBytes,        <co id='decoder_fcallop' />
			   Address_t pBuffer,
			   CAnalyzer&amp; rAnalyzer);

private:
  void stateChange(CAnalyzer&amp; rAnalyzer);  <co id='decoder_typehandlers' />
  void scaler(CAnalyzer&amp; rAnalyzer);
  void event(CAnalyzer&amp; rAnalyzer);
  void other(CAnalyzer&amp; rAnalyzer);        <co id='decoder_unanticipated' />
};
                
            </programlisting>
        </example>
        <calloutlist>
            <callout arearefs="decoder_data">
                <para>
                    This local data will be used as follows:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><varname>m_lastHeader</varname></term>
                        <listitem>
                            <para>
                                Each time we get a new block of data from
                                the source, we'll cache a copy of the
                                block header here.  The block header provides
                                byte order signatures as well as other useful
                                book keeping information we'll want in processing
                                the buffer.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><varname>m_lastTitle</varname></term>
                        <listitem>
                            <para>
                                For each state change item encountered, we'll
                                pull the run title out and copy it into this
                                member data.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><varname>m_lastRunNumber</varname></term>
                        <listitem>
                            <para>
                                For each state change item encountered we'll
                                pull the run number out and copy it into this
                                member data.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><varname>m_entities</varname></term>
                        <listitem>
                            <para>
                                We'll put the number of entities in each item
                                here.  For all but scaler items, this is just
                                <literal>1</literal>.  For scaler items,
                                this is the number of scalers in the scaler
                                item.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><varname>m_pCurrentItem</varname></term>
                        <listitem>
                            <para>
                                Points to the item we're working on in the
                                current buffer (note that this allows us to
                                return the body pointer and body size).
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </callout>
            <callout arearefs='decoder_interface'>
                <para>
                    The methods below indicate that we will implement the
                    <classname>CBufferDecoder</classname> interface.
                </para>
            </callout>
            <callout arearefs='decoder_fcallop'>
                <para>
                    This method will get called by the data source, I/O
                    handler when a data block is available.
                </para>
            </callout>
            <callout arearefs='decoder_typehandlers'>
                <para>
                    This set of methods provides handlers for each of the
                    item types the data acquisition system can provide us.
                </para>
            </callout>
            <callout arearefs='decoder_unanticipated'>
                <para>
                    Povides a handler for item types we don't recognize.  This
                    allows us to continue to operate
                    at some basic level if additional
                    item types are introduced.
                </para>
            </callout>
        </calloutlist>
        <para>
            In spite of the ordering of the methods in the header, the
            best place to start is probable with the <methodname>operator()</methodname>
            method.  Once we've coded that and the type specific handlers,
            the <firstterm>getter</firstterm> methods should fall into place
            fairly easily.
        </para>
        <example>
            <title><methodname>SomeDaqBufferDecoder::operator()</methodname> implementation</title>
            <programlisting>
void
SomeDaqBufferDecoder::operator()(
    UInt_t nBytes, Address_t pBuffer, CAnalyzer&amp; rAnalyzer
)
{
  SomeDaqSystem::BufferHeader* pHeader =                       <co id='decoder_op_savehdr' />
    reinterpret_cast&lt;SomeDaqSystem::BufferHeader*&gt;(pBuffer);
  std::memcpy(&amp;m_lastHeader, pHeader, sizeof(SomeDaqSystem::BufferHeader));

  pHeader++;                                                    <co id='decoder_op_firstitem' />
  m_pCurrentItem = reinterpret_cast&lt;SomeDaqSystem::Header*&gt;(pHeader);

  BufferTranslator* pT =                                        <co id='decoder_op_translator' />
    BufferFactory::CreateBuffer(pBuffer, m_lastHeader.s_signature);
  
  for (int i = 0; i &lt; pT-&gt;TranslateLong(m_lastHeader.s_itemCount); i++) {  <co id='decoder_op_itemloop' />

    switch(pT-&gt;TranslateLong(m_pCurrentItem-&gt;s_type)) {
    case SomeDaqSystem::BEGIN:
    case SomeDaqSystem::END:
      stateChange(rAnalyzer);
      break;
    case SomeDaqSystem::SCALER:                               <co id='decoder_op_dispatch' />
      scaler(rAnalyzer);
      break;
    case SomeDaqSystem::EVENT:
      event(rAnalyzer);
      break;
    default:
      other(rAnalyzer);
      break;
    }
                                                             <co id='decoder_op_nextitem' />
    std::uint8_t* pBytes = reinterpret_cast&lt;std::uint8_t*&gt;(m_pCurrentItem);  
    pBytes += pT-&gt;TranslateLong(m_pCurrentItem-&gt;s_size);
    m_pCurrentItem = reinterpret_cast&lt;SomeDaqSystem::Header*&gt;(pBytes);
  }

  delete pT;                                                <co id='decoder_op_freetranslator' />
  
}

            </programlisting>
        </example>
        <calloutlist>
            <callout arearefs='decoder_op_savehdr'>
                <para>
                    This chunk of code saves the buffer header in the member
                    data we set aside for this purpose.  The buffer
                    header has two fields we care very much about, the number
                    of items to process and the byte order signature of the
                    originating system.
                </para>
            </callout>
            <callout arearefs='decoder_op_firstitem'>
                <para>
                    Immediately following the buffer header is the first item.
                    This chunk of code forms a pointer to that first item.
                    As we process the buffer, <varname>m_pCurrentItem</varname>
                    will always point to the current item.  
                </para>
            </callout>
            <callout arearefs='decoder_op_translator'>
                <para>
                    It is possible the originating system has a different
                    byte ordering than the host.  This block of code provides
                    us with a buffer translator that can be used  to reorder
                    items from the buffer into our byte ordering.  
                </para>
                <para>
                    We don't use this much so it's not worth making a
                    translating pointer.  In the code that follows we'll use
                    <methodname>TranslateLong</methodname> to translate 32
                    bit items from the data acquisition system to our
                    byte ordering.
                </para>
            </callout>
            <callout arearefs='decoder_op_itemloop'>
                <para>
                    This loop loops over all the items in the buffer.  Note the
                    use of <methodname>TranslateLong</methodname> to ensure that
                    the item count inthe buffer header is translated to our
                    host's byte order.
                </para>
            </callout>
            <callout arearefs='decoder_op_dispatch'>
                <para>
                    This switch dispatches control to the handler for the
                    appropriate data type.  Note again the use of
                    <methodname>TranslateLong</methodname> to ensure the
                    item type is expressed in our own ordering.
                </para>
            </callout>
            <callout arearefs='decoder_op_nextitem'>
                <para>
                    Performs the book keeping needed to advance to the
                    next item in the buffer. Note again the use of
                    <methodname>TranslateLong</methodname> to ensure the
                    size of the item is expressed in our native byte ordering.
                </para>
            </callout>
            <callout arearefs='decoder_op_freetranslator'>
                <para>
                    Delete the buffer translator we created.  Note that re-creating
                    it for each buffer allows for the pathalogical case that the
                    data is coming from some heterogenous set of systems.
                </para>
            </callout>
        </calloutlist>
        <para>
            Let's look at the state transition method.  What that needs to do is:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Set the entity count to 1.
                </para>
            </listitem>
            <listitem>
                <para>
                    Extract the run number (remember byte order translation).
                </para>
            </listitem>
            <listitem>
                <para>
                    Extract the title.
                </para>
            </listitem>
            <listitem>
                <para>
                    Invoke the analyzer's <methodname>OnStateChange</methodname>
                    method with the appropriate item type.   We're going to
                    provide a helper method called
                    <methodname>translateItemType</methodname> that will
                    translate an item type into one of the types expected by
                    SpecTcl.
                </para>
            </listitem>
        </itemizedlist>
        <example>
            <title>Implementation of <methodname>SomeDaqBufferDecoder::stateChange</methodname></title>
            <programlisting>
void
SomeDaqBufferDecoder::stateChange(CAnalyzer&amp; rAnalyzer)
{
  
  BufferTranslator* pT =
    BufferFactory::CreateBuffer(m_pCurrentItem, m_lastHeader.s_signature);
  SomeDaqSystem::StateChange* pItem =
    reinterpret_cast&lt;SomeDaqSystem::StateChange*&gt;(m_pCurrentItem);
  
  m_entities = 1;
  m_lastRunNumber = pT-&gt;TranslateLong(pItem->&gt;s_runNumber);
  m_lastTitle    = pItem-&gt;s_title;

  rAnalyzer.OnStateChange(
     translateItemType(pT-&gt;TranslateLong(pItem-&gt;s_header.s_type)),
     *this
  );
  delete pT;
				     
}
            </programlisting>
        </example>
        <para>
            The code above pretty much is what you'd expect to see from the
            specification provided.
        </para>
        <para>
            The only differences between <methodname>scaler</methodname>
            and <methodname>stateChange</methodname> are that we
            fill in the entity count from the number of scalers in the
            scaler item, and there's no run number or title to extract from
            the item.
        </para>
        <example>
            <title>Implementation of <methodname>SomeDaqBufferDecoder::scaler</methodname></title>
            <programlisting>
void
SomeDaqBufferDecoder::scaler(CAnalyzer&amp; rAnalyzer)
{
 BufferTranslator* pT =
    BufferFactory::CreateBuffer(m_pCurrentItem, m_lastHeader.s_signature);
  SomeDaqSystem::Scalers* pScaler =
    reinterpret_cast&lt;SomeDaqSystem::Scalers*&gt;(m_pCurrentItem);

  m_entities = pT-&gt;TranslateLong(pScaler-&gt;s_numScalers);

  rAnalyzer.OnScaler(*this);

  delete pT;
  
}             
            </programlisting>
        </example>
        <para>
            Again I think the code is pretty well self explanatory.
        </para>
        <para>
            For events, we're just going to set the entity count to 1
            and invoke <methodname>OnPhysics</methodname>.  While
            <methodname>OnPhysics</methodname> can handle a block of events,
            we're not going to try to do that in this simple example.
        </para>
        <example>
            <title>Implementation of <methodname>SomeDaqBufferDecoder::event</methodname></title>
            <programlisting>
void
SomeDaqBufferDecoder::event(CAnalyzer&amp; rAnalyzer)
{
  m_entities = 1;
  rAnalyzer.OnPhysics(*this);
}
                
            </programlisting>
        </example>
        <para>
            <methodname>other</methodname> is similarly simple, however, once
            more we need to get the item type.
        </para>
        <example>
            <title>Implementation of <methodname>SomeDaqBufferDecoder::other</methodname></title>
            <programlisting>
void
SomeDaqBufferDecoder::other(CAnalyzer&amp; rAnalyzer)
{
 BufferTranslator* pT =
    BufferFactory::CreateBuffer(m_pCurrentItem, m_lastHeader.s_signature);

 m_entities = 1;
 
 rAnalyzer.OnOther(
    translateItemType(pT->TranslateLong(m_pCurrentItem->s_type)),
    *this
  );

 delete pT;
}
                
            </programlisting>
        </example>
        <para>
            Let's implement <methodname>translateItemType</methodname> before
            we turn to the getter menthods.  The only choice we really need
            to make is how to handle item types that are not yet defined.
            For now we'll add the type to <literal>MAXSYSBUFTYPE</literal>
            turning it into a user item type.  In doing so, we're making the
            implicit assumption item types won't be zero.
        </para>
        <example>
            <title>Implementation of <methodname>SomeDaqBufferDecoder::translateItemType</methodname></title>
            <programlisting>
std::uint32_t
SomeDaqBufferDecoder::translateItemType(std::uint32_t type)
{
  static std::map&lt;uint32_t, uint32_t&gt;  typeMap = {
    {1, BEGRUNBF}, {2, ENDRUNBF}, {3, SCALERBF}, {4, DATABF}
  };

  auto p = typeMap.find(type);
  if (p != typeMap.end()) {
    return p->second;
  } else {
    return MAXSYSBUFTYPE + type;
  }
}
            </programlisting>
        </example>
        <para>
            The only thing interesting is the use of an std::map.  This is an
            associative container.  It maps keys to values supporting an efficent
            <methodname>find</methodname> method.  The <literal>auto</literal> keyword
            declaring <varname>p</varname> allows the compiler to infer the type
            to be <type>std::map&lt;std::uint32_t, std::uint32_t&gt;::iterator</type>.
            This is a pointer like object to an std::pair whose first member is a
            map index and whose second is the value of the map entry associated
            with that index.
        </para>
        <para>
            Now we can look at the trivial, one-liner getter methods:
        </para>
        <example>
            <title>Trivial getter implementations</title>
            <programlisting>

const Address_t
SomeDaqBufferDecoder::getBody()
{
  return m_pCurrentItem + 1;
}
UInt_t
SomeDaqBufferDecoder::getRun()
{
  return m_lastRunNumber;
}
UInt_t
SomeDaqBufferDecoder::getEntityCount()
{
  return m_entities;
}
UInt_t
SomeDaqBufferDecoder::getLamCount()
{
  return 0;
}
UInt_t
SomeDaqBufferDecoder::getPatternCount()
{
  return 0;
}
void
SomeDaqBufferDecoder::getByteOrder(Short_t&amp; sig16, Int_t&amp; sig32)
{
  sig32 = m_lastHeader.s_signature;
  sig16 = (m_lastHeader.s_signature &amp; 0xffff);
}

std::string
SomeDaqBufferDecoder::getTitle()
{
  return m_lastTitle;
}

            </programlisting>
        </example>
        <para>
            The next getters take a bit more work, but not much:
        </para>
        <example>
            <title>Not as trivial getters:</title>
            <programlisting>
BufferTranslator*
SomeDaqBufferDecoder::getBufferTranslator()
{
  return  BufferFactory::CreateBuffer(
    m_pCurrentItem, m_lastHeader.s_signature
  );
}

UInt_t
SomeDaqBufferDecoder::getBodySize()
{
  BufferTranslator* pT = getBufferTranslator();
  UInt_t size  = pT->TranslateLong(m_pCurrentItem->s_size);

  delete pT;
  return size;
}
UInt_t
SomeDaqBufferDecoder::getSequenceNo()
{
  BufferTranslator* pT = getBufferTranslator();
  UInt_t seq = pT->TranslateLong(m_lastHeader.s_sequence);
  
  delete pT;
  return seq;
}

UInt_t
SomeDaqBufferDecoder::getBufferType()
{
  BufferTranslator* pT = getBufferTranslator();
  UInt_t            rawType = pT->TranslateLong(m_pCurrentItem->s_type);
  delete pT;

  return translateItemType(rawType);
}

            </programlisting>
        </example>
        <para>
            Next we need to write a creator for this that can be passed to
            <methodname>CAttachCommand::addDecoderType</methodname>.  This
            is pretty trivial.  Almost the hardest part is to choose
            a <option>-format</option> value to associate with this
            decoder.  Let's use <literal>blockring</literal> to indicate
            that these are essentially ring items but in fixed sized blocks.
        </para>
        <para>
            Here's the header, <filename>SomeDaqDecoderCreator.h</filename>:
        </para>
        <example>
            <title>Header for <classname>SomeDaqDecoderCreator</classname></title>
            <programlisting>
#ifndef SOMEDAQDECODERCREATOR_H
#define SOMEDAQDECODERCREATOR_H

#include &lt;AttachCommand.h&gt;
#include &lt;CCreator.h&gt;

class SomeDaqDecoderCreator : public CAttachCommand::CDecoderCreator
{
public:
  virtual CBufferDecoder*  operator()();
  virtual std::string describe() const;
};


#endif

            </programlisting>
        </example>
        <para>
            As previously described, we need to implement both pure virutal
            methods.  The <methodname>operator()</methodname> just needs
            to create a new SomeDaqBufferDecoder object and
            <methodname>describe</methodname> just has to return a description
            of the decoder.
        </para>
        <para>
            Here's the entire class implementation:
        </para>
        <example>
            <title>Implementation of <methodname>SomeDaqDecoderCreator</methodname></title>
            <programlisting>
#include "SomeDaqDecoderCreator.h"
#include "SomeDaqBufferDecoder.h"

CBufferDecoder*
SomeDaqDecoderCreator::operator()()
{
  return new SomeDaqBufferDecoder;
}

std::string
SomeDaqDecoderCreator::describe() const
{
  return "Decode buffers from blocked 'ring items'";
}                
            </programlisting>
        </example>
        <para>
            In <methodname>CMySpecTclApp::AddCommands</methodname>, we can then
            add a line that looks like:
        </para>
        <programlisting>
CAttachCommand::addDecoderType("blockring", new SomeDaqDecoderCreator);            
        </programlisting>
        <para>
            To make the new decoder we wrote available to SpecTcl
        </para>
    </section>
</chapter>
<chapter id='chap.plugins'>
    <title id='chap.plugins.title'>SpecTcl plugins</title>
    <para>
        Until now we've only talked about code that is statically compiled
        into SpecTcl to extend its functionlity.  Plugins are shared libraries
        that are loaded on command to dynamically extend SpecTcl's functionality
        at run time.  Two examples of plugins that are available from the NSCl are
        the Radware I/O plugin that adds commands to save spectra in Radware format
        and the Root Filter format plugin that adds the ability to save filtered
        data as Root Ntuples so filtered events can easily be impoted to Root.
    </para>
    <para>
        The ability to write a SpecTcl plugin really comes as a natural consequence
        of using Tcl as the SpecTcl command langauge.  The Tcl built in command
        <command>load</command> loads a shared library and invokes a specific
        initialization function.  This in conjunction with the SpecTcl
        package subsystem allows plugins to be defined, made known to SpecTcl
        and loaded via the <command>package require</command> Tcl command.
    </para>
    <para>
        In this chapter:
    </para>
    <itemizedlist>
        <listitem>
            <para>
                I'll provide an overview of the process of writing Tcl loadable
                packages.
            </para>
        </listitem>
        <listitem>
            <para>
                I'll describe how to make those packages known to SpecTcl.
            </para>
        </listitem>
        <listitem>
            <para>
                We'll work through an example;  wrapping the buffer decoder
                we wrote in the previous chapter into a plugin that can be
                loaded on demand rather than compiled in.
            </para>
        </listitem>
    </itemizedlist>
    <note>
        <title>NOTE</title>
        <para>
            The use of plugins is not absolutely necessary.  It does, however
            make distributing SpecTcl extensions somewhat simpler.  Feel free
            to skip this chapter on a first reading, however.  Come back to it
            as needed.
        </para>
    </note>
    <section>
        <title>Writing and publishing compiled Tcl packages</title>
        <para>
            To write and publish plugin you must:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Write code to support the functionality of your plugin.
                    For our example, we've already done this in the previous chapter.
                </para>
            </listitem>
            <listitem>
                <para>
                    Write A Tcl loadable module initialization function. Note
                    that this must have C not C++ bindings.
                </para>
            </listitem>
            <listitem>
                <para>
                    Produce a package index file,
                    <filename>pkgIndex.tcl</filename> with the appropriate
                    <command>package ifneeded</command> commands.
                </para>
            </listitem>
            <listitem>
                <para>
                    Package the shared library and package index in a directory
                    that is already part of or is added to the Tcl package
                    search path (<varname>auto_path</varname>).
                </para>
            </listitem>
        </itemizedlist>
        <para>
            We're going to start this section with a discussion of the initialization
            function as we've already got code to support our plugin's functionality.
            The name of the initialization function is important.   The name of the
            initialization function is derived from the name of the shared library
            you are making by:
        </para>
        <orderedlist>
            <listitem>
                <para>
                    Removing the leading lib
                </para>
            </listitem>
            <listitem>
                <para>
                    Removing the trailing .so and anything after that
                    (e.g. version numbers).
                </para>
            </listitem>
            <listitem>
                <para>
                    Making the first name of all that remains upper case.
                </para>
            </listitem>
            <listitem>
                <para>
                    Making all the remaining parts of the name lower case.
                </para>
            </listitem>
            <listitem>
                <para>
                    Appending <literal>_Init</literal> to the result.
                </para>
            </listitem>
        </orderedlist>
        <para>
            So, for example,  if we decide we're going to build the
            shared library: <filename>libSomeDaqDecoder.so</filename>,
            our initialization function must be called:
            <function>Somedaqdecoder_Init</function>.
        </para>
        <para>
            The function receives the interpreter (raw interpreter of type
            <type>Tcl_Interp*</type>) as its only argument and, on success
            is supposed to return <literal>TCL_OK</literal>, and on failure
            <literal>TCL_ERROR</literal>.
        </para>
        <para>
            The initialization function should:
        </para>
        <orderedlist>
            <listitem>
                <para>
                    Initialize the Tcl stubs interface, if Tcl is stubs enabled
                    and you want your extension to be stubs enabled (you should
                    as this insulates you from the exact Tcl version SpecTcl
                    is built with enabling your plugin to be more portable).
                </para>
                <para>
                    This is done by invoking <function>Tcl_InitStubs</function>.
                    You must also be sure to link your plugin to the stubs
                    library rather than Tcl directly.
                </para>
            </listitem>
            <listitem>
                <para>
                    Make the name and version of the package you intend to supply
                    to the interpreterk nown, via a call to
                    <function>Tcl_PkgProvide</function>.
                </para>
            </listitem>
            <listitem>
                <para>
                    Do whatever's necessary to incorporate your package into
                    SpecTcl.
                </para>
            </listitem>
        </orderedlist>
        <para>
            Much of this is best covered by example in the next section.
            We'll say a bit here about packages, package indices and the package
            load process.  This will serve as a bit of background on how to
            distribute your plugin so that it can be incorporated into SpecTcl.
            Note that this is a Tcl topic, not a SpecTcl topic.
        </para>
        <para>
            When Tcl processes the <command>package require</command> command
            for a package that isn ot already loaded, it searches the directories
            in <varname>auto_path</varname> one by one for a file named
            <filename>pkgIndex.tcl</filename>.  If that file is located, it is
            sourced into the interpreter.
        </para>
        <para>
            Typically <filename>pkgIndex</filename> will contain a series of
            <command>package ifneeded</command> commands that define how
            to load a set of packages into the interpreter.  When sourced,
            the Tcl variable <varname>dir</varname> is the full path
            to the directory in which the <filename>pkgIndex.tcl</filename>
            script is installed.
        </para>
        <para>
            The form of the <command>package ifneeded</command> command is:
        </para>
        <cmdsynopsis>
            <command>
package ifneeded <replaceable>name version load-script</replaceable>
            </command>
        </cmdsynopsis>
        <para>
            Where <parameter>name</parameter> is the name of a package,
            <parameter>version</parameter> is a version of that package and
            <parameter>load-script</parameter> are the commands needed to
            load that package into the interpreter.  Note that the
            <command>package require</command> command can specify a version
            as well as matching criteria and you can have
            <command>package ifneeded</command> commands for several versions
            of the same package.
        </para>
        <para>
            For a compiled extension, the script must be a <command>load</command>
            command for the appropriate shared library.  For example for
            libSomDaqDecoder.so, providing version 1.0 of the package
            SomeDaqDecoder, the <filename>pkgIndex.tcl</filename> file might
            contain:
        </para>
        <programlisting>

package ifneeded SomeDaqDecoder 1.0  \
    [list load [file join $dir libSomeDaqDecoder.so]]
        </programlisting>
        <para>
            The Tcl <command>list</command> command can be used to build up
            command forcing appropriate quoting and the
            <command>file join</command> command supplies a system independent
            mechanism for joining file path elements in to a file path.
        </para>
    </section>
    <section>
        <title>Distributing the <classname>SomeDaqBufferDecoder</classname> as a plugin</title>
        <para>
            In the previous section we described, in theoretical terms what we
            need to do to create a Tcl extension and, thus, a SpecTcl plugin.
            In this section we will take concrete steps to turn the
            the buffer decoder developed in the previous chapter into a plugin.
            We will:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Show the initialization function for this function.
                </para>
            </listitem>
            <listitem>
                <para>
                    Show a modified Makefile for SpecTcl that also generates
                    the shared library for the extension/plugin
                </para>
            </listitem>
            <listitem>
                <para>
                    Show a <filename>pkgIndex.tcl</filename> file which
                    provides the proper package index for this extension/plugin
                </para>
            </listitem>
            <listitem>
                <para>
                    Show a screen log of a short SpecTcl session showing that
                    the extension/plugin loads and integrates with SpecTcl.
                </para>
            </listitem>
            <listitem>
                <para>
                    Describe what you'd need to do to distribute the plugin in
                    binary form.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            From now I'm going to use the word <firstterm>plugin</firstterm> rather than
            the Tcl term extension to describe our work.  
        </para>
        <para>
            Let's see what the plugin's initialization function looks like:
        </para>
        <example>
            <title>Plugin initialization for the sample daq decoder plugin</title>
            <programlisting>
#define USE_TCL_STUBS 1                            <co id='plugin_usetclstubs' />

#include &lt;tcl.h&gt;
#include &lt;AttachCommand.h&gt;                   <co id='plugin_headers' />
#include "SomeDaqDecoderCreator.h"

const char* packageName    = "SomeDaqDecoder";
const char* packageVersion = "1.0";                <co id='plugin_strings' />
const char* TclMinVersion  = "8.5";

extern "C" {                                       <co id='plugin_cbinding' />
  int Somedaqdecoder_Init(Tcl_Interp* interp)      <co id='plugin_initentry' />
  {
    const char* actualVersion = Tcl_InitStubs(interp, TclMinVersion, 0); <co id='plugin_initstubs' />
    if (!actualVersion) {
      Tcl_AppendResult(interp, "Unable to initialize Tcl Stubs", NULL); <co id='plugin_initstubserror' />
      return TCL_ERROR;
    }

    int status = Tcl_PkgProvide(interp,
                            const_cast&lt;char*&gt;(packageName),       <co id='plugin_pkgprovide' />
                            const_cast&lt;char*&gt;(packageVersion));
    if (status != TCL_OK) status;


    CAttachCommand::addDecoderType("blockring", new SomeDaqDecoderCreator);  <co id='plugin_registercreator' />

    return TCL_OK;                                <co id='plugin_normalstatus' />
  }
}

            </programlisting>
        </example>
        <calloutlist>
            <callout arearefs='plugin_usetclstubs'>
                <para>
                    This preprocessor definition switches on the plugin interface
                    in the <filename>tcl.h</filename> header.  This definition
                    could also  have been, and often is added to the compiler's
                    command line flags (<literal>-DUSE_TCL_STUBS</literal>).
                </para>
                <para>
                    In this case we really want to be sure that we're using
                    the stubs interface because that employes a jump table
                    rather than direct linkages to the Tcl run time libraries
                    to insulate us from Tcl version.  
                </para>
            </callout>
            <callout arearefs='plugin_headers'>
                <para>
                    We need several headers to correctly compile:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><filename>tcl.h</filename></term>
                        <listitem>
                            <para>
                                Defines the Tcl API functions and data types.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><filename>AttachCommand.h</filename></term>
                        <listitem>
                            <para>
                                Provides the bits of the SpecTcl library we need,
                                specifically how to register our decoder creator
                                with SpecTcl's <command>attach</command>
                                command.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><filename>SomeDaqDecoderCreator.h</filename></term>
                        <listitem>
                            <para>
                                In order to register our decoder with the
                                <command>attach</command> command we'll need
                                to provide an instance of <classname>SomeDaqDecoderCreator</classname>,.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </callout>
            <callout arearefs='plugin_strings'>
                <para>
                    Defines several constant strings we'll need:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><varname>pakageName</varname></term>
                        <listitem>
                            <para>
                                The name of the package we are initializing.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><varname>packageVersion</varname></term>
                        <listitem>
                            <para>
                                The version of the package initialized by this
                                code.  Package versions allow clients to distinguish
                                between historical implementations of a package
                                that may not be forward or backwards compatible.
                                See the documetation of the
                                <command>package provide</command> command
                                for more information.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><varname>TclMinVersion</varname></term>
                        <listitem>
                            <para>
                                Initialization of the Tcl stubs interface requires
                                some information about the specific versions of
                                Tcl our package complies with.  We'll us this
                                to indicate that the value of this string
                                specifies the minimum acceptable version of
                                Tcl.
                            </para>
                            <para>
                                Note to nitpickers.  Probably this package runs
                                just fine on Tcl 8.0 or later but I've not had
                                the motivation to try it out on that version.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </callout>
           <callout arearefs='plugin_cbinding'>
            <para>
                Since the Tcl API is written in C it is important not to allow
                C++ to modify the name of our initialization  entry point to
                indicate the argument signature (name decoration or mangling is
                how C++ supports function name overloading in the face of
                linkers that know nothing of argument signatures).
                The <literal>extern "C"</literal> declaration here means that
                the block of code that follows will use C not C++ linkage
                conventions wich, in turn, means that function names won't get
                decorated.
            </para>
            <para>
                If we forget to  do this, at load time Tcl will complain that it
                can't find our initialization function.
            </para>
           </callout>
           <callout arearefs='plugin_initentry'>
            <para>
                This is the initialization function entry.  The name
                depends on the name of the library our plugin will be
                built into.  We chose
                <filename>libSomeDaqDecoder.so</filename>, and that forces us
                touse the name <function>Somedaqdecoder_Init</function>.
            </para>
           </callout>
           <callout arearefs='plugin_initstubs'>
            <para>
                <function>Tcl_InitStubs</function> initializes the Tcl stubs
                interface by building a jump table in the stubs library so that
                calls to stubs interfaces get forwarded to the actual API
                functions in the Tcl API shared library loaded by SpecTcl.
            </para>
            <para>
                The first parameter is the interpreter.  The second is a Tcl
                version number string.  The final parameter is nonzero
                if the version string passed in must exactly match the
                version string of the Tcl shared library linked into SpecTcl,
                and false if that version or any newer version will satisfy
                our requirements.
            </para>
           </callout>
           <callout arearefs='plugin_initstubserror'>
            <para>
                <function>Tcl_InitStubs</function> returns a pointer to a string
                that is the Tcl version actually loaded on success or a Null
                pointer if the call fails.  If the call fails, we
                append a message (hopefully the reason the call fails is already
                in the result string), to the interpreter result string so this
                error can be properly reported to the user.
            </para>
            <para>
                Package initialization returns <literal>TCL_ERROR</literal>
                to indicate the initialization failed and the package
                is not loaded.
            </para>
           </callout>
           <callout arearefs='plugin_pkgprovide'>
            <para>
                <function>Tcl_PkgProvide</function> lets Tcl know that initializing
                this library provides a Tcl package.
                The first parameter is the interpreter, the second the package name
                and the third, the package version number.
            </para>
            <para>
                The function returns <literal>TCL_OK</literal> on success.
                On failure we just pass the return code back to our caller indicating
                the package did not load.  There's a tacit hope that
                <function>Tcl_PkgProvide</function> has left an interpreter result
                that describes the reason for failure.
            </para>
           </callout>
           <callout arearefs='plugin_registercreator'>
            <para>
                The point of our initialization is to add our buffer decoder to
                the list that <command>attach</command> can use by associating
                it with a <option>-format</option> keyword.  This
                line performs that operation.
            </para>
           </callout>
           <callout arearefs='plugin_normalstatus'>
            <para>
                Since all has gone well we return <literal>TCL_OK</literal>
                to show that.
            </para>
           </callout>
           
        </calloutlist>
        <para>
            Let's look at the Makefile for a tailored SpecTcl modified
            to also produce our plugin library:
        </para>
        <example>
            <title>Makefile that can produce the plugin</title>
            <programlisting>
...
USERCXXFLAGS=-std=c++11 -fPIC                 <co id='plugin_PIC' />

USERCCFLAGS=$(USERCXXFLAGS)

USERLDFLAGS=

OBJECTS=MySpecTclApp.o

all: SpecTcl libSomeDaqDecoder.so            <co id='plugin_newtarget' />

SpecTcl: $(OBJECTS)
        $(CXXLD)  -o SpecTcl $(OBJECTS) $(USERLDFLAGS) \
        $(LDFLAGS)


clean:  cleanlib
        rm -f $(OBJECTS) SpecTcl

depend:
        makedepend $(USERCXXFLAGS) *.cpp *.c

help:
        echo "make                 - Build customized SpecTcl"
        echo "make clean           - Remove objects from previous builds"
        echo "make depend          - Add dependencies to the Makefile. "

                                 <co id='plugin_libtarget' />
libSomeDaqDecoder.so: SomeDaqBufferDecoder.o  SomeDaqDecoderCreator.o packageInit.o
        $(CXXLD) -shared -o libSomeDaqDecoder.so  $^  -ltclstub8.5 $(LDFLAGS)


                                 <co id='plugin_libsources' />

SomeDaqBufferDecoder.o: SomeDaqBufferDecoder.cpp SomeDaqBufferDecoder.h expdata.h

SomeDaqBufferCreator.o: SomeDaqBufferCreator.cpp SomeDaqBufferCreator.h

packageInit.o: packageInit.cpp SomeDaqDecoderCreator.h

                       

cleanlib:                         <co id='plugin_clean' />
        rm -f SomeDaq*.o
        rm -f libSomeDaq*.so*

            </programlisting>
        </example>
        <para>
            Some comments have been removed for brevity.
        </para>
        <calloutlist>
            <callout arearefs='plugin_PIC'>
                <para>
                    To build shared libraries requires that code be compiled
                    as <firstterm>position independent</firstterm>.  This means
                    that all branches and variable references must be relative
                    to somethign (self in the case of branches or a pointer to
                    data in the case of data).  The <literal>-fPIC</literal>
                    compiler flag instructs the compiler to build
                    position independent code.
                </para>
            </callout>
            <callout arearefs='plugin_newtarget'>
                <para>
                    This added line defines the first target <literal>all</literal>
                    to build not only <literal>SpecTcl</literal> but also
                    <filename>libSomeDaqDecoder.so</filename>.
                </para>
                <para>
                    The <command>make</command> command with no target
                    builds the first target in the Makefile, in this case
                    <literal>all</literal>
                </para>
            </callout>
            <callout arearefs='plugin_libtarget'>
                <para>
                    Describes what's needed to make the objects needed by
                    <filename>libSomeDaqDecoder.so</filename>, and
                    how to build the library.  Note that
                    <literal>$^</literal> is a Makefile variable that
                    translates to the dependencies for the target.
                    <literal>-ltclstub8.5</literal>, the stubs library, is specified
                    prior to the standard SpecTcl load  options to ensure
                    that it satisfies all of the Tcl externals prior to
                    the <literal>-ltcl8.6</literal> in the SpecTcl
                    <literal>LDFLAGS</literal> variable.
                </para>
                <para>
                    <option>-shared</option> instructs the linker that the
                    output of the link should be a shared library rather than
                    an executable.  
                </para>
            </callout>
            <callout arearefs='plugin_libsources'>
                <para>
                    These lines build the objects needed by the shared library
                    from the individual source files.  They also describe
                    which headers each source depends on so that a change
                    to a header will also result in an appropriate
                    set of recompilations.
                </para>
            </callout>
            <callout arearefs='plugin_clean'>
                <para>
                    Describes how to clean the results of the shared library
                    build. This will get invoked on
                    <command>make clean</command> because we indicated that
                    <literal>cleanlib</literal> is a dependency for
                    the <literal>clean</literal> target.
                </para>
            </callout>            
        </calloutlist>
        <para>
            The package index file <filename>pkgIndex.tcl</filename> is
            relatively simple:
        </para>
        <programlisting>
package ifneeded SomeDaqDecoder 1.0 \
    [list load [file join $dir libSomeDaqDecoder.so]]

        </programlisting>
        <para>
            The <command>list</command> command can build up a Tcl command
            with appropriate quoting.  The <command>file join</command>
            command joins filename path elements into a file path in a manner
            independent of the operating system.  The <varname>dir</varname>
            variable is the directory the Tcl
            <command>package require</command> command is searching when this
            script is sourced.
        </para>
        <para>
            Let's see if all of this works.  We'll run SpecTcl and show a screen
            log of the process of checking the set of buffer decoders registered
            with <command>attach</command>, adding the package directory to
            <varname>auto_path</varname>, loading the package and
            checking the buffer decoders after the load.
        </para>
        <programlisting>
<computeroutput>%</computeroutput> <command>attach</command>
<computeroutput>
You must have exactly one data source type
Usage:
  attach {switches...} connection
  Where:
     Switches are taken from the following:
     -format {format type}
     -size nBytes - Number of bytes per buffer.
     {sourcetype} which can be only one of:
        -file  when connection is the name of the file
               from which data will be taken
        -pipe  When connection is a command whose stdout is
               taken as the event source.
        -test  When connection selects one of the test data sources
        -null  No events will be made available.
Available format types are:
filter - SpecTcl filter format files.                    <co id='plugin_attnosample' />
jumbo - NSCL 'standard' buffer format with jumbo sized buffers
nscl - NSCL 'standard' buffer format decoder'
ring  - NSCL DAQ Ring buffer data acquisition system

%</computeroutput> <command>lappend auto_path .</command>  <co id='plugin_autopath' />
<computeroutput>/usr/share/tcltk/tcl8.6 /usr/share/tcltk
/user/fox/test/pgmguideexamples/lib /usr/local/lib/tcltk /usr/local/share/tcltk
/usr/lib/tcltk/x86_64-linux-gnu /usr/lib/tcltk /usr/lib/tcltk/tcl8.6 /usr/lib
/usr/opt/spectcl/5.0/TclLibs /usr/opt/spectcl/5.0/TclLibs
/usr/share/tcltk/tklib0.6 /usr/share/tcltk/tcllib1.16 /usr/share/tcltk/tk8.6
/usr/share/tcltk/tk8.6/ttk /usr/opt/spectcl/5.0/TclLibs
/usr/opt/spectcl/5.0/Script /usr/share/tcltk/itk3.3
/usr/share/tcltk/iwidgets4.0.1 /usr/share/tcltk/iwidgets4.0.1/generic
/usr/share/tcltk/iwidgets4.0.1/scripts /usr/opt/spectcl/5.0/Script .
%</computeroutput> <command>package require SomeDaqDecoder</command> <co id='plugin_require' />
<computeroutput>1.0                                        <co id='plugin_loadok' />
%</computeroutput> <command>attach</command>
<computeroutput>You must have exactly one data source type
Usage:
  attach {switches...} connection
  Where:
     Switches are taken from the following:
     -format {format type}
     -size nBytes - Number of bytes per buffer.
     {sourcetype} which can be only one of:
        -file  when connection is the name of the file
               from which data will be taken
        -pipe  When connection is a command whose stdout is
               taken as the event source.
        -test  When connection selects one of the test data sources
        -null  No events will be made available.
Available format types are:
blockring - Decode buffers from blocked 'ring items'            <co id='plugin_attsample' />
filter - SpecTcl filter format files.
jumbo - NSCL 'standard' buffer format with jumbo sized buffers
nscl - NSCL 'standard' buffer format decoder'
ring  - NSCL DAQ Ring buffer data acquisition system

%</computeroutput>

        </programlisting>
        <calloutlist>
            <callout arearefs='plugin_attnosample'>
                <para>
                    When most SpecTcl commands are issued with an error in
                    their syntax, they will output detailed help on the
                    usage of the command.  In this case, the
                    <command>attach</command> command, among other things,
                    lists the set of legal format types.  Note that
                    <literal>blockring</literal> is not listed.
                </para>
            </callout>
            <callout arearefs='plugin_autopath'>
                <para>
                    We add the current working directory (<literal>.</literal>)
                    to the <varname>auto_path</varname>.  This means
                    that <command>package require</command> will look in
                    this directory for a <command>pkgIndex.tcl</command>
                    script.  For this demonstration, the index file and the
                    shared library are both in the same directory from which
                    we ran SpecTcl.
                </para>
            </callout>
            <callout arearefs='plugin_require'>
                <para>
                    This <command>package require</command> command attempts to
                    load the package.
                </para>
            </callout>
            <callout arearefs='plugin_loadok'>
                <para>
                    When <command>package require</command> successfully loads
                    a package, the return value from the command is the
                    package version string.  This <literal>1.0</literal>
                    indicates the package was successfully loaded.
                </para>
            </callout>
            <callout arearefs='plugin_attsample'>
                <para>
                    After the load note that the <literal>blockring</literal>
                    format is shown as available to the
                    <command>attach</command> commmand.  This indicates our
                    package was able to register its creator.
                </para>
            </callout>
             
        </calloutlist>
        <para>
            One of the interesting things about plugins is that they can
            be distributed by only supplying their package index file and
            their shared library.  That can be put in a Tarball and
            handed off to any user.  This is the advantage of using the
            Tcl stubs library as you are insulated from the need to know
            the specific version of Tcl SpecTcl was linked against.
        </para>
        <para>
            To install a plugin so that it's automatically available to all
            SpecTcl users, you can ask your system administrator to
            install the plugin in a directory under the
            <filename>TclLibs</filename> subdirectory of the Tcl
            installation.
        </para>
    </section>
</chapter>
<chapter id='chap.dynamicpipe'>
    <title id='chap.dynamicpipe.title'>Dynamic processing pipelines</title>
    <para>
        Beginning with SpecTcl 5.1, SpecTcl supports dynamic event processsing
        pipelines.  At the very least, this allows you to use the same
        SpecTcl executable image to analyze raw data and to playback filter files.
        You can also use it to selectively enable analysis or to allow a single
        SpecTcl executable to analyze data from a wide variety of data formats.
    </para>
    <para>
        To use this facility you must:
    </para>
    <itemizedlist>
        <listitem>
            <para>
                Create instances of the event processors you want to use.
            </para>
        </listitem>
        <listitem>
            <para>
                Register the event processor instances with the pipeline manager.
            </para>
        </listitem>
        <listitem>
            <para>
                Use the SpecTcl <command>pman</command> commands to setup event processing
                pipelines involving those event processors.
            </para>
        </listitem>
        <listitem>
            <para>
                Use the SpecTcl <command>pman</command> command to select
                the event processing pipeline to use.
            </para>
        </listitem>
        <listitem>
            <para>
                Start anlayzing data from a data source.
            </para>
        </listitem>
    </itemizedlist>
    <para>
        In this chapter we'll give sample code that shows how to create
        instances of event processors and how to register them with the
        pipeline manager singleton.  We'll also give examples of Tcl command
        sequences that build up and select event processing pipelines.
    </para>
    <para>
        Before continuing, let me reassure you that all of your existing
        SpecTcl code should work just fine.  When SpecTcl starts, it creates
        a pipeline named <literal>default</literal> and sets that pipeline
        as the current event processing pipeline.  The
        <methodname>CreateAnalysisPipeline</methodname> code you use
        registers event processors you create (they must be uniquely named or
        have default names) and adds them to the current event processing
        pipeline.  Thus everything we describe in this chapter is optional.
    </para>
    <section>
        <title>Creating and registering event processors.</title>
        <para>
            To use dynamic event processors, you must have  a set of
            event processor instances, each registered with the pipeline
            manager singleton under a unqique name.  In this section,
            I'll show how to create a few event processors and register
            them with the pipeline manager.  This code could appear in
            <methodname>CreateAnalysisPipeline</methodname>.  We're going to
            assume you have created event processor classes namec Evp1, Evp2
            and Evp3. Additionally, we're going to
            instantiate and register the filter event
            processor that comes with SpecTcl.
        </para>
        <example>
            <title>Creating and registering</title>
            <programlisting>
#include &lt;FilterEventProcessor.h&gt;
#include "Evp1.h"
#include "Evp2.h"                           <co id='dynpipe.includes' />
#include "Evp3.h"
#include &lt;CPipelineManager.h&gt;
....
void
CMySpecTclApp::CreateAnalysisPipeline(CAnalyzer& rAnalyzer)
{
    CPipelineManager* pMgr = CPipelineManager::getInstance()  <co id='dynpipe.pmgrsingleton' />
    
    pMgr->registerEventProcessor("evp1", new Evp1);
    pMgr->registerEventProcessor("evp2", new Evp2);           <co id='dynpipe.evpregister' />
    pMgr->registerEventProcessor("evp3", new Evp3);
    pMgr->registerEventProcessor("filter", new CFilterEventProcessor);
}
            </programlisting>
        </example>
        <calloutlist>
            <callout arearefs='dynpipe.includes'>
                <para>
                    These includes, presumably pull in the class definitions
                    for the your <classname>Evp1</classname> ..
                    <classname>Evp3</classname> classes, the
                    <classname>CFilterEventProcessor</classname> definition
                    and definition of <classname>CPipelineManager</classname>,
                    the pipeline manager singleton.
                </para>
            </callout>
            <callout arearefs='dynpipe.pmgrsingleton'>
                <para>
                    Since the <classname>CPipelineManager</classname> is a
                    singleton, you can't construct it.
                    It's <methodname>getInstance</methodname> method
                    (it's declared as private).
                    returns a pointer to the one and only instance of this
                    class.
                </para>
            </callout>
            <callout arearefs='dynpipe.evpregister'>
                <para>
                    Each of these calls registers an event processor with the
                    pipeline manager.  The first paramteer is a name that will
                    be associated with the event processor instance.  The second,
                    a pointer to an instance of the event processor.
                    If you attempt to register a duplicate name a
                    <classname>std::logic_error</classname> exception will be
                    thrown by the pipleline manager.
                </para>
            </callout>
        </calloutlist>
        <para>
            Note that we have not created any event processing pipelines.  In
            this set of examples, we're going to do that at the Tcl script level.
            If you prefer, the pipeline manager does provide methods to create
            pipelines, add event processors to them to select the pipeline that
            SpecTcl will use to analyze data.
        </para>
        <para>
            See the programming reference for a complete description of the
            methods provided by the pipeline manager singleton.
        </para>
    </section>
    <section>
        <title>Using the <command>pman</command> command to create and select pipelines</title>
        <para>
            In this section, we are going to assume that SpecTcl has the code
            described in the previous section and therefore there are
            four event processors registered: <literal>evp1</literal>,
            <literal>evp2</literal>, <literal>evp3</literal> and
            <literal>filter</literal>.
            We'll create two pipelines. One called <literal>raw</literal>
            which will contain the user written <literal>evp*</literal> event
            prociessors and one called <literal>filter</literal> which
            contains the filter event processor.  We'll then select the
            <literal>raw</literal> event processing pipeline to be the one
            SpecTcl uses.
        </para>
        <para>
            Once more, all this could be done programatically using the
            pipeline manager object, but this method is more flexible and
            allows pipeline management to be added to your experiment
            specific Tcl/Tk GUI without any additional C++ coding.
        </para>
        <example>
            <title>Using the <command>pman</command> SpecTcl command</title>
            <programlisting>
pman mk raw                                <co id='dynpipe.pman.mk' />
foreach proc [list evp1 evp2 evp3] {
    pman add raw $proc                     <co id='dynpipe.pman.add' />
}

pman mk filter                             <co id='dynpipe.pman.filter' />
pman add filter filter

pman use raw                               <co id='dynpipe.pman.use'/>
            </programlisting>
        </example>
        <calloutlist>
            <callout arearefs='dynpipe.pman.mk'>
                <para>
                    The <command>pman</command> command is a command
                    ensemble.  This means that it requires a subcommand
                    to tell it what to do.   The <command>mk</command>
                    subcommand creates new pipelines.  This line
                    creates a new event processing pipeline called
                    <literal>raw</literal>
                </para>
            </callout>
            <callout arearefs='dynpipe.pman.add'>
                <para>
                    This loop adds the user written event processors we
                    registered in the C++ code in the previous section
                    to the <literal>raw</literal> pipeline.
                    The list in the <command>foreach</command> loop
                    determines the order in which the event processors
                    are called.
                </para>
            </callout>
            <callout arearefs='dynpipe.pman.filter'>
                <para>
                    Similarly, this pair of commands creates the
                    pipeline named <literal>filter</literal> and makes
                    the <literal>filter</literal> event processor its only element.
                    Pipeline names must be unique, and event processor names must
                    be unique, but the namespaces for pipelines and event processors
                    are distinct allowing the pipeline to have the same name
                    as an event processor.
                </para>
            </callout>
            <callout arearefs='dynpipe.pman.use'>
                <para>
                    SpecTcl only runs a singl event processing pipeline at a time.
                    When it starts executing, a pipeline named
                    <literal>default</literal> is used.  The
                    <command>use</command> subcommand specifies a new pipeline
                    to be used by SpecTcl to analyze data.
                </para>
                <para>
                    We could have equally well just added our raw event
                    processors to the <literal>default</literal> pipeline not
                    bothering with a <literal>raw</literal> pipeline.
                    We chose not to for illustrative purposes, and to give
                    that pipeline a better name.
                </para>
                <para>
                    The same SpecTcl executable can read filter files by
                    simply doing a <command>pman use filter</command> at a later
                    time.
                </para>
            </callout>
        </calloutlist>
    </section>

</chapter>
</book>
