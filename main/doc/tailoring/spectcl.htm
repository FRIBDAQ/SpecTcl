<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=iso-8859-1">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<link rel=File-List href="./spectcl_files/filelist.xml">
<link rel=Edit-Time-Data href="./spectcl_files/editdata.mso">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
<title>SpecTcl's handling of event data</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>fox</o:Author>
  <o:LastAuthor>fox</o:LastAuthor>
  <o:Revision>2</o:Revision>
  <o:TotalTime>10</o:TotalTime>
  <o:Created>2006-10-19T20:20:00Z</o:Created>
  <o:LastSaved>2006-10-19T20:30:00Z</o:LastSaved>
  <o:Pages>6</o:Pages>
  <o:Words>2604</o:Words>
  <o:Characters>14845</o:Characters>
  <o:Company>MSU</o:Company>
  <o:Lines>123</o:Lines>
  <o:Paragraphs>29</o:Paragraphs>
  <o:CharactersWithSpaces>18230</o:CharactersWithSpaces>
  <o:Version>9.6926</o:Version>
 </o:DocumentProperties>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;
	mso-font-charset:2;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:0 268435456 0 0 -2147483648 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p
	{font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
pre
	{margin:0in;
	margin-bottom:.0001pt;
	font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Courier New";}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
 /* List Definitions */
@list l0
	{mso-list-id:795681991;
	mso-list-type:hybrid;
	mso-list-template-ids:637703686 -797433384 -1117348032 25310280 265448940 1603310866 1192267608 -1284325340 -1693141758 -1415827198;}
@list l0:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l1
	{mso-list-id:810513743;
	mso-list-type:hybrid;
	mso-list-template-ids:-1669547732 1614722520 67698691 67698693 67698689 67698691 67698693 67698689 67698691 67698693;}
@list l1:level1
	{mso-level-start-at:0;
	mso-level-number-format:bullet;
	mso-level-text:-;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
ol
	{margin-bottom:0in;}
ul
	{margin-bottom:0in;}
-->
</style>
</head>

<body lang=EN-US link=blue vlink=blue style='tab-interval:.5in'>

<div class=Section1>

<table border=0 cellspacing=0 cellpadding=0 width="100%" style='width:100.0%;
 mso-cellspacing:0in;mso-padding-alt:0in 0in 0in 0in'>
 <tr>
  <td width="9%" nowrap style='width:9.0%;padding:0in 0in 0in 0in'>
  <p class=MsoNormal align=center style='text-align:center'><b><a
  href="http://www.nscl.msu.edu"><span style='text-decoration:none;text-underline:
  none'><img border=0 width=63 height=52 id="_x0000_i1025"
  src="../images/nscl_logo_small.gif" alt="nscl_logo_small.gif (2463 bytes)"></span></a><o:p></o:p></b></p>
  </td>
  <td width="79%" style='width:79.0%;padding:0in 0in 0in 0in'>
  <h1>SpecTcl's handling of Event Data</h1>
  </td>
  <td width="12%" style='width:12.0%;padding:0in 0in 0in 0in'>
  <p class=MsoNormal><a href="../index.htm"><span style='text-decoration:none;
  text-underline:none'><img border=0 width=192 height=84 id="_x0000_i1026"
  src="../images/hh00706_.jpg" alt="HH00706_.wmf (6530 bytes)"></span></a></p>
  </td>
 </tr>
</table>

<p><a name=Top></a><a href="../index.htm"><span style='mso-bookmark:Top'>SpecTcl
Home</span><span style='mso-bookmark:Top'></span></a><span style='mso-bookmark:
Top'></span>&nbsp; <a href="../general_information.htm">General Information</a>
<a href="../users_guide.htm">User Guide</a> <a href="../programmers_guide.htm">Programmer's
Guide</a> <a href="../obtaining_and_installing.htm">Obtaining and Installing</a></p>

<p><a href="tailoring.htm">Tailoring SpecTcl</a></p>

<h1>Page Contents:</h1>

<ul type=disc>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l0 level1 lfo1;tab-stops:list .5in'><a href="#Classes">Discussion
     of the relevant classes.</a></li>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l0 level1 lfo1;tab-stops:list .5in'><a
     href="#Writing Event Processors">Writing event processors.</a></li>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l0 level1 lfo1;tab-stops:list .5in'><a
     href="#Filling in the application class">Filling in the application class.</a></li>
</ul>

<h1><a name=Classes>The Classes:</a></h1>

<p>The figure below shows the set of classes which interact to analyze data in
SpecTcl.</p>

<p><img border=0 width=583 height=667 id="_x0000_i1027" src="images/spectc1.jpg"></p>

<p>To build a tailored version of SpecTcl you will need to understand aspects
of the following classes:</p>

<table border=0 cellpadding=0 width="100%" style='width:100.0%;mso-cellspacing:
 1.5pt'>
 <tr>
  <td width="17%" style='width:17.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><a href="#CEvent">CEvent</a></p>
  </td>
  <td width="83%" style='width:83.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>The unpacked event adjustable array</p>
  </td>
 </tr>
 <tr>
  <td width="17%" style='width:17.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><a href="#CMySpecTclApp">CMySpecTclApp</a></p>
  </td>
  <td width="83%" style='width:83.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Your derivation of the application base class</p>
  </td>
 </tr>
 <tr>
  <td width="17%" style='width:17.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><a href="#CEventProcessor">CEventProcessor</a></p>
  </td>
  <td width="83%" style='width:83.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Event processors you derive from and register on the
  analyzer.</p>
  </td>
 </tr>
</table>

<h2><a name=CEvent></a>The CEvent adjustable array</h2>

<p>The CEvent class represents an unpacked event.&nbsp; The histogramming
kernel of SpecTcl takes parameters from CEvent objects and histograms them
according to the parameters, histograms and gate applications defined by your
Tcl scripts.&nbsp; The job of analyzing the event stream consists of taking the
incoming event stream apart and filling in a CEvent array with the parameters
relevant to the event.</p>

<h2><a name=CMySpecTclApp></a>The CMySpecTclApp application class/object</h2>

<p>There is one object in the system of type CMySpecTclApp.&nbsp; This object
uses its base class functionality to initialize SpecTcl and to set up the
linkages between the interacting objects which make up a&nbsp; SpecTcl.&nbsp;
CMySpecTclApp is is implemented in the MySpecTclApp.cpp file you receive in the
skeleton distribution.&nbsp; At a minimum, you must modify this class to
register event processors which understand the experimental data and what needs
to be done to it to create a filled in CEvent array.</p>

<h2><a name=CEventProcessor></a>The CEventProcessor you derive event processors
from</h2>

<p>Event analysis in SpecTcl takes the form of an analysis pipeline.&nbsp;
Elements in the pipeline are instances of classes derived from
CEventProcessor.&nbsp; Event processors are registered into the analyzer by the
CMySpecTclApp object through calls to its RegisterEventProcessor member
function.&nbsp; Event processors are executed in the order in which they were
registered.&nbsp; Usually, the first event processor will unpack the raw event
into CEvent, and subsequent element in the pipeline will process this unpacked
event performing e.g. calibrations, validation and physics.&nbsp; The results
of subsequent stages in the pipeline are modifications to unpacked parameters
or the creation of additional 'compiled' pseudo parameters which represent the
event at a higher level of abstraction/meaning.</p>

<p>Event processors may also reject the event by calling the analyzers
AbortEvent() member function.&nbsp; If the event is accepted, its size must be set
by some combination of calls to the analyzer's SetEventSize() and
IncrementEventSize() members.&nbsp; This size allows SpecTcl's analyzer to know
where to find the next event in the buffer so it must be 100% accurate.</p>

<p>The Skeleton software includes a 2-step pipeline.&nbsp; The first step
unpacks a fixed length event.&nbsp; The second step computes a single pseudo
parameter.&nbsp;</p>

<p><a href="#Top">Top</a> <a href="tailoring.htm">Tailoring SpecTcl</a></p>

<h1><a name="Writing_Event_Processors"></a>Writing Event Processors</h1>

<p>Event processors are called in sequence when each event is located in a
physics data buffer.&nbsp; The CEventProcesor member functions are described
below:</p>

<table border=1 cellpadding=0 width="100%" style='width:100.0%;mso-cellspacing:
 1.5pt'>
 <tr>
  <td width="12%" style='width:12.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>Returns</b></p>
  </td>
  <td width="17%" style='width:17.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>Name</b></p>
  </td>
  <td width="27%" style='width:27.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>Parameters</b></p>
  </td>
  <td width="44%" style='width:44.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>Does</b></p>
  </td>
 </tr>
 <tr>
  <td width="12%" style='width:12.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>virtual Bool_t</p>
  </td>
  <td width="17%" style='width:17.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>OnAttach</p>
  </td>
  <td width="27%" style='width:27.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>CAnalyzer&amp; rAnalyzer</p>
  </td>
  <td width="44%" style='width:44.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Any necessary processing when the event processor is registered
  into the analyzer.&nbsp; Returns kfFALSE on failure.</p>
  </td>
 </tr>
 <tr>
  <td width="12%" style='width:12.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>virtual Bool_t&nbsp;</p>
  </td>
  <td width="17%" style='width:17.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>OnBegin&nbsp;</p>
  </td>
  <td width="27%" style='width:27.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>CAnalyzer&amp; rAnalyzer,<br>
  CBufferDecoder&amp; rDecoder</p>
  </td>
  <td width="44%" style='width:44.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Called for a begin run buffer.&nbsp; If kfFALSE is
  returned, then the remainder of the pipeline is aborted.</p>
  </td>
 </tr>
 <tr>
  <td width="12%" style='width:12.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>virtual Bool_t&nbsp;</p>
  </td>
  <td width="17%" style='width:17.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>OnEnd</p>
  </td>
  <td width="27%" style='width:27.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>CAnalyzer&amp; rAnalyzer,&nbsp;<br>
  CBufferDecoder&amp; rBuffer</p>
  </td>
  <td width="44%" style='width:44.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Called for an end run buffer.&nbsp; If kfFALSE is
  returned, then the remainder of the pipeline is aborted.</p>
  </td>
 </tr>
 <tr>
  <td width="12%" style='width:12.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>virtual Bool_t</p>
  </td>
  <td width="17%" style='width:17.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>&nbsp;OnPause</p>
  </td>
  <td width="27%" style='width:27.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>CAnalyzer&amp; rAnalyzer,&nbsp;<br>
  CBufferDecoder&amp; rDecoder</p>
  </td>
  <td width="44%" style='width:44.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Called for a pause run buffer.&nbsp; If kfFALSE is
  returned, then the remainder of the pipeline is aborted.</p>
  </td>
 </tr>
 <tr>
  <td width="12%" style='width:12.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>virtual Bool_t</p>
  </td>
  <td width="17%" style='width:17.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>OnResume</p>
  </td>
  <td width="27%" style='width:27.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>CAnalyzer&amp; rAnalyzer,&nbsp;<br>
  CBufferDecoder&amp; rDecoder</p>
  </td>
  <td width="44%" style='width:44.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Called for a resume run buffer.&nbsp; If kfFALSE is returned,
  then the remainder of the pipeline is aborted.</p>
  </td>
 </tr>
 <tr>
  <td width="12%" style='width:12.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>virtual Bool_t</p>
  </td>
  <td width="17%" style='width:17.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>operator()</p>
  </td>
  <td width="27%" style='width:27.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>const Address_t pEvent,&nbsp;<br>
  CEvent&amp; rEvent,&nbsp;<br>
  CAnalyzer&amp; rAnalyzer,&nbsp;<br>
  CBufferDecoder&amp; rDecoder)&nbsp;</p>
  </td>
  <td width="44%" style='width:44.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Called for each event in a physics buffer.&nbsp; At least
  one element in the pipeline must set the event by calling a combination of
  rAnalyzer.SetEventSize(UInt_t n) and<br>
  rAnalyzer.IncrementeventSize(UInt_t n=1)</p>
  </td>
 </tr>
 <tr>
  <td width="12%" style='width:12.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>virtual Bool_t</p>
  </td>
  <td width="17%" style='width:17.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>OnOther</p>
  </td>
  <td width="27%" valign=top style='width:27.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>UInt_t nType,</p>
  <p class=MsoNormal>CAnalyzer&amp; rAnalyzer,</p>
  <p style='margin:0in;margin-bottom:.0001pt'>CBufferDecoder&amp; rDecoder</p>
  </td>
  <td width="44%" style='width:44.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Called whenever any buffer type not processed by the other
  buffer processing functions in the event processor is encountered.<span
  style="mso-spacerun: yes">&nbsp; </span>This is one way, for example, to get
  called for scaler data.<span style="mso-spacerun: yes">&nbsp; </span>The
  nType parameter is the buffer type code.<span style="mso-spacerun:
  yes">&nbsp; </span>You can use the rDecoder parameter to get the buffer
  contents, buffer body or other things you need to process this buffer.</p>
  </td>
 </tr>
 <tr>
  <td width="12%" style='width:12.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>virtual Bool_t</p>
  </td>
  <td width="17%" style='width:17.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>OnEventSourceOpen</p>
  </td>
  <td width="27%" valign=top style='width:27.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>std::string name</p>
  </td>
  <td width="44%" style='width:44.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Called when SpecTcl attaches a new data source.<span
  style="mso-spacerun: yes">&nbsp; </span>This was introduced with SpecTcl 3.2
  and later.<span style="mso-spacerun: yes">&nbsp; </span>The name is the name
  of the data source, and can have one of several formats:</p>
  <p class=MsoNormal style='margin-left:.5in;text-indent:-.25in;mso-list:l1 level1 lfo2;
  tab-stops:list .5in'><![if !supportLists]>-<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span><![endif]>File: filename &#8211; the event source is a file and the path to
  the filename follows the colon</p>
  <p class=MsoNormal style='margin-left:.5in;text-indent:-.25in;mso-list:l1 level1 lfo2;
  tab-stops:list .5in'><![if !supportLists]>-<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span><![endif]>Pipe from: command &#8211; the event source is a pipe and the
  command feeding event data to SpecTcl is given after the colon.</p>
  <p class=MsoNormal style='margin-left:.5in;text-indent:-.25in;mso-list:l1 level1 lfo2;
  tab-stops:list .5in'><![if !supportLists]>-<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span><![endif]>Tape: device<span style="mso-spacerun: yes">&nbsp; </span>-
  (mostly obsolete), the event source is an ANSI labelled tape with event files
  on it, and the device is given after the colon.</p>
  <p class=MsoNormal style='margin-left:.5in;text-indent:-.25in;mso-list:l1 level1 lfo2;
  tab-stops:list .5in'><![if !supportLists]>-<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span><![endif]>Test Source &#8211; the SpecTcl test data source is being used.</p>
  <p class=MsoNormal style='margin-left:.5in;text-indent:-.25in;mso-list:l1 level1 lfo2;
  tab-stops:list .5in'><![if !supportLists]>-<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span><![endif]>Null &#8211; The null data source (immediate end of file) is being
  used.</p>
  </td>
 </tr>
 <tr>
  <td width="12%" style='width:12.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>virtual Bool_t</p>
  </td>
  <td width="17%" style='width:17.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>OnEventSourceEOF</p>
  </td>
  <td width="27%" valign=top style='width:27.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>
  </td>
  <td width="44%" style='width:44.0%;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Called when an end of file is encountered on the event
  source. Note that if the user attaches to an event source, then attaches to
  another one prior to the end of file, this will not get called
  (OnEventSourceOpen will be called for the second attach however).</p>
  </td>
 </tr>
</table>

<h2><br>
Sample Event processor.</h2>

<p>The event processor definition below is part of the sample provided in the
skeleton.&nbsp; It unpacks fixed length events which are preceded by a self
inclusive word count.</p>

<pre>class CFixedEventUnpacker : public<span style="mso-spacerun: yes">&nbsp; </span>CEventProcessor</pre><pre>{</pre><pre>public:</pre><pre><span style="mso-spacerun: yes">&nbsp; </span>virtual Bool_t operator()(const Address_t pEvent,<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// Only need to override the unpacking</pre><pre><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>CEvent&amp;<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>rEvent,<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// behavior.<span style="mso-spacerun: yes">&nbsp; </span>All other members have</pre><pre><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>CAnalyzer&amp;<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>rAnalyzer,<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// adequate default behavior.</pre><pre><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>CBufferDecoder&amp; rDecoder);</pre><pre>};</pre><pre>Bool_t</pre><pre>CFixedEventUnpacker::operator()(const Address_t pEvent,</pre><pre><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>CEvent&amp;<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>rEvent,</pre><pre><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>CAnalyzer&amp;<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>rAnalyzer,</pre><pre><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>CBufferDecoder&amp; rDecoder)</pre><pre>{</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre><span style="mso-spacerun: yes">&nbsp; </span>// This sample unpacker unpacks a fixed length event which is</pre><pre><span style="mso-spacerun: yes">&nbsp; </span>// preceded by a word count.</pre><pre><span style="mso-spacerun: yes">&nbsp; </span>//</pre><pre><span style="mso-spacerun: yes">&nbsp; </span>CTclAnalyzer&amp;<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>rAna((CTclAnalyzer&amp;)rAnalyzer);<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// needed to call CTclAnalyzer::SetEventSize()</pre><pre><span style="mso-spacerun: yes">&nbsp; </span>UShort_t* p<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>= (UShort_t*)pEvent;<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// The event is made up of UShort_t's.</pre><pre><span style="mso-spacerun: yes">&nbsp; </span>UShort_t<span style="mso-spacerun: yes">&nbsp; </span>nWords = *p++;<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// The first word of the evetn is its size.</pre><pre><span style="mso-spacerun: yes">&nbsp; </span>Int_t<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>i<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>= 1;<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// This is the index of the CEvent of the first</pre><pre><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>//<span style="mso-spacerun: yes">&nbsp; </span>parameter we fill in.</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre><span style="mso-spacerun: yes">&nbsp; </span>// At least one member of the pipeline must tell the analyzer how</pre><pre><span style="mso-spacerun: yes">&nbsp; </span>// many bytes were in the raw event so it knows where to find the</pre><pre><span style="mso-spacerun: yes">&nbsp; </span>// next event.</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre><span style="mso-spacerun: yes">&nbsp; </span>rAna.SetEventSize(nWords*sizeof(UShort_t));<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// Set event size.<span style="mso-spacerun: yes">&nbsp; </span>In Bytes!!!!</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre><span style="mso-spacerun: yes">&nbsp; </span>nWords--;<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// The word count is self inclusive.</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre><span style="mso-spacerun: yes">&nbsp; </span>while(nWords) {<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></pre><pre><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;</span>rEvent[i] = *p++;<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>// Unpack into the event array.</pre><pre><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>nWords--;</pre><pre><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>i++;</pre><pre><span style="mso-spacerun: yes">&nbsp; </span>}</pre><pre><span style="mso-spacerun: yes">&nbsp; </span>return kfTRUE;<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// kfFALSE would abort pipeline.</pre><pre>}</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre>

<p><a href="#Top">Top</a> <a href="tailoring.htm">Tailoring SpecTcl</a></p>

<h1><a name="Filling_in_the_application_class"></a>Filling in the Application
Class</h1>

<p>The CTclApplicationClass must be filled in and instantiated to complete
SpecTcl initialization. At a minimum, one EventProcessor must be registered
into the event pipeline.&nbsp; This section will describe all of the member
functions in the CTclApplication class, when they are called,&nbsp; what they
should do and what the parent's class default behavior is.</p>

<p><a href="#Top">Top</a> <a href="tailoring.htm">Tailoring SpecTcl</a></p>

<p><b>virtual void CreateAnalysisPipeline(CAnalyzer&amp; rAnalyzer)</b></p>

<p>This function is the only one which absolutely has to be coded by you.&nbsp;
All of the others could, in simple cases be left to their default behavior.
This function is the next to the last action performed by the application
initialization.&nbsp; The last action is to source any action scripts that the
user requests (call to SourceFunctionalScripts).&nbsp; By this time essentially
all of SpecTcl is set up.</p>

<p>The programmer must register the event processors which make up the analysis
pipeline.&nbsp; For example:</p>

<pre>static CFixedEventUnpacker Stage1;</pre><pre>static CAddFirst2<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Stage2;</pre><pre>...</pre><pre>void </pre><pre>CMySpecTclApp::CreateAnalysisPipeline(CAnalyzer&amp; rAnalyzer)<span style="mso-spacerun: yes">&nbsp; </span></pre><pre>{ </pre><pre><span style="mso-spacerun: yes">&nbsp;&nbsp;</span>RegisterEventProcessor(Stage1);</pre><pre><span style="mso-spacerun: yes">&nbsp; </span>RegisterEventProcessor(Stage2);</pre><pre>}<span style="mso-spacerun: yes">&nbsp; </span></pre>

<p>The example above declares two event processors, <i>Stage1&nbsp;</i> and <i>Stage2</i>
and registers them in the analysis pipeline.</p>

<p><a href="#Top">Top</a> <a href="tailoring.htm">Tailoring SpecTcl</a></p>

<p><b>virtual void BindTCLVariables(CTCLInterpreter&amp; rInterp)</b></p>

<p>This function is called at the beginning of MySpecTclApp's initialization.
Any tcl variables the user needs can be bound at this time to CTCLVariable
objects.&nbsp; The default behavior is to call
CTclGrammerApp::BindTCLVariables() to bind the variables which SpecTcl uses to
set limits on statically allocated resources (such as DisplayMegabytes), or
initial sizes of dynamically allocated resources (such as ParameterCount).</p>

<p>You may <i>extend</i> the default functionality by adding your own
code..&nbsp; You <i>must not</i> remove the call to CTclGrammerApp::BindTCLVariables()
and expect SpecTcl to work.</p>

<p><a href="#Top">Top</a> <a href="tailoring.htm">Tailoring SpecTcl</a></p>

<p><b>virtual void SourceLimitScripts(CTCLInterpreter&amp; rInterpreter)</b></p>

<p>This function is called right after BindTCLVariables.&nbsp; It is intended
to source scripts which set variable values needed by SpecTcl or your
extensions.&nbsp; By default, this function calls
CTclGrammerApp::SourceLimitScripts() which executes SpecTclInit.tcl&nbsp;&nbsp;
first in the SpecTcl distribution area adn then in your home directory if it
exists.</p>

<p><a href="#Top">Top</a> <a href="tailoring.htm">Tailoring SpecTcl</a></p>

<p><b>void SetLimits()</b></p>

<p>Called after SourceLimitScripts.&nbsp; By now it is assumed that any tcl
variables involved in static limit setting will have been bound
(BindTclVariables) and initialized by user scripts (sourced by
SourceLimitScripts).&nbsp; In this function, if there are static limits which
need be set, or other configurable&nbsp; variables which must be initialized
from Tcl variables, <i>extend</i> this function.&nbsp; Do not delete the call
to CTclGrammerApp::SetLimits() as some critical SpecTcl limits are set by that
call.</p>

<p><a href="#Top">Top</a> <a href="tailoring.htm">Tailoring SpecTcl</a></p>

<p><b>virtual void CreateHistogrammer ()&nbsp;</b></p>

<p>Called immediately after SetLimits. This function is expected to set up a
data sink for the analyzer.&nbsp; The default call,
CTclGrammerApp::CreateHistogrammer() will set up a TclHistogrammer as the data
sink.&nbsp; If desired, this can be overridden and e.g. user specific data
sinks can be registered instead.</p>

<p><a href="#Top">Top</a> <a href="tailoring.htm">Tailoring SpecTcl</a></p>

<p><b>virtual void SelectDisplayer (UInt_t nDisplaySize,&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
CHistogrammer&amp; rHistogrammer)</b></p>

<p>Called after CreateHistogrammer.&nbsp; The nDisplaySize parameter is, if
appropriate to the number of megabytes desired for display memory shared
between the SpecTcl and the displayer.&nbsp; The rHistogrammer parameter is the
histogrammer created in CreateHistogramer.&nbsp;</p>

<p>This function creates a displayer and hooks it to SpecTcl's
histogrammer.&nbsp; The displayer by default is Xamine (via the call to
CTclGrammerApp::SelectDisplayer).&nbsp; This can be overridden by removing that
call and substituting code to generate the user's own displayer.</p>

<p><a href="#Top">Top</a> <a href="tailoring.htm">Tailoring SpecTcl</a></p>

<p><b>virtual void SetupTestDataSource ()</b></p>

<p>Called immediately after SelectDisplayer.&nbsp; The default action is to
call CTclGrammerApp::SetupTestDataSource which in turn sets up a data source to
produced 5 parameter fixed length events with gaussian distributions.&nbsp; If
you don't have your own test data source you can leave this alone.&nbsp; Sample
code for this is shown <a href="samplecode/sample_test_data_source.htm">here</a>.&nbsp;
Otherwise, remove the call to CTclGrammerApp::SetupTestDataSource and add code
to create your own test data source.</p>

<p><a href="#Top">Top</a> <a href="tailoring.htm">Tailoring SpecTcl</a></p>

<p><b>virtual void CreateAnalyzer (CEventSink* pSink)</b></p>

<p>Called immediately after SetupTestDataSource. Creates the data analyzer
object.&nbsp; By default a CTclGrammerApp::CreateAnalyzer is called causeing
a&nbsp; CTclAnalyzer object to be created and the event sink created in
CreateHistogrammer linked to it.&nbsp; The CTclAnalyzer is the standard
analyzer used by SpecTcl, if you have your own analyzer derived from and
extended from the CAnalyzer class, you can create an instance of it instead and
hook it into the system.&nbsp; Do this by removing the call to
CTclGrammerApp::CreateAnalyzer and adding your own code.</p>

<p><a href="#Top">Top</a> <a href="tailoring.htm">Tailoring SpecTcl</a></p>

<p><b>virtual void SelectDecoder (CAnalyzer&amp; rAnalyzer)</b></p>

<p>Called right after CreateAnalyzer. Selects which buffer decoder to use to
process incoming buffers, creates it and attaches it to SpecTcl.&nbsp; The
default code calls CTclGrammerApp::SelectDecoder() which in turn creates a
CNSCLBufferDecoder which is suitable for decoding NSCL data buffers.&nbsp; If
you have data from another data acquisition system, you will need to create
your own CBufferDecoder derived class, instantiate it here, and hook it into
the system.&nbsp; In order to help you do this, click for the code in <a
href="samplecode/ctclgrammerapp.htm">CTclGrammerApp::SelectDecoder</a></p>

<p><a href="#Top">Top</a> <a href="tailoring.htm">Tailoring SpecTcl</a></p>

<p><b>virtual void AddCommands (CTCLInterpreter&amp; rInterp)</b></p>

<p>Called immediately after SelectDecoder.&nbsp; Adds commands to the TCL
interpreter.&nbsp; The default action is to call
CTclGrammerApp::AddCommands.&nbsp; This call should not be removed as it
registers the standard SpecTcl commands to the Tk/Tcl interpreter.&nbsp; You
may, however extend the interpreter with commands and command packages of your
own.&nbsp;&nbsp; <a href="commands.htm">See here for information about how to
extend the interpreter with user written commands</a>.</p>

<p><a href="#Top">Top</a> <a href="tailoring.htm">Tailoring SpecTcl</a></p>

<p><b>virtual void SetupRunControl ()</b></p>

<p>Called immediately after AddCommands.&nbsp; Sets up the run control system.
The run control system is manipulated by the SpecTcl <a
href="../Commands/start.htm">start</a> and <a href="../Commands/stop.htm">stop</a>
commands.&nbsp; In most cases you will not need to modify the default
code.&nbsp; The default code calls CTclGrammerApp::SetupRunControl which sets
up a run control object suitable for use in the Tc/Tk environment.</p>

<p><a href="#Top">Top</a> <a href="tailoring.htm">Tailoring SpecTcl</a></p>

<p><b>virtual void SourceFunctionalScripts (CTCLInterpreter&amp; rInterp)</b></p>

<p>This function is called last.&nbsp; It provides an opportunity to source
experiment specific Tcl/Tk setup scripts.&nbsp; The default behavior is to call
CTclGrammerApp::SourceFunctionalScripts which in turn runs the SpecTclRC.tcl in
the user's home and&nbsp; current working directories if it exists there.&nbsp;
The attempts to run this file are enclosed in try blocks which silently catch
all exceptions.&nbsp; If you want to source additional functional scripts, then
you may add code to this function.&nbsp; <a
href="samplecode/sourcefunctionalscripts.htm">To see how to do this; see here
for a listing of CTclGrammerApp::SourceFunctionalScripts()</a></p>

<p><a href="#Top">Top</a> <a href="tailoring.htm">Tailoring SpecTcl</a></p>

<p><b>virtual int operator() ()</b></p>

<p>This function is the &quot;Entry point&quot; for the object.&nbsp; It is
called at Tcl initialization.&nbsp; The default operation is to invoke
CTclGrammerApp::operator() which calls the functions described on this page in
the order listed.&nbsp; You may extend this functionality by adding code before
or after this call.&nbsp; It is not a good idea to remove the call to
CTclGrammerApp::operator() since so much of SpecTcl is set up through this
function.</p>

<p><a href="#Top">Top</a> <a href="tailoring.htm">Tailoring SpecTcl</a></p>

<p><a href="../index.htm">SpecTcl Home</a>&nbsp; <a
href="../general_information.htm">General Information</a> <a
href="../users_guide.htm">User Guide</a> <a href="../programmers_guide.htm">Programmer's
Guide</a> <a href="../obtaining_and_installing.htm">Obtaining and Installing</a></p>


<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>


<p>Last Modified: <!--webbot bot="Timestamp" s-type="EDITED"
s-format="%B %d, %Y" startspan -->October 28, 2003<!--webbot bot="Timestamp" endspan i-checksum="30351" -->by:
<a href="mailto:fox@nscl.msu.edu">fox@nscl.msu.edu</a><br>
<span style='font-size:10.0pt'>© Copyright NSCL 1999, All rights reserved</span></p>

</div>

</body>

</html>
