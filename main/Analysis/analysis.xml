<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                      "file:///usr/share/xml/docbook/schema/dtd/4.5/docbookx.dtd
"
>
<book>
    <bookinfo>
      <title>SpecTcl Analysis Framework (v4.0+).</title>
      <author><firstname>Ron</firstname><surname>Fox</surname></author>
      <revhistory>
          <revision>
             <revnumber>1.0</revnumber>
             <date>?Date written?</date>
             <authorinitials>RF</authorinitials>
             <revremark>Original Release</revremark>
          </revision>
      </revhistory>
    </bookinfo>
    <chapter>
        <title>Introduction</title>
        <para>
            SpecTcl's event processor framework and its
            <methodname>operator()</methodname> method are adequate when all you
            want to do is analyze your event data.  Sometimes, however, you need
            to be able to extract data from other event types.
            The SpecTcl analysis framework allows you to do this.
            This document shows you how to use it and provides reference material
            for you to use when programming with it.
        </para>
        <para>
            The remainder of this document:
        </para>
        <itemizedlist>
            <listitem><para>
                Provides an overiew of the classes in the anlaysis framework and
                how they fit together.
            </para></listitem>
            <listitem><para>
                Works through a simple annotated example.
            </para></listitem>
            <listitem><para>
                Provides manpages for the classes that make up the framework.
            </para></listitem>
        </itemizedlist>
    </chapter>
    <chapter>
        <title>Class Overview.</title>
        <para>
            Two classes make up the analysis framework.
        </para>
        <para>
              The first,
            <classname>CAnalysisBase</classname> provides a base class
            that you must extend to perform your application specific actions.
            This class consists of a set of callback functions.  When hooked
            into SpecTcl, these callbacks get called when the appropriate event
            types are seen.  
        </para>
        <para>
            The data in each event type is marshalled from the
            event into callback parameters.    This allows you to write your
            analysis indepedent of the format of the data being analyzed.
        </para>
        <para>
            The second class is a special event processor,
            <classname>CAnalysisEventProcessor</classname>.  This event processor
            is constructed with an instance of a <classname>CAnalysisBase</classname>
            derived class.  When registered into the SpecTcl analysis pipeline,
            it performs the parameter marshalling and method dispatching for its
            analysis object.
        </para>
        <para>
            The callback methods of <classname>CAnalysisBase</classname>
            specify a client data parameter.  When used with the
            <classname>CAnalysisEventProcessor</classname>, this
            is a struct that includes a pointer to arbitrary data and a pointer
            to the <classname>CAnalysisEventProcessor</classname> instance.
            This allows user written code access to facilities exported
            by the event processor.  It also allows additional data to
            be imported into the users's code.
        </para>
    </chapter>
    <chapter>
        <title>A worked Example</title>
        <para>
            This chapter examines a complete, though simple and worthless
            example.  You will see:
        </para>
        <itemizedlist>
            <listitem><para>
                A class derived from <classname>CAnalysisBase</classname>
            </para></listitem>
            <listitem><para>
                The registration of a <classname>CAnalysisEventProcessor</classname>
                in <filename>MySpecTclApp.cpp</filename> that uses our analysis class.
            </para></listitem>
            <listitem><para>
                    The modifications required to the Makefile to build this all with
                SpecTcl.
            </para></listitem>
        </itemizedlist>
        <section>
            <title>Deriving a class from <classname>CAnalysisBase</classname></title>
            <para>
                Let's have a look first at the header for our class derived from
                <classname>CAnalysisBase</classname>:
            </para>
            <example>
                <title><classname>TestAnalyzer.h</classname></title>
                <programlisting>
#include &lt;CAnalysisBase.h&gt;                               <co id='hdr.include_base' />


class TestAnalyzer : public CAnalysisBase                      <co id='hdr.derivation' />
{
public:
    virtual void onStateChange(                                <co id='hdr.onstatechange' />
        StateChangeType type, int runNumber, time_t absoluteTime, float runTime,
        std::string title, void* clientData
    );
    virtual void onScalers(                                    <co id='hdr.onscalers' />
        time_t absoluteTime, float startOffset, float endOffset,
        std::vector&lt;unsigned&gt; scalers, bool incremental, void* clientData
    );

    virtual void onStringLists(                                <co id='hdr.onstringlist' />
        StringListType type, time_t absoluteTime, float runTime,
        std::vector&lt;std::string&gt; strings, void* clientData
    );

    virtual unsigned onEvent(void* pEvent, void* clientData);  <co id='hdr.onevent' />
};

                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='hdr.include_base'>
                    <para>
                        This <literal>#include</literal> includes a definition
                        of the <classname>CAnalysisBase</classname> base class.
                        Note that the <classname>CAnalysisBase</classname>
                        is not an abstract base name. It provides suitable
                        default implementations for its interface.
                        You only need to override the methos you
                        actually need to implement.
                    </para>
                </callout>
                <callout arearefs='hdr.derivation'>
                    <para>
                        The <classname>TestAnalyzer</classname> class here
                        is defined as derived from the
                        <classname>CAnalysisBase</classname> class.
                    </para>
                </callout>
                <callout arearefs='hdr.onstatechange'>
                    <para>
                        The <methodname>onStateChange</methodname> method is
                        a callback that will be invoked whenever a run
                        state transition event is detected.  Run state
                        transitions include events such as data acquisition
                        starting or stopping, pausing or resuming.
                    </para>
                </callout>
                <callout arearefs='hdr.onscalers'>
                    <para>
                        The <methodname>onScalers</methodname> method is
                        invoked whenever a scaler event is detected.
                        Scaler events contain data from counters that are
                        periodically read throughout the run.
                    </para>
                </callout>
                <callout arearefs='hdr.onstringlist'>
                    <para>
                        The <methodname>onStringList</methodname> method is
                        invoked whenever an event that contains a list
                        of strings is encountered.
                    </para>
                </callout>
                <callout arearefs='hdr.onevent'>
                    <para>
                        <methodname>onEvent</methodname> is invoked for physics
                        events.  While you can use this, it is recommended
                        that analysis that needs to work with physics events
                        be in classes that are derived directly from
                        <classname>CEventProcessor</classname>.
                    </para>
                </callout>
            </calloutlist>
            <para>
                Our implementation of this class is just going to output the
                key values passed in to each callback:
            </para>
            <example>
                <title><classname>TestAnalyzer.cpp</classname></title>
                <programlisting>
#include "TestAnalyzer.h"                                       <co id='cpp.include' />
#include &lt;iostream&gt;
#include &lt;time.h&gt;
#include &lt;stdint.h&gt;

void TestAnalyzer::onStateChange(                              <co id='cpp.onstatechange' />
        StateChangeType type, int runNumber, time_t absoluteTime, float runTime,
        std::string title, void* clientData
    )
{
  std::cerr &lt;&lt; "--------------------\n";
  std::cerr &lt;&lt; "State change:  " &lt;&lt; type &lt;&lt; std:: endl;
  std::cerr &lt;&lt; "  Run:    " &lt;&lt; runNumber &lt;&lt; " Title: " &lt;&lt; title &lt;&lt; std::endl;
  std::cerr &lt;&lt; runTime &lt;&lt;  " seconds into the run\n";
  std::cerr &lt;&lt; " At " &lt;&lt; ctime(&amp;absoluteTime);

}

void TestAnalyzer::onScalers(                                  <co id='cpp.onscalers' />
        time_t absoluteTime, float startOffset, float endOffset,
        std::vector&lt;unsigned&gt; scalers, bool incremental, void* clientData
    )
{
  std::cerr &lt;&lt; "------------------------\n";          
  std::cerr &lt;&lt; "Scalers at : " &lt;&lt; ctime(&amp;absoluteTime) &lt;&lt; std::endl;
  std::cerr &lt;&lt; "Starting:  " &lt;&lt; startOffset &lt;&lt; " ending " &lt;&lt; endOffset &lt;&lt; " seconds into the run\n";
  for(int i =0; i &lt; scalers.size(); i++) {
    std::cerr &lt;&lt;  i &lt;&lt; " : " &lt;&lt; scalers[i] &lt;&lt; std::endl;
  }

}

void TestAnalyzer::onStringLists(                             <co id='cpp.onstringlists' />
        StringListType type, time_t absoluteTime, float runTime,
        std::vector&lt;std::string&gt; strings, void* clientData
      )
{
  std::cerr &lt;&lt; "-------------------------\n";
  std::cerr &lt;&lt; "String list at : " &lt;&lt; ctime(&amp;absoluteTime) &lt;&lt; "(" &lt;&lt; runTime &lt;&lt; " seconds in\n";
  for (int i = 0; i &lt; strings.size(); i++) {
    std::cerr &lt;&lt; strings[i] &lt;&lt; std::endl;
  }
}


unsigned 
TestAnalyzer::onEvent(void* pEvent, void* clientData)       <co id='cpp.onevent' />
{
  /* 
   * A word of explanation:
   *    10.x+ ignore the return value. only 8.x- pay attention to ti.
   *    for 8.x- the size is uint16_t so this code should be ok.
   */
  uint16_t* sizeptr = reinterpret_cast&lt;uint16_t*&gt;(pEvent);

  return *sizeptr * sizeof(uint16_t);
}

                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='cpp.include'>
                    <para>
                        Class implementations need to have their definitions
                        visible to the compiler.  This <literal>#include</literal>
                        does that.
                    </para>
                </callout>
                <callout arearefs='cpp.onstatechange'>
                    <para>
                        This method is called when a state change event is seen.
                        The method outputs the key information about the event
                        to stderr.  Two parameters are worth mention.
                    </para>
                    <para>
                        <parameter>type</parameter> is actually an enumerated type
                        of <type>CAnalysisBase::StateChangeType</type>.  See the
                        reference pages on <classname>CAnalysisBase</classname>
                        for information about the values this parameter can take.
                    </para>
                    <para>
                        <parameter>clientData</parameter> is data that is
                        passed without interpretation to the method.  Making this
                        a <type>void*</type> allows this framework to be used
                        outside of SpecTcl.  Within SpecTcl, however, this is actually
                        a pointer to a <type>CAnalysisEventProcessor::ClientData</type>
                        structure which contains: <structfield>s_pUserData</structfield>,
                        user data passed in at the event processor's construction time
                        and <structfield>s_pCaller</structfield>, a pointer to the
                        object that invoked this method (a
                        <classname>CAnalysisEventProcessor</classname> object).
                    </para>
                </callout>
                <callout arearefs='cpp.onscalers'>
                    <para>
                        Called when a scaler event is received.  The importand
                        parameters are printed. Note that the scalers have been
                        marshalled into a vector and the time into the run
                        is a float in order to allow for sub-second time
                        resolution (via the offset divisor field).  Again,
                        the strenght of this framework is that you don't need
                        to know about the divisor, or even if the data taken
                        includes it.  All of that is taken care of by the
                        <classname>CAnalysisEventProcessor</classname> behind
                        the scenes.
                    </para>
                </callout>
                <callout arearefs='cpp.onstringlists'>
                    <para>
                        Processes events that consist of string lists. Again
                        an enumerated type: <type>CAnalysisBase::StringListType</type>
                        indicates the type of the event.  The method prints out the
                        key parameters and the strings  The strings have been
                        marshalled into a <type>std::vector</type> so that you
                        don't need to worry about the existence of padding
                        (NSCDAQ-8.x) or lack of it (NSCLDAQ-10.0 and later).
                    </para>
                </callout>
                <callout arearefs='cpp.onevent'>
                    <para>
                        This is called for each physics event.  For ring item based
                        DAQ versions (e.g. 10.0 and later), the return value is
                        ignored for earlier versions, it is necessary for the
                        method to return the number of bytes in the event.
                    </para>
                    <para>
                        This can be problematic.  Normally the first 16 bit
                        word of an event is the number of 16 bit words
                        in the event, including this count.  If, however
                        the data were acquired using a VM-USB or CC-USB
                        controller, this word count is not self inclusive.
                    </para>
                </callout>
            </calloutlist>
        </section>
        <section>
            <title>Adding a <classname>CAnalysisEventProcessor</classname> to the processing pipeline</title>
            <para>
                In the previous section we wrote a class that was derived from
                <classname>CAnlaysisBase</classname>.  In order to connect
                this code to the stream of events SpecTcl analyzes, we must:
            </para>
            <itemizedlist>
                <listitem><para>Create an instance (object) of our class</para></listitem>
                <listitem><para>
                    Construct a <classname>CAnalysisEventProcessor</classname>
                    object that has our analysis object bound to it.
                </para></listitem>
                <listitem><para>
                    Add our <classname>CAnalysisEventProcessor</classname>
                    to the SpecTcl analysis pipeline.
                </para></listitem>
            </itemizedlist>
            <para>
                In this section you'll see fragments of code from
                <filename>MySpecTclApp.cpp</filename> that show
                how perform these operations.
            </para>
            <section>
                <title>Importing class definitions</title>
                <para>
                    In order to operate with our analysis class and the
                    <classname>CAnalysisEventProcessor</classname> class,
                    we must import the definitions  of these classes into
                    <filename>MySpecTclApp.cpp</filename>.
                    Therefore, in the section of <literal>#include</literal>
                    duirectives, the following lines must be added:
                </para>
                <informalexample>
                    <programlisting>
#include &lt;TreeParameter.h&gt;
                                // Add the lines below:
#include "TestAnalyzer.h"
#include &lt;CAnalysisEventProcessor.h&gt;
                    </programlisting>
                </informalexample>

            </section>
            <section>
                <title>Modifying <methodname>CreateAnalysisPipeline</methodname></title>
                    <para>
                        The method <methodname>CreateAnalysisPipeline</methodname>
                        in <filename>MySpecTclApp.cpp</filename> is where SpecTcl's
                        analysis pipeline is set up.  Adding the line below to that
                        method's body will construct the analysis object, the event processotr
                        and add the pipeline element:
                    </para>
                    <informalexample>
                        <programlisting>
    RegisterEventProcessor(*(new CAnalysisEventProcessor(new TestAnalyzer, 0)));
                        </programlisting>
                    </informalexample>
                    <para>
                        It's best to untangle this line from the inside out.
                        <literal>new TestAnalyzer</literal> creates an instance
                        of our analyzer.  This is the first parameter to the
                        constructor of <classname>CAnalysisEventProcessor</classname>.
                    </para>
                    <para>
                        The second parameter <literal>0</literal> is any arbitrary
                        data that we want passed to each method call of the
                        <classname>TestAnalyzer</classname> object.  In our case
                        we don't want any data passed.   The type of this parameter
                        is a <type>void*</type> allowing us to pass pointers to
                        objects, structs or any other complex data we need.
                    </para>
                    <para>
                        Therefore:
                        <literal>new CAnalysisEventProcessor(new TestAnalyzer, 0))</literal>
                        Creates a new <classname>CAnalysisEventProcessor</classname> binding
                        an instance of our <classname>TestAnalyzer</classname> to it.
                        That object will be the object whose callback methods will
                        be invoked by the new <classname>CAnalysisEventProcessor</classname>
                        object.
                    </para>
                    <para>
                        Finally, all of this is wrapped in a call to
                        <methodname>RegisterEventProcessor</methodname> which adds the
                        new <classname>CAnalysisEventProcessor</classname> to the end
                        of the analysis pipeline.
                        <methodname>RegisterEventProcessor</methodname> expects a reference
                        to an event processor hence the <literal>*</literal> in the
                        parameter.
                    </para>
                    <para>
                        We are creating an anonymous (un-named) event processor.  We
                        could also add a string parameter to the call to
                        <methodname>RegisterEventProcessor</methodname> to name it
                        allowing it to be located via the SpecTcl API class e.g.:
                    </para>
                    <informalexample>
                        <programlisting>
    RegisterEventProcessor(
        *(new CAnalysisEventProcessor(new TestAnalyzer, 0)), "TestAnalysis"
    );
                        </programlisting>
                    </informalexample>

            </section>
        </section>
        <section>
            <title>Modifying the <filename>Makefile</filename></title>
            <para>
                Having written our analyzer and ensured that it is connected
                to any data stream that SpecTcl analyzes, we need to modify
                the <filename>Makefile</filename> to ensure that our
                analyzer is built into our tailored SpecTcl.
                This is done by simply adding an entry to the
                <literal>OBJECTS</literal> macro definition line
                making that line look like:
            </para>
            <informalexample>
                <programlisting>
OBJECTS=MySpecTclApp.o TestAnalyzer.o
                </programlisting>
            </informalexample>
        </section>
    </chapter>
    <part>
        <title>
            Reference Information
        </title>
        <partintro>
            <para>
                This part of the document provides reference pages
                for the
                <classname>CAnalysisBase</classname> and
                <classname>CAnalysisEventProcessor</classname>
                classes.
            </para>
        </partintro>
        <refentry id="spectcl3_canalysisbase">
          <refentryinfo>
            <author>
                <personname>
                    <firstname>Ron</firstname>
                    <surname>Fox</surname>
                </personname>
            </author>
            <productname>NSCLSpecTcl</productname>
            <productnumber></productnumber>
          </refentryinfo>
          <refmeta>
             <refentrytitle id="spectcl3_canalysisbase_title">CAnalysisBase</refentrytitle>
             <manvolnum>3spectcl</manvolnum>
                 <refmiscinfo class='empty'></refmiscinfo>
          </refmeta>
          <refnamediv>
             <refname>CAnalysisBase</refname>
             <refpurpose>Base class for custom analyzers</refpurpose>
          </refnamediv>
          
          <refsynopsisdiv>
           <synopsis>
        #include &lt;CAnalysisBase.h&gt;
               class <ooclass><classname>CAnalysisBase</classname></ooclass>
        {
        public:
            typedef <type>StateChangeType</type>;
            
            typedef <type>StringListType</type>;
            
        public:
            <methodsynopsis>
                <modifier>virtual </modifier>
                <type>void </type>
                <methodname>onStateChange </methodname>
                <methodparam>
                    <modifier></modifier><type>StateChangeType </type>
                        <parameter>type</parameter>
                </methodparam>
                <methodparam>
                    <modifier></modifier><type>int </type>
                        <parameter>runNumber</parameter>
                </methodparam>
                <methodparam>
                    <modifier></modifier><type>time_t </type>
                        <parameter>absoluteTime</parameter>
                </methodparam>
                <methodparam>
                    <modifier></modifier><type>float </type>
                        <parameter>runTime</parameter>
                </methodparam>
                <methodparam>
                    <modifier></modifier><type>std::string </type>
                        <parameter>title</parameter>
                </methodparam>
                <methodparam>
                    <modifier></modifier><type>void* </type>
                        <parameter>clientData</parameter>
                </methodparam>
                <exceptionname>CBaseClassException::NonFatalException</exceptionname>
                <exceptionname>CBaseClassException::FatalException</exceptionname>
                <modifier></modifier>
            </methodsynopsis>  
            <methodsynopsis>
                <modifier>virtual </modifier>
                <type>void </type>
                <methodname>onScalers</methodname>
                <methodparam>
                    <modifier></modifier><type>time_t </type>
                        <parameter>absoluteTime</parameter>
                </methodparam>
                <methodparam>
                    <modifier></modifier><type>float </type>
                        <parameter>startOffset</parameter>
                </methodparam>
                <methodparam>
                    <modifier></modifier><type>float </type>
                        <parameter>endOffset</parameter>
                </methodparam>
                <methodparam>
                    <modifier></modifier><type>std::vector&lt;unsigned&gt; </type>
                        <parameter>scalers</parameter>
                </methodparam>
                <methodparam>
                    <modifier></modifier><type>bool </type>
                        <parameter>incremental</parameter>
                </methodparam>
                <methodparam>
                    <modifier></modifier><type>void* </type>
                        <parameter>clientData</parameter>
                </methodparam>
                
                <exceptionname>CBaseClassException::NonFatalException</exceptionname>
                <exceptionname>CBaseClassException::FatalException</exceptionname>
                <modifier></modifier>
            </methodsynopsis>  
            <methodsynopsis>
                <modifier>virtual </modifier>
                <type>void </type>
                <methodname>onStringLists</methodname>
                <methodparam>
                    <modifier></modifier><type>StringListType </type>
                        <parameter>type</parameter>
                </methodparam>
                <methodparam>
                    <modifier></modifier><type>time_t </type>
                        <parameter>absoluteTime</parameter>
                </methodparam>
                <methodparam>
                    <modifier></modifier><type>float </type>
                        <parameter>runTime </parameter>
                </methodparam>
                <methodparam>
                    <modifier></modifier><type>std::vector&lt;std::string&lt; </type>
                        <parameter>strings</parameter>
                </methodparam>
                <methodparam>
                    <modifier></modifier><type>void* </type>
                        <parameter>clientData</parameter>
                </methodparam>
                
                <exceptionname>CBaseClassException::NonFatalException</exceptionname>
                <exceptionname>CBaseClassException::FatalException</exceptionname>
                <modifier></modifier>
            </methodsynopsis>  
            <methodsynopsis>
                <modifier>virtual </modifier>
                <type>unsigned </type>
                <methodname>onEvent</methodname>
                <methodparam>
                    <modifier></modifier><type>void*</type>
                        <parameter> pEvent</parameter>
                </methodparam>
                <methodparam>
                    <modifier></modifier><type>void* </type>
                        <parameter>clientData</parameter>
                </methodparam>
                
                <exceptionname>CBaseClassException::NonFatalException</exceptionname>
                <exceptionname>CBaseClassException::FatalException</exceptionname>
                <modifier></modifier>
            </methodsynopsis>                      
        };
           </synopsis>
          </refsynopsisdiv>
          <refsect1>
             <title>DESCRIPTION</title>
             <para>
                <classname>CAnalysisBase</classname> is the base class for
                custom analyzer classes you write.  It defines  a set of
                virtual methods that are called back as events of specific types are
                encountered.  Reasonable default implementations are provided
                for each of these methods. 
             </para>
             <para>
                Normally, to perform custom analysis on non-physics events, you will
                derive a class from <classname>CAnalysisBase</classname> overriding
                the methods that respond to the event types you want to analyze.
                See also
                <link linkend='spectcl3_canalysiseventprocessor'
                      endterm='spectcl3_canalysiseventprocessor_title' />
                for information about the class that normally performs these
                callbacks.
             </para>
             <para>
                While this document describes the use of
                <classname>CAnalysisBase</classname> in SpecTcl it is certainly
                possible to call objects of this type back from other analysis
                frameworkds (e.g. a batch event file processor).
             </para>
          </refsect1>
          <refsect1>
             <title>
            METHODS
             </title>
             <variablelist>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual </modifier>
                            <type>void </type>
                            <methodname>onStateChange </methodname>
                            <methodparam>
                                <modifier></modifier><type>StateChangeType </type>
                                    <parameter>type</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier></modifier><type>int </type>
                                    <parameter>runNumber</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier></modifier><type>time_t </type>
                                    <parameter>absoluteTime</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier></modifier><type>float </type>
                                    <parameter>runTime</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier></modifier><type>std::string </type>
                                    <parameter>title</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier></modifier><type>void* </type>
                                    <parameter>clientData</parameter>
                            </methodparam>
                            <exceptionname>CBaseClassException::NonFatalException</exceptionname>
                            <exceptionname>CBaseClassException::FatalException</exceptionname>
                            <modifier></modifier>
                        </methodsynopsis>  
                    </term>
                    <listitem>
                        <para>
                            Called in response to events that indicate a change
                            in run state was performed.  The
                            <parameter>type</parameter> parameter
                            describes the state change.  See
                            <literal>PUBLIC VARIABLES, TYPES and CONSTANTS</literal>
                            for information about its <type>StateChangeType</type>
                            data type.
                        </para>
                        <para>
                            <parameter>runNumber</parameter> is set to the
                            value of the run number at the time of the state
                            change.  <parameter>absoluteTime</parameter>
                            is a <type>time_t</type> that represents the
                            time of day at which the transition occured.
                            If the underlying event structure is not able
                            to provide this the value of
                            <parameter>absoluteTime</parameter> will be
                            <literal>0</literal>
                        </para>
                        <para>
                            <parameter>runTime</parameter> is the elapsed time into a run at
                            which the state change occured (naturally for begin
                            run events this is <literal>0.0</literal>).  If the
                            underlying event structure cannot supply this information
                            <parameter>runTime</parameter> is set to <literal>-1.0</literal>
                        </para>
                        <para>
                            <parameter>title</parameter> is the title of the run.
                        </para>
                        <para>
                            <parameter>clientData</parameter> is additional data
                            that is passed to the callback.  The contents of this
                            depend on the caller.  See
                            <link linkend='spectcl3_canalysiseventprocessor'
                                  endterm='spectcl3_canalysiseventprocessor_title' />
                            for information about what this parameter means when
                            objects of this class are hooked into SpecTcl's
                            analysis pipeline.
                        </para>
                        <para>
                            See
                            <literal>PUBLIC VARIABLES, TYPES and CONSTANTS</literal>
                            for information about the
                            <classname>NonFatalException</classname> and
                            <classname>FatalException</classname> exception
                            classes this method can throw.
                        </para>
                    </listitem>
                    
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual </modifier>
                            <type>void </type>
                            <methodname>onScalers</methodname>
                            <methodparam>
                                <modifier></modifier><type>time_t </type>
                                    <parameter>absoluteTime</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier></modifier><type>float </type>
                                    <parameter>startOffset</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier></modifier><type>float </type>
                                    <parameter>endOffset</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier></modifier><type>std::vector&lt;unsigned&gt; </type>
                                    <parameter>scalers</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier></modifier><type>bool </type>
                                    <parameter>incremental</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier></modifier><type>void* </type>
                                    <parameter>clientData</parameter>
                            </methodparam>
                            
                            <exceptionname>CBaseClassException::NonFatalException</exceptionname>
                            <exceptionname>CBaseClassException::FatalException</exceptionname>
                            <modifier></modifier>
                        </methodsynopsis>  
                    </term>
                    <listitem>
                        <para>
                            Called when a scaler event is encountered in the
                            input event stream.  <parameter>absoluteTime</parameter>,
                            where supported by the event format is the absolute
                            time at which the scaler event was generated.  If
                            this is not supported, <literal>0</literal> is
                            supplied instead.
                        </para>
                        <para>
                            <parameter>startOffset</parameter> and
                            <parameter>endOffset</parameter> are the number of seconds
                            into the run at which the scaler event was generated.
                            Note that for NSCLDAQ-11.0 and later, this may not be an
                            integer.
                        </para>
                        <para>
                            <parameter>scalers</parameter> is a vector of the
                            scaler values.  <parameter>incremental</parameter>
                            is <literal>true</literal> if scalers are reset as
                            they are read and <literal>false</literal> if they
                            are not.
                        </para>
                        <para>
                            As with all of these methods <parameter>clientData</parameter>
                            is some additional framework dependent data passed to the
                            method by the callsr.
                        </para>
                        <para>
                            See
                            <literal>PUBLIC VARIABLES, TYPES and CONSTANTS</literal>
                            for information about the
                            <classname>NonFatalException</classname> and
                            <classname>FatalException</classname> exception
                            classes this method can throw.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual </modifier>
                            <type>void </type>
                            <methodname>onStringLists</methodname>
                            <methodparam>
                                <modifier></modifier><type>StringListType </type>
                                    <parameter>type</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier></modifier><type>time_t </type>
                                    <parameter>absoluteTime</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier></modifier><type>float </type>
                                    <parameter>runTime </parameter>
                            </methodparam>
                            <methodparam>
                                <modifier></modifier><type>std::vector&lt;std::string&lt; </type>
                                    <parameter>strings</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier></modifier><type>void* </type>
                                    <parameter>clientData</parameter>
                            </methodparam>
                            
                            <exceptionname>CBaseClassException::NonFatalException</exceptionname>
                            <exceptionname>CBaseClassException::FatalException</exceptionname>
                            <modifier></modifier>
                        </methodsynopsis>  
                    </term>
                    <listitem>
                        <para>
                            Called when an event item that contains a list of
                            strings is encountered in the input stream.
                            The <parameter>type</parameter> parameter
                            describes the type of string list event that was
                            encountered.
                            See <literal>PUBLIC VARIABLES, TYPES and CONSTANTS</literal>
                            for information about the values that can
                            be assigned the <type>StringListType</type> data
                            type.
                        </para>
                        <para>
                            absoluteTime is the absolute time at which the
                            event was created.  If the underlying event structure
                            does not support providing this, the value will be
                            <literal>0</literal>
                        </para>
                        <para>
                            <parameter>runTime</parameter> is the number of
                            seconds in to the run at which this event was created.
                            If the underlying event structure does not support
                            providing this, the value will be
                            <literal>-1.0</literal>.
                        </para>
                        <para>
                            <parameter>strings</parameter> is a vector containing
                            the strings in the event, in the order in which they
                            occur.  The format of these strings will depend on
                            the value of the <parameter>type</parameter> parameter.
                            The format of these strings has remained unchanged
                            from NSCLDAQ-8.0 at which time these events were
                            introduced through NSCLDAQ-11.0 which is the
                            current version at the time this document
                            was written.
                        </para>
                        <para>
                            As with all of these methods <parameter>clientData</parameter>
                            is some additional framework dependent data passed to the
                            method by the callsr.
                        </para>
                        <para>
                            See
                            <literal>PUBLIC VARIABLES, TYPES and CONSTANTS</literal>
                            for information about the
                            <classname>NonFatalException</classname> and
                            <classname>FatalException</classname> exception
                            classes this method can throw.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual </modifier>
                            <type>unsigned </type>
                            <methodname>onEvent</methodname>
                            <methodparam>
                                <modifier></modifier><type>void*</type>
                                    <parameter> pEvent</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier></modifier><type>void* </type>
                                    <parameter>clientData</parameter>
                            </methodparam>
                            
                            <exceptionname>CBaseClassException::NonFatalException</exceptionname>
                            <exceptionname>CBaseClassException::FatalException</exceptionname>
                            <modifier></modifier>
                        </methodsynopsis> 
                    </term>
                    <listitem>
                        <para>
                            Called when physics events are encountered. This method must
                            returnt he number of bytes in that event.  The
                            default method is correct for all data that does
                            not come from a VM-USB or CC-USB controller.
                            For those controllers, <literal>2</literal> must
                            be added to the value from the base class.
                        </para>
                        <para>
                            Note that the return value is only relevant for
                            NSCLDAQ versions less than 10.0 after which the
                            framing envelope for the event provides sufficient
                            information to compute the event size properly.
                        </para>
                        <para>
                            <parameter>pEvent</parameter> points to the data
                            that is in the body of the event.
                        </para>
                        <para>
                            As with all of these methods <parameter>clientData</parameter>
                            is some additional framework dependent data passed to the
                            method by the callsr.
                        </para>
                        <para>
                            See
                            <literal>PUBLIC VARIABLES, TYPES and CONSTANTS</literal>
                            for information about the
                            <classname>NonFatalException</classname> and
                            <classname>FatalException</classname> exception
                            classes this method can throw.
                        </para>
                    </listitem>
                </varlistentry>
                                      
             </variablelist>
          </refsect1>
           <refsect1>
              <title>PUBLIC VARIABLES, TYPES and CONSTANTS</title>
              <para>
                The <classname>CAnalysisBase</classname> class defines four data
                types:
              </para>
              <refsect2>
                <title>CAnalysisBase::StateChangeType</title>
                <para>
                    This data type is an enumerated type which defines
                    the values that the <parameter>type</parameter>
                    parameter of <methodname>onStateChange</methodname>
                    can take:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>Begin</literal></term>
                        <listitem>
                            <para>
                                Indicates the state change is describing a
                                start of data taking for a new run.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>End</literal></term>
                        <listitem>
                            <para>
                                Indicates the state change describes the
                                permanent end of data taking for an existing
                                run.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>Pause</literal></term>
                        <listitem>
                            <para>
                                Indicates that the state change describes a
                                temporary pause in data taking for a run.
                                This can be followed immediately by a state
                                change for type=<literal>End</literal>
                                or type=<literal>Resume</literal>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>Resume</literal></term>
                        <listitem>
                            <para>
                                Indicates that the state change describes a
                                resumption of data taking for a paused run.
                            </para>
                        </listitem>
                    </varlistentry>
                    
                </variablelist>
              </refsect2>
              <refsect2>
                <title>CAnalysisBase::StringListType</title>
                <para>
                    Since NSCLDAQ-8.0, readout software can emit events
                    that consist of a list of strings.  There are several
                    types of string list events that can be emitted
                    and this type defines the values that the
                    <parameter>type</parameter> parameter for
                    <methodname>onStringLists</methodname> can be
                    given:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>PacketTypes</literal></term>
                        <listitem>
                            <para>
                                Events can be organized as a hierarchical
                                set of documented packets.  Documented
                                packets are wrapped in a header
                                that contains an inclusive size and
                                a type.
                            </para>
                            <para>
                                When you use packets in your event
                                structure it is easier to combine detector
                                subystems in a single Readout/SpecTcl analysis
                                because event processors that need to unpack
                                raw data can easily look only at the parts of
                                the raw event they are written to unpack while
                                ignoring the parts they are not.
                            </para>
                            <para>
                                This type of string list event provides
                                textual documentation of the types of packets
                                to expect in events as well as their version
                                number and creation dates.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>MontitoredVariables</term>
                        <listitem>
                            <para>
                                Since NSCLDAQ-8.2 some versions of the Readout
                                framework supported the ability to define
                                Tcl variables that were periodically written
                                to the event stream as a series of
                                Tcl <command>set</command> commands that
                                would reproduce the values of those variables
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>RunVariables</term>
                        <listitem>
                            <para>
                                Run variables are similar to monitored variables,
                                however they are variables that have fixed values
                                for the length of a data taking run (for example
                                the run number).
                            </para>
                        </listitem>
                    </varlistentry>
                    
                </variablelist>
              </refsect2>
              <refsect2>
                <title>CAnalysisBase::NonFatalException</title>
                <para>
                    This exception is derived from
                    <classname>std::runtime_error</classname> and
                    represents an error your analysis code discoveres that
                    is not fatal to the understanding of the event structure.
                    This sort of
                    exception should be caught by the caller and appropriate
                    action taken.
                </para>
                <para>
                    If the caller is a <classname>CAnalysisEventProcessor</classname>,
                    the exception error is output to stderr and the analysis
                    pipeline for this event is aborted.
                </para>
              </refsect2>
              <refsect2>
                <title>CAnalysisBase::FatalException</title>
                <para>
                    This exception is derived from
                    <classname>std::runtime_error</classname> and
                    represents an error your analysis code discoveres that
                    is fatal to the understanding of the event structure.
                    This sort
                    of exception should be caught by the caller and appropriate
                    action taken.
                </para>
                <para>
                    If the caller is a <classname>CAnalysisEventProcessor</classname>,
                    the exception error is output to stderr and the program exits
                    with the status <literal>EXIT_FAILURE</literal>.
                </para>
              </refsect2>
           </refsect1>
        </refentry>
        <refentry id="spectcl3_canalysiseventprocessor">
          <refentryinfo>
            <author>
                <personname>
                    <firstname>Ron</firstname>
                    <surname>Fox</surname>
                </personname>
            </author>
            <productname>NSCLSpecTcl</productname>
            <productnumber></productnumber>
          </refentryinfo>
          <refmeta>
             <refentrytitle id='spectcl3_canalysiseventprocessor_title'>CAnalysisEventProcessor</refentrytitle>
             <manvolnum>3spectcl</manvolnum>
                 <refmiscinfo class='empty'></refmiscinfo>
          </refmeta>
          <refnamediv>
             <refname>CAnalysisEventProcessor</refname>
             <refpurpose>Event processor for the <classname>CAnalysisBase</classname> objects</refpurpose>
          </refnamediv>
          
          <refsynopsisdiv>
           <synopsis>
        #include &lt;CAnalysisEventProcessor.h&gt;
               class <ooclass><classname>CAnalysisEventProcessor </classname></ooclass> : public <classname>CEventProcessor</classname>
        {
        public:
            typedef  <type>ClientData</type>, *<type>pClientData</type>;
            
        
        public:
            <constructorsynopsis>
               <methodname>CAnalysisEventProcessor</methodname>
               <methodparam>
                <modifier></modifier><type>CAnalysisBase* </type>
                    <parameter>pProcessor</parameter>
               </methodparam>
               <methodparam>
                <modifier></modifier><type>void* </type>
                    <parameter>pClientData</parameter>
                    <initializer>0</initializer>
               </methodparam>
               
            </constructorsynopsis>
            <methodsynopsis>
                <modifier>virtual </modifier>
                <type>Bool_t </type>
                <methodname>operator()</methodname>
                <methodparam>
                    <modifier>const </modifier><type>Address_t</type>
                        <parameter> pEvent</parameter>
                </methodparam>
                <methodparam>
                    <modifier></modifier><type>CEvent&amp; </type>
                        <parameter>rEvent, </parameter>
                </methodparam>
                <methodparam>
                    <modifier></modifier><type>CAnalyzer&amp; </type>
                        <parameter>rAnalyzer</parameter>
                </methodparam>
                <methodparam>
                    <modifier></modifier><type>CBufferDecoder&amp; </type>
                        <parameter>rDecoder</parameter>
                </methodparam>
                
                <modifier></modifier>
            </methodsynopsis>  
            <methodsynopsis>
                <modifier>virtual </modifier>
                <type>Bool_t </type>
                <methodname>OnBegin</methodname>
                <methodparam>
                    <modifier></modifier><type>CAnalyzer&amp; </type>
                        <parameter>rAnalyzer</parameter>
                </methodparam>
                <methodparam>
                    <modifier></modifier><type>CBufferDecoder&amp; </type>
                        <parameter>rDecoder</parameter>
                </methodparam>
                
            </methodsynopsis>  
            <methodsynopsis>
                <modifier>virtual </modifier>
                <type>Bool_t </type>
                <methodname>OnEnd</methodname>
                <methodparam>
                    <modifier></modifier><type>CAnalyzer&amp; </type>
                        <parameter>rAnalyzer</parameter>
                </methodparam>
                <methodparam>
                    <modifier></modifier><type>CBufferDecoder&amp; </type>
                        <parameter>rDecoder</parameter>
                </methodparam>
                
            </methodsynopsis>  
            <methodsynopsis>
                <modifier>virtual </modifier>
                <type>Bool_t </type>
                <methodname>OnPause</methodname>
                <methodparam>
                    <modifier></modifier><type>CAnalyzer&amp; </type>
                        <parameter>rAnalyzer</parameter>
                </methodparam>
                <methodparam>
                    <modifier></modifier><type>CBufferDecoder&amp; </type>
                        <parameter>rDecoder</parameter>
                </methodparam>
                
            </methodsynopsis>  
            <methodsynopsis>
                <modifier>virtual </modifier>
                <type>Bool_t </type>
                <methodname>OnResume</methodname>
                <methodparam>
                    <modifier></modifier><type>CAnalyzer&amp; </type>
                        <parameter>rAnalyzer</parameter>
                </methodparam>
                <methodparam>
                    <modifier></modifier><type>CBufferDecoder&amp; </type>
                        <parameter>rDecoder</parameter>
                </methodparam>
                
            </methodsynopsis>  
            <methodsynopsis>
                <modifier>virtual </modifier>
                <type>Bool_t </type>
                <methodname>OnOther</methodname>
                <methodparam>
                    <modifier></modifier><type>UInt_t </type>
                        <parameter>nType</parameter>
                </methodparam>
                <methodparam>
                    <modifier></modifier><type>CAnalyzer&amp; </type>
                        <parameter>rAnalyzer</parameter>
                </methodparam>
                <methodparam>
                    <modifier></modifier><type>CBufferDecoder&amp;</type>
                        <parameter> rDecoder</parameter>
                </methodparam>
                
            </methodsynopsis>  
            
 
        public:
            <methodsynopsis>
                <modifier></modifier>
                <type>CEvent*</type>
                <methodname>getEvent</methodname>
                <void />
            </methodsynopsis>  
            <methodsynopsis>
                <modifier></modifier>
                <type>CBufferDecoder* </type>
                <methodname>getDecoder</methodname>
                <void />
            </methodsynopsis>  
            <methodsynopsis>
                <modifier></modifier>
                <type></type>
                <methodname>CAnalyzer*</methodname>
                <void />
            </methodsynopsis>              

        };
           </synopsis>
          </refsynopsisdiv>
          <refsect1>
             <title>DESCRIPTION</title>
             <para>
                This event processor class can be used with SpecTcl
                and a user written
                <link linkend='spectcl3_canalysisbase'
                      endterm='spectcl3_canalysisbase_title' />
                class to perform arbitrary analysis within SpecTcl.
                The intent of this framework is to provide simplified,
                format independent access to data other thatn that from
                physics triggers.
             </para>
             <para>
                To analyze physics triggers it's usually simpler to write
                a custom <classname>CEventProcessor</classname> and
                add that to the SpecTcl analysis pipeline.
             </para>
          </refsect1>
          <refsect1>
             <title>
            METHODS
             </title>
             <variablelist>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                           <methodname>CAnalysisEventProcessor</methodname>
                           <methodparam>
                            <modifier></modifier><type>CAnalysisBase* </type>
                                <parameter>pProcessor</parameter>
                           </methodparam>
                           <methodparam>
                            <modifier></modifier><type>void* </type>
                                <parameter>pClientData</parameter>
                                <initializer>0</initializer>
                           </methodparam>
                           
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The constructor for
                            <classname>CAnalysisEventProcessor</classname>
                            requires a pair of parameters.
                        </para>
                        <para>
                            The
                            first <parameter>pProcessor</parameter>
                            is a pointer to an instance of a class
                            derived from
                            <link linkend='spectcl3_canalysisbase'
                                  endterm='spectcl3_canalysisbase_title' />.
                            This object's methods will be invoked at the
                            approrpriate time by the the event processor
                            when it is part of the SpecTcl Analysis pipeline.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual </modifier>
                            <type>Bool_t </type>
                            <methodname>operator()</methodname>
                            <methodparam>
                                <modifier>const </modifier><type>Address_t</type>
                                    <parameter> pEvent</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier></modifier><type>CEvent&amp; </type>
                                    <parameter>rEvent, </parameter>
                            </methodparam>
                            <methodparam>
                                <modifier></modifier><type>CAnalyzer&amp; </type>
                                    <parameter>rAnalyzer</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier></modifier><type>CBufferDecoder&amp; </type>
                                    <parameter>rDecoder</parameter>
                            </methodparam>
                            
                            <modifier></modifier>
                        </methodsynopsis>  
                    </term>
                    <listitem>
                        <para>
                            This method is invoked by the SpecTcl analysis
                            pipeline for each physics event.  It will marhshall
                            the parameters required to invoke it's analyzer's
                            <methodname>onEvent</methodname> method.  
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual </modifier>
                            <type>Bool_t </type>
                            <methodname>OnBegin</methodname>
                            <methodparam>
                                <modifier></modifier><type>CAnalyzer&amp; </type>
                                    <parameter>rAnalyzer</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier></modifier><type>CBufferDecoder&amp; </type>
                                    <parameter>rDecoder</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Called by the SpecTcl anlaysis pipeline for begin
                            run events.  The method marshalls the parameters
                            required to invoke it's analyzer's
                            <methodname>onStateChange</methodname> method.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual </modifier>
                            <type>Bool_t </type>
                            <methodname>OnEnd</methodname>
                            <methodparam>
                                <modifier></modifier><type>CAnalyzer&amp; </type>
                                    <parameter>rAnalyzer</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier></modifier><type>CBufferDecoder&amp; </type>
                                    <parameter>rDecoder</parameter>
                            </methodparam>
                            
                        </methodsynopsis>  
                    </term>
                    <listitem>
                        <para>
                            Called by SpecTcl's analysis pipeline when an end run
                            event is encountered.  The method marshalls the
                            parameters required for its subsequent
                            call to the analyzer's
                            <methodname>onStateChange</methodname> method.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual </modifier>
                            <type>Bool_t </type>
                            <methodname>OnPause</methodname>
                            <methodparam>
                                <modifier></modifier><type>CAnalyzer&amp; </type>
                                    <parameter>rAnalyzer</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier></modifier><type>CBufferDecoder&amp; </type>
                                    <parameter>rDecoder</parameter>
                            </methodparam>
                            
                        </methodsynopsis>  
                    </term>
                    <listitem>
                        <para>
                            Called by the SpecTcl analysis pipeline for a
                            Pause run event. The method marshalls the
                            parameters required for its subsequent
                            call to the analyzer's
                            <methodname>onStateChange</methodname> method.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual </modifier>
                            <type>Bool_t </type>
                            <methodname>OnResume</methodname>
                            <methodparam>
                                <modifier></modifier><type>CAnalyzer&amp; </type>
                                    <parameter>rAnalyzer</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier></modifier><type>CBufferDecoder&amp; </type>
                                    <parameter>rDecoder</parameter>
                            </methodparam>
                            
                        </methodsynopsis>  
                    </term>
                    <listitem>
                        <para>
                            Called by the SpecTcl analysis pipeline for a
                            resume run event. The method marshalls the
                            parameters required for its subsequent
                            call to the analyzer's
                            <methodname>onStateChange</methodname> method.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual </modifier>
                            <type>Bool_t </type>
                            <methodname>OnOther</methodname>
                            <methodparam>
                                <modifier></modifier><type>UInt_t </type>
                                    <parameter>nType</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier></modifier><type>CAnalyzer&amp; </type>
                                    <parameter>rAnalyzer</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier></modifier><type>CBufferDecoder&amp;</type>
                                    <parameter> rDecoder</parameter>
                            </methodparam>
                            
                        </methodsynopsis>  
                        
                    </term>
                    <listitem>
                        <para>
                            Called by the analysis framework for event types that
                            are not known by it.  Based onthe <parameter>nType</parameter>
                            parameter, parmameters are marshalled and the appropriate
                            analyzer method is called.  Specifially:
                        </para>
                        <variablelist>
                            <varlistentry>
                                <term><varname>nType</varname> = <literal>SCALERBF</literal></term>
                                <listitem>
                                    <para>
                                        The <methodname>onScaler</methodname> method is called.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><varname>nType</varname> = <literal>STATEVARBF</literal></term>
                                <listitem>
                                    <para>
                                        The <methodname>onStringLists</methodname>
                                        method is called.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><varname>nType</varname> = <literal>RUNVARBF</literal></term>
                                <listitem>
                                    <para>
                                        The <methodname>onStringLists</methodname>
                                        is called.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><varname>nType</varname> = <literal>PKTDOCBF</literal></term>
                                <listitem>
                                    <para>
                                        The <methodname>onStringLists</methodname>
                                        is called.
                                    </para>
                                </listitem>
                            </varlistentry>
                        </variablelist>
                        <para>
                            When <methodname>onStringLists</methodname>
                            is called, its <parameter>type</parameter>
                            will identify the type of the string list
                            event.  For more about the possible types,
                            see
                            <link linkend='spectcl3_canalysisbase'
                                  endterm='spectcl3_canalysisbase_title' />
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CEvent*</type>
                            <methodname>getEvent</methodname>
                            <void />
                        </methodsynopsis>  
                    </term>
                    <listitem>
                        <para>
                            This allows the analysis object to obtain the current
                            output event being produced by the event analysis
                            pipeline.   If a physics event is not being created
                            (the analyzer object's <methodname>onEvent</methodname>)
                            is not the one processing, this method will return a
                            null pointer.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CBufferDecoder* </type>
                            <methodname>getDecoder</methodname>
                            <void />
                        </methodsynopsis>  
                        
                    </term>
                    <listitem>
                        <para>
                            Allows the analyzer object to retrieve the current
                            buffer decoder object being used by the
                            <classname>CAnalyzer</classname> object.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type></type>
                            <methodname>CAnalyzer*</methodname>
                            <void />
                        </methodsynopsis>              
                    </term>
                    <listitem>
                        <para>
                            Allows the analyzer object to retrieve the
                            <classname>CAnalyzer</classname> object that
                            is coordinating the analysis pipeline.
                        </para>
                    </listitem>
                </varlistentry>
             </variablelist>
          </refsect1>
           <refsect1>
              <title>PUBLIC VARIABLES, TYPES and CONSTANTS</title>
              <para>
                The analysis object methods are called with a
                <type>void*</type> <parameter>clientData</parameter>
                parameter.  When used with the <classname>CAnalyzsisEventProcessor</classname>,
                the <parameter>clientData</parameter> parameter is actually
                a pointer to a struct defined by the typedef
                <classname>CAnalysisEventProcessor::ClientData</classname>.
              </para>
              <para>
                This struct has the following fields (in order):
              </para>
              <variablelist>
                <varlistentry>
                    <term><structfield>s_pUserData</structfield></term>
                    <listitem>
                        <para>
                            The user data passed in at construction time.
                            This is saved and passed as a
                            <type>void*</type> without any interpretation.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><structfield>s_pCaller</structfield></term>
                    <listitem>
                        <para>
                            Pointer to the
                            <classname>CAnalysisEventProcessor</classname>
                            that called the method.  This allows
                            the analysis object to make use of services
                            expoerted by the event processor object.
                            
                        </para>
                    </listitem>
                </varlistentry>
                
                
              </variablelist>
           </refsect1>
        </refentry>     
    </part>
</book>