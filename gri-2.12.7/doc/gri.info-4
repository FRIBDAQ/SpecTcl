This is gri.info, produced by makeinfo version 4.3 from gri.texi.

INFO-DIR-SECTION Scientific Applications
START-INFO-DIR-ENTRY
* Gri: (gri).  Programming language for scientific illustration
END-INFO-DIR-ENTRY


File: gri.info,  Node: Draw Circle,  Next: Draw Contour,  Prev: Draw Box,  Up: Draw

`draw circle'
.............

     draw circle with radius .r_cm. at .x_cm. .y_cm.

Draw circle of specified radius (in cm) at the specified location (in
cm on the page).


File: gri.info,  Node: Draw Contour,  Next: Draw Curve,  Prev: Draw Circle,  Up: Draw

`draw contour'
..............

     `draw contour [{.value. \
       [unlabelled | {labelled "\label"}]} \
       | {.min. .max. .inc. \
         [.inc_unlabelled.] [unlabelled]}]'

This command draws contours based on the "grid" data previously read in
by a `read grid data' command or created by gridding column data with a
`create grid from columns' command.  If the grid data don't exist, or
if the x and y locations of the grid points do not exist (see `set x
grid', `set y grid', etc), Gri will complain.

   With no optional parameters, draw labelled contours at an interval
that is picked automatically based on the range of the data.

   With a single numerical value (`.value.'), draw the indicated
contour.  With the addition of `labelled "\label"', put the indicated
label instead of a numeric label.  This can be useful for using
scientific notation instead of computer notation for exponents, e.g.
`draw contour 1e-5 labelled "10$^{-5}$"'.

   With (`.min.', `.max.' and `.inc.') given, draw contours for z(x,y)
= `.min.', z(x,y) = `.min. + .inc.', z(x,y) = `.min. + 2*.inc.', ...,
z(x,y) = `.max.'

   With the additional value `.inc_unlabelled.' specified, extra
unlabelled contours are drawn at this finer interval.

   With the optional parameter `unlabelled' at the end of any form of
this command (except the `labelled "\label"' variation, of course), Gri
will not label the contour(s).

   *Hint:* It can be effective to draw contours at a certain interval
with labels, and a thicker pen, e.g.

     set line width rapidograph 3x0
     draw contour -2 5 1 0.25
     set line width rapidograph 1
     draw contour -2 5 1

   Interpolation method: The interpolation scheme is the same used for
converting grid-values to image values (*Note Convert Grid To Image::).

   *See also* `set contour labels'


File: gri.info,  Node: Draw Curve,  Next: Draw Essay,  Prev: Draw Contour,  Up: Draw

`draw curve'
............

   Several forms exist.

     `draw curve'

Draws a curve connecting the points (x,y), which have been read in by a
command like `read columns x y'.  Line segments are drawn between all
(x,y) points, except: (1) no line segments are drawn to any missing
data (see `set missing value'), and (2) if clipping is turned on (see
`set clip on'), no line segments are drawn outside the clipping region.
*See also* `draw curve overlying'

     `draw curve overlying'

Like `draw curve', except that before drawing, the area underneath the
curve (+/- one linewidth) is whited out.  This clarifies graphs where
curves overlie other curves or the axes.  *See also* `draw curve'.

     `draw curve filled [to {.y. y}|{.x. x}]'

The form `draw curve filled ...' draws filled curves.  If the `to
.value.' is not specified, fill the region defined by the x-y points
using the current paint colour (see `set graylevel').  To complete the
shape, an extra line is drawn between the first and last points.

   The form `draw curve filled to .y. y' fills the region between y(x)
and y = `.y.'; do not connect the first and last points as in the case
where `to .yvalue.' is not specified.

   The form `draw curve filled to .x. x' fills the region between x(y)
and x = `.x.'


File: gri.info,  Node: Draw Essay,  Next: Draw Gri Logo,  Prev: Draw Curve,  Up: Draw

`draw essay'
............

     `draw essay "text"|reset'

Draw indicated text on the page.  Succeeding calls draw text further and
further down the page, starting at the top.

   The current font size is used; to alter this, use `set font size'
before `draw essay'.

   When `reset' is present instead of text, the drawing position is
reset to the top of the page.  Use this after a `new page' command to
ensure that the next text lines will appear at the top of the page as
expected.  EXAMPLE:

     set font size 2 cm
     draw essay "Line 1, at top of page"
     draw essay "Line 2, below top line"


File: gri.info,  Node: Draw Gri Logo,  Next: Draw Grid,  Prev: Draw Essay,  Up: Draw

`draw gri logo'
...............

     `draw gri logo .x_cm. .y_cm. .height_cm. .style. \fgcolor \bgcolor'

Draw a Gri logo at given location with given style and colors.  The
lower-left corner of the logo will be `.x_cm.' centimeters from the
left-hand side of the page and `.y_cm.' centimeters from the bottom of
the page.  The logo will be `.height_cm.' centimeters tall.  The
textual parameters `\fgcolor' and `\bgcolor' give the foreground and
background colors, respectively, and these are used in styles as noted
in the table below

     .style.    style
     =======    ===================
        0       stroke curve
        1       fill with color \fgcolor, no background
        2       fill with color \fgcolor it in tight box of color \bgcolor
        3       as 2 but in square box
        4       draw in \fgcolor on top of shifted copy in \bgcolor

   An example is given below

     draw gri logo 1 1 3 4 blue green


File: gri.info,  Node: Draw Grid,  Next: Draw Image Histogram,  Prev: Draw Gri Logo,  Up: Draw

`draw grid'
...........

     `draw grid'

Draw plus-signs at locations where grid data are non-missing.


File: gri.info,  Node: Draw Image Histogram,  Next: Draw Image Palette,  Prev: Draw Grid,  Up: Draw

`draw image histogram'
......................

     `draw image histogram \
       [box .llx_cm. .lly_cm. .urx_cm. .ury_cm.]'

With no optional parameters, draw histogram of all unmasked parts of the
image, placing it above the current top of the plot.

   When the `box' options are present, they specify the box (in
centimetre coordinates on the page) in which the histogram plot is to be
done.


File: gri.info,  Node: Draw Image Palette,  Next: Draw Image,  Prev: Draw Image Histogram,  Up: Draw

`draw image palette'
....................

     `draw image palette
        [axisleft|axisright|axistop|axisbottom]
        [left .left. right .right. [increment .inc.]]
        [box .xleft_cm. .ybottom_cm. .xright_cm. .ytop_cm.]'

With no optional parameters, draw palette for image, placed above the
current top showing values ranging from `.min_value.' to `.max_value.'
as given in `set image range'.

   Optional keywords (`axisleft', etc) control the orientation of the
palette, the default being `axisbottom'.

   The optional parameters `.left.' and `.right.' may be used to
specify the range to be drawn in the palette.  If the additional
optional parameter `.inc.' is present, it specifies the interval
between tics on the scale; if not present, the tics are at increments of
2 * (`.right.' - `.left'.).  (If `.inc.'  has the wrong sign, it will
be corrected without warning.)

   When the optional `box' parameters are present, they prescribe the
bounding box to contain the palette.  The units are centimetres on the
page.  If these parameters are not present, the box will be drawn above
the image plot.

   *Hint* It is a good idea to make the palette range `.left.' to
`.right.' extend a little beyond the range of full white and full
black, since otherwise neither pure white nor pure black will appear in
the colorbar.  For example

     set image grayscale black 0 white 1 increment 0.1
     draw image palette left -0.1 right 1.1 increment 0.1

   *Hint* Continuous-tone images with superimposed contours are often
effective.  To get the contour lines drawn on the image palette, do
something like this

     draw image
     .left.   = 0
     .right.  = 9
     .inc.    = 1
     .space.  = 3
     .height. = 1
     draw image palette left .left. \
       right .right. \
       increment .inc. \
       box \
         ..xmargin.. \
         {rpn ..ymargin.. ..ysize.. + .space. + } \
         {rpn ..xmargin.. ..xsize.. +} \
         {rpn ..ymargin.. ..ysize.. + .space. + .height. + }
     draw contour .left. .right. .inc. unlabelled
     
     .c. = .left.
     while {rpn .right. .c. <= }
       .c_cm. = {rpn .c. .left. - \
        .right. .left. - / \
         ..xsize.. * ..xmargin.. +}
       draw line from \
         .c_cm. \
         {rpn ..ymargin.. ..ysize.. + .space. + }\
         to \
         .c_cm. \
         {rpn ..ymargin.. ..ysize.. + .space. + .height. +} \
         cm
       .c. += 1
     end while


File: gri.info,  Node: Draw Image,  Next: Draw Isopycnal,  Prev: Draw Image Palette,  Up: Draw

`draw image'
............

     `draw image'

Draw black/white image made by `convert grid to image' or by `read
image'.


File: gri.info,  Node: Draw Isopycnal,  Next: Draw Isospice,  Prev: Draw Image,  Up: Draw

`draw isopycnal'
................

     `draw isopycnal \
        [unlabelled] .density. [.P_sigma. [.P_theta.]]'

   Draw isopycnal curve for a temperature-salinity diagram.  This curve
is the locus of temperature and salinity values which yield seawater of
the indicated density, at the indicated pressure.  The UNESCO equation
of state is used.

   For the results to make sense, the x-axis should be salinity and the
y-axis should be either in-situ temperature or potential temperature.

   The `.density.' unit is kg/m^3.  If the supplied value exceeds 100
then it will be taken to indicate the actual density; otherwise it will
be taken to indicate density minus 1000 kg/m^3.  (The deciding value of
100 kg/m^3 was chosen since water never has this density; the more
intuitive value of 1000 kg/m^3 would be inappropriate since water can
have that density at some temperatures.)  Thus, 1020 and 20 each
correspond to an actual density of 1020 kg/m^3.

   The reference pressure for density, `.P_sigma.', is in decibars
(roughly corresponding to meters of water depth).  If no value is
supplied, a pressure of 0 dbar (i.e. atmospheric pressure) is used.

   The reference pressure for theta, `.P_theta.', is in decibars, and
defaults to zero (i.e. atmospheric pressure) if not supplied.  This
option is used if the y-axis is potential temperature referenced to a
pressure other than the surface.  Normally the potential temperature is,
however, referenced to the surface, so that specifying a value for
`.P_theta.' is uncommon.

   By default, labels will be drawn on the isopycnal curve; this may be
prevented by supplying the keyword `unlabelled'.  If labels are drawn,
they will be of order 1000, or of order 10 to 30, according to the
value of `.density.' supplied (see above).  The label format defaults
to "%g" in the C-language format notation, and may be controlled by
`set contour format'.  The label position may be controlled by `set
contour label position' command (bug: only non-centered style works).
Setting label position is useful if labels collide with data points.
Labels are drawn in the whiteunder mode, so they can white-out data
below.  For this reason it is common to draw data points after drawing
isopycnals.

   If the y-axis is in-situ temperature, the command should be called
without specifying `.P_sigma.', or, equivalently, with `.P_sigma.' = 0.
That is, the resultant curve will correspond to the (S,T) solution to
the equation

     .density. = RHO(S, T, 0)

where `RHO=RHO(S,T,p)' is the UNESCO equation of state for seawater.
This is a curve of constant sigma_T.

   If the y-axis is potential temperature referenced to the surface,
`.P_theta.' should not be specified, or should be specified to be zero.
The resultant curve corresponds to a constant value of potential
density referenced to pressure `.P_sigma.', i.e. the (S,theta) solution
to the equation

     .density. = RHO(S, theta, .P_sigma.)

For example, with `.P_sigma.=0' (the default), the result is a curve of
constant sigma_theta.

   If the y-axis is potential temperature referenced to some pressure
other than that at the surface, `.P_theta.' should be supplied.  The
resultant curve will be the (S,theta) solution to the equation

     .density. = RHO(S, T', .P_sigma.)

where

     T'=THETA(S, theta, .P_theta., .P_sigma.)

where `THETA=THETA(S,T,P,Pref)' is the UNESCO formula for potential
temperature of a water-parcel moved to a reference pressure of `Pref'.
Note that `theta', potential temperature referenced to pressure
`.P_theta.', is the variable assumed to exist on the y-axis.


File: gri.info,  Node: Draw Isospice,  Next: Draw Label Boxed,  Prev: Draw Isopycnal,  Up: Draw

`draw isospice'
...............

     `draw isospice .spice. [unlabelled]'

Draw an iso-spice line for a "TS" diagram, using (S, T) data stored in
files in a subdirectory named `iso-spice0' in a directory named by the
unix environment variable `GRI_EOS_DIR'.  You must set this environment
variable yourself, in the normal unix way.  If `GRI_EOS_DIR' is not
defined, Gri looks in the directory `/data/po/ocean/EOS/iso0'; of
course, this will work only for people on the same machine as the
author.

   Only certain iso-spice lines are stored in these files, so only
certain values of `.spice.' are allowed.  They are 21.75, 22.00, 22.25,
..., 30.75.  You must supply `.density.' in exactly this format (with 2
decimal places), or else Gri will not find the appropriate TS file, and
will give a "can't open file" error.  NB: isopycnals ranging from about
23.00 to 26.00 cross a TS diagram spanning 34<S<36 and 0<T<10.

   The line is labelled at the right with the density value, unless the
`unlabelled' option is given.

   Clipping should be on when drawing iso-spice lines.  A warning will
be given if the isospice line does not intersect the clipping region.

   EXAMPLE

     set clip on
     draw isospice line 27.00
     draw isospice line 27.50 unlabelled


File: gri.info,  Node: Draw Label Boxed,  Next: Draw Label Whiteunder,  Prev: Draw Isospice,  Up: Draw

`draw label'
............

     `draw label boxed "string" at .xleft. .ybottom. [cm]'

Draw boxed label for plot, located with lower-left corner at indicated
(x,y) position (specified in user units or in cm on the page).  The
current font size and pen color are used.  The geometry derives from the
current font size, with the label being centered within the box.


File: gri.info,  Node: Draw Label Whiteunder,  Next: Draw Label For Last Curve,  Prev: Draw Label Boxed,  Up: Draw

`draw label whiteunder'
.......................

     `draw label whiteunder "\string" at .xleft. .ybottom. [cm]'

Draw label for plot, located with lower-left corner at indicated (x,y)
position (specified in user units or in cm on the page).  Whiteout is
used to clean up the area under the label.  BUGS: Cannot handle angled
text; doesn't check for super/subscripts.


File: gri.info,  Node: Draw Label For Last Curve,  Next: Draw Label,  Prev: Draw Label Whiteunder,  Up: Draw

`draw label for last curve'
...........................

     `draw label for last curve "label"'

Draw a label for the last curve drawn, using the `..xlast..' and
`..ylast..' built-in variables.


File: gri.info,  Node: Draw Label,  Next: Draw Line From,  Prev: Draw Label For Last Curve,  Up: Draw

`draw label'
............

     `draw label "\string" [centered|rightjustified] \
         at .x. .y. [cm|pt] \
         [rotated .deg.]'

With no optional parameters, draw string at given location in USER
units.

   With the `cm' or `pt' keyword is present, the location is in
centimetres or points on the page.

   With the `rotated' keyword present, the angle in degrees from the
horizontal, measured positive in the counterclockwise direction, is
given.

   With the keyword `centered' present, the text is centered at the
given location; similarly the keyword `rightjustified' makes the text
end at the given location.


File: gri.info,  Node: Draw Line From,  Next: Draw Line Legend,  Prev: Draw Label,  Up: Draw

`draw line from ... to'
.......................

     `draw line from .x0. .y0. to .x1. .y1. [cm|pt]'

With no optional parameters, draw a line from (`.x0.', `.y0.')  to
(`.x1.', `.y1'.), where coordinates are in user units.  With the `cm'
or `pt' keyword present, the coordinates are in centimetres or points
on the page.  NOTE: This will not cause auto-drawing of axes.


File: gri.info,  Node: Draw Line Legend,  Next: Draw Lines,  Prev: Draw Line From,  Up: Draw

`draw line legend'
..................

     `draw line legend "label" at .x. .y. [cm] [length .cm.]'

Draw a legend identifying the current line type with the given label.  A
short horizontal line is drawn starting at the location (`.x.', `.y.'),
which may be specified in centimetres or, the default, in user
coordinates.  The line length is normally 1 cm, but this length can be
set by the last option.  The indicated label string is drawn 0.25 cm to
the right of the line.

   *See also* `draw symbol legend ...'.

   EXAMPLE (of keeping track of the desired location for the legend)

     .offset. = 1                    # cm to offset legends
     # ... get salinity data
     set line width 0.25
     draw curve
     draw line legend "Salinity" at .x. .y.
     # ... get temperature data
     set line width 1.0
     set dash 0.45 0.05
     draw curve
     .y. += .offset.
     draw line legend "Temperature" at .x. .y.


File: gri.info,  Node: Draw Lines,  Next: Draw Patches,  Prev: Draw Line Legend,  Up: Draw

`draw lines'
............

     `draw lines {vertically .left. .right. .inc.} | \
         {horizontally .bottom. .top. .inc.}'

Draw several lines, either vertically or horizontally.  This can be
useful in drawing gridlines for axes, etc.  The following example shows
how to draw thin gray lines extending from the labelled tics on the x
axis (ie, at 0, 0.1, 0.2, ... 1):

     set x axis 0 1 0.1 0.05
     set y axis 10 20 10
     draw axes
     set graylevel 0.75
     set line width 0.5
     draw lines vertically 0 1 0.1
     set graylevel 0


File: gri.info,  Node: Draw Patches,  Next: Draw Polygon,  Prev: Draw Lines,  Up: Draw

`draw patches'
..............

     `draw patches .width. .height. [cm]'

With the optional `cm' keyword not present, draw column data z(x,y) as
gray patches according to the grayscale as set by most recent `set
image grayscale'.  The patches are aligned along the horizontal, and
have the indicated size in user units.

   With the optional keyword `cm' is present, the patch size is
specified in centimetres.


File: gri.info,  Node: Draw Polygon,  Next: Draw Regression Line,  Prev: Draw Patches,  Up: Draw

`draw polygon'
..............

     `draw polygon [filled] .x0. .y0. .x1. .y1. [...]'

Draw a polygon connecting the indicated points, specified in user units.
The last point is joined to the first by a line segment.  At least two
points must be specified.  If the `filled' keyword is present, the
polygon is filled with the current pen color.


File: gri.info,  Node: Draw Regression Line,  Next: Draw Symbol At,  Prev: Draw Polygon,  Up: Draw

`draw regression line'
......................

     `draw regression line [clipped]'

Fit and draw a regression line to column data, of the form  `y =
..coeff0.. + ..coeff1.. * x', exporting `..coeff0..', `..coeff0_sig..',
`..coeff1..'  and `..coeff1_sig..'  as global variables (*Note
Regress::).

Normally, the line is not clipped to the axes frame, but it will be if
the keyword `clipped' is given.

HINT: to label the plot you might do the following:

     sprintf \label "y = %f + %f * x. R$^2$=%f" \
       ..coeff0.. ..coeff1.. ..R2..
     draw title "The linear fit is \label"


File: gri.info,  Node: Draw Symbol At,  Next: Draw Symbol Legend,  Prev: Draw Regression Line,  Up: Draw

`draw symbol ... at'
....................

     `draw symbol .code.|\name at .x. .y. [cm|pt]'

Draw a symbol at given (single) location.  The location is normally in
user coordinates; it will be in centimetres on the page if the optional
`cm' or `pt' keyword is given.

   With the optional numerical/name code specified, then the symbol of
that number or name is drawn at each (x,y) datum, whether or not a
z-column exists.  The numerical/name codes are:

      # name                description
     -- ----                -----------
      0 plus                +
      1 times               x
      2 box                 box
      3 circ                circle
      4 diamond             diamond
      5 triangleup          triangle with base at bottom
      6 triangleright       triangle with base at left
      7 triangledown        triangle with base at top
      8 triangleleft        triangle with base at right
      9 asterisk            *
     10 star                star of David
     11 filledbox           filled box
     12 bullet              filled circle
     13 filleddiamond       filled diamond
     14 filledtriangleup    filled triangleup
     15 filledtriangleright filled triangleright
     16 filledtriangledown  filled triangledown
     17 filledtriangleleft  filled triangleleft


File: gri.info,  Node: Draw Symbol Legend,  Next: Draw Symbol,  Prev: Draw Symbol At,  Up: Draw

`draw symbol legend'
....................

     `draw symbol legend \symbol_name "label" \
         at .x. .y. [cm]'

Draw indicated symbol at indicated location, with the indicated label
beside it.  The label is drawn one M-space to the right of the symbol,
vertically centered on the indicated `.y.' location.


File: gri.info,  Node: Draw Symbol,  Next: Draw Time Stamp,  Prev: Draw Symbol Legend,  Up: Draw

`draw symbol'
.............

     `draw symbol [[.code.|\name]    \
         | [graylevel z]             \
           [color [hue z|.h.]        \
                  [brightness .b.]   \
                  [saturation .s.]]]'

With no optional parameters, draw symbols at the (x,y) data.  If a
z-column has been read with `read columns', then its value codes the
symbol to draw, according to the table below.  (The value of z is first
rounded to the nearest integer.)  If no z-column has been read, the
symbol X is drawn at each datum.

   With the optional numerical/name code specified, then the symbol of
that number or name is drawn at each (x,y) datum, whether or not a
z-column exists.  The numerical/name codes are:

      # name                description
     -- ----                -----------
      0 plus                +
      1 times               x
      2 box                 box
      3 circ                circle
      4 diamond             diamond
      5 triangleup          triangle with base at bottom
      6 triangleright       triangle with base at left
      7 triangledown        triangle with base at top
      8 triangleleft        triangle with base at right
      9 asterisk            *
     10 star                star of David
     11 filledbox           filled box
     12 bullet              filled circle
     13 filleddiamond       filled diamond
     14 filledtriangleup    filled triangleup
     15 filledtriangleright filled triangleright
     16 filledtriangledown  filled triangledown
     17 filledtriangleleft  filled triangleleft

   With the optional `graylevel z' fields specified, the graylevel is
given by the `z' column (0=black, 1=white).

   With the optional `color' field specified, the color is specified,
either directly in the command (the `hue .h.' form) or in the z column.
For more information on color, refer to the `set color hsb ...'
command.

   Examples: both `draw symbol bullet color' and `draw symbol bullet
color hue z' draw bullets whose hue is given by the value in the z
column.  The hue (or the color, in other words) blends smoothly across
the spectrum as the numerical value ranges from 0 to 1.  The value
0yields red, 1/3 yields green, 2/3 yields blue, etc.  If the
`brightness' and the `saturation' are not specified, they both default
to the value 1, which yields pure, bright colors.

   Example: draw all in green dots `draw symbol bullet color hue 0.333
brightness 1 saturation 1'

   Example: display spectrum of dots

     set symbol size 0.3
     open "awk 'END{ \
         for(c=0;c<1;c+=1/40) \
             print(c,c,c)}' | "
     read columns x y z
     close
     draw symbol bullet color hue z


File: gri.info,  Node: Draw Time Stamp,  Next: Draw Title,  Prev: Draw Symbol,  Up: Draw

`draw time stamp'
.................

     `draw time stamp \
         [fontsize .points. \
             [at .x_cm. .y_cm. cm \
                 [with angle .deg.]]]'

Draw the command-file name, PostScript file name, and time, at the top
of graph.  Normally, the timestamp is drawn at the top of the page, in a
fontsize of 10 points.  But the user can specify the fontsize, and
additionally the location (in cm) and additionally the angle measured in
degrees anticlockwise from the horizontal.

   NOTE: If you want to have the plot drawn in landscape mode, ensure
that `set page landscape' precedes `draw time stamp.'


File: gri.info,  Node: Draw Title,  Next: Draw Values,  Prev: Draw Time Stamp,  Up: Draw

`draw title'
............

     `draw title "\string"'

Draw the indicated string above the plot.


File: gri.info,  Node: Draw Values,  Next: Draw X Axis,  Prev: Draw Title,  Up: Draw

`draw values'
.............

     draw values                 \
         [.dx. .dy.]             \
         [\format]               \
         [separation .xcm. .ycm.]

Draw values of `z' column, at corresponding (`x', `y') locations.  If
the `separation' keyword is present, the distance between successive
points is checked, and points are skipped unless the x and y
separations exceed the indicated distances.

   * `draw values' Draw the values of `z(x,y)', positioned 1/2 M-space
     to the right of `(x,y)' and vertically centred on `y'.  The values
     are written in a good general format known as `%lg', in C
     terminology.

   * `draw values %.2f' Draw values of `z(x,y)' positioned as described
     above, but using the indicated format string.  This format string
     specifies that 2 numbers be used after the decimal place, and that
     floating point should be used.  See any C manual for format codes.

   * `draw values .dx. .dy.' Print values of `z(x,y)' at indicated
     offset vector (`.dx.',`.dy.'), measured in centimeters, from the
     values of `(x,y)' at which the data are defined.

   * `draw values .dx. .dy. %.3f' Print values of `z(x,y)' at indicated
     distance from `(x,y)', indicated format.


File: gri.info,  Node: Draw X Axis,  Next: Draw X Box Plot,  Prev: Draw Values,  Up: Draw

`draw x axis'
.............

     draw x axis [at bottom|top|{.y. [cm]} [lower|upper]]

Draw an x axis, optionally at a specified location and of a specified
style.
   * `draw x axis' Draw a lower x axis (ie, one with the numbers below
     the line) at the bottom of the box defined by `set y axis'.

   * `draw x axis at bottom' Draw a lower x axis (ie, one with the
     numbers below the line) at the bottom of the box defined by `set y
     axis'.

   * `draw x axis at top' Draw an upper x axis (ie, one with the
     numbers above the line) at the top of the box defined by `set y
     axis' (or above any existing stacked x axes there)

   * `draw x axis at .y.' Draw a lower x axis at indicated value of
     `.y.'.

   * `draw x axis at .y. upper' Draw an upper x axis at indicated value
     of .y.


File: gri.info,  Node: Draw X Box Plot,  Next: Draw Y Axis,  Prev: Draw X Axis,  Up: Draw

`draw x box plot'
.................

     draw x box plot at .y. [size .cm.]

Draw Tukey box plots (which give a summary of histogram properties).
Box plots were invented by Tukey for eda (exploratory data analysis).
The centre of the box is the median.  The box edges show the first
quartile (q1) and the third quartile (q3).  The distance from q3 to q1
is called the inter-quartile range.  The whiskers (i.e., the lines with
crosses at the end) extend from q1 and q3 to the furthest data points
which are still within a distance of 1.5 inter-quartile ranges from q1
and q3.  Beyond the whiskers, all outliers are shown: open circles are
used for data within a distance of 3 inter-quartile ranges beyond q1 and
q3, and in closed circles beyond that.

   * `draw x box plot at .y.' Draw Tukey's box plot, spreading in the x
     direction, centered at y=`.y.' and of default width 0.5 cm.

   * `draw x box plot at .y. size .cm.' Draw Tukey's box plot,
     spreading in the x direction, centered at y=`.y.' and of width
     `.cm.' centimetres.


File: gri.info,  Node: Draw Y Axis,  Next: Draw Y Box Plot,  Prev: Draw X Box Plot,  Up: Draw

`draw y axis'
.............

     draw y axis [at left|right|{.x. cm} [left|right]]

Draw a y axis, optionally at a specified location and of a specified
style.

   * `draw y axis' Draw a left-hand-side y axis (ie, one with the
     numbers to the left of the line) at left of box defined by `set x
     axis'

   * `draw y axis at left' Draw a left-hand-side y axis (ie, one with
     the numbers to the left of the line) at left of box defined by
     `set x axis'.

   * `draw y axis at right' Draw a right-hand-side y axis (ie, one with
     the numbers to the right of the line) at right of box defined by
     `set x axis'.

   * `draw y axis at .x.' Draw a left-hand-side y axis (ie, one with
     the numbers to the left of the line) at indicated value of `.x.'

   * `draw y axis at .x. right' Draw a right-hand-side y axis (ie, one
     with the numbers to the right of the line) at indicated value of
     `.x.'


File: gri.info,  Node: Draw Y Box Plot,  Next: Draw Zero Line,  Prev: Draw Y Axis,  Up: Draw

`draw y box plot'
.................

     draw y box plot at .x. [size .cm]

Draw Tukey box plots (which give summary of histogram properties).
   * `draw y box plot at .x.' Draw Tukey's box plot, spreading in the y
     direction, centered at x=`.x.' and of default width 0.5 cm.

   * `draw y box plot at .x. size .cm.' Draw Tukey's box plot,
     spreading in the y direction, centered at x=`.x.' and of width
     `.cm.' centimetres.


File: gri.info,  Node: Draw Zero Line,  Next: End Group,  Prev: Draw Y Box Plot,  Up: Draw

`draw zero line'
................

     draw zero line [horizontally|vertically]

Draw lines corresponding to x=0 or y=0.
   * `draw zero line' Draw line y=0 if it is within axes.

   * `draw zero line horizontally' Draw line y=0 if it is within axes.

   * `draw zero line vertically' Draw line x=0 if it is within axes.


File: gri.info,  Node: End Group,  Next: Expecting,  Prev: Draw Zero Line,  Up: List Of Gri Commands

`end grouip'
............

     end group

_Command not implemented yet.  Syntax may change._


File: gri.info,  Node: Expecting,  Next: Filter,  Prev: End Group,  Up: List Of Gri Commands

`expecting'
-----------

     expecting version a.b
     expecting version a.b.c

Show a list of incompatibilites that have been introduced since the
named version.  This command can make your commandfiles more reliable
against changes to Gri.

   There are two forms of the version number.  Modern versions use the
triplet form, e.g.  `expecting version 2.8.7', but prior to October
1996 the version numbers were written in decimal form, so that you
would write `expecting version 1.069' for example.


File: gri.info,  Node: Filter,  Next: Flip,  Prev: Expecting,  Up: List Of Gri Commands

`filter'
--------

   * `filter column x|y|z|u|v|weight recursively a[0] a[1] ... b[0]
     b[1] ...' Filter indicated column, using a two-pass recursive
     filter.  The first pass runs from the start to the end, while the
     second pass runs from the end to the start; in this way, the phase
     shift inherent in this type of filter is removed entirely.  The
     coefficients are used in the following formula (demonstrated on
     the `x' column):

          x_new[i] = b[0] * x[i] \
            + b[1] * x[i-1] \
            + b[2] * x[i-2] \
            + ... \
            - a[1] * x_new[i-1] \
            - a[2] * x_new[i-2] \
            - ...

     Thus, for example, setting `a[i]' = 0 results in a simple
     backwards-looking moving-average filter applied in two passes.
     The real power of this type of filter, however, comes when
     non-zero `a[i]' coefficients are given, thus adding recursion
     (i.e., `x_new[i]' depends on `x_new[i-...]').  See any standard
     reference on digital filters for an explanation.  You might find
     that the Matlab command `butter' an easy way to design filter
     coefficients.  Here are some examples:

          # Filter x column with simple 2-point moving
          # average.  (This slurs into a 3-point moving
          # average, in effect, since the filter is run
          # forwards and then backwards.)
          filter column x recursively 0 0 0.5 0.5
          
          # Use filter designed with the Matlab
          # command butter(2,0.1), which creates a
          # 2nd order lowpass butterworth filter
          # with a cutoff frequency of 0.1
          # (in units which have a frequency
          # of 1 corresponding to one-half the
          # sampling rate).
          filter column x recursively \
              1     -1.561  0.6414 \
              0.0201 0.0402 0.0201

   * `filter grid rows|columns recursively a[0] a[1] ... b[0] b[1] ...'

     Apply recursive filter (see `filter column ... recursively' for
     meaning of this filter operation) to the individual rows or
     columns of the grid data.  For example, the command `filter grid
     columns recursively 0 0 0.5 0.5' applies a 2-point moving average
     filter across the columns, smoothing the grid in the x-direction.

   * `filter image highpass' Remove low-wavenumber components from
     image (ie, sharpen edges).  Do this by subtracting a Laplacian
     smoothed version of the image.

   * `filter image lowpass' Remove high-wavenumber components from
     image (ie, smooth shapes).  Do this by Laplacian smoothing.

   *See also* *Note Smooth::.


File: gri.info,  Node: Flip,  Next: Get Env,  Prev: Filter,  Up: List Of Gri Commands

`flip'
------

     `flip grid|image x|y'

Flip grid or image by relecting it about a horizontal or vertical
centerline.
   * `flip grid x' Flip grid so right-hand side becomes left-hand side.

   * `flip grid y' Flip grid so bottom side becomes top side.

   * `flip image x' Flip image so right-hand side becomes left-hand
     side.

   * `flip image y' Flip image so bottom side becomes top side.


File: gri.info,  Node: Get Env,  Next: Group,  Prev: Flip,  Up: List Of Gri Commands

`get env'
---------

     `get env \result \environment_variable'

Get the value of an "environment variable" from the unix operating
system, and store the result in the indicated synonym.  This makes most
sense on unix systems (hence the name, patterned after the unix command
`getenv').  This command can be useful in making gri programs resistant
to changes in data-file locations.  Suppose, for example, there is a
file called `data', normally in a local directory called `Bravo'.  The
line `open Bravo/data' will fail if the Bravo directory is moved.  But
if the name of the datafile is stored in an unix environment variable,
`DIR_BRAVO' say, then the gri program will work no matter where the
Bravo data are moved, so long as an appropriate environment variable is
modified when the data are moved.  Example:

     get env \dir DIR_BRAVO
     if {rpn "\dir" "" ==}
         show "Cannot determine location of the Bravo data,"
         show "which should be stored in the environment"
         show "variable DIR_BRAVO.  You should"
         show "do something like"
         show "export DIR_BRAVO='/data/Bravo/'"
         show "in your ~/.environment file"
         quit
     end if
     open \dir/data
     ...


File: gri.info,  Node: Group,  Next: Heal,  Prev: Get Env,  Up: List Of Gri Commands

`group'
-------

     `group ["\name"]'

_Command not implemented yet.  Syntax may change._


File: gri.info,  Node: Heal,  Next: Help,  Prev: Group,  Up: List Of Gri Commands

`heal'
------

     heal columns|{columns along x|y}
   The `heal' command heals over gaps in either columnar or gridded
data.  This is done by linear interpolation across the missing-value
gaps.

   * `heal columns'

     Fill in missing values in x, y, z, ... columns, by linear
     interpolation to neighboring valid data.  All gaps in the data
     will get replaced by a linear function of index which matches the
     data at the indices just before and just after the gap.  For
     example, if the y data were like

          111
          3
          -9
          -9
          -9
          7
          333

     where `-9' is the missing-value code, then they would get replace
     by

          111
          3
          4
          5
          6
          7
          333

     Notes: (1) This is done *independently* for all existing columns.
     (2) Gaps at the start and end of the columns are not filled in.

   * `heal grid along x'

     Scan in the x direction, filling in missing values by linear
     interpolation.  Since this uses the the x-grid, you must first
     have done `read grid x' or `set x grid'.

   * `heal grid along y'

     Scan in the y direction, filling in missing values by linear
     interpolation.  Since this uses the the y-grid, you must first
     have done `read grid y' or `set y grid'.


File: gri.info,  Node: Help,  Next: If,  Prev: Heal,  Up: List Of Gri Commands

`help'
------

     `help [*|command_name|{- topic}]'

Give help on a command or topic.
   * `help' Print a general help message.

   * `help *' Prints complete help info.

   * `help command_name' Prints help on the command whose name begins
     with the string `command_name'.  The string may be several words
     long; e.g.  `help set' or `help set x axis'.

   * `help - topic_name' The minus sign tells Gri that the string to
     follow it is a topic, not a command.  Topics Gri knows about are
     listed by the one-word `help' request.


File: gri.info,  Node: If,  Next: Ignore,  Prev: Help,  Up: List Of Gri Commands

`if'
----

   (*See also* *Note If Statements::.)

     `if {[!] .flag.}|\flag|{{"string1" == "string2"}}'

Control program flow.  The `if' block is ended with a line containing
`end if'.  Optional `else' and `else if' blocks are allowed.  Note that
rpn expressions are allowed, and a special form of string comparison is
allowed, as in the examples below.

     if .flag.
       # List of Gri commands to be done if .flag. is 1.
       # This list may extend across any number of lines.
     end if

If the variable `.flag.' is not equal to 0, do the code between the
`if' line and the `end if' line.

     if .flag.
       # Commands done if .flag. is 1
     else
       # Commands done if .flag. is 0
     end if

If the variable `.flag.' is not equal to 0, do the code between the
`if' line and the `else' line.  If `.flag.' is equal to 0, do the code
between the `else' line and the `end if' line.

     if ! .flag.
       # Commands done if .flag. is 0
     end if

If the variable `.flag.' is equal to 0, do the code between the `if'
line and the `end if' line.

     if {rpn .flag. 10 <}
       # Commands done if 10 is less than .flag.
     end if

If the variable `.flag.' is greater than 10, do the code between the
`if' line and the `end if' line.

     if \smooth
       # Commands done if \smooth is 1
     else
       # Commands done if \smooth is 0
     end if

If the number stored in the synonym `\smooth' is not equal to 0, do the
code between the `if' line and the `else' line.  If the synonym stores
a representation of a number not equal to zero, do the `else' part.  If
the synonym contains text that does not decode to a number, generate
error message.

     if {"\item" == "Temperature"}
       # Commands done if the synonym \item is equal to the
       # indicated text string.
     end if

If the synonym `\item' has the value `Temperature' stored in it, do the
indicated code.

     if {rpn "\item" "Temperature" ==}
       # Commands done if the synonym \item
       # equals indicated text string.
     end if

As above, but using the `rpn' calculator (*Note rpn Mathematics::).

     if {rpn "\item" "Temperature" !=}
       # ...
     end if

As above, but do the indicated code if `\item' is *not* equal to
`Temperature'.


File: gri.info,  Node: Ignore,  Next: Input,  Prev: If,  Up: List Of Gri Commands

`ignore'
--------

     `ignore last .n.'

Ignores last `.n.' lines read by `read columns'.


File: gri.info,  Node: Input,  Next: Insert,  Prev: Ignore,  Up: List Of Gri Commands

`input'
-------

     `input \ps_filename \
       [.xcm. .ycm. \
         [.xmag. .ymag. \
           [.rot_deg.]]]'

Input the named PostScript file directly into the Gri output PostScript
file.  (If the filename has punctuation, insert it in double quotes,
e.g. `input "../thefile"'.)  If no options are specified, the file is
input at normal scale, with normal margins.  (Aside to PostScript
programmers: the named file is sandwiched between `gsave' and
`grestore' commands.)  If `.xcm.' and `.ycm.' are specified, then the
origin is moved to the named location first.  If, in addition, `.xmag.'
and `.ymag.' are specified, then these are used as scale factors after
translation.  Finally, if `.rot_deg.' is specified in addition, then
the indicated counterclockwise rotation is applied after translation
and scaling.  Hint: if the results look wrong, the first thing to do is
to think carefully about the order of the (translation, scaling,
rotation) operations.


File: gri.info,  Node: Insert,  Next: Interpolate,  Prev: Input,  Up: List Of Gri Commands

`insert'
--------

     `insert \filename'

Perform the commands in the indicated file.

   If the file name is absolute (i.e. starts with `.', or with `/' or
with `~') then an error results if the file is not present (or cannot
be read by this user).

   However, if the file name starts with a normal letter, Gri will try
harder to locate the file.  If it is not in the local directory, and if
a `set path to "PATH" for commands' has been done, then Gri will search
the colon-separated directories for the file (*Note Set Path To::).

   If you don't want path-searching done, use the `source' command
instead (*Note Source::).


File: gri.info,  Node: Interpolate,  Next: List,  Prev: Insert,  Up: List Of Gri Commands

`interpolate'
-------------

     interpolate x grid to .left. .right. .inc.|{/.cols.}'
     interpolate y grid to .bottom. .top. .inc.|{/.rows.}'

Transform grid by interpolating between existing grid data, according to
a new x or y grid specified in the manner of `set x grid' and `set y
grid'.  Note that the new grid is neccessarily regular, while the first
grid needn't have been.  The data of the new grid are constructed by
interpolation, using the same interpolation algorithm as the `convert
grid to image' command.


File: gri.info,  Node: List,  Next: Ls,  Prev: Interpolate,  Up: List Of Gri Commands

`list'
------

     `list \command-syntax'

List the source of a gri command.  Often this is just the name of a C
function internal to gri (try `list list' for an example), but when the
command is written in the gri programming language the source will be
more understandable (try `list set panel').


File: gri.info,  Node: Ls,  Next: Mask,  Prev: List,  Up: List Of Gri Commands

`ls'
----

     `ls [\file_specification]'

List files in current directory.  (The current directory can be printed
by the gri command `pwd' and can be set by the gri command `cd'.)  `ls
\file_specification' lists files in current directory which match the
file specification.  Normal unix file specification options are
understood.


File: gri.info,  Node: Mask,  Next: New,  Prev: Ls,  Up: List Of Gri Commands

`mask'
------

     `mask the image [to {uservalue .u.}|{imagevalue .i.}]'

Examine both the image and the mask pixel by pixel.  For any pixels
which have a mask value of 1 (which indicates an invalid region of the
image), change the image value.  If no `to' phrase is present, change
the image value to 0 in pixel units.  If the `to uservalue .u.' phrase
is present, change the pixel to hold the imagevalue that corresponds to
this uservalue (see `set image range' command for a discussion of this
correspondance).  If the `to imagevalue .i.' phrase is present, change
the pixel to hold that imagevalue (in range 0 to 255 inclusive for
8-bit images).


File: gri.info,  Node: New,  Next: Newpage,  Prev: Mask,  Up: List Of Gri Commands

`new'
-----

     new .variable_name. | \synonym_name \
        [.variable_name. | \synonym_name \
        [...]]

`new' sets aside storage for new version of the named variable(s)
and/or synonym(s).  Any number of variables and synonyms may be
specified.  If a given variable/synonym already exists, this will create
a new version of it, and future assignments will be stored in this new
version *without* affecting the pre-existing version.  If the
variable/synonym is `delete'ed, the new version is deleted, making the
old, unaltered, version accessible again.

   This command is used mostly for temporary use, to prevent clashing
with existing values.  Suppose you want to change the font size inside
a new command or an if block.  Then you might do the following, where
the variable `.tmp.' is used to store the old font size.  Note that the
use of the `new/delete' statements prevents the assignment to the local
version of the variable `.tmp.' from affecting the value known outside
the `if' block, if in fact `.tmp.' happened to exist outside the block.

     set font size 10
     draw label "This is in fontsize 10" at 10 2 cm
     if .want_title.
       new .tmp.
       .tmp. = ..fontsize..
       set font size 22
       draw label "This is 22 font" at 10 5 cm
       set font size .tmp.
       delete .tmp.
     end if
     draw label "This is 10 font" at 10 8 cm

   *Special case*: for local synonyms (e.g. `\.word1.', etc.), the
`new' operator checks to see whether the synonym is standing for an
"ampersand" argument, signalling a changeable argument that is a
variable or a synonym.  In such a case, `new' creates a new instance of
the item in the calling context.  The test suite has examples (*Note
Test Suite::).


File: gri.info,  Node: Newpage,  Next: New Postscript File,  Prev: New,  Up: List Of Gri Commands

`new page'
----------

     `new page'

Finish the present page, and start a new page.  All settings (of
linewidth, axes, landscape/portrait, etc) are retained on the new page.
Among these settings is the flag that tells gri whether you need axes
plotted along with your data.


File: gri.info,  Node: New Postscript File,  Next: Open,  Prev: Newpage,  Up: List Of Gri Commands

`new postscript file'
---------------------

     `new postscript file "name"'

Finish the present Postscript file, and start a new page with the given
name.  All settings (of linewidth, axes, landscape/portrait, etc.) and
data are retained on the new file.


File: gri.info,  Node: Open,  Next: Opening Simple Files,  Prev: New Postscript File,  Up: List Of Gri Commands

`open'
------

   There are two styles of `open' command.  In the first style, a
simple file is to be opened.  In the second style a unix-like "pipe" is
opened, i.e. Gri will read the output of a system command instead of a
file.

* Menu:

* Opening Simple Files::
* Opening Pipes::
* Opening URLs::


File: gri.info,  Node: Opening Simple Files,  Next: Ascii Files,  Prev: Open,  Up: Open

Opening simple files
....................

* Menu:

* Ascii Files::
* Binary Files::
* NetCDF Files::


File: gri.info,  Node: Ascii Files,  Next: Binary Files,  Prev: Opening Simple Files,  Up: Opening Simple Files

   Ascii Files Most applications involve ascii files, and these are
very easy to handle in Gri.  For example given a data file named
`foo.dat', just use the command

     open foo.dat

and then you can read the data using various commands.  Thus a complete
program might be

     open foo.dat
     read columns x y
     draw curve

   If a filename contains blanks or punctuation symbols, you must put
it in double quotes (`"'), e.g.

     open "foo bar.dat"

   Indeed, Gri accepts double-quotes on any `open' command and some
folks use it on all commands, as a matter of habit.

   Gri can handle compressed files appropriately, e.g.

     open foo.data.gz

so that there is no need to uncompress data for use with Gri.

   Gri is quite persistant in looking for your file, and if a given
file is not found, it will then check to see if a compressed version is
available, and use that instead.  Thus

     open foo.dat

will look for a file named `foo.dat.gz' if `foo.dat' is not available.
(Only files compressed with the GNU `gzip' utility are handled.)

   If the `open' command was successful in opening the file, it will
set the value of the synonym `\.return_value.' to the full pathname of
the file.  Thus, if `open a.dat' is done in directory `/home/gri', then
`\.return_value.' will equal the string `/home/gri/a.dat'.

