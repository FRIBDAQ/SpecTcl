<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD Docbook XML 4.3//EN"
           "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"
> 
<book>
<article>

<refentry>
    <refmeta>
        <refentrytitle>CTCLList</refentrytitle>
        <manvolnum>3</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLList</refname>
        <refpurpose>
            Provide access to Tcl List parsing.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <programlisting>
#include &lt;TCLList.h&gt;
...
class CTCLList  : public CTCLInterpreterObject
{

public:
  CTCLList (CTCLInterpreter* pInterp);
  CTCLList (CTCLInterpreter* pInterp, const  char* am_pList  );
  CTCLList (CTCLInterpreter* pInterp, const std::string&amp; rList);
  CTCLList (const CTCLList&amp; aCTCLList );

  CTCLList&amp; operator= (const CTCLList&amp; aCTCLList);
  int operator== (const CTCLList&amp; aCTCLList);
  int operator!= (const CTCLList&amp; aCTCLList);

  const char* getList() const;

  int Split (StringArray&amp; rElements)  ;
  int Split (int&amp; argc, char*** argv);

  const char* Merge (const StringArray&amp; rElements)  ;
  const char* Merge(int argc, char** argv);

};


        </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Tcl Lists are white space separated words.  It is definition of
            words and quoting issues that makes the parsing of lists less than
            straightforward.
        </para>
        <para>
            Fortunately, Tcl provides several list processing functions.  The
            concept of a list and access to list processing functions are
            encapsulated in the <classname>CTCLList</classname> class.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>

<type>CTCLList</type> (<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>);
<type>CTCLList</type> (<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
          const  <type>char</type>* <parameter>pList</parameter>  );
<type>CTCLList</type> (<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
          const <type>std::string</type>&amp; <parameter>rList</parameter>);
<type>CTCLList</type> (const <type>CTCLList</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            These four functions provide various ways to create a <classname>CTCLList</classname>
            object.  The first constructor creates an empty list.  The next two, create a list
            that has an initial value given by either the <literal>NULL</literal>
            terminated string <parameter>pList</parameter>, or the <type>std::string</type>
            object <parameter>rList</parameter>.
            The final constructor creates a list that is a duplicate of the list
            described by the object <parameter>rhs</parameter>.
        </para>
        <para>
            <programlisting>

  <type>CTCLList</type>&amp; <function>operator=</function> (const <type>CTCLList</type>&amp; <parameter>rhs</parameter>);
  <type>int</type> <function>operator==</function> (const <type>CTCLList</type>&amp; <parameter>rhs</parameter>);
  <type>int</type> <function>operator!=</function> (const <type>CTCLList</type>&amp; <parameter>rhs</parameter>);
            </programlisting>
        </para>
        <para>
            These function provide assignment (<function>operator=</function>),
            equality comparison (<function>operator==</function>), and
            inequality comparison (<function>operator!=</function>) with another
            <classname>CTCLList</classname> object, <parameter>rhs</parameter>.
            Assignment is defined as copying the string format of the list.
            Equality comparison is defined as the both interpreter and strings being equal.
            Inequality is defined as !operator==.
        </para>
        <para>
            <programlisting>
  const <type>char</type>* <function>getList()</function> const;
            </programlisting>
        </para>
        <para>
            <function>getList</function> returns an immutable pointer to
            the string rerpesentation of the list.  Note that the const qualfier
            on the pointer means that attempts to dereference the pointer which
            would modify the list result in error messages.  For Example:
            <programlisting>
        CTCLList aList(pInterp, "some list");
        const char* pData = aList.getList();
        *pData = 'S';         // Compiler error!!!!
            </programlisting>
        </para>
        <para>
            <programlisting>
<type>int</type> <function>Split</function> (<type>StringArray</type>&amp; <parameter>rElements</parameter>)  ;
<type>int</type> <function>Split</function> (<type>int</type>&amp; <parameter>argc</parameter>,
           <type>char</type>*** <parameter>argv</parameter>);
            </programlisting>
        </para>
        <para>
            Splits a list up into its component words.   <parameter>relements</parameter>
            is a <type>std::vector&lt;std::string&gt;</type> into which the elements will be split.
            <parameter>argc</parameter> is a reference to an integer into which the
            number of elements will be put. <parameter>argv</parameter> is a pointer to a
            <type>char</type>** into which will be placed a pointer to dynamically
            allocated storage containing a list of <parameter>argc</parameter> pointers
            to the words in the string.  This storage must be released by the caller
            with  <function>Tcl_Free</function>.
            For example:
            <programlisting>
                CTCLList someList(pInterp, someInitialContents);
                ...
                int argc;
                char** argv;
                someList.Split(argc, &amp;argv);
                //
                //  ... do something with the data
                //
                ...
                //
                // Done with the list elements.
                //
                Tcl_Free((char*)argv);
            </programlisting>
        </para>
        <para>
            <programlisting>
const <type>char</type>* <function>Merge</function> (const <type>StringArray</type>&amp; <parameter>rElements</parameter>)  ;
const <type>char</type>* <function>Merge</function>(<type>int</type> argc,
                 <type>char</type>** <parameter>argv</parameter>);
        </programlisting>
        </para>
        <para>
            Merges a bunch of words in to a list.  If necessary, quoting is performed to
            ensure that words that have whitespace or other special characters will be
            correctly formatted into the list. <parameter>rElements</parameter> is a
            <type>std::vector&lt;std::string&gt;</type> of words that will be merged into the
            string.  <parameter>argc</parameter> is a count of the number of words,
            and <parameter>argv</parameter> is a pointer to an array of pointers to the
            words stored as <literal>NULL</literal> terminated strings.
            The return value is the final string representation of the list after the
            merge operation has been performed.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLInterpreter(3),
CTCLInterpreterObject(3),
Tcl_Free(3tcl)
        </para>
    </refsect1>
</refentry>



</article>
</book>
