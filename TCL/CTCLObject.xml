<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD Docbook XML 4.3//EN"
                      "file:///usr/share/xml/docbook/schema/dtd/4.3/docbookx.dtd"
 >
<book>
<article>

<refentry>
    <refmeta>
        <refentrytitle>CTCLObject</refentrytitle>
        <manvolnum>3</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLObject</refname>
        <refpurpose>
            Encapsulate Tcl Dual ported objects.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <programlisting>
#include &lt;TCLObject.h&gt;
...
class CTCLObject : public CTCLInterpreterObject
{

public:
  CTCLObject ();
  CTCLObject (Tcl_Obj* am_pObject);
  CTCLObject (const CTCLObject&amp; aCTCLObject );
  virtual  ~CTCLObject ( );

  CTCLObject&amp; operator= (const CTCLObject&amp; aCTCLObject);
  int operator== (const CTCLObject&amp; aCTCLObject) const;

  Tcl_Obj* getObject();
  const Tcl_Obj* getObject() const;

   CTCLObject&amp; operator= (const std::string&amp; rSource)    ;
   CTCLObject&amp; operator= (const char* pSource)    ;
   CTCLObject&amp; operator= (int nSource)    ;
   CTCLObject&amp; operator= (const CTCLList&amp; rList)    ;
   CTCLObject&amp; operator= (double dSource)     ;
   CTCLObject&amp;  operator=(Tcl_Obj* rhs);

  operator std::string ()    ;
  operator int ()    ;
  operator CTCLList ()    ;
  operator double ()    ;

  CTCLObject&amp; operator+= (const CTCLObject&amp; rObject)    ;
  CTCLObject&amp; operator+= (int nItem)    ;
  CTCLObject&amp; operator+= (const std::string&amp; rItem)    ;
  CTCLObject&amp; operator+= (const char* pItem)    ;
  CTCLObject&amp; operator+= (double  Item)    ;

  CTCLObject clone ()    ;

  CTCLObject operator() ()    ;

  CTCLObject   getRange(int first, int last);

  CTCLObject&amp;  concat(CTCLObject&amp; rhs); // Concat lists.
  std::vector&lt;CTCLObject&gt;  getListElements();
  CTCLObject&amp;  setList(std::vector&lt;CTCLObject&gt; elements);
  int          llength();
  CTCLObject   lindex(int index);
  CTCLObject&amp;  lreplace(int first, int count, std::vector&lt;CTCLObject&gt; newElements);

};

        </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Tcl as a scripting language carries a deeply embedded philosophy that
            everything can be treated as a string.  Nonetheless, in many cases,
            entities manipulated by the interpreter are more efficiently manipulated
            when they have other types of internal representations.  For example strings
            which represent floating point numbers in extended computations are more
            efficiently represented directly as <type>float</type> or <type>double</type>
            variables.
        </para>
        <para>
            Tcl uses <firstterm>dual ported</firstterm> objects to capture this efficiently.
            A Tcl object is a thing that has a string representation and at most one
            other typed representation (e.g. list, integer, floating point).  Conversions
            from string to this representation are done once and cached as long as possible,
            so that when an object has been used as a particular type there is essentially
            no additional conversion cost to use it as that type again.
        </para>
        <para>
            While a <type>Tcl_Obj</type> and therefore a <classname>CTCLObject</classname>
            can exist independent of an interpreter, many member functions require the
            object be bound to an interpreter, or they will fail with an assertion failure
            causing the program to abort.  Use the base class <function>Bind</function>
            (<classname>CTCLInterpreterObject</classname>::<function>Bind</function>)
            member to bind the object to an existing interpreter, usually as soon as
            possible.
        </para>
        <para>
            Tcl objects also can be shared with a lazy copy on write scheme so that
            overhead associated with duplicating objects (e.g. when using them as
            parameters to Tcl commands) is minimized.
        </para>
        <para>
            <classname>CTCLObject</classname> exposes an object oriented interface to the
            Tcl dual ported object.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            <programlisting>
  <function>CTCLObject</function> ();
  <function>CTCLObject</function> (<type>Tcl_Obj</type>* <parameter>pObject</parameter>);
  <function>CTCLObject</function> (const <type>CTCLObject</type>&amp; <parameter>rhs</parameter> );
            </programlisting>
        </para>
        <para>
            Constructs a Tcl object wrapped in a <classname>CTCLObject</classname>.
            <parameter>pObject</parameter> is an existing <type>Tcl_Obj</type> pointer that will be wrapped.
            <parameter>rhs</parameter> is an existing <classname>CTCLObject</classname>
            that will be used to create another reference to the same underlying
            object.  Note that in the last two of these forms, a new <type>Tcl_Obj</type>
            is not created.  Instead, <function>Tcl_IncrRefCount</function> is used
            on the previously existing object to mark it as shared.
            All member functions which  modify the underlying object will create a new
            object (copy on write semantics), and decrement the reference count of the
            original object.  Destroying a <classname>CTCLObject</classname> invokes
            <function>Tcl_DecrRefCount</function> on the underlying <type>Tcl_Obj</type>
            object.  This may or may not result in destruction of that underlying object
            depending on the resulting reference count.
        </para>
        <para>
            <programlisting>

  <type>CTCLObject</type>&amp; <function>operator</function>= (const <type>CTCLObject</type>&amp; <parameter>rhs</parameter>);
  <type>int</type> <function>operator==</function> (const <type>CTCLObject</type>&amp; <parameter>rhs</parameter>) const;
            </programlisting>
        </para>
        <para>
            These two members provide assignment and equality comparison for <classname>CTCLObject</classname>
            instances with another object <parameter>rhs</parameter>.  Assignment operates
            efficiently by decrementing the reference count on the prior object,
            incrementing the reference count for <parameter>rhs</parameter>, and
            copying its <type>Tcl_Obj*</type> only.
            Equality comparision is true if the underlying objects have the same string
            representation.
        </para>
        <para>
            <programlisting>
  <type>Tcl_Obj</type>* <function>getObject</function>();
  const <type>Tcl_Obj</type>* <function>getObject</function>() const;
            </programlisting>
        </para>
        <para>
            Retrieves a mutable or immutable pointer to the underlying object.
            If you intend to retain this pointer for longer than the lifetime of the
            <classname>CTCLObject</classname> object from which it comes or longer
            than the lifetime of the execution of the calling function you should
            invoke <function>Tcl_IncrRefCount</function> to mark the object shared
            and prevent its destruction until you no longer need it, at which point
            you should invoke <function>Tcl_DecrRefCount</function>.
        </para>
        <para>
            You should not modify the underlying object as that violates the
            copy on write semantics expected of <type>Tcl_Obj</type> objects.
            Instead, use <function>Tcl_DuplicateObj</function> to create a new
            object (decrementing the reference count of the previous object), and
            modify that one instead.  The following code snippet shows this:
            <programlisting>
        int      len;
        Tcl_Obj* pObject = someObject.getObject();
        string   value   = string(Tcl_GetStringFromObj(pObject, &amp;len));
        value           += "new text";
        pObject          = Tcl_DuplicateObj(pObject); // Split off a new object.
        Tcl_SetStringObj(pObject, (char*)value.c_str(), -1);
            </programlisting>
        </para>
        <para>
            <programlisting>
   <type>CTCLObject</type>&amp; <function>operator=</function> (const <type>std::string</type>&amp; <parameter>rSource</parameter>)    ;
   <type>CTCLObject</type>&amp; <function>operator=</function> (const <type>char</type>* <parameter>pSource</parameter>)    ;
   <type>CTCLObject</type>&amp; <function>operator=</function> (<type>int</type> <parameter>nSource</parameter>)    ;
   <type>CTCLObject</type>&amp; <function>operator=</function> (const <type>CTCLList</type>&amp; <parameter>rList</parameter>)    ;
   <type>CTCLObject</type>&amp; <function>operator=</function> (<type>double</type> <parameter>dSource</parameter>)     ;
   <type>CTCLObject</type>&amp; <function>operator=</function>(<type>Tcl_Obj</type>* <parameter>rhs</parameter>);
            </programlisting>
        </para>
        <para>
            Assigns a new value to the object.  The reference count of the previously
            encapsulated object is decremented and a new object is created into
            which the right hand side value is loaded.  This preserves copy on write
            semantics.  <parameter>rSource</parameter> and <parameter>pSource</parameter> load
            the new object with a string valued entity.  No attempt is made to create another
            representation for the object (yet).
            <parameter>nSource</parameter> loads the object with an integer value and its
            string representation.
            <parameter>rList</parameter> loads the object with a list representation and
            its string representation.
            <parameter>dSource</parameter> loads the object with a double precision floating
            point value and its string representation.  <parameter>rhs</parameter> simply
            copies in the new object pointer and increments its reference count.
        </para>
        <para>
            <programlisting>

  <function>operator std::string</function> ()    ;
  <function>operator int</function> ()    ;
  <function>operator CTCLList</function> ()    ;
  <function>operator double</function> ()    ;
            </programlisting>
        </para>
        <para>
            These function provide implicit and explicit type conversions between
            a <classname>CTCLObject</classname> instance and other types.
            The type conversions attempt to extract the appropriately typed value
            from the underlying object.  If successful, the value is returned.
            On failure, a <classname>CTCLException</classname> is thrown.
            For example:
            <programlisting>
        CTCLObject object = "3.14159";  // String rep.
        object.Bind(pInterp);           // Some of these need an interp.
        double     pi     = object      // (operator double()).
        object            = "george";   // string rep.
        try {
           int trash = object;          // fails.
        }
        catch (CTCLException&amp; e) {
            // this catch block will execute.
        }
            </programlisting>
        </para>
        <para>
            <programlisting>

<type>CTCLObject</type>&amp; <function>operator+=</function> (const <type>CTCLObject</type>&amp; <parameter>rObject</parameter>)    ;
<type>CTCLObject</type>&amp; <function>operator+=</function> (<type>int</type> <parameter>nItem</parameter>)    ;
<type>CTCLObject</type>&amp; <function>operator+=</function> (const <type>std::string</type>&amp; <parameter>rItem</parameter>)    ;
<type>CTCLObject</type>&amp; <function>operator+=</function> (const <type>char</type>* <parameter>pItem</parameter>)    ;
<type>CTCLObject</type>&amp; <function>operator+=</function> (<type>double</type>  <parameter>Item</parameter>)    ;
            </programlisting>
        </para>
        <para>
            Creates the list representation of the underlying object, converts either
            <parameter>rObject</parameter>,
            <parameter>nItem</parameter>,
            <parameter>rItem</parameter>,
            <parameter>pItem</parameter>,
            <parameter>Item</parameter> to its string representation and appends
            it as a list entry to the object.
        </para>
        <para>
            <programlisting>

  <type>CTCLObject</type> <function>clone</function> ()    ;
            </programlisting>
        </para>
        <para>
            A wrapper for <function>Tcl_DuplicateObj</function>.  The object is
            duplicated and its duplicate is returned wrapped by a
            <classname>CTCLOjbect</classname>.
        </para>
        <para>
            <programlisting>

<type>CTCLObject</type> <function>operator()</function> ()    ;
            </programlisting>
        </para>
        <para>
            The object's string representation is compiled by its bound
            interpreter to Tcl byte code and executed as a script by that
            bound interpreter.  Note that the byte code compilation is cached
            so that subsequent invocations of the script will not require
            recompilation unless other references force a different second
            representation on the object (e.g. fetching it as a list).
            The result of the script execution is returned as a new <classname>CTCLObject</classname>
            If script compilation failed, or script execution resulted in an error,
            a <classname>CTCLException</classname> will be thrown describing this.
        </para>
        <para>
            <programlisting>

<type>CTCLObject</type> <function>getRange</function>(<type>int</type> <parameter>first</parameter>,
                   <type>int</type> <parameter>last</parameter>);
            </programlisting>
        </para>
        <para>
            Returns a new object that consists of a subrange of the string representation of
            the original object. <parameter>first</parameter> is the index of the first
            character of the substring returned. <parameter>last</parameter> is the
            index of the last character of the substring. See <function>Tcl_GetRange</function>
            for more information, note however that some values of <parameter>first</parameter>
            or <parameter>last</parameter> will be treated specially, and that the
            underlying string representation operated on is a <firstterm>Unicode</firstterm> string
            for which some characters in some languages may require more than one byte.
        </para>
        <para>
            <programlisting>
<type>CTCLObject</type>&amp;  <function>concat</function>(<type>CTCLObject</type>&amp; <parameter>rhs</parameter>); // Concat lists.
            </programlisting>
        </para>
        <para>
            Concatenates the <parameter>rhs</parameter> as a list element to the object.
            A refrence to the new object is returned.  Copy on write semantics are maintained.
        </para>
        <para>
            <programlisting>
<type>std::vector&lt;CTCLObject&gt;</type>  <function>getListElements</function>();
            </programlisting>
        </para>
        <para>
            Converts the object into its underlying list representation.  The
            elements of the list are loaded into a vector of <classname>CTCLObject</classname>
            objects and returned.  If the underlying string representation does not have
            a valid list representation, (e.g. "{this cannot be converted") a
            <classname>CTCLException</classname> is thrown.
        </para>
        <para>
            <programlisting>
CTCLObject&amp;  setList(std::vector&lt;CTCLObject&gt; elements);
            </programlisting>
        </para>
        <para>
            Loads the object with a string and list representation whose words are
            the appropriately quoted string representation of <parameter>elements</parameter>.
            A reference to the new object is returned.  Copy on write semantics are
            maintained.
        </para>
        <para>
            <programlisting>
<type>int</type> <function>llength()</function>;
            </programlisting>
        </para>
        <para>
            If necessary, converts the object to its list representation and returns the
            number of elements in that list.  If it is not possible to convert the
            string represenation of the object into a valid list, a <classname>CTCLException</classname>
            is thrown.
        </para>
        <para>
            <programlisting>
<type>CTCLObject</type> <function>lindex</function>(<type>int</type> <parameter>index</parameter>);
            </programlisting>
        </para>
        <para>
            If necessary, creates the list representation of the object and returns a
            new object that is element number <parameter>index</parameter> of that list.
            If the object cannot be converted into a list, a <classname>CTCLException</classname>
            is thrown.
        </para>
        <para>
            <programlisting>
<type>CTCLObject</type>&amp; <function>lreplace</function>(<type>int</type> <parameter>first</parameter>,
                    <type>int</type> <parameter>count</parameter>,
                    <type>std::vector&lt;CTCLObject&gt;</type> <parameter>newElements</parameter>);
            </programlisting>
        </para>
        <para>
            If necessary, converts the object to its list representation.  If that conversion
            fails a <classname>CTCLException</classname> is thrown.  The set of elements
            specified by <parameter>first</parameter> and <parameter>count</parameter>,
            are replaced by the words held in the vector <parameter>newElements</parameter>.
            <parameter>newElements</parameter> can, of course, be an empty vector in order
            to remove <parameter>count</parameter> elements starting at <parameter>first</parameter>
            from the list.  A reference to the resulting object is returned.
            Copy on write semantics are enforced.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLException(3),
CTCLInterpreter(3),
CTCLInterpreterObject(3),
Tcl_DecrRefCount(3tcl),
Tcl_DuplicateObj(3tcl),
Tcl_GetRange(3tcl),
Tcl_IncrRefCount(3tcl),
Tcl_NewObj(3tcl),
Tcl_SetStringObj(3tcl)

        </para>
    </refsect1>
</refentry>



</article>
</book>
