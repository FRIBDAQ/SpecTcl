<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD Docbook XML 4.3//EN"
                      "file:///usr/share/xml/docbook/schema/dtd/4.3/docbookx.dtd"
 >
<book>
<article>

<refentry>
    <refmeta>
        <refentrytitle>CTCLTimer</refentrytitle>
        <manvolnum>3</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLTimer</refname>
        <refpurpose>
            Abstract base class for C++ objects attached to timer events.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLTimer.h&gt;
...
class CTCLTimer  : public CTCLInterpreterObject
{
public:
  CTCLTimer ();
  CTCLTimer(CTCLInterpreter* pInterp, UInt_t nMsec = 0);
  virtual ~CTCLTimer ( );


  Tk_TimerToken getToken() const;
  UInt_t getMsec() const;
  Bool_t IsSet() const;

  virtual   void operator() ()   = 0;

  void Set ()  ;
  void Set(UInt_t nms);
  void Clear ()  ;
};


    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Tcl/Tk provide a mechanism for scheduling functions to be executed
            after a time delay specified in milliseconds.   The <classname>CTCLTimer</classname>
            class is an abstract base class that provides an interface into the API
            for that facility.  To use <classname>CTCLTimer</classname> you must
            create a class derived from <classname>CTCLTimer</classname> that
            overrides and implement the <function>operator()</function> function.
            Create an object from the resulting function class.  Use the object's
            <function>Set</function> and <function>Clear</function> members to schedule
            or cancel a scheduled execution.  The code fragment
            example below shows how to do this
            to create a class that periodically emits the text "Tick" to stderr.
            Many #include directives are missing for brevity.
            <programlisting>
// Interface to <classname>Ticker</classname> normally goes in a header.
class Ticker : public CTCLTimer
{
public:
    Ticker(CTCLInterpreter* pInterp, int seconds);
    virtual ~Ticker();

    virtual void operator()();
};
...
// Implementation of <classname>Ticker</classname> normally goes in a .cpp

// Constructor of Ticker:

Ticker::Ticker(int seconds) :
    CTCLTimer(pInterp, seconds*1000)
{
    Set();                   // Schedule first one.
}
// Destructor.. chain to base class.
Ticker::~Ticker() {}

// called when timer goes off:
void
Ticker::operator()() {
    cerr &lt;&lt; "Tick\n";
    Set();                 // Schedule next one.
}
...


Ticker Tick(pInterp, 1);  // Tick every second.

            </programlisting>
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
<function>CTCLTimer</function> ();
<function>CTCLTimer</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
          <type>UInt_t</type> <parameter>nMsec</parameter> = <literal>0</literal>);
          </programlisting>
          </para>
          <para>
            Construct timer objects.  The first form of the constructor creates a timer
            object that must be later bound into an interpreter via a call to
            <classname>CTCLInterpreterObject</classname>::<function>Bind</function>.
            The seconf form of the contructor creates a timer object that is already
            bound to <parameter>pInterp</parameter> and has an initial schedule delay
            of <parameter>nMsec</parameter>.
          </para>
          <para>
          <programlisting>
  Tk_TimerToken getToken() const;
  UInt_t getMsec() const;
          </programlisting>
          </para>
          <para>
            These two members access internal state of the object.
            <function>getToken</function> returns the <type>Tk_TimerToken</type>
            associated with the timer object.  This is the Tcl/Tk token that
            identifies the timer request to the interpreter.
            <function>getMsec</function> retrieves the current value of the delay parameter
            in milliseconds.
          </para>
          <para>
          <programlisting>
  virtual   void operator() ()   = 0;
        </programlisting>
        </para>
        <para>
            This function must be overidden and implemented in concrete timer classes.
            See the example in DESCRIPTION above.
        </para>
        <para>
        <programlisting>

  void Set ()  ;
  void Set(UInt_t nms);
  Bool_t IsSet() const;
        </programlisting>
        </para>
        <para>
            <function>Set</function> schedules the object for execution.  If
            <parameter>nms</parameter> is provided it is saved as the scheduling
            parameter and determines the delay
            in milliseconds before <function>operator()</function> is
            next called.  If not provided, the most recently used delay will be
            used again.
        </para>
        <para>
            <function>IsSet</function> returns <literal>kfTRUE</literal> if the
            timer is currently pending, or <literal>kfFALSE</literal> if no pending
            timer request is active.
        </para>
        <para>
        <programlisting>
  void Clear ()  ;
        </programlisting>
        </para>
        <para>
           If a Timer request is pending, cancels it.  If no timer request is pending,
            this function does nothing, and does not report an error.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLInterpreterObject(3)
        </para>
    </refsect1>
    <refsect1>
        <title>REFERENCES</title>
        <para>
            <programlisting>
Musser, Derge, Saini: <parameter>STL Tutorial and Reference Guide</parameter>
Addison-Wesley Professional Computing Series; 2001 ISBN 0-201-37923-6
See section 2.4 for a description and discussion of function objects.
            </programlisting>
        </para>
    </refsect1>
</refentry>
</article>
</book>
