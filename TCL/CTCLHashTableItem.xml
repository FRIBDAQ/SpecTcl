<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD Docbook XML 4.3//EN"
       "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"
 >
<book>
<article>

<refentry>
    <refmeta>
        <refentrytitle>CTCLHashTableItem</refentrytitle>
        <manvolnum>3</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLHashTableItem</refname>
        <refpurpose>
            Encapsulation of an entry in a Tcl Hash table as encapsulated
            in <classname>CTCLHashTable</classname>
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <programlisting>
#include &lt;TCLHashTableItem.h&gt;
...

template &lt;class T&gt;              // T Must have copy ctor &amp; Assignment defined.
class CTCLHashTableItem
{
  CTCLHashTableItem (T am_Item );
  CTCLHashTableItem (const CTCLHashTableItem&amp; aCTCLHashTableItem );
  virtual ~CTCLHashTableItem ( );

  CTCLHashTableItem operator= (const CTCLHashTableItem&amp; aCTCLHashTableItem);
   int operator== (const CTCLHashTableItem&amp; aCTCLHashTableItem);
  T getItem() const;
  T* operator-&gt; ();
}
        </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title></title>
        <para>
            Provides an object oriented interface to elements of a hash table.
            See CTCLHashTable(3), and the first REFERENCE below for more information
            about hash tables.
        </para>
        <para>
            Note that this is a templated class.  The template parameter is
            the type of the item to be stored in the hash table.  Suppose,
            for example, we have a bunch of named calibration parameters
            (floating point) that are stored in a hash table.  A calibration
            The following code creates the calibration table, and inserts an
            element named george in it with the initial value of 0.0:
            <programlisting>
        CTCLHashTable&lt;float&gt;  calibrationTable;
        CTCLHashTableItem&lt;float&gt; entry(0.0);
        calibrationTable.Enter(std::string("george"), entry);
            </programlisting>
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
<function>CTCLHashTableItem</function> (<type>T</type> <parameter>Item</parameter> );
<function>CTCLHashTableItem</function> (const <type>CTCLHashTableItem</type>&amp; <parameter>hashItem</parameter> );
        </programlisting>
        </para>
        <para>
            Constructs a <classname>CTCLHashTableItem</classname> either from the underlying
            type (<parameter>Item</parameter>) or from an existing <classname>CTCLHashTableItem</classname>
            (<parameter>hashItem</parameter>).
        </para>
        <para>
        <programlisting>
<type>CTCLHashTableItem</type> <function>operator=</function>(const <type>CTCLHashTableItem</type>&amp; <parameter>rhs</parameter>);
<type>int</type> <parameter>operator==</parameter> (const <type>CTCLHashTableItem</type>&amp; <type>rhs</type>);
        </programlisting>
        </para>
        <para>
            <function>operator=</function> allows you to assign the value of one
            <classname>CTCLHashTableItem</classname> to another.  The underlying
            templated type must be capable of assignment.
        </para>
        <para>
            <function>operator==</function> allows you to compare two
            <classname>CTCLHashTableItem</classname>s to each other.  The underlying
            templated type must be capable of equality comparison.
        </para>
        <para>
            <programlisting>
<type>T</type> <function>getItem</function>() const;
            </programlisting>
        </para>
        <para>
            Returns the value of the item wrapped by the <classname>CTCLHashTableItem</classname>
            The underlying type must be capable of copy construction.
        </para>
        <para>
            <programlisting>
<type>T</type>* <function>operator-&gt;</function> ();       </programlisting>
        </para>
        <para>
            Returns the address of the contents of the <classname>CTCLHashTableItem</classname>.
            This is most useful if <classname>T</classname> is a structure or class as it can be
            used to dereference member (data or functions) of the structure or class.
            For example:
            <programlisting>
                struct complex {
                                 double real;
                                 double imaginary;
                                 complex(double r, double i) :
                                    real(r), imaginary(i) {}
                                } complex;
                CTCLHashTableItem&lt;complex&gt; v(1.0, 2.0);
                double real = v-&gt;real;             // real = 1.0
                double imag = v-&gt;imaginary;        // imag = 2.0
            </programlisting>
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLHashTable(3),
CTCLHashTableIterator(3)
        </para>
    </refsect1>
    <refsect1>
        <title>REFERENCES</title>
        <para>
            <programlisting>
Niklaus Wirth <parameter>Algorithms + Data Structures = Programs</parameter>
Prentice Hall Series in Automatic Computation 1976 See section 4.6
            </programlisting>
        </para>
    </refsect1>
</refentry>



</article>
</book>
